<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>乐优商城day10：商品管理</title>
    <link href="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/"/>
    <url>/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>独立实现商品新增后台</li><li>独立实现商品编辑后台</li><li>独立搭建前台系统页面</li></ul><h1 id="1-商品新增"><a href="#1-商品新增" class="headerlink" title="1.商品新增"></a>1.商品新增</h1><p>当我们点击新增商品按钮：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528450695946.png" srcset="/img/loading.gif" alt="1528450695946"></p><p>就会出现一个弹窗：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528450773322.png" srcset="/img/loading.gif" alt="1528450773322"></p><p>里面把商品的数据分为了4部分来填写：</p><ul><li>基本信息：主要是一些简单的文本数据，包含了SPU和SpuDetail的部分数据，如<ul><li>商品分类：是SPU中的<code>cid1</code>，<code>cid2</code>，<code>cid3</code>属性</li><li>品牌：是spu中的<code>brandId</code>属性</li><li>标题：是spu中的<code>title</code>属性</li><li>子标题：是spu中的<code>subTitle</code>属性</li><li>售后服务：是SpuDetail中的<code>afterService</code>属性</li><li>包装列表：是SpuDetail中的<code>packingList</code>属性</li></ul></li><li>商品描述：是SpuDetail中的<code>description</code>属性，数据较多，所以单独放一个页面</li><li>规格参数：商品规格信息，对应SpuDetail中的<code>genericSpec</code>属性</li><li>SKU属性：spu下的所有Sku信息</li></ul><p>对应到页面中的四个<code>stepper-content</code>：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528457410198.png" srcset="/img/loading.gif" alt="1528457410198"></p><h2 id="1-1-弹窗事件"><a href="#1-1-弹窗事件" class="headerlink" title="1.1.弹窗事件"></a>1.1.弹窗事件</h2><p>弹窗是一个独立组件：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528084394245.png" srcset="/img/loading.gif" alt="1528084394245"></p><p>并且在Goods组件中已经引用它：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528457758806.png" srcset="/img/loading.gif" alt="1528457758806"></p><p>并且在页面中渲染：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528457859739.png" srcset="/img/loading.gif" alt="1528457859739"></p><p>在<code>新增商品</code>按钮的点击事件中，改变这个<code>dialog</code>的<code>show</code>属性：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528457992959.png" srcset="/img/loading.gif" alt="1528457992959"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528458037693.png" srcset="/img/loading.gif" alt="1528458037693"></p><h2 id="1-2-基本数据"><a href="#1-2-基本数据" class="headerlink" title="1.2.基本数据"></a>1.2.基本数据</h2><p>我们先来看下基本数据：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/%E4%B9%90%E4%BC%98/7%E6%9C%881%E5%8F%B7%E6%9B%B4%E6%96%B0/day10-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528086595597.png" srcset="/img/loading.gif" alt="1528086595597"></p><h3 id="1-2-1-商品分类"><a href="#1-2-1-商品分类" class="headerlink" title="1.2.1.商品分类"></a>1.2.1.商品分类</h3><p>商品分类信息查询我们之前已经做过，所以这里的级联选框已经实现完成：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528459846644.png" srcset="/img/loading.gif" alt="1528459846644"></p><p>刷新页面，可以看到请求已经发出：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528460001803.png" srcset="/img/loading.gif" alt="1528460001803"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528460054188.png" srcset="/img/loading.gif" alt="1528460054188"></p><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528460159541.png" srcset="/img/loading.gif" alt="1528460159541"></p><h3 id="1-2-2-品牌选择"><a href="#1-2-2-品牌选择" class="headerlink" title="1.2.2.品牌选择"></a>1.2.2.品牌选择</h3><h4 id="1-2-2-1页面"><a href="#1-2-2-1页面" class="headerlink" title="1.2.2.1页面"></a>1.2.2.1页面</h4><p>品牌也是一个下拉选框，不过其选项是不确定的，只有当用户选择了商品分类，才会把这个分类下的所有品牌展示出来。</p><p>所以页面编写了watch函数，监控商品分类的变化，每当商品分类值有变化，就会发起请求，查询品牌列表：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528460401582.png" srcset="/img/loading.gif" alt="1528460401582"></p><p>选择商品分类后，可以看到请求发起：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528460607735.png" srcset="/img/loading.gif" alt="1528460607735"></p><p>接下来，我们只要编写后台接口，根据商品分类id，查询对应品牌即可。</p><h4 id="1-2-2-2后台接口"><a href="#1-2-2-2后台接口" class="headerlink" title="1.2.2.2后台接口"></a>1.2.2.2后台接口</h4><p>页面需要去后台查询品牌信息，我们自然需要提供：</p><p>请求方式：GET</p><p>请求路径：/brand/cid/{cid}</p><p>请求参数：cid</p><p>响应数据：品牌集合</p><blockquote><p>BrandController</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据分类查询品牌</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cid</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"cid/&#123;cid&#125;"</span>)<span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandListByCid(<span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">"cid"</span>)Long cid)&#123;    List&lt;Brand&gt; brandList = <span class="hljs-keyword">this</span>.brandService.queryByCid(cid);    <span class="hljs-keyword">if</span>(CollectionUtils.isEmpty(brandList))&#123;        <span class="hljs-comment">// 响应404</span>        <span class="hljs-keyword">return</span> ResponseEntity.badRequest().build();    &#125;    <span class="hljs-comment">// 响应200</span>    <span class="hljs-keyword">return</span> ResponseEntity.ok(brandList);&#125;</code></pre></div><blockquote><p>BrandService</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Brand&gt; <span class="hljs-title">queryBrandByCategory</span><span class="hljs-params">(Long cid)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.brandMapper.queryByCategoryId(cid);&#125;</code></pre></div><blockquote><p>BrandMapper</p></blockquote><p>根据分类查询品牌有中间表，需要自己编写Sql：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT b.* FROM tb_brand b LEFT JOIN tb_category_brand cb ON b.id = cb.brand_id WHERE cb.category_id = #&#123;cid&#125;"</span>)<span class="hljs-function">List&lt;Brand&gt; <span class="hljs-title">queryByCategoryId</span><span class="hljs-params">(Long cid)</span></span>;</code></pre></div><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528462393536.png" srcset="/img/loading.gif" alt="1528462393536"></p><h3 id="1-2-3-其它文本框"><a href="#1-2-3-其它文本框" class="headerlink" title="1.2.3.其它文本框"></a>1.2.3.其它文本框</h3><p>剩余的几个属性：标题、子标题等都是普通文本框，我们直接填写即可，没有需要特别注意的。</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528462474512.png" srcset="/img/loading.gif" alt="1528462474512"></p><h2 id="1-3-商品描述"><a href="#1-3-商品描述" class="headerlink" title="1.3.商品描述"></a>1.3.商品描述</h2><p>商品描述信息比较复杂，而且图文并茂，甚至包括视频。</p><p>这样的内容，一般都会使用富文本编辑器。</p><h3 id="1-3-1-什么是富文本编辑器"><a href="#1-3-1-什么是富文本编辑器" class="headerlink" title="1.3.1.什么是富文本编辑器"></a>1.3.1.什么是富文本编辑器</h3><p>百度百科：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526290914491.png" srcset="/img/loading.gif" alt="1526290914491"></p><p>通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。</p><p>富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue</p><p>但是我们今天要说的，是一款支持Vue的富文本编辑器：<code>vue-quill-editor</code></p><h3 id="1-3-2-Vue-Quill-Editor"><a href="#1-3-2-Vue-Quill-Editor" class="headerlink" title="1.3.2.Vue-Quill-Editor"></a>1.3.2.Vue-Quill-Editor</h3><p>GitHub的主页：<a href="https://github.com/surmon-china/vue-quill-editor" target="_blank" rel="noopener">https://github.com/surmon-china/vue-quill-editor</a></p><p>Vue-Quill-Editor是一个基于Quill的富文本编辑器：<a href="https://quilljs.com/" target="_blank" rel="noopener">Quill的官网</a></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526291232678.png" srcset="/img/loading.gif" alt="1526291232678"></p><h3 id="1-3-3-使用指南"><a href="#1-3-3-使用指南" class="headerlink" title="1.3.3.使用指南"></a>1.3.3.使用指南</h3><p>使用非常简单：</p><p>第一步：安装，使用npm命令：</p><div class="hljs"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> vue-quill-editor <span class="hljs-comment">--save</span></code></pre></div><p>第二步：加载，在js中引入：</p><p>全局引入：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> VueQuillEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-quill-editor'</span><span class="hljs-keyword">const</span> options = &#123;&#125;; <span class="hljs-comment">/* &#123; default global options &#125; */</span>Vue.use(VueQuillEditor, options); <span class="hljs-comment">// options可选</span></code></pre></div><p>局部引入：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'quill/dist/quill.core.css'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'quill/dist/quill.snow.css'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'quill/dist/quill.bubble.css'</span><span class="hljs-keyword">import</span> &#123;quillEditor&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-quill-editor'</span><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    components:&#123;        quillEditor    &#125;&#125;)</code></pre></div><p>我们这里采用局部引用：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528465859061.png" srcset="/img/loading.gif" alt="1528465859061"></p><p>第三步：页面使用：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">quill-editor</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.spuDetail.description"</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">"editorOption"</span>/&gt;</span></code></pre></div><h3 id="1-3-4-自定义的富文本编辑器"><a href="#1-3-4-自定义的富文本编辑器" class="headerlink" title="1.3.4.自定义的富文本编辑器"></a>1.3.4.自定义的富文本编辑器</h3><p>不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526296083605.png" srcset="/img/loading.gif" alt="1526296083605.png"></p><p>使用也非常简单：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"2"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-editor</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.spuDetail.description"</span> <span class="hljs-attr">upload-url</span>=<span class="hljs-string">"/upload/image"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span></code></pre></div><ul><li>upload-url：是图片上传的路径</li><li>v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description</li></ul><h3 id="1-3-5-效果"><a href="#1-3-5-效果" class="headerlink" title="1.3.5.效果"></a>1.3.5.效果</h3><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528469209005.png" srcset="/img/loading.gif" alt="1528469209005"></p><h2 id="1-4-商品规格参数"><a href="#1-4-商品规格参数" class="headerlink" title="1.4.商品规格参数"></a>1.4.商品规格参数</h2><p>规格参数的查询我们之前也已经编写过接口，因为商品规格参数也是与商品分类绑定，所以需要在商品分类变化后去查询，我们也是通过watch监控来实现：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528469560330.png" srcset="/img/loading.gif" alt="1528469560330"></p><p>可以看到这里是根据商品分类id查询规格参数：SpecParam。我们之前写过一个根据gid（分组id）来查询规格参数的接口，我们接下来完成根据分类id查询规格参数。</p><blockquote><h3 id="改造查询规格参数接口"><a href="#改造查询规格参数接口" class="headerlink" title="改造查询规格参数接口"></a>改造查询规格参数接口</h3></blockquote><p>我们在原来的根据 gid（规格组id)查询规格参数的接口上，添加一个参数：cid，即商品分类id。</p><p>等一下， 考虑到以后可能还会根据是否搜索、是否为通用属性等条件过滤，我们多添加几个过滤条件：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/params"</span>)<span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;SpecParam&gt;&gt; querySpecParam(    <span class="hljs-meta">@RequestParam</span>(value=<span class="hljs-string">"gid"</span>, required = <span class="hljs-keyword">false</span>) Long gid,    <span class="hljs-meta">@RequestParam</span>(value=<span class="hljs-string">"cid"</span>, required = <span class="hljs-keyword">false</span>) Long cid,    <span class="hljs-meta">@RequestParam</span>(value=<span class="hljs-string">"searching"</span>, required = <span class="hljs-keyword">false</span>) Boolean searching,    <span class="hljs-meta">@RequestParam</span>(value=<span class="hljs-string">"generic"</span>, required = <span class="hljs-keyword">false</span>) Boolean generic    )&#123;        List&lt;SpecParam&gt; list =                <span class="hljs-keyword">this</span>.specificationService.querySpecParams(gid,cid,searching,generic);        <span class="hljs-keyword">if</span>(list == <span class="hljs-keyword">null</span> || list.size() == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-keyword">return</span> ResponseEntity.ok(list);    &#125;</code></pre></div><p>改造service：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SpecParam&gt; <span class="hljs-title">querySpecParams</span><span class="hljs-params">(Long gid, Long cid, Boolean searching, Boolean generic)</span> </span>&#123;    SpecParam param = <span class="hljs-keyword">new</span> SpecParam();    param.setGroupId(gid);    param.setCid(cid);    param.setSearching(searching);    param.setGeneric(generic);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.specParamMapper.select(param);&#125;</code></pre></div><p>如果param中有属性为null，则不会吧属性作为查询条件，因此该方法具备通用性，即可根据gid查询，也可根据cid查询。</p><p>测试：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528470181643.png" srcset="/img/loading.gif" alt="1528470181643"></p><p>刷新页面测试：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528470221970.png" srcset="/img/loading.gif" alt="1528470221970"></p><h2 id="1-5-SKU信息"><a href="#1-5-SKU信息" class="headerlink" title="1.5.SKU信息"></a>1.5.SKU信息</h2><p>Sku属性是SPU下的每个商品的不同特征，如图：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528470828296.png" srcset="/img/loading.gif" alt="1528470828296"></p><p>当我们填写一些属性后，会在页面下方生成一个sku表格，大家可以计算下会生成多少个不同属性的Sku呢？</p><p>当你选择了上图中的这些选项时：</p><ul><li>颜色共2种：迷夜黑，勃艮第红，绚丽蓝</li><li>内存共2种：4GB，6GB</li><li>机身存储1种：64GB，128GB</li></ul><p>此时会产生多少种SKU呢？ 应该是 3 * 2 * 2 = 12种，这其实就是在求笛卡尔积。</p><p>我们会在页面下方生成一个sku的表格：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528470876872.png" srcset="/img/loading.gif" alt="1528470876872"></p><h2 id="1-6-页面表单提交"><a href="#1-6-页面表单提交" class="headerlink" title="1.6.页面表单提交"></a>1.6.页面表单提交</h2><p>在sku列表的下方，有一个提交按钮：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528470945475.png" srcset="/img/loading.gif" alt="1528470945475"></p><p>并且绑定了点击事件：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528471079383.png" srcset="/img/loading.gif" alt="1528471079383"></p><p>点击后会组织数据并向后台提交：</p><div class="hljs"><pre><code class="hljs js">submit() &#123;  <span class="hljs-comment">// 表单校验。</span>  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.$refs.basic.validate)&#123;    <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"请先完成表单内容！"</span>);  &#125;  <span class="hljs-comment">// 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中</span>  <span class="hljs-keyword">const</span> &#123;    categories: [&#123; <span class="hljs-attr">id</span>: cid1 &#125;, &#123; <span class="hljs-attr">id</span>: cid2 &#125;, &#123; <span class="hljs-attr">id</span>: cid3 &#125;],    ...goodsParams  &#125; = <span class="hljs-keyword">this</span>.goods;  <span class="hljs-comment">// 处理规格参数</span>  <span class="hljs-keyword">const</span> specs = &#123;&#125;;  <span class="hljs-keyword">this</span>.specs.forEach(<span class="hljs-function">(<span class="hljs-params">&#123; id,v &#125;</span>) =&gt;</span> &#123;    specs[id] = v;  &#125;);  <span class="hljs-comment">// 处理特有规格参数模板</span>  <span class="hljs-keyword">const</span> specTemplate = &#123;&#125;;  <span class="hljs-keyword">this</span>.specialSpecs.forEach(<span class="hljs-function">(<span class="hljs-params">&#123; id, options &#125;</span>) =&gt;</span> &#123;    specTemplate[id] = options;  &#125;);  <span class="hljs-comment">// 处理sku</span>  <span class="hljs-keyword">const</span> skus = <span class="hljs-keyword">this</span>.skus    .filter(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.enable)    .map(<span class="hljs-function">(<span class="hljs-params">&#123; price, stock, enable, images, indexes, ...rest &#125;</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 标题，在spu的title基础上，拼接特有规格属性值</span>      <span class="hljs-keyword">const</span> title = goodsParams.title + <span class="hljs-string">" "</span> + <span class="hljs-built_in">Object</span>.values(rest).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.v).join(<span class="hljs-string">" "</span>);      <span class="hljs-keyword">const</span> obj = &#123;&#125;;      <span class="hljs-built_in">Object</span>.values(rest).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;        obj[v.id] = v.v;      &#125;);      <span class="hljs-keyword">return</span> &#123;        price: <span class="hljs-keyword">this</span>.$format(price), <span class="hljs-comment">// 价格需要格式化</span>        stock,        indexes,        enable,        title, <span class="hljs-comment">// 基本属性</span>        images: images ? images.join(<span class="hljs-string">","</span>) : <span class="hljs-string">''</span>, <span class="hljs-comment">// 图片</span>        ownSpec: <span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// 特有规格参数</span>      &#125;;    &#125;);  <span class="hljs-built_in">Object</span>.assign(goodsParams, &#123;    cid1,    cid2,    cid3, <span class="hljs-comment">// 商品分类</span>    skus <span class="hljs-comment">// sku列表</span>  &#125;);  goodsParams.spuDetail.genericSpec = <span class="hljs-built_in">JSON</span>.stringify(specs);  goodsParams.spuDetail.specialSpec = <span class="hljs-built_in">JSON</span>.stringify(specTemplate);  <span class="hljs-comment">// 提交到后台</span>  <span class="hljs-keyword">this</span>.$http(&#123;    method: <span class="hljs-keyword">this</span>.isEdit ? <span class="hljs-string">"put"</span> : <span class="hljs-string">"post"</span>,    url: <span class="hljs-string">"/item/goods"</span>,    data: goodsParams  &#125;)    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-comment">// 成功，关闭窗口</span>      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">"close"</span>);      <span class="hljs-comment">// 提示成功</span>      <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"保存成功了"</span>);    &#125;)    .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"保存失败！"</span>);    &#125;);&#125;</code></pre></div><p>点击提交，查看控制台提交的数据格式：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528472289831.png" srcset="/img/loading.gif" alt="1528472289831"></p><p>整体是一个json格式数据，包含Spu表所有数据：</p><ul><li>brandId：品牌id</li><li>cid1、cid2、cid3：商品分类id</li><li>subTitle：副标题</li><li>title：标题</li><li>spuDetail：是一个json对象，代表商品详情表数据<ul><li>afterService：售后服务</li><li>description：商品描述</li><li>packingList：包装列表</li><li>specialSpec：sku规格属性模板</li><li>genericSpec：通用规格参数</li></ul></li><li>skus：spu下的所有sku数组，元素是每个sku对象：<ul><li>title：标题</li><li>images：图片</li><li>price：价格</li><li>stock：库存</li><li>ownSpec：特有规格参数</li><li>indexes：特有规格参数的下标</li></ul></li></ul><h2 id="1-7-后台实现"><a href="#1-7-后台实现" class="headerlink" title="1.7.后台实现"></a>1.7.后台实现</h2><h3 id="1-7-1-实体类"><a href="#1-7-1-实体类" class="headerlink" title="1.7.1.实体类"></a>1.7.1.实体类</h3><p>SPU和SpuDetail实体类已经添加过，添加Sku和Stock对象：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528472531490.png" srcset="/img/loading.gif" alt="1528472531490"></p><blockquote><p>Sku</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_sku"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sku</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long spuId;    <span class="hljs-keyword">private</span> String title;    <span class="hljs-keyword">private</span> String images;    <span class="hljs-keyword">private</span> Long price;    <span class="hljs-keyword">private</span> String ownSpec;<span class="hljs-comment">// 商品特殊规格的键值对</span>    <span class="hljs-keyword">private</span> String indexes;<span class="hljs-comment">// 商品特殊规格的下标</span>    <span class="hljs-keyword">private</span> Boolean enable;<span class="hljs-comment">// 是否有效，逻辑删除用</span>    <span class="hljs-keyword">private</span> Date createTime;<span class="hljs-comment">// 创建时间</span>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<span class="hljs-comment">// 最后修改时间</span>    <span class="hljs-meta">@Transient</span>    <span class="hljs-keyword">private</span> Integer stock;<span class="hljs-comment">// 库存</span>&#125;</code></pre></div><p>注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。</p><blockquote><p>Stock</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_stock"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long skuId;    <span class="hljs-keyword">private</span> Integer seckillStock;<span class="hljs-comment">// 秒杀可用库存</span>    <span class="hljs-keyword">private</span> Integer seckillTotal;<span class="hljs-comment">// 已秒杀数量</span>    <span class="hljs-keyword">private</span> Integer stock;<span class="hljs-comment">// 正常库存</span>&#125;</code></pre></div><h3 id="1-7-2-GoodsController"><a href="#1-7-2-GoodsController" class="headerlink" title="1.7.2.GoodsController"></a>1.7.2.GoodsController</h3><p>请求方式：POST</p><p>请求路径：/goods</p><p>请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个SpuBo对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpuBo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Spu</span> </span>&#123;    <span class="hljs-meta">@Transient</span>    String cname;<span class="hljs-comment">// 商品分类名称</span>    <span class="hljs-meta">@Transient</span>    String bname;<span class="hljs-comment">// 品牌名称</span>    <span class="hljs-meta">@Transient</span>    SpuDetail spuDetail;<span class="hljs-comment">// 商品详情</span>    <span class="hljs-meta">@Transient</span>    List&lt;Sku&gt; skus;<span class="hljs-comment">// sku列表</span>&#125;</code></pre></div><ul><li>返回类型：无</li></ul><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 新增商品</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> spu</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@PostMapping</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Void&gt; <span class="hljs-title">saveGoods</span><span class="hljs-params">(@RequestBody SpuBo spuBo)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">this</span>.goodsService.save(spu);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.CREATED);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR);    &#125;&#125;</code></pre></div><p>注意：通过@RequestBody注解来接收Json请求</p><h3 id="1-7-3-GoodsService"><a href="#1-7-3-GoodsService" class="headerlink" title="1.7.3.GoodsService"></a>1.7.3.GoodsService</h3><p>这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(SpuBo spu)</span> </span>&#123;    <span class="hljs-comment">// 保存spu</span>    spu.setSaleable(<span class="hljs-keyword">true</span>);    spu.setValid(<span class="hljs-keyword">true</span>);    spu.setCreateTime(<span class="hljs-keyword">new</span> Date());    spu.setLastUpdateTime(spu.getCreateTime());    <span class="hljs-keyword">this</span>.spuMapper.insert(spu);    <span class="hljs-comment">// 保存spu详情</span>    spu.getSpuDetail().setSpuId(spu.getId());    <span class="hljs-keyword">this</span>.spuDetailMapper.insert(spu.getSpuDetail());    <span class="hljs-comment">// 保存sku和库存信息</span>    saveSkuAndStock(spu.getSkus(), spu.getId());&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveSkuAndStock</span><span class="hljs-params">(List&lt;Sku&gt; skus, Long spuId)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Sku sku : skus) &#123;        <span class="hljs-keyword">if</span> (!sku.getEnable()) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 保存sku</span>        sku.setSpuId(spuId);        <span class="hljs-comment">// 初始化时间</span>        sku.setCreateTime(<span class="hljs-keyword">new</span> Date());        sku.setLastUpdateTime(sku.getCreateTime());        <span class="hljs-keyword">this</span>.skuMapper.insert(sku);        <span class="hljs-comment">// 保存库存信息</span>        Stock stock = <span class="hljs-keyword">new</span> Stock();        stock.setSkuId(sku.getId());        stock.setStock(sku.getStock());        <span class="hljs-keyword">this</span>.stockMapper.insert(stock);    &#125;&#125;</code></pre></div><h3 id="1-7-4-Mapper"><a href="#1-7-4-Mapper" class="headerlink" title="1.7.4.Mapper"></a>1.7.4.Mapper</h3><p>都是通用Mapper，略</p><p>目录结构：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528473533815.png" srcset="/img/loading.gif" alt="1528473533815"></p><h1 id="2-商品修改"><a href="#2-商品修改" class="headerlink" title="2.商品修改"></a>2.商品修改</h1><h2 id="2-1-编辑按钮点击事件"><a href="#2-1-编辑按钮点击事件" class="headerlink" title="2.1.编辑按钮点击事件"></a>2.1.编辑按钮点击事件</h2><p>在商品详情页，每一个商品后面，都会有一个编辑按钮：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528476387213.png" srcset="/img/loading.gif" alt="1528476387213"></p><p>点击这个按钮，就会打开一个商品编辑窗口，我们看下它所绑定的点击事件：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528476530008.png" srcset="/img/loading.gif" alt="1528476530008"></p><p>对应的方法：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528476579123.png" srcset="/img/loading.gif" alt="1528476579123"></p><p>可以看到这里发起了两个请求，在查询商品详情和sku信息。</p><p>因为在商品列表页面，只有spu的基本信息：id、标题、品牌、商品分类等。比较复杂的商品详情（spuDetail)和sku信息都没有，编辑页面要回显数据，就需要查询这些内容。</p><p>因此，接下来我们就编写后台接口，提供查询服务接口。</p><h2 id="2-2-查询SpuDetail接口"><a href="#2-2-查询SpuDetail接口" class="headerlink" title="2.2.查询SpuDetail接口"></a>2.2.查询SpuDetail接口</h2><blockquote><p>GoodsController</p></blockquote><p>需要分析的内容：</p><ul><li>请求方式：GET</li><li>请求路径：/spu/detail/{id}</li><li>请求参数：id，应该是spu的id</li><li>返回结果：SpuDetail对象</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/spu/detail/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;SpuDetail&gt; <span class="hljs-title">querySpuDetailById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id) </span>&#123;    SpuDetail detail = <span class="hljs-keyword">this</span>.goodsService.querySpuDetailById(id);    <span class="hljs-keyword">if</span> (detail == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);    &#125;    <span class="hljs-keyword">return</span> ResponseEntity.ok(detail);&#125;</code></pre></div><blockquote><p>GoodsService</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SpuDetail <span class="hljs-title">querySpuDetailById</span><span class="hljs-params">(Long id)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.spuDetailMapper.selectByPrimaryKey(id);&#125;</code></pre></div><blockquote><p>测试</p></blockquote><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528477123640.png" srcset="/img/loading.gif" alt="1528477123640"></p><h2 id="2-3-查询sku"><a href="#2-3-查询sku" class="headerlink" title="2.3.查询sku"></a>2.3.查询sku</h2><blockquote><p>分析</p></blockquote><ul><li>请求方式：Get</li><li>请求路径：/sku/list</li><li>请求参数：id，应该是spu的id</li><li>返回结果：sku的集合</li></ul><blockquote><p>GoodsController</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"sku/list"</span>)<span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuBySpuId(<span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">"id"</span>) Long id) &#123;    List&lt;Sku&gt; skus = <span class="hljs-keyword">this</span>.goodsService.querySkuBySpuId(id);    <span class="hljs-keyword">if</span> (skus == <span class="hljs-keyword">null</span> || skus.size() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);    &#125;    <span class="hljs-keyword">return</span> ResponseEntity.ok(skus);&#125;</code></pre></div><blockquote><p>GoodsService</p></blockquote><p>需要注意的是，为了页面回显方便，我们一并把sku的库存stock也查询出来</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sku&gt; <span class="hljs-title">querySkuBySpuId</span><span class="hljs-params">(Long spuId)</span> </span>&#123;    <span class="hljs-comment">// 查询sku</span>    Sku record = <span class="hljs-keyword">new</span> Sku();    record.setSpuId(spuId);    List&lt;Sku&gt; skus = <span class="hljs-keyword">this</span>.skuMapper.select(record);    <span class="hljs-keyword">for</span> (Sku sku : skus) &#123;        <span class="hljs-comment">// 同时查询出库存</span>        sku.setStock(<span class="hljs-keyword">this</span>.stockMapper.selectByPrimaryKey(sku.getId()).getStock());    &#125;    <span class="hljs-keyword">return</span> skus;&#125;</code></pre></div><blockquote><p>测试：</p></blockquote><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528477189379.png" srcset="/img/loading.gif" alt="1528477189379"></p><h2 id="2-4-页面回显"><a href="#2-4-页面回显" class="headerlink" title="2.4.页面回显"></a>2.4.页面回显</h2><p>随便点击一个编辑按钮，发现数据回显完成：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528477890801.png" srcset="/img/loading.gif" alt="1528477890801"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528477928748.png" srcset="/img/loading.gif" alt="1528477928748"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528477970912.png" srcset="/img/loading.gif" alt="1528477970912"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528478019100.png" srcset="/img/loading.gif" alt="1528478019100"></p><h2 id="2-5-页面提交"><a href="#2-5-页面提交" class="headerlink" title="2.5.页面提交"></a>2.5.页面提交</h2><p>这里的保存按钮与新增其实是同一个，因此提交的逻辑也是一样的，这里不再赘述。</p><p>随便修改点数据，然后点击保存，可以看到浏览器已经发出请求：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528478194128.png" srcset="/img/loading.gif" alt="1528478194128"></p><h2 id="2-6-后台实现"><a href="#2-6-后台实现" class="headerlink" title="2.6.后台实现"></a>2.6.后台实现</h2><p>接下来，我们编写后台，实现修改商品接口。</p><h3 id="2-6-1-Controller"><a href="#2-6-1-Controller" class="headerlink" title="2.6.1.Controller"></a>2.6.1.Controller</h3><ul><li>请求方式：PUT</li><li>请求路径：/</li><li>请求参数：Spu对象</li><li>返回结果：无</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 新增商品</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> spu</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@PutMapping</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Void&gt; <span class="hljs-title">updateGoods</span><span class="hljs-params">(@RequestBody SpuBo spu)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">this</span>.goodsService.update(spu);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR);    &#125;&#125;</code></pre></div><h3 id="2-6-2-Service"><a href="#2-6-2-Service" class="headerlink" title="2.6.2.Service"></a>2.6.2.Service</h3><p>spu数据可以修改，但是SKU数据无法修改，因为有可能之前存在的SKU现在已经不存在了，或者以前的sku属性都不存在了。比如以前内存有4G，现在没了。</p><p>因此这里直接删除以前的SKU，然后新增即可。</p><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(SpuBo spu)</span> </span>&#123;    <span class="hljs-comment">// 查询以前sku</span>    List&lt;Sku&gt; skus = <span class="hljs-keyword">this</span>.querySkuBySpuId(spu.getId());    <span class="hljs-comment">// 如果以前存在，则删除</span>    <span class="hljs-keyword">if</span>(!CollectionUtils.isEmpty(skus)) &#123;        List&lt;Long&gt; ids = skus.stream().map(s -&gt; s.getId()).collect(Collectors.toList());        <span class="hljs-comment">// 删除以前库存</span>        Example example = <span class="hljs-keyword">new</span> Example(Stock<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        example.createCriteria().andIn(<span class="hljs-string">"skuId"</span>, ids);        <span class="hljs-keyword">this</span>.stockMapper.deleteByExample(example);        <span class="hljs-comment">// 删除以前的sku</span>        Sku record = <span class="hljs-keyword">new</span> Sku();        record.setSpuId(spu.getId());        <span class="hljs-keyword">this</span>.skuMapper.delete(record);    &#125;    <span class="hljs-comment">// 新增sku和库存</span>    saveSkuAndStock(spu.getSkus(), spu.getId());    <span class="hljs-comment">// 更新spu</span>    spu.setLastUpdateTime(<span class="hljs-keyword">new</span> Date());    spu.setCreateTime(<span class="hljs-keyword">null</span>);    spu.setValid(<span class="hljs-keyword">null</span>);    spu.setSaleable(<span class="hljs-keyword">null</span>);    <span class="hljs-keyword">this</span>.spuMapper.updateByPrimaryKeySelective(spu);    <span class="hljs-comment">// 更新spu详情</span>    <span class="hljs-keyword">this</span>.spuDetailMapper.updateByPrimaryKeySelective(spu.getSpuDetail());&#125;</code></pre></div><h3 id="2-6-3-mapper"><a href="#2-6-3-mapper" class="headerlink" title="2.6.3.mapper"></a>2.6.3.mapper</h3><p>与以前一样。</p><h2 id="2-7-其它"><a href="#2-7-其它" class="headerlink" title="2.7.其它"></a>2.7.其它</h2><p>商品的删除、上下架大家自行实现。</p><h1 id="3-搭建前台系统"><a href="#3-搭建前台系统" class="headerlink" title="3.搭建前台系统"></a>3.搭建前台系统</h1><p>后台系统的内容暂时告一段落，有了商品，接下来我们就要在页面展示商品，给用户提供浏览和购买的入口，那就是我们的门户系统。</p><p>门户系统面向的是用户，安全性很重要，而且搜索引擎对于单页应用并不友好。因此我们的门户系统不再采用与后台系统类似的SPA（单页应用）。</p><p>依然是前后端分离，不过前端的页面会使用独立的html，在每个页面中使用vue来做页面渲染。</p><h2 id="3-1-静态资源"><a href="#3-1-静态资源" class="headerlink" title="3.1.静态资源"></a>3.1.静态资源</h2><p>webpack打包多页应用配置比较繁琐，项目结构也相对复杂。这里为了简化开发（毕竟我们不是专业的前端人员），我们不再使用webpack，而是直接编写原生的静态HTML。</p><h3 id="3-1-1-创建工程"><a href="#3-1-1-创建工程" class="headerlink" title="3.1.1.创建工程"></a>3.1.1.创建工程</h3><p>创建一个新的工程：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528479807646.png" srcset="/img/loading.gif" alt="1528479807646"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528479863567.png" srcset="/img/loading.gif" alt="1528479863567"></p><h3 id="3-1-2-导入静态资源"><a href="#3-1-2-导入静态资源" class="headerlink" title="3.1.2.导入静态资源"></a>3.1.2.导入静态资源</h3><p>将课前资料中的leyou-portal解压，并复制到这个项目下</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528479930705.png" srcset="/img/loading.gif" alt="1528479930705"></p><p>解压缩：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528479984188.png" srcset="/img/loading.gif" alt="1528479984188"></p><p>项目结构：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528480139441.png" srcset="/img/loading.gif" alt="1528480139441"></p><h2 id="3-2-live-server"><a href="#3-2-live-server" class="headerlink" title="3.2.live-server"></a>3.2.live-server</h2><p>没有webpack，我们就无法使用webpack-dev-server运行这个项目，实现热部署。</p><p>所以，这里我们使用另外一种热部署方式：live-server，</p><h3 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1.简介"></a>3.2.1.简介</h3><p>地址；<a href="https://www.npmjs.com/package/live-server" target="_blank" rel="noopener">https://www.npmjs.com/package/live-server</a></p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526460917348.png" srcset="/img/loading.gif" alt="1526460917348"></p><p>这是一款带有热加载功能的小型开发服务器。用它来展示你的HTML / JavaScript / CSS，但不能用于部署最终的网站。 </p><h3 id="3-2-2-安装和运行参数"><a href="#3-2-2-安装和运行参数" class="headerlink" title="3.2.2.安装和运行参数"></a>3.2.2.安装和运行参数</h3><p>安装，使用npm命令即可，这里建议全局安装，以后任意位置可用</p><div class="hljs"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> -g live-<span class="hljs-keyword">server</span></code></pre></div><p>运行时，直接输入命令：</p><div class="hljs"><pre><code class="hljs axapta">live-<span class="hljs-keyword">server</span></code></pre></div><p>另外，你可以在运行命令后，跟上一些参数以配置：</p><ul><li><code>--port=NUMBER</code> - 选择要使用的端口，默认值：PORT env var或8080</li><li><code>--host=ADDRESS</code> - 选择要绑定的主机地址，默认值：IP env var或0.0.0.0（“任意地址”）</li><li><code>--no-browser</code> - 禁止自动Web浏览器启动</li><li><code>--browser=BROWSER</code> - 指定使用浏览器而不是系统默认值</li><li><code>--quiet | -q</code> - 禁止记录</li><li><code>--verbose | -V</code> - 更多日志记录（记录所有请求，显示所有侦听的IPv4接口等）</li><li><code>--open=PATH</code> - 启动浏览器到PATH而不是服务器root</li><li><code>--watch=PATH</code> - 用逗号分隔的路径来专门监视变化（默认值：观看所有内容）</li><li><code>--ignore=PATH</code>- 要忽略的逗号分隔的路径字符串（<a href="https://github.com/es128/anymatch" target="_blank" rel="noopener">anymatch</a> -compatible definition）</li><li><code>--ignorePattern=RGXP</code>-文件的正则表达式忽略（即<code>.*\.jade</code>）（<strong>不推荐使用</strong>赞成<code>--ignore</code>）</li><li><code>--middleware=PATH</code> - 导出要添加的中间件功能的.js文件的路径; 可以是没有路径的名称，也可以是引用<code>middleware</code>文件夹中捆绑的中间件的扩展名</li><li><code>--entry-file=PATH</code> - 提供此文件（服务器根目录）代替丢失的文件（对单页应用程序有用）</li><li><code>--mount=ROUTE:PATH</code> - 在定义的路线下提供路径内容（可能有多个定义）</li><li><code>--spa</code> - 将请求从/ abc转换为/＃/ abc（方便单页应用）</li><li><code>--wait=MILLISECONDS</code> - （默认100ms）等待所有更改，然后重新加载</li><li><code>--htpasswd=PATH</code> - 启用期待位于PATH的htpasswd文件的http-auth</li><li><code>--cors</code> - 为任何来源启用CORS（反映请求源，支持凭证的请求）</li><li><code>--https=PATH</code> - 到HTTPS配置模块的路径</li><li><code>--proxy=ROUTE:URL</code> - 代理ROUTE到URL的所有请求</li><li><code>--help | -h</code> - 显示简洁的使用提示并退出</li><li><code>--version | -v</code> - 显示版本并退出</li></ul><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>我们进入leyou-portal目录，输入命令：</p><div class="hljs"><pre><code class="hljs pgsql">live-<span class="hljs-keyword">server</span> <span class="hljs-comment">--port=9002</span></code></pre></div><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1528480541193.png" srcset="/img/loading.gif" alt="1528480541193"></p><h2 id="3-3-域名访问"><a href="#3-3-域名访问" class="headerlink" title="3.3.域名访问"></a>3.3.域名访问</h2><p>现在我们访问只能通过：<a href="http://127.0.0.1:9002" target="_blank" rel="noopener">http://127.0.0.1:9002</a></p><p>我们希望用域名访问：<a href="http://www.leyou.com" target="_blank" rel="noopener">http://www.leyou.com</a></p><p>第一步，修改hosts文件，添加一行配置：</p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> www.leyou.com</code></pre></div><p>第二步，修改nginx配置，将<a href="http://www.leyou.com反向代理到127.0.0.1:9002" target="_blank" rel="noopener">www.leyou.com反向代理到127.0.0.1:9002</a></p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  www.leyou.com;    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host <span class="hljs-variable">$host</span>;    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Server <span class="hljs-variable">$host</span>;    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:9002;        <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;        <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;    &#125;&#125;</code></pre></div><p>重新加载nginx配置：<code>nginx.exe -s reload</code></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526462774092.png" srcset="/img/loading.gif" alt="1526462774092"></p><h2 id="3-4-common-js"><a href="#3-4-common-js" class="headerlink" title="3.4.common.js"></a>3.4.common.js</h2><p>为了方便后续的开发，我们在前台系统中定义了一些工具，放在了common.js中：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526643361038.png" srcset="/img/loading.gif" alt="1526643361038"></p><p>部分代码截图：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/%E4%B9%90%E4%BC%98/7%E6%9C%881%E5%8F%B7%E6%9B%B4%E6%96%B0/day10-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday10/1526643526973.png" srcset="/img/loading.gif" alt="1526643526973"></p><p>首先对axios进行了一些全局配置，请求超时时间，请求的基础路径，是否允许跨域操作cookie等</p><p>定义了对象 ly ，也叫leyou，包含了下面的属性：</p><ul><li>getUrlParam(key)：获取url路径中的参数</li><li>http：axios对象的别名。以后发起ajax请求，可以用ly.http.get()</li><li>store：localstorage便捷操作，后面用到再详细说明</li><li>formatPrice：格式化价格，如果传入的是字符串，则扩大100被并转为数字，如果传入是数字，则缩小100倍并转为字符串</li><li>formatDate(val, pattern)：对日期对象val按照指定的pattern模板进行格式化</li><li>stringify：将对象转为参数字符串</li><li>parse：将参数字符串变为js对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day09：商品规格管理</title>
    <link href="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/"/>
    <url>/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解商品规格数据结构设计思路</li><li>实现商品规格查询</li><li>了解SPU和SKU数据结构设计思路</li><li>实现商品查询</li><li>了解商品新增的页面实现</li><li>独立编写商品新增后台功能</li></ul><h1 id="1-商品规格数据结构"><a href="#1-商品规格数据结构" class="headerlink" title="1.商品规格数据结构"></a>1.商品规格数据结构</h1><p>乐优商城是一个全品类的电商网站，因此商品的种类繁多，每一件商品，其属性又有差别。为了更准确描述商品及细分差别，抽象出两个概念：SPU和SKU，了解一下：</p><h2 id="1-1-SPU和SKU"><a href="#1-1-SPU和SKU" class="headerlink" title="1.1.SPU和SKU"></a>1.1.SPU和SKU</h2><p>SPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集</p><p>SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品</p><p>以图为例来看：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526085541996.png" srcset="/img/loading.gif" alt="1526085541996"></p><ul><li>本页的 华为Mate10 就是一个商品集（SPU）</li><li>因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU）</li></ul><p>可以看出：</p><ul><li>SPU是一个抽象的商品集概念，为了方便后台的管理。</li><li>SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU</li></ul><h2 id="1-2-数据库设计分析"><a href="#1-2-数据库设计分析" class="headerlink" title="1.2.数据库设计分析"></a>1.2.数据库设计分析</h2><h3 id="1-2-1-思考并发现问题"><a href="#1-2-1-思考并发现问题" class="headerlink" title="1.2.1.思考并发现问题"></a>1.2.1.思考并发现问题</h3><p>弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。</p><p>首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？</p><div class="hljs"><pre><code class="hljs qml"><span class="hljs-attribute">id:</span><span class="hljs-string">主键</span><span class="hljs-string">title</span>：标题description：描述specification：规格packaging_list：包装after_service：售后服务comment：评价category_id：商品分类brand_id：品牌</code></pre></div><p>似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526086539789.png" srcset="/img/loading.gif" alt="1526086539789"></p><p>不同商品的规格不一定相同，数据库中要如何保存？</p><p>再看下SKU，大家觉得应该有什么字段？</p><div class="hljs"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span>：主键spu_id：关联的spuprice：价格images：图片stock：库存颜色？内存？硬盘？</code></pre></div><p>碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，我们是全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？</p><h3 id="1-2-2-分析规格参数"><a href="#1-2-2-分析规格参数" class="headerlink" title="1.2.2.分析规格参数"></a>1.2.2.分析规格参数</h3><p>仔细查看每一种商品的规格你会发现：</p><p>虽然商品规格千变万化，但是同一类商品（如手机）的规格是统一的，有图为证：</p><blockquote><p>华为的规格：</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526087063700.png" srcset="/img/loading.gif" alt="1526087063700"></p><blockquote><p>三星的规格：</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526087142454.png" srcset="/img/loading.gif" alt="1526087142454"></p><p>也就是说，商品的规格参数应该是与分类绑定的。<strong>每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同</strong>。</p><p>如下图所示：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526088168565.png" srcset="/img/loading.gif" alt="1526088168565"></p><h3 id="1-2-3-SKU的特有属性"><a href="#1-2-3-SKU的特有属性" class="headerlink" title="1.2.3.SKU的特有属性"></a>1.2.3.SKU的特有属性</h3><p>SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。</p><p>不同种类的商品，一个手机，一个衣服，其SKU属性不相同。</p><p>同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。</p><p>这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，<strong>SKU的特有属性是商品规格参数的一部分</strong>：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526088981953.png" srcset="/img/loading.gif" alt="1526088981953"></p><p>也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分：</p><ul><li>所有sku共享的规格属性（称为全局属性）</li><li>每个sku不同的规格属性（称为特有属性）</li></ul><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526089506566.png" srcset="/img/loading.gif" alt="1526089506566"></p><h3 id="1-2-4-搜索属性"><a href="#1-2-4-搜索属性" class="headerlink" title="1.2.4.搜索属性"></a>1.2.4.搜索属性</h3><p>打开一个搜索页，我们来看看过滤的条件：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526090072535.png" srcset="/img/loading.gif" alt="1526090072535"></p><p>你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526090228171.png" srcset="/img/loading.gif" alt="1526090228171"></p><p>也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。要注意的是，无论是SPU的全局属性，还是SKU的特有属性，都有可能作为搜索过滤条件的，并不冲突，而是有一个交集：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526091216124.png" srcset="/img/loading.gif" alt="1526091216124"></p><h2 id="1-3-规格参数表"><a href="#1-3-规格参数表" class="headerlink" title="1.3.规格参数表"></a>1.3.规格参数表</h2><h3 id="1-3-1-表结构"><a href="#1-3-1-表结构" class="headerlink" title="1.3.1.表结构"></a>1.3.1.表结构</h3><p>先看下规格参数表：</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_specification&#96; (  &#96;category_id&#96; bigint(20) NOT NULL COMMENT &#39;规格模板所属商品分类id&#39;,  &#96;specifications&#96; varchar(3000) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;规格参数模板，json格式&#39;,  PRIMARY KEY (&#96;category_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品规格参数模板，json格式。&#39;;</code></pre></div><p>很奇怪是吧，只有两个字段。特别需要注意的是第二个字段：</p><ul><li>specificatons：规格参数模板，json格式</li></ul><p>为什么是一个json？我们看下规格参数的格式：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526092179381.png" srcset="/img/loading.gif" alt="1526092179381"></p><p>如果按照传统数据库设计，这里至少需要3张表：</p><ul><li>group：代表组，与商品分类关联</li><li>param_key：属性名，与组关联，一对多</li><li>param_value：属性备选值，与属性名关联，一对多</li></ul><p>这样程序的复杂度大大增加，但是提高了数据的复用性。</p><p>我们的解决方案是，采用json来保存整个规格参数模板，不需要额外的表，一个字符串就够了。</p><h3 id="1-3-2-json结构分析"><a href="#1-3-2-json结构分析" class="headerlink" title="1.3.2.json结构分析"></a>1.3.2.json结构分析</h3><blockquote><p>先整体看一下：</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526092693138.png" srcset="/img/loading.gif" alt="1526092693138"></p><ul><li>因为规格参数分为很多组，所以json最外层是一个数组。</li><li>数组中是对象类型，每个对象代表一个组的数据，对象的属性包括：<ul><li>group：组的名称</li><li>params：该组的所有属性</li></ul></li></ul><blockquote><p>接下来是params：</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526093111370.png" srcset="/img/loading.gif" alt="1526093111370"></p><p>以<code>主芯片</code>这一组为例：</p><ul><li><p>group：注明，这里是主芯片</p></li><li><p>params：该组的所有规格属性，因为不止一个，所以是一个数组。这里包含四个规格属性：CPU品牌，CPU型号，CPU频率，CPU核数。每个规格属性都是一个对象，包含以下信息：</p><ul><li>k：属性名称</li><li>searchable：是否作为搜索字段，将来在搜索页面使用，boolean类型</li><li>global：是否是SPU全局属性，boolean类型。true为全局属性，false为SKU的特有属性</li><li>options：属性值的可选项，数组结构。起约束作用，不允许填写可选项以外的值，比如CPU核数，有人添10000核岂不是很扯淡</li><li>numerical：是否为数值，boolean类型，true则为数值，false则不是。为空也代表非数值</li><li>unit：单位，如：克，毫米。如果是数值类型，那么就需要有单位，否则可以不填。</li></ul></li></ul><p>上面的截图中所有属性都是全局属性，我们来看看内存，应该是特有属性：</p><p>  <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526262641446.png" srcset="/img/loading.gif" alt="1526262641446"></p><p>总结下：</p><ul><li>规格参数分组，每组有多个参数</li><li>参数的 <code>k</code>代表属性名称，没有值，具体的SPU才能确定值</li><li>参数会有不同的属性：是否可搜索，是否是全局、是否是数值，这些都用boolean值进行标记：<ul><li>SPU下的多个SKU共享的参数称为全局属性，用<code>global</code>标记</li><li>SPU下的多个SKU特有的参数称为特有属性</li><li>如果参数是数值类型，用<code>numerical</code>标记，并且指定单位<code>unit</code></li><li>如果参数可搜索，用<code>searchable</code>标记</li></ul></li></ul><h1 id="2-商品规格参数管理"><a href="#2-商品规格参数管理" class="headerlink" title="2.商品规格参数管理"></a>2.商品规格参数管理</h1><h2 id="2-1-页面实现"><a href="#2-1-页面实现" class="headerlink" title="2.1.页面实现"></a>2.1.页面实现</h2><p>页面比较复杂，这里就不带着大家去实现完整页面效果了，我们一起分析一下即可。</p><h3 id="2-1-1-整体布局"><a href="#2-1-1-整体布局" class="headerlink" title="2.1.1.整体布局"></a>2.1.1.整体布局</h3><p>打开规格参数页面，看到如下内容：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526095296462.png" srcset="/img/loading.gif" alt="1526095296462"></p><p>因为规格是跟商品分类绑定的，因此首先会展现商品分类树，并且提示你要选择商品分类，才能看到规格参数的模板。一起了解下页面的实现：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526095548672.png" srcset="/img/loading.gif" alt="1526095548672"></p><p>可以看出页面分成3个部分：</p><ul><li><p><code>v-card-title</code>：标题部分，这里是提示信息，告诉用户要先选择分类，才能看到模板</p></li><li><p><code>v-tree</code>：这里用到的是我们之前讲过的树组件，展示商品分类树，不过现在是假数据，我们只要把<code>treeData</code>属性删除，它就会走<code>url</code>属性指定的路径去查询真实的商品分类树了。</p><div class="hljs"><pre><code class="hljs js">&lt;v-tree url=<span class="hljs-string">"/item/category/list"</span> :isEdit=<span class="hljs-string">"false"</span>  @handleClick=<span class="hljs-string">"handleClick"</span> /&gt;</code></pre></div></li><li><p><code>v-dialog</code>：Vuetify提供的对话框组件，v-model绑定的dialog属性是boolean类型：</p><ul><li>true则显示弹窗</li><li>false则隐藏弹窗</li></ul></li></ul><h3 id="2-1-2-data中定义的属性"><a href="#2-1-2-data中定义的属性" class="headerlink" title="2.1.2.data中定义的属性"></a>2.1.2.data中定义的属性</h3><p>接下来，看看Vue实例中data定义了哪些属性，对页面会产生怎样的影响：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526287774316.png" srcset="/img/loading.gif" alt="1526287774316"></p><ul><li>specifications：选中一个商品分类后，需要查询后台获取规格参数信息，保存在这个对象中，Vue会完成页面渲染。</li><li>oldSpec：当前页兼具了规格的增、改、查等功能，这个对象记录被修改前的规格参数，以防用户撤销修改，用来恢复数据。</li><li>dialog：是否显示对话框的标记。true则显示，false则不显示</li><li>currentNode：记录当前选中的商品分类节点</li><li>isInsert：判断接下来是新增还是修改</li></ul><h2 id="2-2-规格参数的查询"><a href="#2-2-规格参数的查询" class="headerlink" title="2.2.规格参数的查询"></a>2.2.规格参数的查询</h2><p>点击树节点后要显示规格参数，因此查询功能应该编写在点击事件中。</p><p>了解一下：</p><h3 id="2-2-1-树节点的点击事件"><a href="#2-2-1-树节点的点击事件" class="headerlink" title="2.2.1.树节点的点击事件"></a>2.2.1.树节点的点击事件</h3><p>当我们点击树节点时，要将<code>v-dialog</code>打开，因此必须绑定一个点击事件：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526095959539.png" srcset="/img/loading.gif" alt="1526095959539"></p><p>我们来看下<code>handleClick</code>方法：</p><div class="hljs"><pre><code class="hljs js">handleClick(node) &#123;    <span class="hljs-comment">// 判断点击的节点是否是父节点（只有点击到叶子节点才会弹窗）</span>    <span class="hljs-keyword">if</span> (!node.isParent) &#123;        <span class="hljs-comment">// 如果是叶子节点，那么就发起ajax请求，去后台查询商品规格数据。</span>        <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/spec/"</span> + node.id)            .then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123;            <span class="hljs-comment">// 查询成功后，把响应结果赋值给specifications属性，Vue会进行自动渲染。</span>            <span class="hljs-keyword">this</span>.specifications = resp.data;            <span class="hljs-comment">// 记录下此时的规格数据，当页面撤销修改时，用来恢复原始数据</span>            <span class="hljs-keyword">this</span>.oldSpec = resp.data;            <span class="hljs-comment">// 打开弹窗</span>            <span class="hljs-keyword">this</span>.dialog = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// 标记此时要进行修改操作</span>            <span class="hljs-keyword">this</span>.isInsert = <span class="hljs-literal">false</span>;        &#125;)            .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-comment">// 如果没有查询成功，那么询问是否添加规格</span>            <span class="hljs-keyword">this</span>.$message.confirm(<span class="hljs-string">'该分类还没有规格参数，是否添加?'</span>)                .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                <span class="hljs-comment">// 如果要添加，则将specifications初始化为空</span>                <span class="hljs-keyword">this</span>.specifications = [&#123;                    group: <span class="hljs-string">''</span>,                    params: []                &#125;];                <span class="hljs-comment">// 打开弹窗</span>                <span class="hljs-keyword">this</span>.dialog = <span class="hljs-literal">true</span>;                <span class="hljs-comment">// 标记为新增</span>                <span class="hljs-keyword">this</span>.isInsert = <span class="hljs-literal">true</span>;            &#125;)        &#125;)    &#125;&#125;</code></pre></div><p>因此，我们接下来要做的事情，就是编写接口，实现规格参数的查询了。</p><h3 id="2-2-2-后端代码"><a href="#2-2-2-后端代码" class="headerlink" title="2.2.2.后端代码"></a>2.2.2.后端代码</h3><blockquote><p>实体类</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_specification"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Specification</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long categoryId;    <span class="hljs-keyword">private</span> String specifications;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getCategoryId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> categoryId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCategoryId</span><span class="hljs-params">(Long categoryId)</span> </span>&#123;        <span class="hljs-keyword">this</span>.categoryId = categoryId;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSpecifications</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> specifications;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSpecifications</span><span class="hljs-params">(String specifications)</span> </span>&#123;        <span class="hljs-keyword">this</span>.specifications = specifications;    &#125;&#125;</code></pre></div><blockquote><p>mapper</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpecificationMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Specification</span>&gt; </span>&#123;&#125;</code></pre></div><blockquote><p>controller</p></blockquote><p>先分析下需要的东西，在页面的ajax请求中可以看出：</p><ul><li><p>请求方式：查询，肯定是get</p></li><li><p>请求路径：/spec/{cid} ，这里通过路径占位符传递商品分类的id</p></li><li><p>请求参数：商品分类id</p></li><li><p>返回结果：页面是直接把<code>resp.data</code>赋值给了specifications：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526104087329.png" srcset="/img/loading.gif" alt="1526104087329"></p><p>那么我们返回的应该是规格参数的字符串</p></li></ul><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"spec"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecificationController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SpecificationService specificationService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">querySpecificationByCategoryId</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>&#123;        Specification spec = <span class="hljs-keyword">this</span>.specificationService.queryById(id);        <span class="hljs-keyword">if</span> (spec == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-keyword">return</span> ResponseEntity.ok(spec.getSpecifications());    &#125;&#125;</code></pre></div><blockquote><p>service:</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecificationService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SpecificationMapper specificationMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> Specification <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.specificationMapper.selectByPrimaryKey(id);    &#125;&#125;</code></pre></div><blockquote><p>页面访问测试：</p></blockquote><p>目前，我们数据库只提供了3条规格参数信息：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526104551227.png" srcset="/img/loading.gif" alt="1526104551227"></p><p>我们访问：<a href="http://api.leyou.com/api/item/spec/76" target="_blank" rel="noopener">http://api.leyou.com/api/item/spec/76</a></p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526104475036.png" srcset="/img/loading.gif" alt="1526104475036"></p><p>然后在后台系统中测试：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526104599452.png" srcset="/img/loading.gif" alt="1526104599452"></p><p>当我们点击一个还不存在的规格参数的商品分类：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526104769276.png" srcset="/img/loading.gif" alt="1526104769276"></p><h2 id="2-3-增、删、改（作业）"><a href="#2-3-增、删、改（作业）" class="headerlink" title="2.3.增、删、改（作业）"></a>2.3.增、删、改（作业）</h2><p>增删改的作业就留给大家去完成了。页面中接口都已定义，你要做的就是实现后台接口。</p><h1 id="3-SPU和SKU数据结构"><a href="#3-SPU和SKU数据结构" class="headerlink" title="3.SPU和SKU数据结构"></a>3.SPU和SKU数据结构</h1><p>规格确定以后，就可以添加商品了,先看下数据库表</p><h2 id="3-1-SPU表"><a href="#3-1-SPU表" class="headerlink" title="3.1.SPU表"></a>3.1.SPU表</h2><h3 id="3-1-1-表结构"><a href="#3-1-1-表结构" class="headerlink" title="3.1.1.表结构"></a>3.1.1.表结构</h3><p>SPU表：</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_spu&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;spu id&#39;,  &#96;title&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;标题&#39;,  &#96;sub_title&#96; varchar(255) DEFAULT &#39;&#39; COMMENT &#39;子标题&#39;,  &#96;cid1&#96; bigint(20) NOT NULL COMMENT &#39;1级类目id&#39;,  &#96;cid2&#96; bigint(20) NOT NULL COMMENT &#39;2级类目id&#39;,  &#96;cid3&#96; bigint(20) NOT NULL COMMENT &#39;3级类目id&#39;,  &#96;brand_id&#96; bigint(20) NOT NULL COMMENT &#39;商品所属品牌id&#39;,  &#96;saleable&#96; tinyint(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;是否上架，0下架，1上架&#39;,  &#96;valid&#96; tinyint(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;是否有效，0已删除，1有效&#39;,  &#96;create_time&#96; datetime DEFAULT NULL COMMENT &#39;添加时间&#39;,  &#96;last_update_time&#96; datetime DEFAULT NULL COMMENT &#39;最后修改时间&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;208 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;spu表，该表描述的是一个抽象的商品，比如 iphone8&#39;;</code></pre></div><p>与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。</p><p>我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_spu_detail&#96; (  &#96;spu_id&#96; bigint(20) NOT NULL,  &#96;description&#96; text COMMENT &#39;商品描述信息&#39;,  &#96;specifications&#96; varchar(3000) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;全部规格参数数据&#39;,  &#96;spec_template&#96; varchar(1000) NOT NULL COMMENT &#39;特有规格参数及可选值信息，json格式&#39;,  &#96;packing_list&#96; varchar(1000) DEFAULT &#39;&#39; COMMENT &#39;包装清单&#39;,  &#96;after_service&#96; varchar(1000) DEFAULT &#39;&#39; COMMENT &#39;售后服务&#39;,  PRIMARY KEY (&#96;spu_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</code></pre></div><p>这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。</p><p>需要注意的是这两个字段：specifications和spec_template。</p><h3 id="3-1-2-spu中的规格参数"><a href="#3-1-2-spu中的规格参数" class="headerlink" title="3.1.2.spu中的规格参数"></a>3.1.2.spu中的规格参数</h3><p>前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数，因此我们计划是这样：</p><ul><li>SPU中保存全局的规格参数信息。</li><li>SKU中保存特有规格参数。</li></ul><p>以手机为例，品牌、操作系统等肯定是全局属性，内存、颜色等肯定是特有属性。</p><p>当你确定了一个SPU，比如小米的：红米4X</p><p>全局属性举例：</p><div class="hljs"><pre><code class="hljs angelscript">品牌：小米型号：红米<span class="hljs-number">4</span>X</code></pre></div><p>特有属性举例：</p><div class="hljs"><pre><code class="hljs angelscript">颜色：[香槟金, 樱花粉, 磨砂黑]内存：[<span class="hljs-number">2</span>G, <span class="hljs-number">3</span>G]机身存储：[<span class="hljs-number">16</span>GB, <span class="hljs-number">32</span>GB]</code></pre></div><p>来看下我们的 表如何存储这些信息：</p><h4 id="3-1-2-1-specifications字段"><a href="#3-1-2-1-specifications字段" class="headerlink" title="3.1.2.1.specifications字段"></a>3.1.2.1.specifications字段</h4><p>首先是specifications，其中保存全部规格参数信息，因此也是一个json格式：</p><blockquote><p>整体来看：</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526262279963.png" srcset="/img/loading.gif" alt="1526262279963"></p><p>整体看上去与规格参数表中的数据一样，也是一个数组，并且分组，每组下有多个参数</p><blockquote><p>展开一组来看</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526262389233.png" srcset="/img/loading.gif" alt="1526262389233"></p><p>可以看到，与规格参数表中的模板相比，最大的区别就是，这里指定了具体的值，因为商品确定了，其参数值肯定也确定了。</p><blockquote><p>特有属性</p></blockquote><p>刚才看到的是全局属性，那么特有属性在这个字段中如何存储呢？</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526263214087.png" srcset="/img/loading.gif" alt="1526263214087"></p><p>我们发现特有属性也是有的，但是，注意看这里是不确定具体值的，因为特有属性只有在SKU中才能确定。这里只是保存了options，所有SKU属性的可选项。</p><p>在哪里会用到这个字段的值呢，商品详情页的规格参数信息中：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526267700765.png" srcset="/img/loading.gif" alt="1526267700765"></p><h4 id="3-1-2-2-spec-template字段"><a href="#3-1-2-2-spec-template字段" class="headerlink" title="3.1.2.2.spec_template字段"></a>3.1.2.2.spec_template字段</h4><p>既然specifications已经包含了所有的规格参数，那么为什么又多出了一个spec_template呢？</p><p>里面又有哪些内容呢？</p><p>来看数据格式：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526267952827.png" srcset="/img/loading.gif" alt="1526267952827"></p><p>可以看出，里面只保存了规格参数中的特有属性，而且格式进行了大大的简化，只有属性的key，和待选项。</p><p>为什么要冗余保存一份？</p><p>因为很多场景下我们只需要查询特有规格属性，如果放在一起，每次查询再去分离比较麻烦。</p><p>比如，商品详情页展示可选的规格参数时：</p><p>   <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526267828817.png" srcset="/img/loading.gif" alt="1526267828817"></p><h2 id="3-2-SKU表"><a href="#3-2-SKU表" class="headerlink" title="3.2.SKU表"></a>3.2.SKU表</h2><h3 id="3-2-1-表结构"><a href="#3-2-1-表结构" class="headerlink" title="3.2.1.表结构"></a>3.2.1.表结构</h3><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_sku&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;sku id&#39;,  &#96;spu_id&#96; bigint(20) NOT NULL COMMENT &#39;spu id&#39;,  &#96;title&#96; varchar(255) NOT NULL COMMENT &#39;商品标题&#39;,  &#96;images&#96; varchar(1000) DEFAULT &#39;&#39; COMMENT &#39;商品的图片，多个图片以‘,’分割&#39;,  &#96;price&#96; bigint(15) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;销售价格，单位为分&#39;,  &#96;indexes&#96; varchar(100) COMMENT &#39;特有规格属性在spu属性模板中的对应下标组合&#39;,  &#96;own_spec&#96; varchar(1000) COMMENT &#39;sku的特有规格参数，json格式，反序列化时应使用linkedHashMap，保证有序&#39;,  &#96;enable&#96; tinyint(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;是否有效，0无效，1有效&#39;,  &#96;create_time&#96; datetime NOT NULL COMMENT &#39;添加时间&#39;,  &#96;last_update_time&#96; datetime NOT NULL COMMENT &#39;最后修改时间&#39;,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;key_spu_id&#96; (&#96;spu_id&#96;) USING BTREE) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8&#39;;</code></pre></div><p>还有一张表，代表库存：</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_stock&#96; (  &#96;sku_id&#96; bigint(20) NOT NULL COMMENT &#39;库存对应的商品sku id&#39;,  &#96;seckill_stock&#96; int(9) DEFAULT &#39;0&#39; COMMENT &#39;可秒杀库存&#39;,  &#96;seckill_total&#96; int(9) DEFAULT &#39;0&#39; COMMENT &#39;秒杀总数量&#39;,  &#96;stock&#96; int(9) NOT NULL COMMENT &#39;库存数量&#39;,  PRIMARY KEY (&#96;sku_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;库存表，代表库存，秒杀库存等信息&#39;;</code></pre></div><p>问题：为什么要将库存独立一张表？</p><p>因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。</p><p>特别需要注意的是sku表中的<code>indexes</code>字段和<code>own_spec</code>字段。sku中应该保存特有规格参数的值，就在这两个字段中。</p><h3 id="3-2-2-sku中的特有规格参数"><a href="#3-2-2-sku中的特有规格参数" class="headerlink" title="3.2.2.sku中的特有规格参数"></a>3.2.2.sku中的特有规格参数</h3><h4 id="3-2-2-1-indexes字段"><a href="#3-2-2-1-indexes字段" class="headerlink" title="3.2.2.1.indexes字段"></a>3.2.2.1.indexes字段</h4><p>在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"机身颜色"</span>: [        <span class="hljs-string">"香槟金"</span>,        <span class="hljs-string">"樱花粉"</span>,        <span class="hljs-string">"磨砂黑"</span>    ],    <span class="hljs-attr">"内存"</span>: [        <span class="hljs-string">"2GB"</span>,        <span class="hljs-string">"3GB"</span>    ],    <span class="hljs-attr">"机身存储"</span>: [        <span class="hljs-string">"16GB"</span>,        <span class="hljs-string">"32GB"</span>    ]&#125;</code></pre></div><p>这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。</p><p>比如：</p><ul><li>红米4X，香槟金，2GB内存，16GB存储</li><li>红米4X，磨砂黑，2GB内存，32GB存储</li></ul><p>你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样：</p><ul><li>红米4X，0,0,0</li><li>红米4X，2,0,1</li></ul><p>既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526266901335.png" srcset="/img/loading.gif" alt="1526266901335"></p><p>这个设计在商品详情页会特别有用：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526267180997.png" srcset="/img/loading.gif" alt="1526267180997"></p><p>当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。</p><h4 id="3-2-2-2-own-spec字段"><a href="#3-2-2-2-own-spec字段" class="headerlink" title="3.2.2.2.own_spec字段"></a>3.2.2.2.own_spec字段</h4><p>看结构：</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"机身颜色"</span>:<span class="hljs-string">"香槟金"</span>,<span class="hljs-attr">"内存"</span>:<span class="hljs-string">"2GB"</span>,<span class="hljs-attr">"机身存储"</span>:<span class="hljs-string">"16GB"</span>&#125;</code></pre></div><p>保存的是特有属性的键值对。</p><p>SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的键值对了。</p><p>这样，在页面展示规格参数信息时，就可以根据key来获取值，用于显示。</p><h2 id="3-3-导入图片信息"><a href="#3-3-导入图片信息" class="headerlink" title="3.3.导入图片信息"></a>3.3.导入图片信息</h2><p>现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机：</p><p>首先，把课前资料提供的数据上传到虚拟机下：<code>/leyou/static</code>目录：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1527823423289.png" srcset="/img/loading.gif" alt="1527823423289"></p><p>然后，使用命令解压缩：</p><div class="hljs"><pre><code class="hljs sh">unzip images.zip</code></pre></div><p>修改Nginx配置，使nginx反向代理这些图片地址：</p><div class="hljs"><pre><code class="hljs sh">vim /opt/nginx/config/nginx.conf</code></pre></div><p>修改成如下配置：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  image.leyou.com;    <span class="hljs-comment"># 监听域名中带有group的，交给FastDFS模块处理</span>    <span class="hljs-attribute">location</span> ~/group([<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])/ &#123;        ngx_fastdfs_module;    &#125;    <span class="hljs-comment"># 将其它图片代理指向本地的/leyou/static目录</span>    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">root</span>   /leyou/static/;    &#125;    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;    <span class="hljs-attribute">location</span> = /50x.html &#123;        <span class="hljs-attribute">root</span>   html;    &#125;&#125;</code></pre></div><h1 id="4-商品查询"><a href="#4-商品查询" class="headerlink" title="4.商品查询"></a>4.商品查询</h1><h2 id="4-1-效果预览"><a href="#4-1-效果预览" class="headerlink" title="4.1.效果预览"></a>4.1.效果预览</h2><p>接下来，我们实现商品管理的页面，先看下我们要实现的效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526268595873.png" srcset="/img/loading.gif" alt="1526268595873"></p><p>可以看出整体是一个table，然后有新增按钮。是不是跟昨天写品牌管理很像？</p><p>模板代码在分别在Goods.vue</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526269215532.png" srcset="/img/loading.gif" alt="1526269215532"></p><h2 id="4-2-从0开始"><a href="#4-2-从0开始" class="headerlink" title="4.2.从0开始"></a>4.2.从0开始</h2><p>接下来，我们自己来实现一下，新建两个组件：MyGoods.vue和MyGoodsForm.vue</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526269362233.png" srcset="/img/loading.gif" alt="1526269362233"></p><p>内容先随意：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;v-card&gt;      MyGoods  &lt;&#x2F;v-card&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    name: &quot;my-goods&quot;,    data() &#123;      return &#123;      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>然后修改menu.js,新建一个菜单：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526269555118.png" srcset="/img/loading.gif" alt="1526269555118"></p><p>修改router/index.js，添加一个路由：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526269615639.png" srcset="/img/loading.gif" alt="1526269615639"></p><p>预览一下：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526269739468.png" srcset="/img/loading.gif" alt="1526269739468"></p><h2 id="4-3-页面实现"><a href="#4-3-页面实现" class="headerlink" title="4.3.页面实现"></a>4.3.页面实现</h2><h3 id="4-3-1-页面基本表格"><a href="#4-3-1-页面基本表格" class="headerlink" title="4.3.1.页面基本表格"></a>4.3.1.页面基本表格</h3><p>商品列表页与品牌列表页几乎一样，我们可以直接去复制一份过来，然后进行一些修改。</p><p>首先，字段不一样，商品列表也展示的SPU信息，包含以下字段：</p><div class="hljs"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span>：title：标题cname：商品分类名称bname：品牌名称</code></pre></div><p>完整代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addGoods"</span>&gt;</span>新增商品<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>      <span class="hljs-comment">&lt;!--搜索框，与search属性关联--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">append-icon</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">hide-details</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-divider</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-data-table</span></span><span class="hljs-tag">      <span class="hljs-attr">:headers</span>=<span class="hljs-string">"headers"</span></span><span class="hljs-tag">      <span class="hljs-attr">:items</span>=<span class="hljs-string">"goodsList"</span></span><span class="hljs-tag">      <span class="hljs-attr">:search</span>=<span class="hljs-string">"search"</span></span><span class="hljs-tag">      <span class="hljs-attr">:pagination.sync</span>=<span class="hljs-string">"pagination"</span></span><span class="hljs-tag">      <span class="hljs-attr">:total-items</span>=<span class="hljs-string">"totalGoods"</span></span><span class="hljs-tag">      <span class="hljs-attr">:loading</span>=<span class="hljs-string">"loading"</span></span><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">"elevation-1"</span></span><span class="hljs-tag">    &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"items"</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"props"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; props.item.id &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xs-center"</span>&gt;</span>&#123;&#123; props.item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xs-center"</span>&gt;</span>&#123;&#123;props.item.cname&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xs-center"</span>&gt;</span>&#123;&#123; props.item.bname &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"justify-center layout"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"info"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"editGoods(props.item)"</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"warning"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> &gt;</span>下架<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-data-table</span>&gt;</span>    <span class="hljs-comment">&lt;!--弹出的对话框--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-dialog</span> <span class="hljs-attr">max-width</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"show"</span> <span class="hljs-attr">persistent</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>        <span class="hljs-comment">&lt;!--对话框的标题--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar</span> <span class="hljs-attr">dense</span> <span class="hljs-attr">dark</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar-title</span>&gt;</span>&#123;&#123;isEdit ? '修改' : '新增'&#125;&#125;商品<span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar-title</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span>/&gt;</span>          <span class="hljs-comment">&lt;!--关闭窗口的按钮--&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">icon</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"closeWindow"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-icon</span>&gt;</span>close<span class="hljs-tag">&lt;/<span class="hljs-name">v-icon</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar</span>&gt;</span>        <span class="hljs-comment">&lt;!--对话框的内容，表单--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">my-goods-form</span> <span class="hljs-attr">:oldGoods</span>=<span class="hljs-string">"oldGoods"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-dialog</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-comment">// 导入自定义的表单组件</span></span><span class="javascript">  <span class="hljs-keyword">import</span> MyGoodsForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyGoodsForm'</span></span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="actionscript">    name: <span class="hljs-string">"my-goods"</span>,</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        search: <span class="hljs-string">''</span>, <span class="hljs-comment">// 搜索过滤字段</span></span><span class="actionscript">        totalGoods: <span class="hljs-number">0</span>, <span class="hljs-comment">// 总条数</span></span><span class="actionscript">        goodsList: [], <span class="hljs-comment">// 当前页品牌数据</span></span><span class="actionscript">        loading: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在加载中</span></span><span class="actionscript">        pagination: &#123;&#125;, <span class="hljs-comment">// 分页信息</span></span>        headers: [<span class="actionscript">          &#123;text: <span class="hljs-string">'id'</span>, align: <span class="hljs-string">'center'</span>, value: <span class="hljs-string">'id'</span>&#125;,</span><span class="actionscript">          &#123;text: <span class="hljs-string">'标题'</span>, align: <span class="hljs-string">'center'</span>, sortable: <span class="hljs-literal">false</span>, value: <span class="hljs-string">'title'</span>&#125;,</span><span class="actionscript">          &#123;text: <span class="hljs-string">'商品分类'</span>, align: <span class="hljs-string">'center'</span>, sortable: <span class="hljs-literal">false</span>, value: <span class="hljs-string">'cname'</span>&#125;,</span><span class="actionscript">          &#123;text: <span class="hljs-string">'品牌'</span>, align: <span class="hljs-string">'center'</span>, value: <span class="hljs-string">'bname'</span>, sortable: <span class="hljs-literal">false</span>,&#125;,</span><span class="actionscript">          &#123;text: <span class="hljs-string">'操作'</span>, align: <span class="hljs-string">'center'</span>, sortable: <span class="hljs-literal">false</span>&#125;</span>        ],<span class="actionscript">        show: <span class="hljs-literal">false</span>,<span class="hljs-comment">// 控制对话框的显示</span></span><span class="actionscript">        oldGoods: &#123;&#125;, <span class="hljs-comment">// 即将被编辑的商品信息</span></span><span class="actionscript">        isEdit: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否是编辑</span></span>      &#125;    &#125;,<span class="actionscript">    mounted() &#123; <span class="hljs-comment">// 渲染后执行</span></span><span class="actionscript">      <span class="hljs-comment">// 查询数据</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.getDataFromServer();</span>    &#125;,    watch: &#123;<span class="actionscript">      pagination: &#123; <span class="hljs-comment">// 监视pagination属性的变化</span></span><span class="actionscript">        deep: <span class="hljs-literal">true</span>, <span class="hljs-comment">// deep为true，会监视pagination的属性及属性中的对象属性变化</span></span>        handler() &#123;<span class="actionscript">          <span class="hljs-comment">// 变化后的回调函数，这里我们再次调用getDataFromServer即可</span></span><span class="actionscript">          <span class="hljs-keyword">this</span>.getDataFromServer();</span>        &#125;      &#125;,<span class="actionscript">      search: &#123; <span class="hljs-comment">// 监视搜索字段</span></span>        handler() &#123;<span class="actionscript">          <span class="hljs-keyword">this</span>.getDataFromServer();</span>        &#125;      &#125;    &#125;,    methods: &#123;<span class="actionscript">      getDataFromServer() &#123; <span class="hljs-comment">// 从服务的加载数的方法。</span></span><span class="actionscript">        <span class="hljs-comment">// 发起请求</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/spu/page"</span>, &#123;</span>          params: &#123;<span class="actionscript">            key: <span class="hljs-keyword">this</span>.search, <span class="hljs-comment">// 搜索条件</span></span><span class="actionscript">            page: <span class="hljs-keyword">this</span>.pagination.page,<span class="hljs-comment">// 当前页</span></span><span class="actionscript">            rows: <span class="hljs-keyword">this</span>.pagination.rowsPerPage,<span class="hljs-comment">// 每页大小</span></span><span class="actionscript">            sortBy: <span class="hljs-keyword">this</span>.pagination.sortBy,<span class="hljs-comment">// 排序字段</span></span><span class="actionscript">            desc: <span class="hljs-keyword">this</span>.pagination.descending<span class="hljs-comment">// 是否降序</span></span>          &#125;<span class="javascript">        &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123; <span class="hljs-comment">// 这里使用箭头函数</span></span><span class="actionscript">          <span class="hljs-keyword">this</span>.goodsList = resp.data.items;</span><span class="actionscript">          <span class="hljs-keyword">this</span>.totalGoods = resp.data.total;</span><span class="actionscript">          <span class="hljs-comment">// 完成赋值后，把加载状态赋值为false</span></span><span class="actionscript">          <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>;</span>        &#125;)      &#125;,      addGoods() &#123;<span class="actionscript">        <span class="hljs-comment">// 修改标记</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.isEdit = <span class="hljs-literal">false</span>;</span><span class="actionscript">        <span class="hljs-comment">// 控制弹窗可见：</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;</span><span class="actionscript">        <span class="hljs-comment">// 把oldBrand变为null</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.oldBrand = <span class="hljs-literal">null</span>;</span>      &#125;,      editGoods(oldGoods)&#123;<span class="actionscript">        <span class="hljs-comment">// 修改标记</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.isEdit = <span class="hljs-literal">true</span>;</span><span class="actionscript">        <span class="hljs-comment">// 控制弹窗可见：</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;</span><span class="actionscript">        <span class="hljs-comment">// 获取要编辑的brand</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.oldGoods = oldGoods;</span>      &#125;,      closeWindow()&#123;<span class="actionscript">        <span class="hljs-comment">// 重新加载数据</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.getDataFromServer();</span><span class="actionscript">        <span class="hljs-comment">// 关闭窗口</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">false</span>;</span>      &#125;    &#125;,    components:&#123;      MyGoodsForm    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>主要的改动点：</p><ul><li><p>页面的<code>v-data-table</code>中的属性绑定修改。items指向goodsList，totalItems指向totalGoods</p></li><li><p>页面渲染的字段名修改：字段改成商品的SPU字段：id、title，cname(商品分类名称),bname（品牌名称）</p></li><li><p>data属性修改了以下属性：</p><ul><li>goodsList：当前页商品数据</li><li>totalGoods：商品总数</li><li>headers：头信息，需要修改头显示名称</li><li>oldGoods：准备要修改的商品</li></ul></li><li><p>加载数据的函数：getDataFromServer，请求的路径进行了修改，另外去除了跟排序相关的查询。SPU查询不排序</p></li><li><p>新增商品的事件函数：清除了一些数据查询接口，只保留弹窗</p></li></ul><p>查看效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526272476614.png" srcset="/img/loading.gif" alt="1526272476614"></p><p>因为没有编写查询功能，表格一直处于loading状态。</p><p>接下来看弹窗：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526272537552.png" srcset="/img/loading.gif" alt="1526272537552"></p><h3 id="4-3-2-上下架状态按钮"><a href="#4-3-2-上下架状态按钮" class="headerlink" title="4.3.2.上下架状态按钮"></a>4.3.2.上下架状态按钮</h3><p>另外，似乎页面少了对上下架商品的过滤，在原始效果图中是有的：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526277614649.png" srcset="/img/loading.gif" alt="1526277614649"></p><p>这在Vuetify中是一组按钮，我们查看帮助文档：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526277713391.png" srcset="/img/loading.gif" alt="1526277713391"></p><p>查看实例得到以下信息：</p><p><code>v-btn</code>：一个按钮</p><p><code>v-btn-toggle</code>：按钮组，内部可以有多个按钮，点击切换，有以下属性：</p><ul><li>multiple：是否支持多选，默认是false</li><li>value：选中的按钮的值，如果是多选，结果是一个数组；单选，结果是点击的v-btn中的value值，因此按钮组的每个btn都需要指定value属性</li></ul><p>改造页面：</p><p>首先在data中定义一个属性，记录按钮的值。</p><div class="hljs"><pre><code class="hljs js">filter:&#123;    saleable: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 上架还是下架</span>    search: <span class="hljs-string">''</span>, <span class="hljs-comment">// 搜索过滤字段</span>&#125;</code></pre></div><p>这里我们的做法是定义一个filter属性，内部在定义search来关联过滤字段，saleable来关联上下架情况。</p><p>这样watch就必须监听filter，而不是只监听search了：</p><div class="hljs"><pre><code class="hljs js">filter: &#123;<span class="hljs-comment">// 监视搜索字段</span>  handler() &#123;    <span class="hljs-keyword">this</span>.getDataFromServer();  &#125;,  deep:<span class="hljs-literal">true</span>&#125;</code></pre></div><p>另外，页面中与search有关的所有字段都需要修改成filter.search:</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--搜索框，与search属性关联--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"filter.search"</span> <span class="hljs-attr">append-icon</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">hide-details</span>/&gt;</span></code></pre></div><p>然后，在页面中添加按钮组：</p><div class="hljs"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">xs3</span>&gt;</span>     状态：     <span class="hljs-tag">&lt;<span class="hljs-name">v-btn-toggle</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"filter.saleable"</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">flat</span>&gt;</span>             全部         <span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">flat</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"true"</span>&gt;</span>             上架         <span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">flat</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"false"</span>&gt;</span>             下架         <span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">v-btn-toggle</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span></code></pre></div><p>最后，不要忘了在查询时，将saleable携带上：</p><div class="hljs"><pre><code class="hljs js">getDataFromServer() &#123; <span class="hljs-comment">// 从服务的加载数的方法。</span>    <span class="hljs-comment">// 发起请求</span>    <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/spu/page"</span>, &#123;        params: &#123;            key: <span class="hljs-keyword">this</span>.filter.search, <span class="hljs-comment">// 搜索条件</span>            saleable: <span class="hljs-keyword">this</span>.filter.saleable, <span class="hljs-comment">// 上下架</span>            page: <span class="hljs-keyword">this</span>.pagination.page,<span class="hljs-comment">// 当前页</span>            rows: <span class="hljs-keyword">this</span>.pagination.rowsPerPage,<span class="hljs-comment">// 每页大小</span>        &#125;    &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123; <span class="hljs-comment">// 这里使用箭头函数</span>        <span class="hljs-keyword">this</span>.goodsList = resp.data.items;        <span class="hljs-keyword">this</span>.totalGoods = resp.data.total;        <span class="hljs-comment">// 完成赋值后，把加载状态赋值为false</span>        <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>;    &#125;)&#125;</code></pre></div><h2 id="4-4-后台提供接口"><a href="#4-4-后台提供接口" class="headerlink" title="4.4.后台提供接口"></a>4.4.后台提供接口</h2><p>页面已经准备好，接下来在后台提供分页查询SPU的功能：</p><h3 id="4-4-1-实体类"><a href="#4-4-1-实体类" class="headerlink" title="4.4.1.实体类"></a>4.4.1.实体类</h3><blockquote><p>SPU</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_spu"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spu</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long brandId;    <span class="hljs-keyword">private</span> Long cid1;<span class="hljs-comment">// 1级类目</span>    <span class="hljs-keyword">private</span> Long cid2;<span class="hljs-comment">// 2级类目</span>    <span class="hljs-keyword">private</span> Long cid3;<span class="hljs-comment">// 3级类目</span>    <span class="hljs-keyword">private</span> String title;<span class="hljs-comment">// 标题</span>    <span class="hljs-keyword">private</span> String subTitle;<span class="hljs-comment">// 子标题</span>    <span class="hljs-keyword">private</span> Boolean saleable;<span class="hljs-comment">// 是否上架</span>    <span class="hljs-keyword">private</span> Boolean valid;<span class="hljs-comment">// 是否有效，逻辑删除用</span>    <span class="hljs-keyword">private</span> Date createTime;<span class="hljs-comment">// 创建时间</span>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<span class="hljs-comment">// 最后修改时间</span><span class="hljs-comment">// 省略getter和setter</span>&#125;</code></pre></div><blockquote><p>SPU详情</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_spu_detail"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpuDetail</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long spuId;<span class="hljs-comment">// 对应的SPU的id</span>    <span class="hljs-keyword">private</span> String description;<span class="hljs-comment">// 商品描述</span>    <span class="hljs-keyword">private</span> String specTemplate;<span class="hljs-comment">// 商品特殊规格的名称及可选值模板</span>    <span class="hljs-keyword">private</span> String specifications;<span class="hljs-comment">// 商品的全局规格属性</span>    <span class="hljs-keyword">private</span> String packingList;<span class="hljs-comment">// 包装清单</span>    <span class="hljs-keyword">private</span> String afterService;<span class="hljs-comment">// 售后服务</span>    <span class="hljs-comment">// 省略getter和setter</span>&#125;</code></pre></div><h3 id="4-4-2-controller"><a href="#4-4-2-controller" class="headerlink" title="4.4.2.controller"></a>4.4.2.controller</h3><p>先分析：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：/spu/page</p></li><li><p>请求参数：</p><ul><li>page：当前页</li><li>rows：每页大小</li><li>key：过滤条件</li><li>saleable：上架或下架</li></ul></li><li><p>返回结果：商品SPU的分页信息。</p><ul><li><p>要注意，页面展示的是商品分类和品牌名称，而数据库中保存的是id，怎么办？</p><p>我们可以新建一个类，继承SPU，并且拓展cname和bname属性，写到<code>ly-item-interface</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpuBo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Spu</span> </span>&#123;    String cname;<span class="hljs-comment">// 商品分类名称</span>        String bname;<span class="hljs-comment">// 品牌名称</span>        <span class="hljs-comment">// 略 。。</span>&#125;</code></pre></div></li></ul></li></ul><p>编写controller代码：</p><p>我们把与商品相关的一切业务接口都放到一起，起名为GoodsController，业务层也是这样</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> GoodsService goodsService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询SPU</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rows</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/spu/page"</span>)    <span class="hljs-keyword">public</span> ResponseEntity&lt;PageResult&lt;SpuBo&gt;&gt; querySpuByPage(            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"page"</span>, defaultValue = <span class="hljs-string">"1"</span>) Integer page,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"rows"</span>, defaultValue = <span class="hljs-string">"5"</span>) Integer rows,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"key"</span>, required = <span class="hljs-keyword">false</span>) String key) &#123;        <span class="hljs-comment">// 分页查询spu信息</span>        PageResult&lt;SpuBo&gt; result = <span class="hljs-keyword">this</span>.goodsService.querySpuByPageAndSort(page, rows, key);        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result.getItems().size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);    &#125;&#125;</code></pre></div><h3 id="4-4-3-service"><a href="#4-4-3-service" class="headerlink" title="4.4.3.service"></a>4.4.3.service</h3><p>所有商品相关的业务（包括SPU和SKU）放到一个业务下：GoodsService。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SpuMapper spuMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CategoryService categoryService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BrandMapper brandMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> PageResult&lt;SpuBo&gt; <span class="hljs-title">querySpuByPageAndSort</span><span class="hljs-params">(Integer page, Integer rows, Boolean saleable, String key)</span> </span>&#123;        <span class="hljs-comment">// 1、查询SPU</span>        <span class="hljs-comment">// 分页,最多允许查100条</span>        PageHelper.startPage(page, Math.min(rows, <span class="hljs-number">100</span>));        <span class="hljs-comment">// 创建查询条件</span>        Example example = <span class="hljs-keyword">new</span> Example(Spu<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        Example.Criteria criteria = example.createCriteria();        <span class="hljs-comment">// 是否过滤上下架</span>        <span class="hljs-keyword">if</span> (saleable != <span class="hljs-keyword">null</span>) &#123;            criteria.orEqualTo(<span class="hljs-string">"saleable"</span>, saleable);        &#125;        <span class="hljs-comment">// 是否模糊查询</span>        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(key)) &#123;            criteria.andLike(<span class="hljs-string">"title"</span>, <span class="hljs-string">"%"</span> + key + <span class="hljs-string">"%"</span>);        &#125;        Page&lt;Spu&gt; pageInfo = (Page&lt;Spu&gt;) <span class="hljs-keyword">this</span>.spuMapper.selectByExample(example);        List&lt;SpuBo&gt; list = pageInfo.getResult().stream().map(spu -&gt; &#123;            <span class="hljs-comment">// 2、把spu变为 spuBo</span>            SpuBo spuBo = <span class="hljs-keyword">new</span> SpuBo();            <span class="hljs-comment">// 属性拷贝</span>            BeanUtils.copyProperties(spu, spuBo);            <span class="hljs-comment">// 3、查询spu的商品分类名称,要查三级分类</span>            List&lt;String&gt; names = <span class="hljs-keyword">this</span>.categoryService.queryNameByIds(                    Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3()));            <span class="hljs-comment">// 将分类名称拼接后存入</span>            spuBo.setCname(StringUtils.join(names, <span class="hljs-string">"/"</span>));            <span class="hljs-comment">// 4、查询spu的品牌名称</span>            Brand brand = <span class="hljs-keyword">this</span>.brandMapper.selectByPrimaryKey(spu.getBrandId());            spuBo.setBname(brand.getName());            <span class="hljs-keyword">return</span> spuBo;        &#125;).collect(Collectors.toList());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageResult&lt;&gt;(pageInfo.getTotal(), list);    &#125;&#125;</code></pre></div><h3 id="4-4-4-mapper"><a href="#4-4-4-mapper" class="headerlink" title="4.4.4.mapper"></a>4.4.4.mapper</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpuMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Spu</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="4-4-5-Category中拓展查询名称的功能"><a href="#4-4-5-Category中拓展查询名称的功能" class="headerlink" title="4.4.5.Category中拓展查询名称的功能"></a>4.4.5.Category中拓展查询名称的功能</h3><p>页面需要商品的分类名称需要在这里查询，因此要额外提供查询分类名称的功能，</p><p>在CategoryService中添加功能：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">queryNameByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.categoryMapper.selectByIdList(ids).stream().map(Category::getName).collect(Collectors.toList());&#125;</code></pre></div><p>mapper的selectByIDList方法是来自于通用mapper。不过需要我们在mapper上继承一个通用mapper接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Category</span>&gt;, <span class="hljs-title">SelectByIdListMapper</span>&lt;<span class="hljs-title">Category</span>, <span class="hljs-title">Long</span>&gt; </span>&#123;     <span class="hljs-comment">// ...coding</span>&#125;</code></pre></div><h2 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5.测试"></a>4.5.测试</h2><p>刷新页面，查看效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526280777975.png" srcset="/img/loading.gif" alt="1526280777975"></p><p>基本与预览的效果一致，OK！</p><h1 id="5-商品新增"><a href="#5-商品新增" class="headerlink" title="5.商品新增"></a>5.商品新增</h1><h2 id="5-1-效果预览"><a href="#5-1-效果预览" class="headerlink" title="5.1.效果预览"></a>5.1.效果预览</h2><p>新增商品窗口：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/../../%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/%E7%AC%94%E8%AE%B0/day08/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526268739827.png" srcset="/img/loading.gif" alt="1526268739827"></p><p>这个表单比较复杂，因为商品的信息比较多，分成了4个部分来填写：</p><ul><li>基本信息</li><li>商品描述信息</li><li>规格参数信息</li><li>SKU信息</li></ul><h2 id="5-2-从0开始"><a href="#5-2-从0开始" class="headerlink" title="5.2.从0开始"></a>5.2.从0开始</h2><p>我们刚刚在查询时，已经实现创建了MyGoodsForm.vue，并且已经在MyGoods中引入。</p><p>不过目前没有写代码：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;v-card&gt;    my goods form  &lt;&#x2F;v-card&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    name: &quot;my-goods-form&quot;,    props: &#123;      oldGoods: &#123;        type: Object      &#125;,      isEdit: &#123;        type: Boolean,        default: false      &#125;    &#125;,    data() &#123;      return &#123;      &#125;    &#125;,    methods: &#123;    &#125;  &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>然后在MyBrand中，已经引入了MyGoodsForm组件，并且页面中也形成了对话框：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 导入自定义的表单组件</span><span class="hljs-keyword">import</span> MyGoodsForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyGoodsForm'</span></code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-dialog</span> <span class="hljs-attr">max-width</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"show"</span> <span class="hljs-attr">persistent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>        <span class="hljs-comment">&lt;!--对话框的标题--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar</span> <span class="hljs-attr">dense</span> <span class="hljs-attr">dark</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar-title</span>&gt;</span>&#123;&#123;isEdit ? '修改' : '新增'&#125;&#125;商品<span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar-title</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span>/&gt;</span>            <span class="hljs-comment">&lt;!--关闭窗口的按钮--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">icon</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"closeWindow"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-icon</span>&gt;</span>close<span class="hljs-tag">&lt;/<span class="hljs-name">v-icon</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar</span>&gt;</span>        <span class="hljs-comment">&lt;!--对话框的内容，表单--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">my-goods-form</span> <span class="hljs-attr">:oldGoods</span>=<span class="hljs-string">"oldGoods"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-dialog</span>&gt;</span></code></pre></div><p>并且也已经给新增按钮绑定了点击事件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"addGoods"</span>&gt;</span>新增商品<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span></code></pre></div><p>addGoods方法中，设置对话框的show属性为true：</p><div class="hljs"><pre><code class="hljs js">addGoods() &#123;    <span class="hljs-comment">// 修改标记</span>    <span class="hljs-keyword">this</span>.isEdit = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 控制弹窗可见：</span>    <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 把oldBrand变为null</span>    <span class="hljs-keyword">this</span>.oldBrand = <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>不过弹窗中没有任何数据：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526281134046.png" srcset="/img/loading.gif" alt="1526281134046"></p><h2 id="5-3-新增商品页的基本框架"><a href="#5-3-新增商品页的基本框架" class="headerlink" title="5.3.新增商品页的基本框架"></a>5.3.新增商品页的基本框架</h2><h3 id="5-3-1-Steppers，步骤线"><a href="#5-3-1-Steppers，步骤线" class="headerlink" title="5.3.1.Steppers，步骤线"></a>5.3.1.Steppers，步骤线</h3><p>预览效果图中，分四个步骤显示商品表单的组件，叫做stepper，看下文档：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526281659782.png" srcset="/img/loading.gif" alt="1526281659782"></p><p>其基本结构如图：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526282309386.png" srcset="/img/loading.gif" alt="1526282309386"></p><p>一个步骤线（v-stepper）总的分为两部分：</p><ul><li>v-stepper-header：代表步骤的头部进度条，只能有一个<ul><li>v-stepper-step：代表进度条的每一个步骤，可以有多个</li></ul></li><li>v-stepper-items：代表当前步骤下的内容组，只能有一个，内部有stepper-content<ul><li>v-stepper-content：代表每一步骤的页面内容，可以有多个</li></ul></li></ul><blockquote><p>v-stepper</p></blockquote><ul><li>value：其值是当前所在的步骤索引，可以用来控制步骤切换</li><li>dark：是否使用黑暗色调，默认false</li><li>non-linear：是否启用非线性步骤，用户不用按顺序切换，而是可以调到任意步骤，默认false</li><li>vertical：是否垂直显示步骤线，默认是false，即水平显示</li></ul><blockquote><p>v-stepper-header的属性：</p></blockquote><ul><li>无</li></ul><blockquote><p>v-stepper-step的属性</p></blockquote><ul><li>color：颜色</li><li>complete：当前步骤是否已经完成，布尔值</li><li>editable：是否可编辑任意步骤（非线性步骤）</li><li>step：步骤索引</li></ul><blockquote><p>v-stepper-items</p></blockquote><ul><li>无</li></ul><blockquote><p>v-stepper-content</p></blockquote><ul><li>step：步骤索引，需要与v-stepper-step中的对应</li></ul><h3 id="5-3-2-编写页面"><a href="#5-3-2-编写页面" class="headerlink" title="5.3.2.编写页面"></a>5.3.2.编写页面</h3><p>首先我们在data中定义一个变量，记录当前的步骤数：</p><div class="hljs"><pre><code class="hljs js">data() &#123;    <span class="hljs-keyword">return</span> &#123;        step: <span class="hljs-number">1</span>, <span class="hljs-comment">// 当前的步骤数，默认为1</span>    &#125;&#125;,</code></pre></div><p>然后在模板页面中引入步骤线：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-stepper</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"step"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-header</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-step</span> <span class="hljs-attr">:complete</span>=<span class="hljs-string">"step &gt; 1"</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"1"</span>&gt;</span>基本信息<span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-step</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-divider</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-step</span> <span class="hljs-attr">:complete</span>=<span class="hljs-string">"step &gt; 2"</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"2"</span>&gt;</span>商品描述<span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-step</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-divider</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-step</span> <span class="hljs-attr">:complete</span>=<span class="hljs-string">"step &gt; 3"</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"3"</span>&gt;</span>规格参数<span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-step</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-divider</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-step</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"4"</span>&gt;</span>SKU属性<span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-step</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-items</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"1"</span>&gt;</span>        基本信息      <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"2"</span>&gt;</span>        商品描述      <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"3"</span>&gt;</span>        规格参数      <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"4"</span>&gt;</span>        SKU属性      <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-items</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526283729193.png" srcset="/img/loading.gif" alt="1526283729193"></p><p>步骤线出现了！</p><p>那么问题来了：该如何让这几个步骤切换呢？</p><h3 id="5-3-3-步骤切换按钮"><a href="#5-3-3-步骤切换按钮" class="headerlink" title="5.3.3.步骤切换按钮"></a>5.3.3.步骤切换按钮</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>如果改变step的值与指定的步骤索引一致，就可以实现步骤切换了：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526283971416.png" srcset="/img/loading.gif" alt="1526283971416"></p><p>因此，我们需要定义两个按钮，点击后修改step的值，让步骤前进或后退。</p><p>那么这两个按钮放哪里？</p><p>如果放在MyGoodsForm内，当表单内容过多时，按钮会被挤压到屏幕最下方，不够友好。最好是能够悬停状态。</p><p>所以，按钮必须放到MyGoods组件中，也就是父组件。</p><p>父组件的对话框是一个card，card组件提供了一个滚动效果，scrollable，如果为true，card的内容滚动时，其头部和底部是可以静止的。</p><p>现在card的头部是弹框的标题，card的中间就是表单内容。如果我们把按钮放到底部，就可以实现悬停效果。</p><h4 id="页面添加按钮"><a href="#页面添加按钮" class="headerlink" title="页面添加按钮"></a>页面添加按钮</h4><p>改造MyGoods的对话框组件：</p><p>  <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526285123845.png" srcset="/img/loading.gif" alt="1526285123845"></p><p>查看页面：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526285086042.png" srcset="/img/loading.gif" alt="1526285086042"></p><h4 id="添加点击事件"><a href="#添加点击事件" class="headerlink" title="添加点击事件"></a>添加点击事件</h4><p>现在这两个按钮点击后没有任何反应。我们需要给他们绑定点击事件，来修改MyGoodsForm中的step的值。</p><p>也就是说，父组件要修改子组件的属性状态。想到什么了？</p><p>props属性。</p><p>我们先在父组件定义一个step属性：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526285364638.png" srcset="/img/loading.gif" alt="1526285364638"></p><p>然后在点击事件中修改它：</p><div class="hljs"><pre><code class="hljs js">previous()&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.step &gt; <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">this</span>.step--    &#125;&#125;,next()&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.step &lt; <span class="hljs-number">4</span>)&#123;        <span class="hljs-keyword">this</span>.step++    &#125;&#125;</code></pre></div><p>页面绑定事件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--底部按钮，用来操作步骤线--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-card-actions</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"elevation-10"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xs3 mx-auto"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"previous"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"step === 1"</span>&gt;</span>上一步<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"next"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"step === 4"</span>&gt;</span>下一步<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-actions</span>&gt;</span></code></pre></div><p>然后把step属性传递给子组件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--对话框的内容，表单--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-3"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 600px"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">my-goods-form</span> <span class="hljs-attr">:oldGoods</span>=<span class="hljs-string">"oldGoods"</span> <span class="hljs-attr">:step</span>=<span class="hljs-string">"step"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span></code></pre></div><p>子组件中接收属性：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526285994382.png" srcset="/img/loading.gif" alt="1526285994382"></p><p>测试效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/10.gif" srcset="/img/loading.gif" alt></p><h2 id="5-4-商品基本信息"><a href="#5-4-商品基本信息" class="headerlink" title="5.4.商品基本信息"></a>5.4.商品基本信息</h2><p>商品基本信息，主要是一些纯文本比较简单的SPU属性，例如：</p><p>商品分类、商品品牌、商品标题、商品卖点（子标题），包装清单，售后服务</p><p>接下来，我们一一添加这些表单项。</p><p>注：这里为了简化，我们就不进行form表单校验了。之前已经讲过。</p><h3 id="5-4-1-在data中定义Goods属性"><a href="#5-4-1-在data中定义Goods属性" class="headerlink" title="5.4.1.在data中定义Goods属性"></a>5.4.1.在data中定义Goods属性</h3><p>首先，我们需要定义一个goods对象，包括商品的上述属性。</p><div class="hljs"><pre><code class="hljs js">data() &#123;    <span class="hljs-keyword">return</span> &#123;        goods:&#123;            categories:&#123;&#125;, <span class="hljs-comment">// 商品3级分类数组信息</span>            brandId: <span class="hljs-number">0</span>,<span class="hljs-comment">// 品牌id信息</span>            title: <span class="hljs-string">''</span>,<span class="hljs-comment">// 标题</span>            subTitle: <span class="hljs-string">''</span>,<span class="hljs-comment">// 子标题</span>            spuDetail: &#123;                packingList: <span class="hljs-string">''</span>,<span class="hljs-comment">// 包装列表</span>                afterService: <span class="hljs-string">''</span>,<span class="hljs-comment">// 售后服务</span>            &#125;,        &#125;    &#125;</code></pre></div><p>注意，这里我们在goods中定义了spuDetail属性，然后把包装列表和售后服务作为它的属性，这样符合数据库的结构。</p><h3 id="5-4-2-商品分类选框"><a href="#5-4-2-商品分类选框" class="headerlink" title="5.4.2.商品分类选框"></a>5.4.2.商品分类选框</h3><p>商品分类选框之前我们已经做过了。是级联选框。直接拿来用：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-cascader</span></span><span class="hljs-tag">        <span class="hljs-attr">url</span>=<span class="hljs-string">"/item/category/list"</span></span><span class="hljs-tag">        <span class="hljs-attr">required</span></span><span class="hljs-tag">        <span class="hljs-attr">showAllLevels</span></span><span class="hljs-tag">        <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.categories"</span></span><span class="hljs-tag">        <span class="hljs-attr">label</span>=<span class="hljs-string">"请选择商品分类"</span>/&gt;</span></code></pre></div><p>跟以前使用有一些区别：</p><ul><li>一个商品只能有一个分类，所以这里去掉了multiple属性</li><li>商品SPU中要保存3级商品分类，因此我们这里需要选择showAllLevels属性，显示所有3级分类</li></ul><p>效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526290196168.png" srcset="/img/loading.gif" alt="1526290196168"></p><p>查看goods的属性，三级类目都在：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526290263252.png" srcset="/img/loading.gif" alt="1526290263252"></p><h3 id="5-4-3-品牌选择"><a href="#5-4-3-品牌选择" class="headerlink" title="5.4.3.品牌选择"></a>5.4.3.品牌选择</h3><h4 id="select组件"><a href="#select组件" class="headerlink" title="select组件"></a>select组件</h4><p>品牌不分级别，使用普通下拉选框即可。我们查看官方文档的下拉选框说明：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526287929674.png" srcset="/img/loading.gif" alt="1526287929674"></p><p>组件名：v-select</p><p>比较重要的一些属性：</p><ul><li>item-text：选项中用来展示的字段名，默认是text</li><li>item-value：选项中用来作为value值的字段名，默认是value</li><li>items：待选项的对象数组</li><li>label：提示文本</li><li>multiple：是否支持多选，默认是false</li></ul><p>其它次要属性：</p><ul><li>autocomplete：是否根据用户输入的文本进行搜索过滤（自动），默认false</li><li>chips：是否以小纸片方式显示用户选中的项，默认false</li><li>clearable：是否添加清空选项图标，默认是false</li><li>color：颜色</li><li>dense：是否压缩选择框高度，默认false</li><li>editable：是否可编辑，默认false</li><li>hide-details：是否隐藏错误提示，默认false</li><li>hide-selected：是否在菜单中隐藏已选择的项</li><li>hint：提示文本</li><li>其它基本与<code>v-text-filed</code>组件类似，不再一一列举</li></ul><h4 id="页面实现"><a href="#页面实现" class="headerlink" title="页面实现"></a>页面实现</h4><p>备选项items需要我们去后台查询，而且必须是在用户选择商品分类后去查询。</p><p>我们定义一个属性，保存品牌的待选项信息：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526289926110.png" srcset="/img/loading.gif" alt="1526289926110"></p><p>然后编写一个watch，监控goods.categories的变化：</p><div class="hljs"><pre><code class="hljs js">watch: &#123;    <span class="hljs-string">'goods.categories'</span>: &#123;        deep: <span class="hljs-literal">true</span>,            handler(val) &#123;            <span class="hljs-comment">// 判断商品分类是否存在，存在才查询</span>            <span class="hljs-keyword">if</span> (val &amp;&amp; val.length &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 根据分类查询品牌</span>                <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/brand/cid/"</span> + <span class="hljs-keyword">this</span>.goods.categories[<span class="hljs-number">2</span>].id)                    .then(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;                    <span class="hljs-keyword">this</span>.brandOptions = data;                &#125;)            &#125;        &#125;    &#125;&#125;</code></pre></div><p>我们的品牌对象包含以下字段：id、name、letter、image。显然item-text应该对应name，item-value应该对应id</p><p>因此我们添加一个选框，指定item-text和item-value</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--品牌--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-select</span></span><span class="hljs-tag">      <span class="hljs-attr">:items</span>=<span class="hljs-string">"brandOptions"</span></span><span class="hljs-tag">      <span class="hljs-attr">item-text</span>=<span class="hljs-string">"name"</span></span><span class="hljs-tag">      <span class="hljs-attr">item-value</span>=<span class="hljs-string">"id"</span></span><span class="hljs-tag">      <span class="hljs-attr">label</span>=<span class="hljs-string">"所属品牌"</span></span><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.brandId"</span></span><span class="hljs-tag">      <span class="hljs-attr">required</span></span><span class="hljs-tag">      <span class="hljs-attr">autocomplete</span></span><span class="hljs-tag">      <span class="hljs-attr">clearable</span></span><span class="hljs-tag">      <span class="hljs-attr">dense</span> <span class="hljs-attr">chips</span></span><span class="hljs-tag">      /&gt;</span></code></pre></div><h4 id="后台提供接口"><a href="#后台提供接口" class="headerlink" title="后台提供接口"></a>后台提供接口</h4><p>页面需要去后台查询品牌信息，我们自然需要提供：</p><blockquote><p>controller</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 根据分类查询品牌</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> cid</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">  */</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"cid/&#123;cid&#125;"</span>)<span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByCategory(<span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">"cid"</span>) Long cid) &#123;    List&lt;Brand&gt; list = <span class="hljs-keyword">this</span>.brandService.queryBrandByCategory(cid);    <span class="hljs-keyword">if</span>(list == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);    &#125;    <span class="hljs-keyword">return</span> ResponseEntity.ok(list);&#125;</code></pre></div><blockquote><p>service</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Brand&gt; <span class="hljs-title">queryBrandByCategory</span><span class="hljs-params">(Long cid)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.brandMapper.queryByCategoryId(cid);&#125;</code></pre></div><blockquote><p>mapper</p></blockquote><p>根据分类查询品牌有中间表，需要自己编写Sql：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT b.* FROM tb_brand b LEFT JOIN tb_category_brand cb ON b.id = cb.brand_id WHERE cb.category_id = #&#123;cid&#125;"</span>)<span class="hljs-function">List&lt;Brand&gt; <span class="hljs-title">queryByCategoryId</span><span class="hljs-params">(Long cid)</span></span>;</code></pre></div><h4 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h4><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526290461916.png" srcset="/img/loading.gif" alt="1526290461916"></p><h3 id="5-4-4-标题等其它字段"><a href="#5-4-4-标题等其它字段" class="headerlink" title="5.4.4.标题等其它字段"></a>5.4.4.标题等其它字段</h3><p>标题等字段都是普通文本，直接使用<code>v-text-field</code>即可：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"商品标题"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.title"</span> <span class="hljs-attr">:counter</span>=<span class="hljs-string">"200"</span> <span class="hljs-attr">required</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"商品卖点"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.subTitle"</span> <span class="hljs-attr">:counter</span>=<span class="hljs-string">"200"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"包装清单"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.spuDetail.packingList"</span> <span class="hljs-attr">:counter</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">multi-line</span> <span class="hljs-attr">:rows</span>=<span class="hljs-string">"3"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"售后服务"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.spuDetail.afterService"</span> <span class="hljs-attr">:counter</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">multi-line</span> <span class="hljs-attr">:rows</span>=<span class="hljs-string">"3"</span>/&gt;</span></code></pre></div><p>一些新的属性：</p><ul><li>counter：计数器，记录当前用户输入的文本字数</li><li>rows：文本域的行数</li><li>multi-line：把单行文本变成文本域</li></ul><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526290761721.png" srcset="/img/loading.gif" alt="1526290761721"></p><h2 id="5-5-商品描述信息"><a href="#5-5-商品描述信息" class="headerlink" title="5.5.商品描述信息"></a>5.5.商品描述信息</h2><p>商品描述信息比较复杂，而且图文并茂，甚至包括视频。</p><p>这样的内容，一般都会使用富文本编辑器。</p><h3 id="5-5-1-什么是富文本编辑器"><a href="#5-5-1-什么是富文本编辑器" class="headerlink" title="5.5.1.什么是富文本编辑器"></a>5.5.1.什么是富文本编辑器</h3><p>百度百科：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526290914491.png" srcset="/img/loading.gif" alt="1526290914491"></p><p>通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。</p><p>富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue</p><p>但是我们今天要说的，是一款支持Vue的富文本编辑器：<code>vue-quill-editor</code></p><h3 id="5-5-2-Vue-Quill-Editor"><a href="#5-5-2-Vue-Quill-Editor" class="headerlink" title="5.5.2.Vue-Quill-Editor"></a>5.5.2.Vue-Quill-Editor</h3><p>GitHub的主页：<a href="https://github.com/surmon-china/vue-quill-editor" target="_blank" rel="noopener">https://github.com/surmon-china/vue-quill-editor</a></p><p>Vue-Quill-Editor是一个基于Quill的富文本编辑器：<a href="https://quilljs.com/" target="_blank" rel="noopener">Quill的官网</a></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526291232678.png" srcset="/img/loading.gif" alt="1526291232678"></p><h3 id="5-5-3-使用指南"><a href="#5-5-3-使用指南" class="headerlink" title="5.5.3.使用指南"></a>5.5.3.使用指南</h3><p>使用非常简单：</p><p>第一步：安装，使用npm命令：</p><div class="hljs"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> vue-quill-editor <span class="hljs-comment">--save</span></code></pre></div><p>第二步：加载，在js中引入：</p><p>全局使用：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> VueQuillEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-quill-editor'</span><span class="hljs-keyword">const</span> options = &#123;&#125;; <span class="hljs-comment">/* &#123; default global options &#125; */</span>Vue.use(VueQuillEditor, options); <span class="hljs-comment">// options可选</span></code></pre></div><p>局部使用：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'quill/dist/quill.core.css'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'quill/dist/quill.snow.css'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'quill/dist/quill.bubble.css'</span><span class="hljs-keyword">import</span> &#123;quillEditor&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-quill-editor'</span><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    components:&#123;        quillEditor    &#125;&#125;)</code></pre></div><p>第三步：页面引用：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">quill-editor</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.spuDetail.description"</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">"editorOption"</span>/&gt;</span></code></pre></div><h3 id="5-5-4-自定义的富文本编辑器"><a href="#5-5-4-自定义的富文本编辑器" class="headerlink" title="5.5.4.自定义的富文本编辑器"></a>5.5.4.自定义的富文本编辑器</h3><p>不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526296083605.png" srcset="/img/loading.gif" alt="1526296083605.png"></p><p>使用也非常简单：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"2"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-editor</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"goods.spuDetail.description"</span> <span class="hljs-attr">upload-url</span>=<span class="hljs-string">"/upload/image"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span></code></pre></div><ul><li>upload-url：是图片上传的路径</li><li>v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description</li></ul><h3 id="5-5-5-效果："><a href="#5-5-5-效果：" class="headerlink" title="5.5.5.效果："></a>5.5.5.效果：</h3><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526297276667.png" srcset="/img/loading.gif" alt="1526297276667"></p><h2 id="5-6-规格参数"><a href="#5-6-规格参数" class="headerlink" title="5.6.规格参数"></a>5.6.规格参数</h2><p>商品规格参数与商品分类绑定，因此我们需要在用户选择商品分类后，去后台查询对应的规格参数模板。</p><h3 id="5-6-1-查询商品规格"><a href="#5-6-1-查询商品规格" class="headerlink" title="5.6.1.查询商品规格"></a>5.6.1.查询商品规格</h3><p>首先，我们在data中定义变量，记录查询到的规格参数模板：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526297766476.png" srcset="/img/loading.gif" alt="1526297766476"></p><p>然后，我们通过watch监控goods.categories的变化，然后去查询规格：</p><p>  <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526375545366.png" srcset="/img/loading.gif" alt="1526375545366"></p><p>查看是否查询到：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526297980403.png" srcset="/img/loading.gif" alt="1526297980403"></p><h3 id="5-6-2-页面展示规格属性"><a href="#5-6-2-页面展示规格属性" class="headerlink" title="5.6.2.页面展示规格属性"></a>5.6.2.页面展示规格属性</h3><p>获取到了规格参数，还需要把它展示到页面中。</p><p>现在查询到的规格参数只有key，并没有值。值需要用户来根据SPU信息填写，因此规格参数最终需要处理为表单。</p><blockquote><p>整体结构</p></blockquote><p>整体来看，规格参数是数组，每个元素是一组规格的集合。我们需要分组来展示。比如每组放到一个card中。</p><blockquote><p>注意事项：</p></blockquote><p>规格参数中的属性有一些需要我们特殊处理：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526298277201.png" srcset="/img/loading.gif" alt="1526298277201"></p><ul><li>global：是否是全局属性，规格参数中一部分是SPU共享，属于全局属性，另一部是SKU特有，需要根据SKU来填写。因此，在当前版面中，只展示global为true的，即全局属性。sku特有属性放到最后一个面板</li><li>numerical：是否是数值类型，如果是，把单位补充在页面表单，不允许用户填写，并且要验证用户输入的数据格式</li><li>options：是否有可选项，如果有，则使用下拉选框来渲染。</li></ul><p>页面代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--3、规格参数--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"3"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"xs10 mx-auto px-3"</span>&gt;</span>        <span class="hljs-comment">&lt;!--遍历整个规格参数，获取每一组--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"spec in specifications"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"spec.group"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"my-2"</span>&gt;</span>            <span class="hljs-comment">&lt;!--组名称--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"subheading"</span>&gt;</span>&#123;&#123;spec.group&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span>            <span class="hljs-comment">&lt;!--遍历组中的每个属性，并判断是否是全局属性，不是则不显示--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"param in spec.params"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"param.k"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"param.global"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>                <span class="hljs-comment">&lt;!--判断是否有可选项，如果没有，则显示文本框。还要判断是否是数值类型，如果是把unit显示到后缀--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"param.options.length &lt;= 0"</span> </span><span class="hljs-tag">                              <span class="hljs-attr">:label</span>=<span class="hljs-string">"param.k"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"param.v"</span> <span class="hljs-attr">:suffix</span>=<span class="hljs-string">"param.unit || ''"</span>/&gt;</span>                <span class="hljs-comment">&lt;!--否则，显示下拉选项--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-select</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"param.k"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"param.v"</span> <span class="hljs-attr">:items</span>=<span class="hljs-string">"param.options"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span></code></pre></div><p>效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526302470344.png" srcset="/img/loading.gif" alt="1526302470344"></p><h2 id="5-7-SKU特有属性"><a href="#5-7-SKU特有属性" class="headerlink" title="5.7.SKU特有属性"></a>5.7.SKU特有属性</h2><p>sku特有属性也存在与specifications中，但是我们现在只想展示特有属性，而不是从头遍历一次。因此，我们应该从specifications中把特有规格属性拆分出来独立保存。</p><h3 id="5-7-1-筛选特有规格参数"><a href="#5-7-1-筛选特有规格参数" class="headerlink" title="5.7.1.筛选特有规格参数"></a>5.7.1.筛选特有规格参数</h3><p>首先：我们在data中新建一个属性，保存特有的规格参数：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526306568822.png" srcset="/img/loading.gif" alt="1526306568822"></p><p>然后，在查询完成规格模板后，立刻对规格参数进行处理，筛选出特有规格参数，保存到specialSpecs中：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 根据分类查询规格参数</span><span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/spec/"</span> + <span class="hljs-keyword">this</span>.goods.categories[<span class="hljs-number">2</span>].id)    .then(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 保存全部规格</span>        <span class="hljs-keyword">this</span>.specifications = data;        <span class="hljs-comment">// 对特有规格进行筛选</span>        <span class="hljs-keyword">const</span> temp = [];        data.forEach(<span class="hljs-function">(<span class="hljs-params">&#123;params&#125;</span>) =&gt;</span> &#123;            params.forEach(<span class="hljs-function">(<span class="hljs-params">&#123;k, options, global&#125;</span>) =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (!global) &#123;                    temp.push(&#123;                        k, options,<span class="hljs-attr">selected</span>:[]                    &#125;)                &#125;            &#125;)        &#125;)        <span class="hljs-keyword">this</span>.specialSpecs = temp;&#125;)</code></pre></div><p>要注意：我们添加了一个selected属性，用于保存用户填写的信息</p><p>查看数据：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526306826026.png" srcset="/img/loading.gif" alt="1526306826026"></p><h3 id="5-7-2-页面渲染SKU属性"><a href="#5-7-2-页面渲染SKU属性" class="headerlink" title="5.7.2.页面渲染SKU属性"></a>5.7.2.页面渲染SKU属性</h3><p>接下来，我们把筛选出的特有规格参数，渲染到SKU页面：</p><p>我们的目标效果是这样的：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526307835157.png" srcset="/img/loading.gif" alt="1526307835157"></p><p>可以看到，</p><ul><li>每一个特有属性自成一组，都包含标题和选项。我们可以使用card达到这个效果。</li><li>无options选项的特有属性，展示一个文本框，有options选项的，展示多个checkbox，让用户选择</li></ul><p>页面代码实现：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--4、SKU属性--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-stepper-content</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"4"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mx-auto"</span>&gt;</span>        <span class="hljs-comment">&lt;!--遍历特有规格参数--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span> <span class="hljs-attr">flat</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"spec in specialSpecs"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"spec.k"</span>&gt;</span>            <span class="hljs-comment">&lt;!--特有参数的标题--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"subheading"</span>&gt;</span>&#123;&#123;spec.k&#125;&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span>            <span class="hljs-comment">&lt;!--特有参数的待选项，需要判断是否有options，如果没有，展示文本框，让用户自己输入--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"spec.options.length &lt;= 0"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"'输入新的' + spec.k"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"spec.selected"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>            <span class="hljs-comment">&lt;!--如果有options，需要展示成多个checkbox--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container fluid grid-list-xs"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-layout</span> <span class="hljs-attr">row</span> <span class="hljs-attr">wrap</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">v-checkbox</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"o in spec.options"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"o"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex xs3"</span></span><span class="hljs-tag">                                <span class="hljs-attr">:label</span>=<span class="hljs-string">"o"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"spec.selected"</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"o"</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">v-layout</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-stepper-content</span>&gt;</span></code></pre></div><p>我们的实现效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526308151513.png" srcset="/img/loading.gif" alt="1526308151513"></p><p>测试下，勾选checkbox或填写文本会发生什么：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526308483766.png" srcset="/img/loading.gif" alt="1526308483766"></p><p>看下规格模板的值：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526308513342.png" srcset="/img/loading.gif" alt="1526308513342"></p><h3 id="5-7-3-自由添加或删除文本框"><a href="#5-7-3-自由添加或删除文本框" class="headerlink" title="5.7.3.自由添加或删除文本框"></a>5.7.3.自由添加或删除文本框</h3><p>刚才的实现中，普通文本项只有一个，如果用户想添加更多值就不行。我们需要让用户能够自由添加新的文本框，而且还能删除。</p><p>这里有个取巧的方法：</p><p>还记得我们初始化 特有规格参数时，新增了一个selected属性吗，用来保存用户填写的值，是一个数组。每当用户新加一个值，该数组的长度就会加1，而初始长度为0</p><p>另外，v-for指令有个特殊之处，就在于它可以遍历数字。比如 v-for=”i in 10”，你会得到1~10</p><p>因此，我们可以遍历selected的长度，每当我们输入1个文本，selected长度会加1，自然会多出一个文本框。</p><p>代码如下：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526309463115.png" srcset="/img/loading.gif" alt="1526309463115"></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card</span> <span class="hljs-attr">flat</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"spec in specialSpecs"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"spec.k"</span>&gt;</span>    <span class="hljs-comment">&lt;!--特有参数的标题--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"subheading"</span>&gt;</span>&#123;&#123;spec.k&#125;&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span>    <span class="hljs-comment">&lt;!--特有参数的待选项，需要判断是否有options，如果没有，展示文本框，让用户自己输入--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"spec.options.length &lt;= 0"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in spec.selected.length+1"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"i"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"'输入新的' + spec.k"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"spec.selected[i-1]"</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"i"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>    <span class="hljs-comment">&lt;!--如果有options，需要展示成多个checkbox--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container fluid grid-list-xs"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-layout</span> <span class="hljs-attr">row</span> <span class="hljs-attr">wrap</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-checkbox</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"o in spec.options"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"o"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex xs3"</span></span><span class="hljs-tag">                        <span class="hljs-attr">:label</span>=<span class="hljs-string">"o"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"spec.selected"</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"o"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span></code></pre></div><p>效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/11.gif" srcset="/img/loading.gif" alt></p><p>而删除文本框相对就比较简单了，只要在文本框末尾添加一个按钮，添加点击事件即可，代码：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526310720065.png" srcset="/img/loading.gif" alt="1526310720065"></p><p>添加了一些布局样式，以及一个按钮，在点击事件中删除一个值。</p><h2 id="5-8-展示SKU列表"><a href="#5-8-展示SKU列表" class="headerlink" title="5.8.展示SKU列表"></a>5.8.展示SKU列表</h2><h3 id="5-8-1-效果预览"><a href="#5-8-1-效果预览" class="headerlink" title="5.8.1.效果预览"></a>5.8.1.效果预览</h3><p>当我们选定SKU的特有属性时，就会对应出不同排列组合的SKU。</p><p>举例：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526311110498.png" srcset="/img/loading.gif" alt="1526311110498"></p><p>当你选择了上图中的这些选项时：</p><ul><li>颜色共2种：土豪金，绚丽红</li><li>内存共2种：2GB，4GB</li><li>机身存储1种：64GB</li></ul><p>此时会产生多少种SKU呢？ 应该是 2 * 2 * 1 = 4种。</p><p>因此，接下来应该由用户来对这4种sku的信息进行详细填写，比如库存和价格等。而多种sku的最佳展示方式，是表格（淘宝、京东都是这么做的），如图：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526311330409.png" srcset="/img/loading.gif" alt="1526311330409"></p><p>而且这个表格应该随着用户选择的不同而动态变化。如何实现？</p><h3 id="5-8-2-算法：求数组笛卡尔积"><a href="#5-8-2-算法：求数组笛卡尔积" class="headerlink" title="5.8.2.算法：求数组笛卡尔积"></a>5.8.2.算法：求数组笛卡尔积</h3><p>大家看这个结果就能发现，这其实是在求多个数组的笛卡尔积。作为一个程序员，这应该是基本功了吧。</p><blockquote><p>两个数组笛卡尔积</p></blockquote><p>假如有两个数组，求笛卡尔积，其基本思路是这样的：</p><ul><li>在遍历一个数组的同时，遍历另一个数组，然后把元素拼接，放到新数组。</li></ul><p>示例1：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>];<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>];<span class="hljs-keyword">const</span> result = [];arr1.forEach(<span class="hljs-function"><span class="hljs-params">e1</span> =&gt;</span> &#123;    arr2.forEach(<span class="hljs-function"><span class="hljs-params">e2</span> =&gt;</span> &#123;        result.push(e1 + <span class="hljs-string">"_"</span> + e2)    &#125;)&#125;)<span class="hljs-built_in">console</span>.log(result);</code></pre></div><p>结果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526354069684.png" srcset="/img/loading.gif" alt="1526354069684"></p><p>完美实现。</p><blockquote><p>N个数组的笛卡尔积</p></blockquote><p>如果是N个数组怎么办？</p><p>不确定数组数量，代码没有办法写死。该如何处理？</p><p>思路：</p><ul><li>先拿其中两个数组求笛卡尔积</li><li>然后把前面运算的结果作为新数组，与第三个数组求笛卡尔积</li></ul><p>把前两次运算的结果作为第三次运算的参数。大家想到什么了？</p><p>没错，之前讲过的一个数组功能：Reduce</p><p>reduce函数的声明：</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">reduce</span><span class="hljs-params">(callback,initvalue)</span></span></code></pre></div><p>callback：是一个回调函数。这个callback可以接收2个参数：arg1,arg2</p><ul><li>arg1代表的上次运算得到的结果</li><li>arg2是数组中正要处理的元素</li></ul><p>initvalue，初始化值。第一次调用callback时把initvalue作为第一个参数，把数组的第一个元素作为第二个参数运算。如果未指定，则第一次运算会把数组的前两个元素作为参数。</p><p>reduce会把数组中的元素逐个用这个函数处理，然后把结果作为下一次回调函数的第一个参数，数组下个元素作为第二个参数，以此类推。</p><p>因此，我们可以把想要求笛卡尔积的多个数组先放到一个大数组中。形成二维数组。然后再来运算：</p><p>示例2：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>];<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>];<span class="hljs-comment">// 用来作为运算的二维数组</span><span class="hljs-keyword">const</span> arr3 = [arr1, arr2, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]]<span class="hljs-keyword">const</span> result = arr3.reduce(<span class="hljs-function">(<span class="hljs-params">last, el</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> arr = [];    <span class="hljs-comment">// last：上次运算结果</span>    <span class="hljs-comment">// el：数组中的当前元素</span>    last.forEach(<span class="hljs-function"><span class="hljs-params">e1</span> =&gt;</span> &#123;        el.forEach(<span class="hljs-function"><span class="hljs-params">e2</span> =&gt;</span> &#123;            arr.push(e1 + <span class="hljs-string">"_"</span> + e2)        &#125;)    &#125;)    <span class="hljs-keyword">return</span> arr&#125;);<span class="hljs-built_in">console</span>.log(result);</code></pre></div><p>结果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526355132141.png" srcset="/img/loading.gif" alt="1526355132141"></p><h3 id="5-8-3-算法结合业务"><a href="#5-8-3-算法结合业务" class="headerlink" title="5.8.3.算法结合业务"></a>5.8.3.算法结合业务</h3><p>来看我们的业务逻辑：</p><p>首先，我们已经有了一个特有参数的规格模板：</p><div class="hljs"><pre><code class="hljs js">[  &#123;    <span class="hljs-string">"k"</span>: <span class="hljs-string">"机身颜色"</span>,    <span class="hljs-string">"selected"</span>: [<span class="hljs-string">"红色"</span>,<span class="hljs-string">"黑色"</span>]  &#125;,  &#123;    <span class="hljs-string">"k"</span>: <span class="hljs-string">"内存"</span>,    <span class="hljs-string">"selected"</span>: [<span class="hljs-string">"8GB"</span>,<span class="hljs-string">"6GB"</span>]  &#125;,  &#123;    <span class="hljs-string">"k"</span>: <span class="hljs-string">"机身存储"</span>,    <span class="hljs-string">"selected"</span>: [<span class="hljs-string">"64GB"</span>,<span class="hljs-string">"256GB"</span>]  &#125;]</code></pre></div><p>可以看做是一个二维数组。</p><p>一维是参数对象。</p><p>二维是参数中的selected选项。</p><p>我们想要的结果：</p><div class="hljs"><pre><code class="hljs js">[    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"红色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"6GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"64GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"红色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"6GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"256GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"红色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"8GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"64GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"红色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"8GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"256GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"黑色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"6GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"64GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"黑色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"6GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"256GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"黑色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"8GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"64GB"</span>&#125;,    &#123;<span class="hljs-string">"机身颜色"</span>:<span class="hljs-string">"黑色"</span>,<span class="hljs-string">"内存"</span>:<span class="hljs-string">"8GB"</span>,<span class="hljs-string">"机身存储"</span>:<span class="hljs-string">"256GB"</span>&#125;,]</code></pre></div><p>思路是这样：</p><ul><li>我们的启点是一个空的对象数组：<code>[{}]</code>，</li><li>然后先与第一个规格求笛卡尔积</li><li>然后再把结果与下一个规格求笛卡尔积，依次类推</li></ul><p>如果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/skus.png" srcset="/img/loading.gif" alt="skus."></p><p>代码：</p><p>我们在Vue中新增一个计算属性，按照上面所讲的逻辑，计算所有规格参数的笛卡尔积</p><div class="hljs"><pre><code class="hljs js">computed: &#123;    skus() &#123;        <span class="hljs-comment">// 过滤掉用户没有填写数据的规格参数</span>        <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">this</span>.specialSpecs.filter(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.selected.length &gt; <span class="hljs-number">0</span>);        <span class="hljs-comment">// 通过reduce进行累加笛卡尔积</span>        <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">last, spec</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> result = [];            last.forEach(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> &#123;                spec.selected.forEach(<span class="hljs-function"><span class="hljs-params">option</span> =&gt;</span> &#123;                    <span class="hljs-keyword">const</span> obj = &#123;&#125;;                    <span class="hljs-built_in">Object</span>.assign(obj, o);                    obj[spec.k] = option;                    result.push(obj);                &#125;)            &#125;)            <span class="hljs-keyword">return</span> result        &#125;, [&#123;&#125;])    &#125;&#125;</code></pre></div><p>结果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526356312119.png" srcset="/img/loading.gif" alt="1526356312119"></p><p>优化：这里生成的是SKU的数组。因此只包含SKU的规格参数是不够的。结合数据库知道，还需要有下面的字段：</p><ul><li>price：价格</li><li>stock：库存</li><li>enable：是否启用。虽然笛卡尔积对应了9个SKU，但用户不一定会需要所有的组合，用这个字段进行标记。</li><li>images：商品的图片</li><li>indexes：特有属性的索引拼接得到的字符串</li></ul><p>我们需要给生成的每个sku对象添加上述字段，代码修改如下：</p><div class="hljs"><pre><code class="hljs js">computed:&#123;    skus()&#123;        <span class="hljs-comment">// 过滤掉用户没有填写数据的规格参数</span>        <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">this</span>.specialSpecs.filter(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.selected.length &gt; <span class="hljs-number">0</span>);        <span class="hljs-comment">// 通过reduce进行累加笛卡尔积</span>        <span class="hljs-keyword">return</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">last, spec, index</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> result = [];            last.forEach(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; spec.selected.length; i++)&#123;                    <span class="hljs-keyword">const</span> option = spec.selected[i];                    <span class="hljs-keyword">const</span> obj = &#123;&#125;;                    <span class="hljs-built_in">Object</span>.assign(obj, o);                    obj[spec.k] = option;                    <span class="hljs-comment">// 拼接当前这个特有属性的索引</span>                    obj.indexes = (o.indexes||<span class="hljs-string">''</span>) + <span class="hljs-string">'_'</span>+ i                    <span class="hljs-keyword">if</span>(index === arr.length - <span class="hljs-number">1</span>)&#123;                        <span class="hljs-comment">// 如果发现是最后一组，则添加价格、库存等字段</span>                        <span class="hljs-built_in">Object</span>.assign(obj, &#123; <span class="hljs-attr">price</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">stock</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">enable</span>:<span class="hljs-literal">false</span>, <span class="hljs-attr">images</span>:[]&#125;)                        <span class="hljs-comment">// 去掉索引字符串开头的下划线</span>                        obj.indexes = obj.indexes.substring(<span class="hljs-number">1</span>);                    &#125;                    result.push(obj);                &#125;            &#125;)            <span class="hljs-keyword">return</span> result        &#125;,[&#123;&#125;])    &#125;&#125;</code></pre></div><p>查看生成的数据：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526363824808.png" srcset="/img/loading.gif" alt="1526363824808"></p><h3 id="5-8-4-页面展现"><a href="#5-8-4-页面展现" class="headerlink" title="5.8.4.页面展现"></a>5.8.4.页面展现</h3><p>页面展现是一个表格。我们之前已经用过。表格需要以下信息：</p><ul><li>items：表格内的数据</li><li>headers：表头信息</li></ul><p>刚才我们的计算属性skus得到的就是表格数据了。我们还差头：headers</p><p>头部信息也是动态的，用户选择了一个属性，就会多出一个表头。与skus是关联的。</p><p>既然如此，我们再次编写一个计算属性，来计算得出header数组：</p><div class="hljs"><pre><code class="hljs js">headers()&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.skus.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> []    &#125;    <span class="hljs-keyword">const</span> headers = [];    <span class="hljs-comment">// 获取skus中的任意一个，获取key，然后遍历其属性</span>    <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>.skus[<span class="hljs-number">0</span>]).forEach(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> &#123;        <span class="hljs-keyword">let</span> value = k;        <span class="hljs-keyword">if</span>(k === <span class="hljs-string">'price'</span>)&#123;            <span class="hljs-comment">// enable，表头要翻译成“价格”</span>            k = <span class="hljs-string">'价格'</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k === <span class="hljs-string">'stock'</span>)&#123;            <span class="hljs-comment">// enable，表头要翻译成“库存”</span>            k = <span class="hljs-string">'库存'</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k === <span class="hljs-string">'enable'</span>)&#123;            <span class="hljs-comment">// enable，表头要翻译成“是否启用”</span>            k = <span class="hljs-string">'是否启用'</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k === <span class="hljs-string">'indexes'</span> || k === <span class="hljs-string">'images'</span>)&#123;            <span class="hljs-comment">// 图片和索引不在表格中展示</span>            <span class="hljs-keyword">return</span>;        &#125;        headers.push(&#123;            text: k,            align: <span class="hljs-string">'center'</span>,            sortable: <span class="hljs-literal">false</span>,            value        &#125;)    &#125;)    <span class="hljs-keyword">return</span> headers;&#125;</code></pre></div><p>接下来编写页面，实现table。</p><p>需要注意的是，price、stock字段需要用户填写数值，不能直接展示。enable要展示为checkbox，让用户选择，如图：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526364758744.png" srcset="/img/loading.gif" alt="1526364758744"></p><p>代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>    <span class="hljs-comment">&lt;!--标题--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"subheading"</span>&gt;</span>SKU列表<span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span>    <span class="hljs-comment">&lt;!--SKU表格，hide-actions因此分页等工具条--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-data-table</span> <span class="hljs-attr">:items</span>=<span class="hljs-string">"skus"</span> <span class="hljs-attr">:headers</span>=<span class="hljs-string">"headers"</span> <span class="hljs-attr">hide-actions</span> <span class="hljs-attr">item-key</span>=<span class="hljs-string">"indexes"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"items"</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"props"</span>&gt;</span>            <span class="hljs-comment">&lt;!--价格和库存展示为文本框--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(v,k) in props.item"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"k"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"['price', 'stock'].includes(k)"</span></span><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xs-center"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">single-line</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"props.item[k]"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-comment">&lt;!--enable展示为checkbox--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xs-center"</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"k === 'enable'"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">v-checkbox</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"props.item[k]"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-comment">&lt;!--indexes和images不展示，其它展示为普通文本--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-xs-center"</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"!['indexes','images'].includes(k)"</span>&gt;</span>&#123;&#123;v&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-data-table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526365039421.png" srcset="/img/loading.gif" alt="1526365039421"></p><h3 id="5-8-5-图片上传列表"><a href="#5-8-5-图片上传列表" class="headerlink" title="5.8.5.图片上传列表"></a>5.8.5.图片上传列表</h3><p>这个表格中只展示了基本信息，当用户需要上传图片时，该怎么做呢？</p><p>Vuetify的table有一个展开功能，可以提供额外的展示空间：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526366340741.png" srcset="/img/loading.gif" alt="1526366340741"></p><p>用法也非常简单，添加一个template，把其slot属性指定为expand即可：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526366667064.png" srcset="/img/loading.gif" alt="1526366667064"></p><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526366997943.png" srcset="/img/loading.gif" alt="1526366997943"></p><p>接下来就是我们的图片上传组件：v-upload</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526367719809.png" srcset="/img/loading.gif" alt="1526367719809"></p><h2 id="5-9-表单提交"><a href="#5-9-表单提交" class="headerlink" title="5.9.表单提交"></a>5.9.表单提交</h2><h3 id="5-9-1-添加提交按钮"><a href="#5-9-1-添加提交按钮" class="headerlink" title="5.9.1.添加提交按钮"></a>5.9.1.添加提交按钮</h3><p>我们在step=4，也就是SKU属性列表页面， 添加一个提交按钮。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--提交按钮--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">xs3</span> <span class="hljs-attr">offset-xs9</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"info"</span>&gt;</span>保存商品信息<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526366187195.png" srcset="/img/loading.gif" alt="1526366187195"></p><h3 id="5-9-2点击事件"><a href="#5-9-2点击事件" class="headerlink" title="5.9.2点击事件"></a>5.9.2点击事件</h3><p>当用户点击保存，我们就需要对页面的数据进行整理，然后提交到后台服务。</p><p>现在我们页面包含了哪些信息呢？我们与数据库对比，看看少什么</p><ul><li>goods：里面包含了SPU的几乎所有信息<ul><li>title：标题</li><li>subtitle：子标题，卖点</li><li>categories：分类对象数组，需要进行整理 **</li><li>brandId：品牌id</li><li>spuDetail：商品详情<ul><li>packingList：包装清单</li><li>afterService：售后服务</li><li>description：商品描述</li><li>缺少全局规格属性specifications **</li><li>缺少特有规格属性模板spec_template **</li></ul></li></ul></li><li>skus：包含了sku列表的几乎所有信息<ul><li>price：价格，需要处理为以分为单位</li><li>stock：库存</li><li>enable：是否启用</li><li>indexes：索引</li><li>images：图片，数组，需要处理为字符串**</li><li>缺少其它特有规格，ows_spec **</li><li>缺少标题：需要根据spu的标题结合特有属性生成 ** </li></ul></li><li>specifications：全局规格参数的键值对信息</li><li>specialSpec：特有规格参数信息</li></ul><p>在页面绑定点击事件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--提交按钮--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">xs3</span> <span class="hljs-attr">offset-xs9</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"info"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"submit"</span>&gt;</span>保存商品信息<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span></code></pre></div><p>编写代码，整理数据：</p><div class="hljs"><pre><code class="hljs js">submit()&#123;    <span class="hljs-comment">// 表单校验。 略</span>    <span class="hljs-comment">// 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中</span>    <span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">categories</span>: [&#123;<span class="hljs-attr">id</span>:cid1&#125;,&#123;<span class="hljs-attr">id</span>:cid2&#125;,&#123;<span class="hljs-attr">id</span>:cid3&#125;], ...goodsParams&#125; = <span class="hljs-keyword">this</span>.goods;    <span class="hljs-comment">// 处理规格参数</span>    <span class="hljs-keyword">const</span> specs = <span class="hljs-keyword">this</span>.specifications.map(<span class="hljs-function">(<span class="hljs-params">&#123;group,params&#125;</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> newParams = params.map(<span class="hljs-function">(<span class="hljs-params">&#123;options,...rest&#125;</span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> rest;        &#125;)        <span class="hljs-keyword">return</span> &#123;group,<span class="hljs-attr">params</span>:newParams&#125;;    &#125;);    <span class="hljs-comment">// 处理特有规格参数模板</span>    <span class="hljs-keyword">const</span> specTemplate = &#123;&#125;;    <span class="hljs-keyword">this</span>.specialSpecs.forEach(<span class="hljs-function">(<span class="hljs-params">&#123;k, selected&#125;</span>) =&gt;</span> &#123;        specTemplate[k] = selected;    &#125;);    <span class="hljs-comment">// 处理sku</span>    <span class="hljs-keyword">const</span> skus = <span class="hljs-keyword">this</span>.skus.filter(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.enable).map(<span class="hljs-function">(<span class="hljs-params">&#123;price,stock,enable,images,indexes, ...rest&#125;</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 标题，在spu的title基础上，拼接特有规格属性值</span>        <span class="hljs-keyword">const</span> title = goodsParams.title + <span class="hljs-string">" "</span> + <span class="hljs-built_in">Object</span>.values(rest).join(<span class="hljs-string">" "</span>);        <span class="hljs-keyword">return</span> &#123;            price: <span class="hljs-keyword">this</span>.$format(price+<span class="hljs-string">""</span>),stock,enable,indexes,title,<span class="hljs-comment">// 基本属性</span>            images: !images ? <span class="hljs-string">''</span> : images.join(<span class="hljs-string">","</span>), <span class="hljs-comment">// 图片</span>            ownSpec: <span class="hljs-built_in">JSON</span>.stringify(rest), <span class="hljs-comment">// 特有规格参数</span>        &#125;    &#125;);    <span class="hljs-built_in">Object</span>.assign(goodsParams, &#123;        cid1,cid2,cid3, <span class="hljs-comment">// 商品分类</span>        skus, <span class="hljs-comment">// sku列表</span>    &#125;)    goodsParams.spuDetail.specifications= <span class="hljs-built_in">JSON</span>.stringify(specs);    goodsParams.spuDetail.specTemplate = <span class="hljs-built_in">JSON</span>.stringify(specTemplate);    <span class="hljs-built_in">console</span>.log(goodsParams)&#125;</code></pre></div><p>点击测试，看效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday09/1526391630336.png" srcset="/img/loading.gif" alt="1526391630336"></p><p>向后台发起请求，因为请求体复杂，我们直接发起Json请求：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">this</span>.$http.post(<span class="hljs-string">"/item/goods"</span>,goodsParams)    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-comment">// 成功，关闭窗口</span>    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'close'</span>);    <span class="hljs-comment">// 提示成功</span>    <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"新增成功了"</span>)    &#125;)    .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"保存失败！"</span>);    &#125;);&#125;)</code></pre></div><h3 id="5-9-3-后台编写接口"><a href="#5-9-3-后台编写接口" class="headerlink" title="5.9.3.后台编写接口"></a>5.9.3.后台编写接口</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><blockquote><p>Spu</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_spu"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Spu</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long brandId;    <span class="hljs-keyword">private</span> Long cid1;<span class="hljs-comment">// 1级类目</span>    <span class="hljs-keyword">private</span> Long cid2;<span class="hljs-comment">// 2级类目</span>    <span class="hljs-keyword">private</span> Long cid3;<span class="hljs-comment">// 3级类目</span>    <span class="hljs-keyword">private</span> String title;<span class="hljs-comment">// 标题</span>    <span class="hljs-keyword">private</span> String subTitle;<span class="hljs-comment">// 子标题</span>    <span class="hljs-keyword">private</span> Boolean saleable;<span class="hljs-comment">// 是否上架</span>    <span class="hljs-keyword">private</span> Boolean valid;<span class="hljs-comment">// 是否有效，逻辑删除用</span>    <span class="hljs-keyword">private</span> Date createTime;<span class="hljs-comment">// 创建时间</span>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<span class="hljs-comment">// 最后修改时间</span>&#125;</code></pre></div><blockquote><p>SpuDetail</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_spu_detail"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpuDetail</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long spuId;<span class="hljs-comment">// 对应的SPU的id</span>    <span class="hljs-keyword">private</span> String description;<span class="hljs-comment">// 商品描述</span>    <span class="hljs-keyword">private</span> String specTemplate;<span class="hljs-comment">// 商品特殊规格的名称及可选值模板</span>    <span class="hljs-keyword">private</span> String specifications;<span class="hljs-comment">// 商品的全局规格属性</span>    <span class="hljs-keyword">private</span> String packingList;<span class="hljs-comment">// 包装清单</span>    <span class="hljs-keyword">private</span> String afterService;<span class="hljs-comment">// 售后服务</span>&#125;</code></pre></div><blockquote><p>Sku</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_sku"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sku</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> Long spuId;    <span class="hljs-keyword">private</span> String title;    <span class="hljs-keyword">private</span> String images;    <span class="hljs-keyword">private</span> Long price;    <span class="hljs-keyword">private</span> String ownSpec;<span class="hljs-comment">// 商品特殊规格的键值对</span>    <span class="hljs-keyword">private</span> String indexes;<span class="hljs-comment">// 商品特殊规格的下标</span>    <span class="hljs-keyword">private</span> Boolean enable;<span class="hljs-comment">// 是否有效，逻辑删除用</span>    <span class="hljs-keyword">private</span> Date createTime;<span class="hljs-comment">// 创建时间</span>    <span class="hljs-keyword">private</span> Date lastUpdateTime;<span class="hljs-comment">// 最后修改时间</span>    <span class="hljs-meta">@Transient</span>    <span class="hljs-keyword">private</span> Long stock;<span class="hljs-comment">// 库存</span>&#125;</code></pre></div><p>注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。</p><blockquote><p>Stock</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_stock"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long skuId;    <span class="hljs-keyword">private</span> Integer seckillStock;<span class="hljs-comment">// 秒杀可用库存</span>    <span class="hljs-keyword">private</span> Integer seckillTotal;<span class="hljs-comment">// 已秒杀数量</span>    <span class="hljs-keyword">private</span> Integer stock;<span class="hljs-comment">// 正常库存</span>&#125;</code></pre></div><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>四个问题：</p><ul><li><p>请求方式：POST</p></li><li><p>请求路径：/goods</p></li><li><p>请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个SpuBo对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpuBo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Spu</span> </span>&#123;    <span class="hljs-meta">@Transient</span>    String cname;<span class="hljs-comment">// 商品分类名称</span>    <span class="hljs-meta">@Transient</span>    String bname;<span class="hljs-comment">// 品牌名称</span>    <span class="hljs-meta">@Transient</span>    SpuDetail spuDetail;<span class="hljs-comment">// 商品详情</span>    <span class="hljs-meta">@Transient</span>    List&lt;Sku&gt; skus;<span class="hljs-comment">// sku列表</span>&#125;</code></pre></div></li><li><p>返回类型：无</p></li></ul><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 新增商品</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> spu</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@PostMapping</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Void&gt; <span class="hljs-title">saveGoods</span><span class="hljs-params">(@RequestBody Spu spu)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">this</span>.goodsService.save(spu);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.CREATED);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR);    &#125;&#125;</code></pre></div><p>注意：通过@RequestBody注解来接收Json请求</p><blockquote><p>Service</p></blockquote><p>这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(SpuBo spu)</span> </span>&#123;    <span class="hljs-comment">// 保存spu</span>    spu.setSaleable(<span class="hljs-keyword">true</span>);    spu.setValid(<span class="hljs-keyword">true</span>);    spu.setCreateTime(<span class="hljs-keyword">new</span> Date());    spu.setLastUpdateTime(spu.getCreateTime());    <span class="hljs-keyword">this</span>.spuMapper.insert(spu);    <span class="hljs-comment">// 保存spu详情</span>    spu.getSpuDetail().setSpuId(spu.getId());    <span class="hljs-keyword">this</span>.spuDetailMapper.insert(spu.getSpuDetail());    <span class="hljs-comment">// 保存sku和库存信息</span>    saveSkuAndStock(spu.getSkus(), spu.getId());&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveSkuAndStock</span><span class="hljs-params">(List&lt;Sku&gt; skus, Long spuId)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Sku sku : skus) &#123;        <span class="hljs-keyword">if</span> (!sku.getEnable()) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 保存sku</span>        sku.setSpuId(spuId);        <span class="hljs-comment">// 默认不参与任何促销</span>        sku.setCreateTime(<span class="hljs-keyword">new</span> Date());        sku.setLastUpdateTime(sku.getCreateTime());        <span class="hljs-keyword">this</span>.skuMapper.insert(sku);        <span class="hljs-comment">// 保存库存信息</span>        Stock stock = <span class="hljs-keyword">new</span> Stock();        stock.setSkuId(sku.getId());        stock.setStock(sku.getStock());        <span class="hljs-keyword">this</span>.stockMapper.insert(stock);    &#125;&#125;</code></pre></div><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><p>都是通用Mapper，略</p>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPU</tag>
      
      <tag>SKU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day08：品牌管理</title>
    <link href="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/"/>
    <url>/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>独立实现品牌新增</li><li>实现图片上传</li><li>了解FastDFS的安装</li><li>使用FastDFS客户端实现上传</li></ul><h1 id="1-品牌的新增"><a href="#1-品牌的新增" class="headerlink" title="1.品牌的新增"></a>1.品牌的新增</h1><p>昨天我们完成了品牌的查询，接下来就是新增功能。</p><h2 id="1-1-页面实现"><a href="#1-1-页面实现" class="headerlink" title="1.1.页面实现"></a>1.1.页面实现</h2><h3 id="1-1-1-初步编写弹窗"><a href="#1-1-1-初步编写弹窗" class="headerlink" title="1.1.1.初步编写弹窗"></a>1.1.1.初步编写弹窗</h3><p>当我们点击新增按钮，应该出现一个弹窗，然后在弹窗中出现一个表格，我们就可以填写品牌信息了。</p><p>我们查看Vuetify官网，弹窗是如何实现：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526115791468.png" srcset="/img/loading.gif" alt="1526115791468"></p><p>另外，我们可以通过文档看到对话框的一些属性：</p><ul><li>value：控制窗口的可见性，true可见，false，不可见</li><li>max-width：控制对话框最大宽度</li><li>scrollable ：是否可滚动，要配合v-card来使用，默认是false</li><li>persistent ：点击弹窗以外的地方不会关闭弹窗，默认是false</li></ul><p>现在，我们来使用一下。</p><p>首先，我们在data中定义一个show属性，来控制对话框的显示状态：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526116451280.png" srcset="/img/loading.gif" alt="1526116451280"></p><p>然后，在页面添加一个<code>v-dialog</code></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--弹出的对话框--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-dialog</span> <span class="hljs-attr">max-width</span>=<span class="hljs-string">"500"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"show"</span> <span class="hljs-attr">persistent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>        <span class="hljs-comment">&lt;!--对话框的标题--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar</span> <span class="hljs-attr">dense</span> <span class="hljs-attr">dark</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar-title</span>&gt;</span>新增品牌<span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar-title</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar</span>&gt;</span>        <span class="hljs-comment">&lt;!--对话框的内容，表单--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>            我是表单        <span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-dialog</span>&gt;</span></code></pre></div><p>说明：</p><ul><li><p>我们给dialog指定了3个属性，分别是</p><ul><li>max-width：限制宽度</li><li>v-model：value值双向绑定到show变量，用来控制窗口显示</li><li>persisitent：控制窗口不会被意外关闭</li></ul></li><li><p>因为可滚动需要配合<code>v-card</code>使用，因此我们在对话框中加入了一个<code>v-card</code></p><ul><li>在<code>v-card</code>的头部添加了一个 <code>v-toolbar</code>，作为窗口的头部，并且写了标题为：新增品牌<ul><li>dense：紧凑显示</li><li>dark：黑暗主题</li><li>color：颜色，primary就是整个网站的主色调，蓝色</li></ul></li><li>在<code>v-card</code>的内容部分，暂时空置，等会写表单</li></ul></li><li><p><code>class=“px-5&quot;</code>：vuetify的内置样式，含义是padding的x轴设置为5，这样表单内容会缩进一些，而不是顶着边框</p><p>基本语法：<code>{property}{direction}-{size}</code></p><ul><li>property：属性，有两种<code>padding</code>和<code>margin</code><ul><li><code>p</code>：对应<code>padding</code></li><li><code>m</code>：对应<code>margin</code></li></ul></li><li>direction：只padding和margin的作用方向，<ul><li><code>t</code> - 对应<code>margin-top</code>或者<code>padding-top</code>属性</li><li><code>b</code> - 对应<code>margin-bottom</code> or <code>padding-bottom</code></li><li><code>l</code> - 对应<code>margin-left</code> or <code>padding-left</code></li><li><code>r</code> - 对应<code>margin-right</code> or <code>padding-right</code></li><li><code>x</code> - 同时对应<code>*-left</code>和<code>*-right</code>属性</li><li><code>y</code> - 同时对应<code>*-top</code>和<code>*-bottom</code>属性</li></ul></li><li>size：控制空间大小，基于<code>$spacer</code>进行倍增，<code>$spacer</code>默认是16px<ul><li><code>0</code>：将<code>margin</code>或padding的大小设置为0</li><li><code>1</code> - 将<code>margin</code>或者<code>padding</code>属性设置为<code>$spacer * .25</code></li><li><code>2</code> - 将<code>margin</code>或者<code>padding</code>属性设置为<code>$spacer * .5</code></li><li><code>3</code> - 将<code>margin</code>或者<code>padding</code>属性设置为<code>$spacer</code></li><li><code>4</code> - 将<code>margin</code>或者<code>padding</code>属性设置为<code>$spacer * 1.5</code></li><li><code>5</code> - 将<code>margin</code>或者<code>padding</code>属性设置为<code>$spacer * 3</code></li></ul></li></ul></li></ul><h3 id="1-1-2-实现弹窗的可见和关闭"><a href="#1-1-2-实现弹窗的可见和关闭" class="headerlink" title="1.1.2.实现弹窗的可见和关闭"></a>1.1.2.实现弹窗的可见和关闭</h3><blockquote><p>窗口可见</p></blockquote><p>接下来，我们要在点击新增品牌按钮时，将窗口显示，因此要给新增按钮绑定事件。</p><div class="hljs"><pre><code class="hljs js">&lt;v-btn color=<span class="hljs-string">"primary"</span> @click=<span class="hljs-string">"addBrand"</span>&gt;新增品牌&lt;<span class="hljs-regexp">/v-btn&gt;</span></code></pre></div><p>然后定义一个addBrand方法：</p><div class="hljs"><pre><code class="hljs js">addBrand()&#123;    <span class="hljs-comment">// 控制弹窗可见：</span>    <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526118714621.png" srcset="/img/loading.gif" alt="1526118714621"></p><blockquote><p>窗口关闭</p></blockquote><p>现在，悲剧发生了，因为我们设置了persistent属性，窗口无法被关闭了。除非把show属性设置为false</p><p>因此我们需要给窗口添加一个关闭按钮：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--对话框的标题--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar</span> <span class="hljs-attr">dense</span> <span class="hljs-attr">dark</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-toolbar-title</span>&gt;</span>新增品牌<span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar-title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span>/&gt;</span>    <span class="hljs-comment">&lt;!--关闭窗口的按钮--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">icon</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"closeWindow"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-icon</span>&gt;</span>close<span class="hljs-tag">&lt;/<span class="hljs-name">v-icon</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-toolbar</span>&gt;</span></code></pre></div><p>并且，我们还给按钮绑定了点击事件，回调函数为closeWindow。</p><p>接下来，编写closeWindow函数：</p><div class="hljs"><pre><code class="hljs js">closeWindow()&#123;    <span class="hljs-comment">// 关闭窗口</span>    <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">false</span>;&#125;</code></pre></div><p>效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526119096686.png" srcset="/img/loading.gif" alt="1526119096686"></p><h3 id="1-1-3-新增品牌的表单页"><a href="#1-1-3-新增品牌的表单页" class="headerlink" title="1.1.3.新增品牌的表单页"></a>1.1.3.新增品牌的表单页</h3><p>接下来就是写表单了。我们有两种选择：</p><ul><li>直接在dialog对话框中编写表单代码</li><li>另外编写一个组件，组件内写表单代码。然后在对话框引用组件</li></ul><p>选第几种？</p><p>我们选第二种方案，优点：</p><ul><li>表单代码独立组件，可拔插，方便后期的维护。</li><li>代码分离，可读性更好。</li></ul><p>我们新建一个<code>MyBrandForm.vue</code>组件：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526119788914.png" srcset="/img/loading.gif" alt="1526119788914"></p><p>将MyBrandForm引入到MyBrand中，这里使用局部组件的语法：</p><p>先导入自定义组件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 导入自定义的表单组件</span><span class="hljs-keyword">import</span> MyBrandForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyBrandForm'</span></code></pre></div><p>然后通过components属性来指定局部组件：</p><div class="hljs"><pre><code class="hljs js">components:&#123;    MyBrandForm&#125;</code></pre></div><p>然后在页面中引用：</p><p>页面效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526128384960.png" srcset="/img/loading.gif" alt="1526128384960"></p><h3 id="1-1-4-编写表单"><a href="#1-1-4-编写表单" class="headerlink" title="1.1.4.编写表单"></a>1.1.4.编写表单</h3><h4 id="1-1-4-1-表单"><a href="#1-1-4-1-表单" class="headerlink" title="1.1.4.1.表单"></a>1.1.4.1.表单</h4><p>查看文档，找到关于表单的部分：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526128476264.png" srcset="/img/loading.gif" alt="1526128476264"></p><p><code>v-form</code>，表单组件，内部可以有许多输入项。<code>v-form</code>有下面的属性：</p><ul><li>value：true，代表表单验证通过；false，代表表单验证失败</li></ul><p><code>v-form</code>提供了两个方法：</p><ul><li>reset：重置表单数据</li><li>validate：校验整个表单数据，前提是你写好了校验规则。返回Boolean表示校验成功或失败</li></ul><p>我们在data中定义一个valid属性，跟表单的value进行双向绑定，观察表单是否通过校验，同时把等会要跟表单关联的品牌brand对象声明出来：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">"my-brand-form"</span>,  data() &#123;    <span class="hljs-keyword">return</span> &#123;      valid:<span class="hljs-literal">false</span>, <span class="hljs-comment">// 表单校验结果标记</span>      brand:&#123;        name:<span class="hljs-string">''</span>, <span class="hljs-comment">// 品牌名称</span>        letter:<span class="hljs-string">''</span>, <span class="hljs-comment">// 品牌首字母</span>        image:<span class="hljs-string">''</span>,<span class="hljs-comment">// 品牌logo</span>        categories:[], <span class="hljs-comment">// 品牌所属的商品分类数组</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><p>然后，在页面先写一个表单：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-form</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"valid"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-form</span>&gt;</span></code></pre></div><h4 id="1-1-4-2-文本框"><a href="#1-1-4-2-文本框" class="headerlink" title="1.1.4.2.文本框"></a>1.1.4.2.文本框</h4><p>我们的品牌总共需要这些字段：</p><ul><li>名称</li><li>首字母</li><li>商品分类，有很多个</li><li>LOGO</li></ul><p>表单项主要包括文本框、密码框、多选框、单选框、文本域、下拉选框、文件上传等。思考下我们的品牌需要哪些？</p><ul><li>文本框：品牌名称、品牌首字母都属于文本框</li><li>文件上传：品牌需要图片，这个是文件上传框</li><li>下拉选框：商品分类提前已经定义好，这里需要通过下拉选框展示，提供给用户选择。</li></ul><p>先看文本框，昨天已经用过的，叫做<code>v-text-field</code>：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526129519056.png" srcset="/img/loading.gif" alt="1526129519056"></p><p>查看文档，<code>v-text-field</code>有以下关键属性：</p><ul><li><strong>append-icon</strong>：文本框后追加图标，需要填写图标名称。无默认值</li><li>clearable：是否添加一个清空图标，点击会清空文本框。默认是false</li><li>color：颜色</li><li>counter：是否添加一个文本计数器，在角落显示文本长度，指定true或允许的组大长度。无默认值</li><li>dark：是否应用黑暗色调，默认是false</li><li>disable：是否禁用，默认是false</li><li>flat：是否移除默认的动画效果，默认是false</li><li>full-width：指定宽度为全屏，默认是false</li><li>hide-details：是否因此错误提示，默认是false</li><li>hint：输入框的提示文本</li><li><strong>label</strong>：输入框的标签</li><li><strong>multi-line</strong>：是否转为文本域，默认是false。文本框和文本域可以自由切换</li><li>placeholder：输入框占位符文本，focus后消失</li><li><strong>required</strong>：是否为必填项，如果是，会在label后加*，不具备校验功能。默认是false</li><li><strong>rows</strong>：文本域的行数，<code>multi-line</code>为true时才有效</li><li><strong>rules</strong>：指定校验规则及错误提示信息，数组结构。默认[]</li><li><strong>single-line</strong>：是否单行文本显示，默认是false</li><li><strong>suffix</strong>：显示后缀</li></ul><p>接下来，我们先添加两个字段：品牌名称、品牌的首字母，校验规则暂时不写：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-form</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"valid"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"brand.name"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"请输入品牌名称"</span> <span class="hljs-attr">required</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"brand.letter"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"请输入品牌首字母"</span> <span class="hljs-attr">required</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-form</span>&gt;</span></code></pre></div><ul><li>千万不要忘了通过<code>v-model</code>把表单项与<code>brand</code>的属性关联起来。</li></ul><p>效果：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526131172190.png" srcset="/img/loading.gif" alt="1526131172190"></p><h4 id="1-1-4-3-级联下拉选框"><a href="#1-1-4-3-级联下拉选框" class="headerlink" title="1.1.4.3.级联下拉选框"></a>1.1.4.3.级联下拉选框</h4><p>接下来就是商品分类了，按照刚才的分析，商品分类应该是下拉选框。</p><p>但是大家仔细思考，商品分类包含三级。在展示的时候，应该是先由用户选中1级，才显示2级；选择了2级，才显示3级。形成一个多级分类的三级联动效果。</p><p>这个时候，就不是普通的下拉选框，而是三级联动的下拉选框！</p><p>这样的选框，在Vuetify中并没有提供（它提供的是基本的下拉框）。因此我已经给大家编写了一个无限级联动的下拉选框，能够满足我们的需求。</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526131637045.png" srcset="/img/loading.gif" alt="1526131637045"></p><p>具体请参考课前资料的《自定义组件用法指南.md》</p><p>我们在代码中使用：</p><div class="hljs"><pre><code class="hljs js">&lt;v-cascader  url=<span class="hljs-string">"/item/category/list"</span>  multiple   required  v-model=<span class="hljs-string">"brand.categories"</span>  label=<span class="hljs-string">"请选择商品分类"</span>/&gt;</code></pre></div><ul><li>url：加载商品分类选项的接口路径</li><li>multiple：是否多选，这里设置为true，因为一个品牌可能有多个分类</li><li>requried：是否是必须的，这里为true，会在提示上加*，提醒用户</li><li>v-model：关联我们brand对象的categories属性</li><li>label：文字说明</li></ul><p>效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526132934902.png" srcset="/img/loading.gif" alt="1526132934902"></p><p>data中获取的结果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526133224362.png" srcset="/img/loading.gif" alt="1526133224362"></p><h4 id="1-1-4-4-文件上传项"><a href="#1-1-4-4-文件上传项" class="headerlink" title="1.1.4.4.文件上传项"></a>1.1.4.4.文件上传项</h4><p>在Vuetify中，也没有文件上传的组件。</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/0B26B319.gif" srcset="/img/loading.gif" alt="img"> </p><p>还好，我已经给大家写好了一个文件上传的组件：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526133576597.png" srcset="/img/loading.gif" alt="1526133576597"></p><p>详细用法，参考《自定义组件使用指南.md》</p><p>我们添加上传的组件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-layout</span> <span class="hljs-attr">row</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">xs3</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 16px; color: #444"</span>&gt;</span>品牌LOGO：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-upload</span></span><span class="hljs-tag">             <span class="hljs-attr">v-model</span>=<span class="hljs-string">"brand.image"</span></span><span class="hljs-tag">             <span class="hljs-attr">url</span>=<span class="hljs-string">"/upload"</span> </span><span class="hljs-tag">             <span class="hljs-attr">:multiple</span>=<span class="hljs-string">"false"</span> </span><span class="hljs-tag">             <span class="hljs-attr">:pic-width</span>=<span class="hljs-string">"250"</span> </span><span class="hljs-tag">             <span class="hljs-attr">:pic-height</span>=<span class="hljs-string">"90"</span></span><span class="hljs-tag">                  /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-layout</span>&gt;</span></code></pre></div><p>注意：</p><ul><li>文件上传组件本身没有提供文字提示。因此我们需要自己添加一段文字说明</li><li>我们要实现文字和图片组件左右放置，因此这里使用了<code>v-layout</code>布局组件：<ul><li>layout添加了row属性，代表这是一行，如果是column，代表是多行</li><li>layout下面有<code>v-flex</code>组件，是这一行的单元，我们有2个单元<ul><li><code>&lt;v-flex xs3&gt;</code> ：显示文字说明，xs3是响应式布局，代表占12格中的3格</li><li>剩下的部分就是图片上传组件了</li></ul></li></ul></li><li><code>v-upload</code>：图片上传组件，包含以下属性：<ul><li>v-model：将上传的结果绑定到brand的image属性</li><li>url：上传的路径，我们先随便写一个。</li><li>multiple：是否运行多图片上传，这里是false。因为品牌LOGO只有一个</li><li>pic-width和pic-height：可以控制l图片上传后展示的宽高</li></ul></li></ul><p>最终结果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526136024649.png" srcset="/img/loading.gif" alt="1526136024649"></p><h4 id="1-1-4-5-按钮"><a href="#1-1-4-5-按钮" class="headerlink" title="1.1.4.5.按钮"></a>1.1.4.5.按钮</h4><p>上面已经把所有的表单项写完。最后就差提交和清空的按钮了。</p><p>在表单的最下面添加两个按钮：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"my-4"</span> <span class="hljs-attr">row</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"clear"</span> &gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-layout</span>&gt;</span></code></pre></div><ul><li>通过layout来进行布局，<code>my-4</code>增大上下边距</li><li><code>v-spacer</code>占用一定空间，将按钮都排挤到页面右侧</li><li>两个按钮分别绑定了submit和clear事件</li></ul><p>我们先将方法定义出来：</p><div class="hljs"><pre><code class="hljs js">methods:&#123;    submit()&#123;        <span class="hljs-comment">// 提交表单</span>    &#125;,    clear()&#123;        <span class="hljs-comment">// 重置表单</span>    &#125;&#125;</code></pre></div><p>重置表单相对简单，因为v-form组件已经提供了reset方法，用来清空表单数据。只要我们拿到表单组件对象，就可以调用方法了。</p><p>我们可以通过<code>$refs</code>内置对象来获取表单组件。</p><p>首先，在表单上定义<code>ref</code>属性：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526137891067.png" srcset="/img/loading.gif" alt="1526137891067"></p><p>然后，在页面查看<code>this.$refs</code>属性：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526138030853.png" srcset="/img/loading.gif" alt="1526138030853"></p><p>看到<code>this.$refs</code>中只有一个属性，就是<code>myBrandForm</code></p><p>我们在clear中来获取表单对象并调用reset方法：</p><div class="hljs"><pre><code class="hljs js">methods:&#123;  submit()&#123;    <span class="hljs-comment">// 提交表单</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);  &#125;,  clear()&#123;    <span class="hljs-comment">// 重置表单</span>    <span class="hljs-keyword">this</span>.$refs.myBrandForm.reset();    <span class="hljs-comment">// 需要手动清空商品分类</span>    <span class="hljs-keyword">this</span>.categories = [];  &#125;&#125;</code></pre></div><p>要注意的是，这里我们还手动把this.categories清空了，因为我写的级联选择组件并没有跟表单结合起来。需要手动清空。</p><h3 id="1-1-5-表单校验"><a href="#1-1-5-表单校验" class="headerlink" title="1.1.5.表单校验"></a>1.1.5.表单校验</h3><h4 id="1-1-5-1-校验规则"><a href="#1-1-5-1-校验规则" class="headerlink" title="1.1.5.1.校验规则"></a>1.1.5.1.校验规则</h4><p>Vuetify的表单校验，是通过rules属性来指定的：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526138441735.png" srcset="/img/loading.gif" alt="1526138441735"></p><p>校验规则的写法：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526138475159.png" srcset="/img/loading.gif" alt="1526138475159"></p><p>说明：</p><ul><li>规则是一个数组</li><li>数组中的元素是一个函数，该函数接收表单项的值作为参数，函数返回值两种情况：<ul><li>返回true，代表成功，</li><li>返回错误提示信息，代表失败</li></ul></li></ul><h4 id="1-1-5-2-项目中代码"><a href="#1-1-5-2-项目中代码" class="headerlink" title="1.1.5.2.项目中代码"></a>1.1.5.2.项目中代码</h4><p>我们有四个字段：</p><ul><li>name：做非空校验和长度校验，长度必须大于1</li><li>letter：首字母，校验长度为1，非空。</li><li>image：图片，不做校验，图片可以为空</li><li>categories：非空校验，自定义组件已经帮我们完成，不用写了</li></ul><p>首先，我们定义规则：</p><div class="hljs"><pre><code class="hljs js">nameRules:[    v =&gt; !!v || <span class="hljs-string">"品牌名称不能为空"</span>,    v =&gt; v.length &gt; <span class="hljs-number">1</span> || <span class="hljs-string">"品牌名称至少2位"</span>],letterRules:[    v =&gt; !!v || <span class="hljs-string">"首字母不能为空"</span>,    v =&gt; <span class="hljs-regexp">/^[A-Z]&#123;1&#125;$/</span>.test(v) || <span class="hljs-string">"品牌字母只能是A~Z的大写字母"</span>]</code></pre></div><p>然后，在页面标签中指定：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"brand.name"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"请输入品牌名称"</span> <span class="hljs-attr">required</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">"nameRules"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"brand.letter"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"请输入品牌首字母"</span> <span class="hljs-attr">required</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">"letterRules"</span> /&gt;</span></code></pre></div><p>效果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526139379209.png" srcset="/img/loading.gif" alt="1526139379209"></p><h3 id="1-1-6-表单提交"><a href="#1-1-6-表单提交" class="headerlink" title="1.1.6.表单提交"></a>1.1.6.表单提交</h3><p>在submit方法中添加表单提交的逻辑：</p><div class="hljs"><pre><code class="hljs js">submit() &#123;    <span class="hljs-comment">// 1、表单校验</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$refs.myBrandForm.validate()) &#123;        <span class="hljs-comment">// 2、定义一个请求参数对象，通过解构表达式来获取brand中的属性</span>        <span class="hljs-keyword">const</span> &#123;categories ,letter ,...params&#125; = <span class="hljs-keyword">this</span>.brand;        <span class="hljs-comment">// 3、数据库中只要保存分类的id即可，因此我们对categories的值进行处理,只保留id，并转为字符串</span>        params.cids = categories.map(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.id).join(<span class="hljs-string">","</span>);        <span class="hljs-comment">// 4、将字母都处理为大写</span>        params.letter = letter.toUpperCase();        <span class="hljs-comment">// 5、将数据提交到后台</span>        <span class="hljs-keyword">this</span>.$http.post(<span class="hljs-string">'/item/brand'</span>, params)            .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-comment">// 6、弹出提示</span>            <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"保存成功！"</span>);        &#125;)            .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"保存失败！"</span>);        &#125;);    &#125;&#125;</code></pre></div><ul><li><p>1、通过<code>this.$refs.myBrandForm</code>选中表单，然后调用表单的<code>validate</code>方法，进行表单校验。返回boolean值，true代表校验通过</p></li><li><p>2、通过解构表达式来获取brand中的值，categories和letter需要处理，单独获取。其它的存入params对象中</p></li><li><p>3、品牌和商品分类的中间表只保存两者的id，而brand.categories中保存的数对象数组，里面有id和name属性，因此这里通过数组的map功能转为id数组，然后通过join方法拼接为字符串</p></li><li><p>4、首字母都处理为大写保存</p></li><li><p>5、发起请求</p></li><li><p>6、弹窗提示成功还是失败，这里用到的是我们的自定义组件功能message组件：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526140298249.png" srcset="/img/loading.gif" alt="1526140298249"></p><p>这个插件把<code>$message</code>对象绑定到了Vue的原型上，因此我们可以通过<code>this.$message</code>来直接调用。</p><p>包含以下常用方法：</p><ul><li>info、error、success、warning等，弹出一个带有提示信息的窗口，色调与为普通（灰）、错误（红色）、成功（绿色）和警告（黄色）。使用方法：this.$message.info(“msg”)</li><li>confirm：确认框。用法：<code>this.$message.confirm(&quot;确认框的提示信息&quot;)</code>，返回一个Promise</li></ul></li></ul><h2 id="1-2-后台实现新增"><a href="#1-2-后台实现新增" class="headerlink" title="1.2.后台实现新增"></a>1.2.后台实现新增</h2><h3 id="1-2-1-controller"><a href="#1-2-1-controller" class="headerlink" title="1.2.1.controller"></a>1.2.1.controller</h3><p>还是一样，先分析四个内容：</p><ul><li>请求方式：刚才看到了是POST</li><li>请求路径：/brand</li><li>请求参数：brand对象，外加商品分类的id数组cids</li><li>返回值：无</li></ul><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 新增品牌</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> brand</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@PostMapping</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Void&gt; <span class="hljs-title">saveBrand</span><span class="hljs-params">(Brand brand, @RequestParam(<span class="hljs-string">"cids"</span>)</span> List&lt;Long&gt; cids) </span>&#123;    <span class="hljs-keyword">this</span>.brandService.saveBrand(brand, cids);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125;</code></pre></div><h3 id="1-2-2-Service"><a href="#1-2-2-Service" class="headerlink" title="1.2.2.Service"></a>1.2.2.Service</h3><p>这里要注意，我们不仅要新增品牌，还要维护品牌和商品分类的中间表。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveBrand</span><span class="hljs-params">(Brand brand, List&lt;Long&gt; cids)</span> </span>&#123;    <span class="hljs-comment">// 新增品牌信息</span>    <span class="hljs-keyword">this</span>.brandMapper.insertSelective(brand);    <span class="hljs-comment">// 新增品牌和分类中间表</span>    <span class="hljs-keyword">for</span> (Long cid : cids) &#123;        <span class="hljs-keyword">this</span>.brandMapper.insertCategoryBrand(cid, brand.getId());    &#125;&#125;</code></pre></div><p>这里调用了brandMapper中的一个自定义方法，来实现中间表的数据新增</p><h3 id="1-2-3-Mapper"><a href="#1-2-3-Mapper" class="headerlink" title="1.2.3.Mapper"></a>1.2.3.Mapper</h3><p>通用Mapper只能处理单表，也就是Brand的数据，因此我们手动编写一个方法及sql，实现中间表的新增：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BrandMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Brand</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 新增商品分类和品牌中间表数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cid 商品分类id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bid 品牌id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"INSERT INTO tb_category_brand (category_id, brand_id) VALUES (#&#123;cid&#125;,#&#123;bid&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertCategoryBrand</span><span class="hljs-params">(@Param(<span class="hljs-string">"cid"</span>)</span> Long cid, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"bid"</span>)</span> Long bid)</span>;&#125;</code></pre></div><h2 id="1-3-请求参数格式错误"><a href="#1-3-请求参数格式错误" class="headerlink" title="1.3.请求参数格式错误"></a>1.3.请求参数格式错误</h2><h3 id="1-3-1-原因分析"><a href="#1-3-1-原因分析" class="headerlink" title="1.3.1.原因分析"></a>1.3.1.原因分析</h3><p>我们填写表单并提交，发现报错了：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526180888663.png" srcset="/img/loading.gif" alt="1526180888663"></p><p>查看控制台的请求详情：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526180937974.png" srcset="/img/loading.gif" alt="1526180937974"></p><p>发现请求的数据格式是JSON格式。</p><blockquote><p>原因分析：</p></blockquote><p>axios处理请求体的原则会根据请求数据的格式来定：</p><ul><li><p>如果请求体是对象：会转为json发送</p></li><li><p>如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。</p><p>如：name=jack&amp;age=12</p></li></ul><h3 id="1-3-2-QS工具"><a href="#1-3-2-QS工具" class="headerlink" title="1.3.2.QS工具"></a>1.3.2.QS工具</h3><p>QS是一个第三方库，我们可以用<code>npm install qs --save</code>来安装。不过我们在项目中已经集成了，大家无需安装：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181889564.png" srcset="/img/loading.gif" alt="1526181889564"></p><p>这个工具的名字：QS，即Query String，请求参数字符串。</p><p>什么是请求参数字符串？例如： name=jack&amp;age=21</p><p>QS工具可以便捷的实现 JS的Object与QueryString的转换。</p><p>在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过<code>this.$qs</code>来获取这个工具：</p><p>我们将<code>this.$qs</code>对象打印到控制台：</p><div class="hljs"><pre><code class="hljs js">created()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$qs);&#125;</code></pre></div><p>发现其中有3个方法：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181747560.png" srcset="/img/loading.gif" alt="1526181747560"></p><p>这里我们要使用的方法是stringify，它可以把Object转为QueryString。</p><p>测试一下，使用浏览器工具，把qs对象保存为一个临时变量：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526182053758.png" srcset="/img/loading.gif" alt="1526182053758"></p><p>然后调用stringify方法：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526182230872.png" srcset="/img/loading.gif" alt="1526182230872"></p><p>成功将person对象变成了 name=jack&amp;age=21的字符串了</p><h3 id="1-3-3-解决问题"><a href="#1-3-3-解决问题" class="headerlink" title="1.3.3.解决问题"></a>1.3.3.解决问题</h3><p>修改页面，对参数处理后发送：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181301670.png" srcset="/img/loading.gif" alt="1526181301670"></p><p>然后再次发起请求：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181331443.png" srcset="/img/loading.gif" alt="1526181331443"></p><p>发现请求成功：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181358204.png" srcset="/img/loading.gif" alt="1526181358204"></p><p>参数格式：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181384653.png" srcset="/img/loading.gif" alt="1526181384653"></p><p>数据库：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526181553737.png" srcset="/img/loading.gif" alt="1526181553737"></p><h2 id="1-4-新增完成后关闭窗口"><a href="#1-4-新增完成后关闭窗口" class="headerlink" title="1.4.新增完成后关闭窗口"></a>1.4.新增完成后关闭窗口</h2><p>我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。</p><p>这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。</p><p>因此，我们需要<strong>在新增的ajax请求完成以后，关闭窗口</strong></p><p>但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？</p><p>之前我们讲过一个父子组件的通信，有印象吗？</p><ul><li>第一步，在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了，我们优化一下，关闭的同时重新加载数据：</li></ul><div class="hljs"><pre><code class="hljs js">closeWindow()&#123;    <span class="hljs-comment">// 关闭窗口</span>    <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 重新加载数据</span>    <span class="hljs-keyword">this</span>.getDataFromServer();&#125;</code></pre></div><ul><li>第二步，父组件在使用子组件时，绑定事件，关联到这个函数：</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--对话框的内容，表单--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">my-brand-form</span> @<span class="hljs-attr">close</span>=<span class="hljs-string">"closeWindow"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span></code></pre></div><ul><li><p>第三步，子组件通过<code>this.$emit</code>调用父组件的函数：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526216993249.png" srcset="/img/loading.gif" alt="1526216993249"></p></li></ul><p>测试一下</p><h1 id="2-实现图片上传"><a href="#2-实现图片上传" class="headerlink" title="2.实现图片上传"></a>2.实现图片上传</h1><p>刚才的新增实现中，我们并没有上传图片，接下来我们一起完成图片上传逻辑。</p><p>文件的上传并不只是在品牌管理中有需求，以后的其它服务也可能需要，因此我们创建一个独立的微服务，专门处理各种上传。</p><h2 id="2-1-搭建项目"><a href="#2-1-搭建项目" class="headerlink" title="2.1.搭建项目"></a>2.1.搭建项目</h2><h3 id="2-1-1-创建module"><a href="#2-1-1-创建module" class="headerlink" title="2.1.1.创建module"></a>2.1.1.创建module</h3><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526192299113.png" srcset="/img/loading.gif" alt="1526192299113"></p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526192347113.png" srcset="/img/loading.gif" alt="1526192347113"></p><h3 id="2-1-2-依赖"><a href="#2-1-2-依赖" class="headerlink" title="2.1.2.依赖"></a>2.1.2.依赖</h3><p>我们需要EurekaClient和web依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>leyou<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.parent<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-upload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="2-1-3-编写配置"><a href="#2-1-3-编写配置" class="headerlink" title="2.1.3.编写配置"></a>2.1.3.编写配置</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">upload-service</span>  <span class="hljs-attr">servlet:</span>    <span class="hljs-attr">multipart:</span>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">5MB</span> <span class="hljs-comment"># 限制文件上传的大小</span><span class="hljs-comment"># Eureka</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 每隔5秒发送一次心跳</span>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 10秒不发送就过期</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></code></pre></div><p>需要注意的是，我们应该添加了限制文件大小的配置</p><h3 id="2-1-4-启动类"><a href="#2-1-4-启动类" class="headerlink" title="2.1.4.启动类"></a>2.1.4.启动类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LyUploadService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(LyUploadService<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>结构：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526192931088.png" srcset="/img/loading.gif" alt="1526192931088"></p><h2 id="2-2-编写上传功能"><a href="#2-2-编写上传功能" class="headerlink" title="2.2.编写上传功能"></a>2.2.编写上传功能</h2><h3 id="2-2-1-controller"><a href="#2-2-1-controller" class="headerlink" title="2.2.1.controller"></a>2.2.1.controller</h3><p>编写controller需要知道4个内容：</p><ul><li>请求方式：上传肯定是POST</li><li>请求路径：/upload/image</li><li>请求参数：文件，参数名是file，SpringMVC会封装为一个接口：MultipleFile</li><li>返回结果：上传成功后得到的文件的url路径</li></ul><p>代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"upload"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UploadService uploadService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 上传图片功能</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"image"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">uploadImage</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"file"</span>)</span> MultipartFile file) </span>&#123;        String url = <span class="hljs-keyword">this</span>.uploadService.upload(file);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(url)) &#123;            <span class="hljs-comment">// url为空，证明上传失败</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);        &#125;        <span class="hljs-comment">// 返回200，并且携带url路径</span>        <span class="hljs-keyword">return</span> ResponseEntity.ok(url);    &#125;&#125;</code></pre></div><h3 id="2-2-2-service"><a href="#2-2-2-service" class="headerlink" title="2.2.2.service"></a>2.2.2.service</h3><p>在上传文件过程中，我们需要对上传的内容进行校验：</p><ol><li>校验文件大小</li><li>校验文件的媒体类型</li><li>校验文件的内容</li></ol><p>文件大小在Spring的配置文件中设置，因此已经会被校验，我们不用管。</p><p>具体代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UploadController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">// 支持的文件类型</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; suffixes = Arrays.asList(<span class="hljs-string">"image/png"</span>, <span class="hljs-string">"image/jpeg"</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 1、图片信息校验</span>            <span class="hljs-comment">// 1)校验文件类型</span>            String type = file.getContentType();            <span class="hljs-keyword">if</span> (!suffixes.contains(type)) &#123;                logger.info(<span class="hljs-string">"上传失败，文件类型不匹配：&#123;&#125;"</span>, type);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 2)校验图片内容</span>            BufferedImage image = ImageIO.read(file.getInputStream());            <span class="hljs-keyword">if</span> (image == <span class="hljs-keyword">null</span>) &#123;                logger.info(<span class="hljs-string">"上传失败，文件内容不符合要求"</span>);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 2、保存图片</span>            <span class="hljs-comment">// 2.1、生成保存目录</span>            File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\heima\\upload"</span>);            <span class="hljs-keyword">if</span> (!dir.exists()) &#123;                dir.mkdirs();            &#125;            <span class="hljs-comment">// 2.2、保存图片</span>            file.transferTo(<span class="hljs-keyword">new</span> File(dir, file.getOriginalFilename()));            <span class="hljs-comment">// 2.3、拼接图片地址</span>            String url = <span class="hljs-string">"http://image.leyou.com/upload/"</span> + file.getOriginalFilename();            <span class="hljs-keyword">return</span> url;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><p>这里有一个问题：为什么图片地址需要使用另外的url？</p><ul><li>图片不能保存在服务器内部，这样会对服务器产生额外的加载负担</li><li>一般静态资源都应该使用独立域名，这样访问静态资源时不会携带一些不必要的cookie，减小请求的数据量</li></ul><h3 id="2-2-3-测试上传"><a href="#2-2-3-测试上传" class="headerlink" title="2.2.3.测试上传"></a>2.2.3.测试上传</h3><p>我们通过RestClient工具来测试：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526196967376.png" srcset="/img/loading.gif" alt="1526196967376"></p><p>结果：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526197027688.png" srcset="/img/loading.gif" alt="1526197027688"></p><p>去目录下查看：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526197060729.png" srcset="/img/loading.gif" alt="1526197060729"></p><p>上传成功！</p><h3 id="2-2-4-绕过网关"><a href="#2-2-4-绕过网关" class="headerlink" title="2.2.4.绕过网关"></a>2.2.4.绕过网关</h3><p>图片上传是文件的传输，如果也经过Zuul网关的代理，文件就会经过多次网路传输，造成不必要的网络负担。在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。</p><p>所以，我们上传文件的请求就不经过网关来处理了。</p><h4 id="2-2-4-1-Zuul的路由过滤"><a href="#2-2-4-1-Zuul的路由过滤" class="headerlink" title="2.2.4.1.Zuul的路由过滤"></a>2.2.4.1.Zuul的路由过滤</h4><p>Zuul中提供了一个ignored-patterns属性，用来忽略不希望路由的URL路径，示例：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">zuul.ignored-patterns</span>: <span class="hljs-string">/upload/**</span></code></pre></div><p>路径过滤会对一切微服务进行判定。</p><p>Zuul还提供了<code>ignored-services</code>属性，进行服务过滤：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">zuul.ignored-services</span>: <span class="hljs-string">upload-servie</span></code></pre></div><p>我们这里采用忽略服务：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">ignored-services:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">upload-service</span> <span class="hljs-comment"># 忽略upload-service服务</span></code></pre></div><p>上面的配置采用了集合语法，代表可以配置多个</p><h4 id="2-2-4-2-Nginx的rewrite指令"><a href="#2-2-4-2-Nginx的rewrite指令" class="headerlink" title="2.2.4.2.Nginx的rewrite指令"></a>2.2.4.2.Nginx的rewrite指令</h4><p>现在，我们修改页面的访问路径：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-upload</span></span><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"brand.image"</span> </span><span class="hljs-tag">      <span class="hljs-attr">url</span>=<span class="hljs-string">"/upload/image"</span> </span><span class="hljs-tag">      <span class="hljs-attr">:multiple</span>=<span class="hljs-string">"false"</span> </span><span class="hljs-tag">      <span class="hljs-attr">:pic-width</span>=<span class="hljs-string">"250"</span> <span class="hljs-attr">:pic-height</span>=<span class="hljs-string">"90"</span></span><span class="hljs-tag">      /&gt;</span></code></pre></div><p>查看页面的请求路径：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526196446765.png" srcset="/img/loading.gif" alt="1526196446765"></p><p>可以看到这个地址不对，依然是去找Zuul网关，因为我们的系统全局配置了URL地址。怎么办？</p><p>有同学会想：修改页面请求地址不就好了。</p><p>注意：原则上，我们是不能把除了网关以外的服务对外暴露的，不安全。</p><p>既然不能修改页面请求，那么就只能在Nginx反向代理上做文章了。</p><p>我们修改nginx配置，将以/api/upload开头的请求拦截下来，转交到真实的服务地址:</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /api/upload &#123;    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8082;    <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;    <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;&#125;</code></pre></div><p>这样写大家觉得对不对呢？</p><p>显然是不对的，因为ip和端口虽然对了，但是路径没变，依然是：<a href="http://127.0.0.1:8002/api/upload/image" target="_blank" rel="noopener">http://127.0.0.1:8002/api/upload/image</a></p><p>前面多了一个/api</p><p>Nginx提供了rewrite指令，用于对地址进行重写，语法规则：</p><div class="hljs"><pre><code class="hljs abnf">rewrite <span class="hljs-string">"用来匹配路径的正则"</span> 重写后的路径 [指令]<span class="hljs-comment">;</span></code></pre></div><p>我们的案例：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;       <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;       <span class="hljs-attribute">server_name</span>  api.leyou.com;       <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host <span class="hljs-variable">$host</span>;       <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Server <span class="hljs-variable">$host</span>;       <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;   <span class="hljs-comment"># 上传路径的映射</span><span class="hljs-attribute">location</span> /api/upload &#123;<span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8082;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">rewrite</span> <span class="hljs-string">"^/api/(.*)$"</span> /<span class="hljs-variable">$1</span> <span class="hljs-literal">break</span>;        &#125;       <span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:10010;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;       &#125;   &#125;</code></pre></div><ul><li><p>首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理</p></li><li><p><code>proxy_pass</code>：反向代理，这次我们代理到8082端口，也就是upload-service服务</p></li><li><p><code>rewrite &quot;^/api/(.*)$&quot; /$1 break</code>，路径重写：</p><ul><li><p><code>&quot;^/api/(.*)$&quot;</code>：匹配路径的正则表达式，用了分组语法，把<code>/api/</code>以后的所有部分当做1组</p></li><li><p><code>/$1</code>：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即<code>/api/</code>后面的所有。这样新的路径就是除去<code>/api/</code>以外的所有，就达到了去除<code>/api</code>前缀的目的</p></li><li><p><code>break</code>：指令，常用的有2个，分别是：last、break</p><ul><li>last：重写路径结束后，将得到的路径重新进行一次路径匹配</li><li>break：重写路径结束后，不再重新匹配路径。</li></ul><p>我们这里不能选择last，否则以新的路径/upload/image来匹配，就不会被正确的匹配到8082端口了</p></li></ul></li></ul><p>修改完成，输入<code>nginx -s reload</code>命令重新加载配置。然后再次上传试试。</p><h3 id="2-2-5-跨域问题"><a href="#2-2-5-跨域问题" class="headerlink" title="2.2.5.跨域问题"></a>2.2.5.跨域问题</h3><p>重启nginx，再次上传，发现报错了：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526200471676.png" srcset="/img/loading.gif" alt="1526200471676"></p><p>不过庆幸的是，这个错误已经不是第一次见了，跨域问题。</p><p>我们在upload-service中添加一个CorsFilter即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1.添加CORS配置信息</span>        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();        <span class="hljs-comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span>        config.addAllowedOrigin(<span class="hljs-string">"http://manage.leyou.com"</span>);        <span class="hljs-comment">//2) 是否发送Cookie信息</span>        config.setAllowCredentials(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//3) 允许的请求方式</span>        config.addAllowedMethod(<span class="hljs-string">"OPTIONS"</span>);        config.addAllowedMethod(<span class="hljs-string">"POST"</span>);        config.addAllowedHeader(<span class="hljs-string">"*"</span>);        <span class="hljs-comment">//2.添加映射路径，我们拦截一切请求</span>        UrlBasedCorsConfigurationSource configSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();        configSource.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);        <span class="hljs-comment">//3.返回新的CorsFilter.</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(configSource);    &#125;&#125;</code></pre></div><p>再次测试：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526200606487.png" srcset="/img/loading.gif" alt="1526200606487"></p><p>不过，非常遗憾的是，访问图片地址，却没有响应。</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526200927268.png" srcset="/img/loading.gif" alt="1526200927268"></p><p>这是因为我们并没有任何服务器对应image.leyou.com这个域名。。</p><p>这个问题，我们暂时放下，回头再来解决。</p><h3 id="2-2-6-之前上传的缺陷"><a href="#2-2-6-之前上传的缺陷" class="headerlink" title="2.2.6.之前上传的缺陷"></a>2.2.6.之前上传的缺陷</h3><p>先思考一下，之前上传的功能，有没有什么问题？</p><p>上传本身没有任何问题，问题出在保存文件的方式，我们是保存在服务器机器，就会有下面的问题：</p><ul><li>单机器存储，存储能力有限</li><li>无法进行水平扩展，因为多台机器的文件无法共享,会出现访问不到的情况</li><li>数据没有备份，有单点故障风险</li><li>并发能力差</li></ul><p>这个时候，最好使用分布式文件存储来代替本地文件存储。</p><h1 id="3-FastDFS"><a href="#3-FastDFS" class="headerlink" title="3.FastDFS"></a>3.FastDFS</h1><h2 id="3-1-什么是分布式文件系统"><a href="#3-1-什么是分布式文件系统" class="headerlink" title="3.1.什么是分布式文件系统"></a>3.1.什么是分布式文件系统</h2><p>分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 </p><p>通俗来讲：</p><ul><li>传统文件系统管理的文件就存储在本机。</li><li>分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问</li></ul><h2 id="3-2-什么是FastDFS"><a href="#3-2-什么是FastDFS" class="headerlink" title="3.2.什么是FastDFS"></a>3.2.什么是FastDFS</h2><p>FastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富：</p><ul><li>文件存储</li><li>文件同步</li><li>文件访问（上传、下载）</li><li>存取负载均衡</li><li>在线扩容</li></ul><p>适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。</p><h2 id="3-3-FastDFS的架构"><a href="#3-3-FastDFS的架构" class="headerlink" title="3.3.FastDFS的架构"></a>3.3.FastDFS的架构</h2><h3 id="3-3-1-架构图"><a href="#3-3-1-架构图" class="headerlink" title="3.3.1.架构图"></a>3.3.1.架构图</h3><p>先上图：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526205318630.png" srcset="/img/loading.gif" alt="1526205318630"></p><p>FastDFS两个主要的角色：Tracker Server 和 Storage Server 。</p><ul><li>Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 </li><li>Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息</li><li>Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 </li><li>Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。</li><li>Storage Cluster ：存储集群，有多个Group组成。</li></ul><h3 id="3-3-2-上传和下载流程"><a href="#3-3-2-上传和下载流程" class="headerlink" title="3.3.2.上传和下载流程"></a>3.3.2.上传和下载流程</h3><blockquote><p>上传</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526205664373.png" srcset="/img/loading.gif" alt="1526205664373"></p><ol><li>Client通过Tracker server查找可用的Storage server。</li><li>Tracker server向Client返回一台可用的Storage server的IP地址和端口号。</li><li>Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。</li><li>上传完成，Storage server返回Client一个文件ID，文件上传结束。</li></ol><blockquote><p>下载</p></blockquote><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526205705687.png" srcset="/img/loading.gif" alt="1526205705687"></p><ol><li>Client通过Tracker server查找要下载文件所在的的Storage server。</li><li>Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。</li><li>Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。</li><li>下载文件成功。</li></ol><h2 id="3-4-安装和使用"><a href="#3-4-安装和使用" class="headerlink" title="3.4.安装和使用"></a>3.4.安装和使用</h2><p>参考课前资料的：《centos安装FastDFS.md》</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526205975025.png" srcset="/img/loading.gif" alt="1526205975025"></p><h2 id="3-5-java客户端"><a href="#3-5-java客户端" class="headerlink" title="3.5.java客户端"></a>3.5.java客户端</h2><p>余庆先生提供了一个Java客户端，但是作为一个C程序员，写的java代码可想而知。而且已经很久不维护了。</p><p>这里推荐一个开源的FastDFS客户端，支持最新的SpringBoot2.0。</p><p>配置使用极为简单，支持连接池，支持自动生成缩略图，狂拽酷炫吊炸天啊，有木有。</p><p>地址：<a href="https://github.com/tobato/FastDFS_Client" target="_blank" rel="noopener">tobato/FastDFS_client</a></p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526206304954.png" srcset="/img/loading.gif" alt="1526206304954"></p><h3 id="3-5-1-引入依赖"><a href="#3-5-1-引入依赖" class="headerlink" title="3.5.1.引入依赖"></a>3.5.1.引入依赖</h3><p>在父工程中，我们已经管理了依赖，版本为：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fastDFS.client.version</span>&gt;</span>1.26.2<span class="hljs-tag">&lt;/<span class="hljs-name">fastDFS.client.version</span>&gt;</span></code></pre></div><p>因此，这里我们直接引入坐标即可：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.tobato<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="3-5-2-引入配置类"><a href="#3-5-2-引入配置类" class="headerlink" title="3.5.2.引入配置类"></a>3.5.2.引入配置类</h3><p>纯java配置：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(FdfsClientConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">// 解决<span class="hljs-title">jmx</span>重复注册<span class="hljs-title">bean</span>的问题</span><span class="hljs-class">@<span class="hljs-title">EnableMBeanExport</span>(<span class="hljs-title">registration</span> </span>= RegistrationPolicy.IGNORE_EXISTING)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastClientImporter</span> </span>&#123;&#125;</code></pre></div><h3 id="3-5-3-编写FastDFS属性"><a href="#3-5-3-编写FastDFS属性" class="headerlink" title="3.5.3.编写FastDFS属性"></a>3.5.3.编写FastDFS属性</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">fdfs:</span>  <span class="hljs-attr">so-timeout:</span> <span class="hljs-number">1501</span>  <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">601</span>  <span class="hljs-attr">thumb-image:</span> <span class="hljs-comment"># 缩略图</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">60</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">60</span>  <span class="hljs-attr">tracker-list:</span> <span class="hljs-comment"># tracker地址</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.101</span><span class="hljs-string">:22122</span></code></pre></div><h3 id="3-5-4-测试"><a href="#3-5-4-测试" class="headerlink" title="3.5.4.测试"></a>3.5.4.测试</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= LyUploadService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">FdfsTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> FastFileStorageClient storageClient;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ThumbImageConfig thumbImageConfig;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\test\\baby.png"</span>);        <span class="hljs-comment">// 上传并且生成缩略图</span>        StorePath storePath = <span class="hljs-keyword">this</span>.storageClient.uploadFile(                <span class="hljs-keyword">new</span> FileInputStream(file), file.length(), <span class="hljs-string">"png"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// 带分组的路径</span>        System.out.println(storePath.getFullPath());        <span class="hljs-comment">// 不带分组的路径</span>        System.out.println(storePath.getPath());    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUploadAndCreateThumb</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\test\\baby.png"</span>);        <span class="hljs-comment">// 上传并且生成缩略图</span>        StorePath storePath = <span class="hljs-keyword">this</span>.storageClient.uploadImageAndCrtThumbImage(                <span class="hljs-keyword">new</span> FileInputStream(file), file.length(), <span class="hljs-string">"png"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// 带分组的路径</span>        System.out.println(storePath.getFullPath());        <span class="hljs-comment">// 不带分组的路径</span>        System.out.println(storePath.getPath());        <span class="hljs-comment">// 获取缩略图路径</span>        String path = thumbImageConfig.getThumbImagePath(storePath.getPath());        System.out.println(path);    &#125;&#125;</code></pre></div><p>结果：</p><div class="hljs"><pre><code class="hljs angelscript">group1/M00/<span class="hljs-number">00</span>/<span class="hljs-number">00</span>/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/<span class="hljs-number">00</span>/<span class="hljs-number">00</span>/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/<span class="hljs-number">00</span>/<span class="hljs-number">00</span>/wKg4ZVro5eCAZEMVABfYcN8vzII630_60x60.png</code></pre></div><p>访问第一个路径：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526215187172.png" srcset="/img/loading.gif" alt="1526215187172"></p><p>访问最后一个路径（缩略图路径），注意加组名：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526215257110.png" srcset="/img/loading.gif" alt="1526215257110"></p><h3 id="3-5-5-改造上传逻辑"><a href="#3-5-5-改造上传逻辑" class="headerlink" title="3.5.5.改造上传逻辑"></a>3.5.5.改造上传逻辑</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UploadController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">// 支持的文件类型</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; suffixes = Arrays.asList(<span class="hljs-string">"image/png"</span>, <span class="hljs-string">"image/jpeg"</span>);    <span class="hljs-meta">@Autowired</span>    FastFileStorageClient storageClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile file)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 1、图片信息校验</span>            <span class="hljs-comment">// 1)校验文件类型</span>            String type = file.getContentType();            <span class="hljs-keyword">if</span> (!suffixes.contains(type)) &#123;                logger.info(<span class="hljs-string">"上传失败，文件类型不匹配：&#123;&#125;"</span>, type);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 2)校验图片内容</span>            BufferedImage image = ImageIO.read(file.getInputStream());            <span class="hljs-keyword">if</span> (image == <span class="hljs-keyword">null</span>) &#123;                logger.info(<span class="hljs-string">"上传失败，文件内容不符合要求"</span>);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 2、将图片上传到FastDFS</span>            <span class="hljs-comment">// 2.1、获取文件后缀名</span>            String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), <span class="hljs-string">"."</span>);            <span class="hljs-comment">// 2.2、上传</span>            StorePath storePath = <span class="hljs-keyword">this</span>.storageClient.uploadFile(                    file.getInputStream(), file.getSize(), extension, <span class="hljs-keyword">null</span>);            <span class="hljs-comment">// 2.3、返回完整路径</span>            <span class="hljs-keyword">return</span> <span class="hljs-string">"http://image.leyou.com/"</span> + storePath.getFullPath();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><p>只需要把原来保存文件的逻辑去掉，然后上传到FastDFS即可。</p><h3 id="3-5-6-测试"><a href="#3-5-6-测试" class="headerlink" title="3.5.6.测试"></a>3.5.6.测试</h3><p>通过RestClient测试：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526215940805.png" srcset="/img/loading.gif" alt="1526215940805"></p><h2 id="3-6-页面测试上传"><a href="#3-6-页面测试上传" class="headerlink" title="3.6.页面测试上传"></a>3.6.页面测试上传</h2><p>发现上传成功：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526216133300.png" srcset="/img/loading.gif" alt="1526216133300"></p><p>不过，当我们访问页面时：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526216178123.png" srcset="/img/loading.gif" alt="1526216178123"></p><p>这是因为我们图片是上传到虚拟机的，ip为：192.168.56.101</p><p>因此，我们需要将image.leyou.com映射到192.168.56.101</p><p>修改我们的hosts：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526216272835.png" srcset="/img/loading.gif" alt="1526216272835"></p><p>再次上传：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526216322359.png" srcset="/img/loading.gif" alt="1526216322359"></p><h1 id="4-修改品牌（作业）"><a href="#4-修改品牌（作业）" class="headerlink" title="4.修改品牌（作业）"></a>4.修改品牌（作业）</h1><p>修改的难点在于回显。</p><p>当我们点击编辑按钮，希望弹出窗口的同时，看到原来的数据：</p><p><img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526216494380.png" srcset="/img/loading.gif" alt="1526216494380"></p><h2 id="4-1-点击编辑出现弹窗"><a href="#4-1-点击编辑出现弹窗" class="headerlink" title="4.1.点击编辑出现弹窗"></a>4.1.点击编辑出现弹窗</h2><p>这个比较简单，修改show属性为true即可实现，我们绑定一个点击事件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"info"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"editBrand"</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span></code></pre></div><p>然后编写事件，改变show 的状态：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526217622765.png" srcset="/img/loading.gif" alt="1526217622765"></p><p>如果仅仅是这样，编辑按钮与新增按钮将没有任何区别，关键在于，如何回显呢？</p><h2 id="4-2-回显数据"><a href="#4-2-回显数据" class="headerlink" title="4.2.回显数据"></a>4.2.回显数据</h2><p>回显数据，就是把当前点击的品牌数据传递到子组件（MyBrandForm）。而父组件给子组件传递数据，通过props属性。</p><ul><li><p>第一步：在编辑时获取当前选中的品牌信息，并且记录到data中</p><p>先在data中定义属性，用来接收用来编辑的brand数据：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526218080029.png" srcset="/img/loading.gif" alt="1526218080029"></p><p>我们在页面触发编辑事件时，把当前的brand传递给editBrand方法：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"info"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"editBrand(props.item)"</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span></code></pre></div><p>然后在editBrand中接收数据，赋值给oldBrand：</p><div class="hljs"><pre><code class="hljs js">editBrand(oldBrand)&#123;  <span class="hljs-comment">// 控制弹窗可见：</span>  <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 获取要编辑的brand</span>  <span class="hljs-keyword">this</span>.oldBrand = oldBrand;&#125;,</code></pre></div></li><li><p>第二步：把获取的brand数据 传递给子组件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--对话框的内容，表单--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">v-card-text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"px-5"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">my-brand-form</span> @<span class="hljs-attr">close</span>=<span class="hljs-string">"closeWindow"</span> <span class="hljs-attr">:oldBrand</span>=<span class="hljs-string">"oldBrand"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-text</span>&gt;</span></code></pre></div></li><li><p>第三步：在子组件中通过props接收要编辑的brand数据，Vue会自动完成回显</p><p>接收数据：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526218243761.png" srcset="/img/loading.gif" alt="1526218243761"></p><p>通过watch函数监控oldBrand的变化，把值copy到本地的brand：</p><div class="hljs"><pre><code class="hljs js">watch: &#123;    oldBrand: &#123;<span class="hljs-comment">// 监控oldBrand的变化</span>        handler(val) &#123;            <span class="hljs-keyword">if</span>(val)&#123;                <span class="hljs-comment">// 注意不要直接复制，否则这边的修改会影响到父组件的数据，copy属性即可</span>                <span class="hljs-keyword">this</span>.brand =  <span class="hljs-built_in">Object</span>.deepCopy(val)            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">// 为空，初始化brand</span>                <span class="hljs-keyword">this</span>.brand = &#123;                    name: <span class="hljs-string">''</span>,                    letter: <span class="hljs-string">''</span>,                    image: <span class="hljs-string">''</span>,                    categories: [],                &#125;            &#125;        &#125;,            deep: <span class="hljs-literal">true</span>    &#125;&#125;</code></pre></div><ul><li>Object.deepCopy 自定义的对对象进行深度复制的方法。</li><li>需要判断监听到的是否为空，如果为空，应该进行初始化</li></ul></li></ul><p>测试：发现数据回显了，除了商品分类以外：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526219653994.png" srcset="/img/loading.gif" alt="1526219653994"></p><h2 id="4-3-商品分类回显"><a href="#4-3-商品分类回显" class="headerlink" title="4.3.商品分类回显"></a>4.3.商品分类回显</h2><p>为什么商品分类没有回显？</p><p>因为品牌中并没有商品分类数据。我们需要在进入编辑页面之前，查询商品分类信息：</p><h3 id="4-3-1-后台提供接口"><a href="#4-3-1-后台提供接口" class="headerlink" title="4.3.1.后台提供接口"></a>4.3.1.后台提供接口</h3><blockquote><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过品牌id查询商品分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bid</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"bid/&#123;bid&#125;"</span>)<span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Category&gt;&gt; queryByBrandId(<span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">"bid"</span>) Long bid) &#123;    List&lt;Category&gt; list = <span class="hljs-keyword">this</span>.categoryService.queryByBrandId(bid);    <span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span> || list.size() &lt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);    &#125;    <span class="hljs-keyword">return</span> ResponseEntity.ok(list);&#125;</code></pre></div><blockquote><p>Service</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Category&gt; <span class="hljs-title">queryByBrandId</span><span class="hljs-params">(Long bid)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.categoryMapper.queryByBrandId(bid);&#125;</code></pre></div><blockquote><p>mapper</p></blockquote><p>因为需要通过中间表进行子查询，所以这里要手写Sql：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据品牌id查询商品分类</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bid</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)"</span>)<span class="hljs-function">List&lt;Category&gt; <span class="hljs-title">queryByBrandId</span><span class="hljs-params">(Long bid)</span></span>;</code></pre></div><h3 id="4-3-2-前台查询分类并渲染"><a href="#4-3-2-前台查询分类并渲染" class="headerlink" title="4.3.2.前台查询分类并渲染"></a>4.3.2.前台查询分类并渲染</h3><p>我们在编辑页面打开之前，先把数据查询完毕：</p><div class="hljs"><pre><code class="hljs js">editBrand(oldBrand)&#123;    <span class="hljs-comment">// 根据品牌信息查询商品分类</span>    <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/category/bid/"</span> + oldBrand.id)        .then(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 控制弹窗可见：</span>        <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 获取要编辑的brand</span>        <span class="hljs-keyword">this</span>.oldBrand = oldBrand        <span class="hljs-comment">// 回显商品分类</span>        <span class="hljs-keyword">this</span>.oldBrand.categories = data;    &#125;)&#125;</code></pre></div><p>再次测试：数据成功回显了</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526222999115.png" srcset="/img/loading.gif" alt="1526222999115"></p><h3 id="4-3-3-新增窗口数据干扰"><a href="#4-3-3-新增窗口数据干扰" class="headerlink" title="4.3.3.新增窗口数据干扰"></a>4.3.3.新增窗口数据干扰</h3><p>但是，此时却产生了新问题：新增窗口竟然也有数据？</p><p>原因：</p><p>​    如果之前打开过编辑，那么在父组件中记录的oldBrand会保留。下次再打开窗口，如果是编辑窗口到没问题，但是新增的话，就会再次显示上次打开的品牌信息了。</p><p>解决：</p><p>​    新增窗口打开前，把数据置空。</p><div class="hljs"><pre><code class="hljs js">addBrand() &#123;    <span class="hljs-comment">// 控制弹窗可见：</span>    <span class="hljs-keyword">this</span>.show = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 把oldBrand变为null</span>    <span class="hljs-keyword">this</span>.oldBrand = <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="4-3-4-提交表单时判断是新增还是修改"><a href="#4-3-4-提交表单时判断是新增还是修改" class="headerlink" title="4.3.4.提交表单时判断是新增还是修改"></a>4.3.4.提交表单时判断是新增还是修改</h3><p>新增和修改是同一个页面，我们该如何判断？</p><p>父组件中点击按钮弹出新增或修改的窗口，因此父组件非常清楚接下来是新增还是修改。</p><p>因此，最简单的方案就是，在父组件中定义变量，记录新增或修改状态，当弹出页面时，把这个状态也传递给子组件。</p><p>第一步：在父组件中记录状态：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526224372366.png" srcset="/img/loading.gif" alt="1526224372366"></p><p>第二步：在新增和修改前，更改状态：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526224447288.png" srcset="/img/loading.gif" alt="1526224447288"></p><p>第三步：传递给子组件</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526224495244.png" srcset="/img/loading.gif" alt="1526224495244"></p><p>第四步，子组件接收标记：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526224563838.png" srcset="/img/loading.gif" alt="1526224563838"></p><p>标题的动态化：</p><p> <img src="/2020/09/26/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday08/1526224628514.png" srcset="/img/loading.gif" alt="1526224628514"></p><p>表单提交动态：</p><p>axios除了除了get和post外，还有一个通用的请求方式：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 将数据提交到后台</span><span class="hljs-comment">// this.$http.post('/item/brand', this.$qs.stringify(params))</span><span class="hljs-keyword">this</span>.$http(&#123;    method: <span class="hljs-keyword">this</span>.isEdit ? <span class="hljs-string">'put'</span> : <span class="hljs-string">'post'</span>, <span class="hljs-comment">// 动态判断是POST还是PUT</span>    url: <span class="hljs-string">'/item/brand'</span>,    data: <span class="hljs-keyword">this</span>.$qs.stringify(<span class="hljs-keyword">this</span>.brand)&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-comment">// 关闭窗口</span>    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">"close"</span>);    <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"保存成功！"</span>);&#125;)    .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"保存失败！"</span>);&#125;);</code></pre></div><h1 id="5-删除（作业）"><a href="#5-删除（作业）" class="headerlink" title="5.删除（作业）"></a>5.删除（作业）</h1>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day07：搭建管理系统页面</title>
    <link href="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/"/>
    <url>/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>使用资料搭建后台系统</li><li>会使用nginx进行反向代理</li><li>实现商品分类查询功能</li><li>掌握cors解决跨域</li><li>实现品牌查询功能</li></ul><h1 id="1-使用域名访问本地项目"><a href="#1-使用域名访问本地项目" class="headerlink" title="1.使用域名访问本地项目"></a>1.使用域名访问本地项目</h1><h2 id="1-1-统一环境"><a href="#1-1-统一环境" class="headerlink" title="1.1.统一环境"></a>1.1.统一环境</h2><p>我们现在访问页面使用的是：<a href="http://localhost:9001" target="_blank" rel="noopener">http://localhost:9001</a></p><p>有没有什么问题？</p><p>实际开发中，会有不同的环境：</p><ul><li>开发环境：自己的电脑</li><li>测试环境：提供给测试人员使用的环境</li><li>预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试</li><li>生产环境：项目最终发布上线的环境</li></ul><p>如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。</p><p>我们将使用以下域名：</p><ul><li>主域名是：<a href="http://www.leyou.com，" target="_blank" rel="noopener">www.leyou.com，</a></li><li>管理系统域名：manage.leyou.com</li><li>网关域名：api.leyou.com</li><li>…</li></ul><p>但是最终，我们希望这些域名指向的还是我们本机的某个端口。</p><p>那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？</p><h2 id="1-2-域名解析"><a href="#1-2-域名解析" class="headerlink" title="1.2.域名解析"></a>1.2.域名解析</h2><p>一个域名一定会被解析为一个或多个ip。这一般会包含两步：</p><ul><li><p>本地域名解析</p><p>浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。</p><ul><li>Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts</li><li>Linux下的hosts文件所在路径： /etc/hosts </li></ul><p>样式：</p><div class="hljs"><pre><code class="hljs accesslog"># My hosts<span class="hljs-number">127.0.0.1</span> localhost<span class="hljs-number">0.0.0.0</span> account.jetbrains.com<span class="hljs-number">127.0.0.1</span> www.xmind.net</code></pre></div></li><li><p>域名服务器解析</p><p>本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。</p></li></ul><h2 id="1-3-解决域名解析问题"><a href="#1-3-解决域名解析问题" class="headerlink" title="1.3.解决域名解析问题"></a>1.3.解决域名解析问题</h2><p>我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为：</p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> api.leyou.com<span class="hljs-number">127.0.0.1</span> manage.leyou.com</code></pre></div><p>这样就实现了域名的关系映射了。</p><p>每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526014883706.png" srcset="/img/loading.gif" alt="1526014883706"></p><p>效果：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526015022365.png" srcset="/img/loading.gif" alt="1526015022365"></p><p>我们添加了两个映射关系：</p><ul><li>127.0.0.1 api.leyou.com ：我们的网关Zuul</li><li>127.0.0.1 manage.leyou.com：我们的后台系统地址</li></ul><p>现在，ping一下域名试试是否畅通：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526015211298.png" srcset="/img/loading.gif" alt="1526015211298"></p><p>OK！</p><h2 id="1-4-nginx解决端口问题"><a href="#1-4-nginx解决端口问题" class="headerlink" title="1.4.nginx解决端口问题"></a>1.4.nginx解决端口问题</h2><p>虽然域名解决了，但是现在如果我们要访问，还得自己加上端口：<code>http://manage.taotao.com:9001</code>。</p><p>这就不够优雅了。我们希望的是直接域名访问：<code>http://manage.taotao.com</code>。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？</p><p>这里就要用到反向代理工具：Nginx</p><h3 id="1-4-1-什么是Nginx"><a href="#1-4-1-什么是Nginx" class="headerlink" title="1.4.1.什么是Nginx"></a>1.4.1.什么是Nginx</h3><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526187409033.png" srcset="/img/loading.gif" alt="1526187409033"></p><p>NIO：not-blocking-io 非阻塞IO</p><p>BIO：blocking-IO 阻塞IO</p><p>nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能：</p><ul><li>反向代理</li><li>负载均衡</li><li>动态路由</li><li>请求过滤</li></ul><h3 id="1-4-2-nginx作为web服务器"><a href="#1-4-2-nginx作为web服务器" class="headerlink" title="1.4.2.nginx作为web服务器"></a>1.4.2.nginx作为web服务器</h3><p>Web服务器分2类：</p><ul><li><p>web应用服务器，如：</p><ul><li>tomcat</li><li>resin</li><li>jetty</li></ul></li><li><p>web服务器，如：</p><ul><li>Apache 服务器</li><li>Nginx</li><li>IIS</li></ul></li></ul><p>区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。<br>并发：web服务器的并发能力远高于web应用服务器。</p><p>Nginx + tomcat</p><h3 id="1-4-3-nginx作为反向代理"><a href="#1-4-3-nginx作为反向代理" class="headerlink" title="1.4.3.nginx作为反向代理"></a>1.4.3.nginx作为反向代理</h3><p>什么是反向代理？</p><ul><li>代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。</li><li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li></ul><p>nginx可以当做反向代理服务器来使用：</p><ul><li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li><li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li></ul><p>利用反向代理，就可以解决我们前面所说的端口问题，如图</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526016663674.png" srcset="/img/loading.gif" alt="1526016663674"></p><h3 id="1-4-4-安装和使用"><a href="#1-4-4-安装和使用" class="headerlink" title="1.4.4.安装和使用"></a>1.4.4.安装和使用</h3><blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote><p>安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/0C36B84E.gif" srcset="/img/loading.gif" alt="img"> </p><p>我们在本地安装一台nginx：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526016829605.png" srcset="/img/loading.gif" alt="1526016829605"></p><p>目录结构：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526188477802.png" srcset="/img/loading.gif" alt="1526188477802"></p><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></blockquote><p>nginx可以通过命令行来启动，操作命令：</p><ul><li>启动：<code>start nginx.exe</code></li><li>停止：<code>nginx.exe -s stop</code></li><li>重新加载：<code>nginx.exe -s reload</code></li></ul><blockquote><h3 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h3></blockquote><p>示例：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526188831504.png" srcset="/img/loading.gif" alt="1526188831504"></p><p>nginx中的每个server就是一个反向代理配置，可以有多个server</p><p>完整配置：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       mime.types;    <span class="hljs-attribute">default_type</span>  application/octet-stream;    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;       <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;    <span class="hljs-attribute">gzip</span>  <span class="hljs-literal">on</span>;<span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  manage.leyou.com;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Server <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        <span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:9001;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;        &#125;    &#125;<span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  api.leyou.com;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Server <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        <span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:10010;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5.测试"></a>1.5.测试</h2><p>启动nginx，然后用域名访问后台管理系统：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526017010289.png" srcset="/img/loading.gif" alt="1526017010289"></p><p>现在实现了域名访问网站了，中间的流程是怎样的呢？</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526189945180.png" srcset="/img/loading.gif" alt="1526189945180"></p><ol><li><p>浏览器准备发起请求，访问<a href="http://mamage.leyou.com，但需要进行域名解析" target="_blank" rel="noopener">http://mamage.leyou.com，但需要进行域名解析</a></p></li><li><p>优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1</p></li><li><p>请求被发往解析得到的ip，并且默认使用80端口：<a href="http://127.0.0.1:80" target="_blank" rel="noopener">http://127.0.0.1:80</a></p><p>本机的nginx一直监听80端口，因此捕获这个请求</p></li><li><p>nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发</p></li><li><p>后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx</p></li><li><p>nginx将得到的结果返回到浏览器</p></li></ol><h1 id="2-实现商品分类查询"><a href="#2-实现商品分类查询" class="headerlink" title="2.实现商品分类查询"></a>2.实现商品分类查询</h1><p>商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1525999005260.png" srcset="/img/loading.gif" alt="1525999005260"></p><ul><li>一个商品分类下有很多商品</li><li>一个商品分类下有很多品牌</li><li>而一个品牌，可能属于不同的分类</li><li>一个品牌下也会有很多商品</li></ul><p>因此，我们需要依次去完成：商品分类、品牌、商品的开发。</p><h2 id="2-1-导入数据"><a href="#2-1-导入数据" class="headerlink" title="2.1.导入数据"></a>2.1.导入数据</h2><p>首先导入课前资料提供的sql：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1525999677772.png" srcset="/img/loading.gif" alt="1525999677772"></p><p>我们先看商品分类表：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1525999774439.png" srcset="/img/loading.gif" alt="1525999774439"></p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_category&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;类目id&#39;,  &#96;name&#96; varchar(20) NOT NULL COMMENT &#39;类目名称&#39;,  &#96;parent_id&#96; bigint(20) NOT NULL COMMENT &#39;父类目id,顶级类目填0&#39;,  &#96;is_parent&#96; tinyint(1) NOT NULL COMMENT &#39;是否为父节点，0为否，1为是&#39;,  &#96;sort&#96; int(4) NOT NULL COMMENT &#39;排序指数，越小越靠前&#39;,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;key_parent_id&#96; (&#96;parent_id&#96;) USING BTREE) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1424 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&#39;;</code></pre></div><p>因为商品分类会有层级关系，因此这里我们加入了<code>parent_id</code>字段，对本表中的其它分类进行自关联。</p><h2 id="2-2-页面实现"><a href="#2-2-页面实现" class="headerlink" title="2.2.页面实现"></a>2.2.页面实现</h2><h3 id="2-2-1-页面分析"><a href="#2-2-1-页面分析" class="headerlink" title="2.2.1.页面分析"></a>2.2.1.页面分析</h3><p>首先我们看下要实现的效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1525999250932.png" srcset="/img/loading.gif" alt="1525999250932"></p><p>商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。</p><p>一起来看页面，对应的是/pages/item/Category.vue：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526000313361.png" srcset="/img/loading.gif" alt="1526000313361"></p><p>页面模板：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">xs12</span> <span class="hljs-attr">sm10</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-tree</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/item/category/list"</span></span><span class="hljs-tag">                <span class="hljs-attr">:treeData</span>=<span class="hljs-string">"treeData"</span></span><span class="hljs-tag">                <span class="hljs-attr">:isEdit</span>=<span class="hljs-string">"isEdit"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleAdd</span>=<span class="hljs-string">"handleAdd"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleEdit</span>=<span class="hljs-string">"handleEdit"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleDelete</span>=<span class="hljs-string">"handleDelete"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleClick</span>=<span class="hljs-string">"handleClick"</span></span><span class="hljs-tag">                /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span></code></pre></div><ul><li><p><code>v-card</code>：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526000692741.png" srcset="/img/loading.gif" alt="1526000692741"></p></li><li><p><code>v-flex</code>：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526001573140.png" srcset="/img/loading.gif" alt="1526001573140"></p><p>本例中，我们用<code>sm10</code>控制在小屏幕及以上时，显示宽度为10格</p></li><li><p><code>v-tree</code>：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526001762446.png" srcset="/img/loading.gif" alt="1526001762446"></p><p>里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。</p></li></ul><h3 id="2-2-2-树组件的用法"><a href="#2-2-2-树组件的用法" class="headerlink" title="2.2.2.树组件的用法"></a>2.2.2.树组件的用法</h3><p>也可参考课前资料中的：《自定义Vue组件的用法.md》</p><p>这里我贴出树组件的用法指南。</p><blockquote><p>属性列表：</p></blockquote><table><thead><tr><th align="left">属性名称</th><th align="left">说明</th><th align="left">数据类型</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">用来加载数据的地址，即延迟加载</td><td align="left">String</td><td align="left">-</td></tr><tr><td align="left">isEdit</td><td align="left">是否开启树的编辑功能</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">treeData</td><td align="left">整颗树数据，这样就不用远程加载了</td><td align="left">Array</td><td align="left">-</td></tr></tbody></table><p>这里推荐使用url进行延迟加载，<strong>每当点击父节点时，就会发起请求，根据父节点id查询子节点信息</strong>。</p><p>当有treeData属性时，就不会触发url加载</p><p>远程请求返回的结果格式：</p><div class="hljs"><pre><code class="hljs json">[    &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">74</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"手机"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">2</span>&#125;,     &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">75</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"家用电器"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">3</span>&#125;]</code></pre></div><blockquote><p>事件：</p></blockquote><table><thead><tr><th align="left">事件名称</th><th align="left">说明</th><th align="left">回调参数</th></tr></thead><tbody><tr><td align="left">handleAdd</td><td align="left">新增节点时触发，isEdit为true时有效</td><td align="left">新增节点node对象，包含属性：name、parentId和sort</td></tr><tr><td align="left">handleEdit</td><td align="left">当某个节点被编辑后触发，isEdit为true时有效</td><td align="left">被编辑节点的id和name</td></tr><tr><td align="left">handleDelete</td><td align="left">当删除节点时触发，isEdit为true时有效</td><td align="left">被删除节点的id</td></tr><tr><td align="left">handleClick</td><td align="left">点击某节点时触发</td><td align="left">被点击节点的node对象,包含全部信息</td></tr></tbody></table><blockquote><p>完整node的信息</p></blockquote><p>回调函数中返回完整的node节点会包含以下数据：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">76</span>, <span class="hljs-comment">// 节点id</span>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"手机"</span>, <span class="hljs-comment">// 节点名称</span>    <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">75</span>, <span class="hljs-comment">// 父节点id</span>    <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否是父节点</span>    <span class="hljs-attr">"sort"</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 顺序</span>    <span class="hljs-attr">"path"</span>: [<span class="hljs-string">"手机"</span>, <span class="hljs-string">"手机通讯"</span>, <span class="hljs-string">"手机"</span>] <span class="hljs-comment">// 所有父节点的名称数组</span>&#125;</code></pre></div><h2 id="2-3-实现功能"><a href="#2-3-实现功能" class="headerlink" title="2.3.实现功能"></a>2.3.实现功能</h2><h3 id="2-3-1-url异步请求"><a href="#2-3-1-url异步请求" class="headerlink" title="2.3.1.url异步请求"></a>2.3.1.url异步请求</h3><p>给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-tree</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/item/category/list"</span></span><span class="hljs-tag">        <span class="hljs-attr">:isEdit</span>=<span class="hljs-string">"isEdit"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleAdd</span>=<span class="hljs-string">"handleAdd"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleEdit</span>=<span class="hljs-string">"handleEdit"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleDelete</span>=<span class="hljs-string">"handleDelete"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleClick</span>=<span class="hljs-string">"handleClick"</span></span><span class="hljs-tag">        /&gt;</span></code></pre></div><p>刷新页面，可以看到：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526004282868.png" srcset="/img/loading.gif" alt="1526004282868"></p><p>页面中的树没有了，并且发起了一条请求：<a href="http://localhost/api/item/category/list?pid=0" target="_blank" rel="noopener">http://localhost/api/item/category/list?pid=0</a> </p><p>大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是：</p><p><a href="http://manage.leyou.com/item/category/list" target="_blank" rel="noopener">http://manage.leyou.com/item/category/list</a></p><p>但实际却是：</p><p><a href="http://localhost/api/item/category/list?pid=0" target="_blank" rel="noopener">http://localhost/api/item/category/list?pid=0</a> </p><p>这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526005059829.png" srcset="/img/loading.gif" alt="1526005059829"></p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526005071153.png" srcset="/img/loading.gif" alt="1526005071153"></p><p>路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526017217473.png" srcset="/img/loading.gif" alt="1526017217473"></p><p>再次查看页面，发现地址已经变成了正确的地址了：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526017265625.png" srcset="/img/loading.gif" alt="1526017265625"></p><p>接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。</p><h3 id="2-3-2-实体类"><a href="#2-3-2-实体类" class="headerlink" title="2.3.2.实体类"></a>2.3.2.实体类</h3><p>在<code>ly-item-interface</code>中添加category实体类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_category"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Category</span> </span>&#123;<span class="hljs-meta">@Id</span><span class="hljs-meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)<span class="hljs-keyword">private</span> Long id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> Long parentId;<span class="hljs-keyword">private</span> Boolean isParent;<span class="hljs-keyword">private</span> Integer sort;<span class="hljs-comment">// getter和setter略</span>    <span class="hljs-comment">// 注意isParent的get和set方法</span>&#125;</code></pre></div><p>需要注意的是，这里要用到jpa的注解，因此我们在<code>ly-item-iterface</code>中添加jpa依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.persistence<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>persistence-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>结构：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526006869782.png" srcset="/img/loading.gif" alt="1526006869782"></p><h3 id="2-3-3-controller"><a href="#2-3-3-controller" class="headerlink" title="2.3.3.controller"></a>2.3.3.controller</h3><p>编写一个controller一般需要知道四个内容：</p><ul><li>请求方式：决定我们用GetMapping还是PostMapping</li><li>请求路径：决定映射路径</li><li>请求参数：决定方法的参数</li><li>返回值结果：决定方法的返回值</li></ul><p>在刚才页面发起的请求中，我们就能得到绝大多数信息：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1527473096007.png" srcset="/img/loading.gif" alt="1527473096007"></p><ul><li><p>请求方式：Get</p></li><li><p>请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list</p></li><li><p>请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目</p></li><li><p>返回结果：？？</p><p>根据前面tree组件的用法我们知道，返回的应该是json数组：</p><div class="hljs"><pre><code class="hljs json">[    &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">74</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"手机"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">2</span>&#125;,     &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">75</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"家用电器"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">3</span>&#125;]</code></pre></div><p>对应的java类型可以是List集合，里面的元素就是类目对象了。</p></li></ul><p>controller代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"category"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CategoryService categoryService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据父节点查询商品类目</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pid</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"list"</span>)    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Category&gt;&gt; queryByParentId(            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"pid"</span>, defaultValue = <span class="hljs-string">"0"</span>) Long pid) &#123;        List&lt;Category&gt; list = <span class="hljs-keyword">this</span>.categoryService.queryListByParent(pid);        <span class="hljs-keyword">if</span> (list == <span class="hljs-keyword">null</span> || list.size() &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-keyword">return</span> ResponseEntity.ok(list);    &#125;&#125;</code></pre></div><h3 id="2-3-4-service"><a href="#2-3-4-service" class="headerlink" title="2.3.4.service"></a>2.3.4.service</h3><p>一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CategoryMapper categoryMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Category&gt; <span class="hljs-title">queryListByParent</span><span class="hljs-params">(Long pid)</span> </span>&#123;        Category category = <span class="hljs-keyword">new</span> Category();        category.setParentId(pid);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.categoryMapper.select(category);    &#125;&#125;</code></pre></div><h3 id="2-3-5-mapper"><a href="#2-3-5-mapper" class="headerlink" title="2.3.5.mapper"></a>2.3.5.mapper</h3><p>我们使用通用mapper来简化开发：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Category</span>&gt; </span>&#123;&#125;</code></pre></div><p>要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？</p><p>我们在启动类上添加一个扫描包功能：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"com.leyou.item.mapper"</span>) <span class="hljs-comment">// 扫描mapper包</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LyItemService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(LyItemService<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="2-3-6-启动并测试"><a href="#2-3-6-启动并测试" class="headerlink" title="2.3.6.启动并测试"></a>2.3.6.启动并测试</h3><p>我们不经过网关，直接访问：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526009785484.png" srcset="/img/loading.gif" alt="1526009785484"></p><p>然后试试网关是否畅通：</p><p>  <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526017422684.png" srcset="/img/loading.gif" alt="1526017422684"></p><p>一切OK！</p><p>然后刷新页面查看：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526017362418.png" srcset="/img/loading.gif" alt="1526017362418"></p><p>发现报错了！</p><p>浏览器直接访问没事，但是这里却报错，什么原因？</p><h2 id="2-4-跨域问题"><a href="#2-4-跨域问题" class="headerlink" title="2.4.跨域问题"></a>2.4.跨域问题</h2><h3 id="2-4-1-什么是跨域"><a href="#2-4-1-什么是跨域" class="headerlink" title="2.4.1.什么是跨域"></a>2.4.1.什么是跨域</h3><p>跨域是指跨域名的访问，以下情况都属于跨域：</p><table><thead><tr><th>跨域原因说明</th><th>示例</th></tr></thead><tbody><tr><td>域名不同</td><td><code>www.jd.com</code> 与 <code>www.taobao.com</code></td></tr><tr><td>域名相同，端口不同</td><td><code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code></td></tr><tr><td>二级域名不同</td><td><code>item.jd.com</code> 与 <code>miaosha.jd.com</code></td></tr></tbody></table><p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p><p><code>www.jd.com/item</code> </p><p><code>www.jd.com/goods</code></p><p>而我们刚才是从<code>manage.leyou.com</code>去访问<code>api.leyou.com</code>，这属于二级域名不同，跨域了。</p><h3 id="2-4-2-为什么有跨域问题？"><a href="#2-4-2-为什么有跨域问题？" class="headerlink" title="2.4.2.为什么有跨域问题？"></a>2.4.2.为什么有跨域问题？</h3><p>跨域不一定会有跨域问题。</p><p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是于当前页同域名的路径</strong>，这能有效的阻止跨站攻击。</p><p>因此：<strong>跨域问题 是针对ajax的一种限制</strong>。</p><p>但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p><h3 id="2-4-3-解决跨域问题的方案"><a href="#2-4-3-解决跨域问题的方案" class="headerlink" title="2.4.3.解决跨域问题的方案"></a>2.4.3.解决跨域问题的方案</h3><p>目前比较常用的跨域解决方案有3种：</p><ul><li><p>Jsonp</p><p>最早的解决方案，利用script标签可以跨域的原理实现。</p><p>限制：</p><ul><li>需要服务的支持</li><li>只能发起GET请求</li></ul></li><li><p>nginx反向代理</p><p>思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式</p><p>缺点：需要在nginx进行额外配置，语义不清晰</p></li><li><p>CORS</p><p>规范化的跨域请求解决方案，安全可靠。</p><p>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul></li></ul><p>我们这里会采用cors的跨域方案。</p><h2 id="2-5-cors解决跨域"><a href="#2-5-cors解决跨域" class="headerlink" title="2.5.cors解决跨域"></a>2.5.cors解决跨域</h2><h3 id="2-5-1-什么是cors"><a href="#2-5-1-什么是cors" class="headerlink" title="2.5.1.什么是cors"></a>2.5.1.什么是cors</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><ul><li><p>浏览器端：</p><p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p></li><li><p>服务端：</p><p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p></li></ul><h3 id="2-5-2-原理有点复杂"><a href="#2-5-2-原理有点复杂" class="headerlink" title="2.5.2.原理有点复杂"></a>2.5.2.原理有点复杂</h3><p>浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。：</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><p>当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：<code>Origin</code>.</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526019242125.png" srcset="/img/loading.gif" alt="1526019242125"></p><p>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p><p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com<span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true<span class="hljs-attribute">Content-Type</span>: text/html; charset=utf-8</code></pre></div><ul><li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意</li><li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li></ul><p>注意：</p><p>如果跨域请求要想操作cookie，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax需要指定withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><h4 id="特殊请求"><a href="#特殊请求" class="headerlink" title="特殊请求"></a>特殊请求</h4><p>不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。</p><blockquote><p>预检请求</p></blockquote><p>特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>一个“预检”请求的样板：</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/cors</span> HTTP/1.1<span class="hljs-attribute">Origin</span>: http://manage.leyou.com<span class="hljs-attribute">Access-Control-Request-Method</span>: PUT<span class="hljs-attribute">Access-Control-Request-Headers</span>: X-Custom-Header<span class="hljs-attribute">Host</span>: api.leyou.com<span class="hljs-attribute">Accept-Language</span>: en-US<span class="hljs-attribute">Connection</span>: keep-alive<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0...</code></pre></div><p>与简单请求相比，除了Origin以外，多了两个头：</p><ul><li>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</li><li>Access-Control-Request-Headers：会额外用到的头信息</li></ul><blockquote><p>预检请求的响应</p></blockquote><p>服务的收到预检请求，如果许可跨域，会发出响应：</p><div class="hljs"><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">200</span> OK<span class="hljs-attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT<span class="hljs-attribute">Server</span>: Apache/2.0.61 (Unix)<span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com<span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true<span class="hljs-attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT<span class="hljs-attribute">Access-Control-Allow-Headers</span>: X-Custom-Header<span class="hljs-attribute">Access-Control-Max-Age</span>: 1728000<span class="hljs-attribute">Content-Type</span>: text/html; charset=utf-8<span class="hljs-attribute">Content-Encoding</span>: gzip<span class="hljs-attribute">Content-Length</span>: 0<span class="hljs-attribute">Keep-Alive</span>: timeout=2, max=100<span class="hljs-attribute">Connection</span>: Keep-Alive<span class="hljs-attribute">Content-Type</span>: text/plain</code></pre></div><p>除了<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li></ul><p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p><h3 id="2-5-3-实现非常简单"><a href="#2-5-3-实现非常简单" class="headerlink" title="2.5.3.实现非常简单"></a>2.5.3.实现非常简单</h3><p>虽然原理比较复杂，但是前面说过：</p><ul><li>浏览器端都有浏览器自动完成，我们无需操心</li><li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li></ul><p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p><p>在<code>ly-api-gateway</code>中编写一个配置类，并且注册CorsFilter：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;<span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;<span class="hljs-keyword">import</span> org.springframework.web.filter.CorsFilter;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1.添加CORS配置信息</span>        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();        <span class="hljs-comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span>        config.addAllowedOrigin(<span class="hljs-string">"http://manage.leyou.com"</span>);        <span class="hljs-comment">//2) 是否发送Cookie信息</span>        config.setAllowCredentials(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//3) 允许的请求方式</span>        config.addAllowedMethod(<span class="hljs-string">"OPTIONS"</span>);        config.addAllowedMethod(<span class="hljs-string">"HEAD"</span>);        config.addAllowedMethod(<span class="hljs-string">"GET"</span>);        config.addAllowedMethod(<span class="hljs-string">"PUT"</span>);        config.addAllowedMethod(<span class="hljs-string">"POST"</span>);        config.addAllowedMethod(<span class="hljs-string">"DELETE"</span>);        config.addAllowedMethod(<span class="hljs-string">"PATCH"</span>);        <span class="hljs-comment">// 4）允许的头信息</span>        config.addAllowedHeader(<span class="hljs-string">"*"</span>);        <span class="hljs-comment">//2.添加映射路径，我们拦截一切请求</span>        UrlBasedCorsConfigurationSource configSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();        configSource.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);        <span class="hljs-comment">//3.返回新的CorsFilter.</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(configSource);    &#125;&#125;</code></pre></div><p>结构：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526021505774.png" srcset="/img/loading.gif" alt="1526021505774"></p><p>4.5.4.重启测试：</p><p>访问正常：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526021419016.png" srcset="/img/loading.gif" alt="1526021419016"></p><p>页面也OK了：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526021447335.png" srcset="/img/loading.gif" alt="1526021447335"></p><p>分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。</p><h1 id="3-品牌的查询"><a href="#3-品牌的查询" class="headerlink" title="3.品牌的查询"></a>3.品牌的查询</h1><p>商品分类完成以后，自然轮到了品牌功能了。</p><p>先看看我们要实现的效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526021968036.png" srcset="/img/loading.gif" alt="1526021968036"></p><p>接下来，我们从0开始，实现下从前端到后端的完整开发。</p><h2 id="3-1-从0开始"><a href="#3-1-从0开始" class="headerlink" title="3.1.从0开始"></a>3.1.从0开始</h2><p>为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526023142926.png" srcset="/img/loading.gif" alt="1526023142926"></p><p>内容初始化一下：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;span&gt;    hello  &lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;my-brand&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>改变router新的index.js，将路由地址指向MyBrand.vue</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526023276997.png" srcset="/img/loading.gif" alt="1526023276997"></p><p>打开服务器，再次查看页面：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526023471428.png" srcset="/img/loading.gif" alt="1526023471428"></p><p>干干净净了。</p><h2 id="3-2-品牌查询页面"><a href="#3-2-品牌查询页面" class="headerlink" title="3.2.品牌查询页面"></a>3.2.品牌查询页面</h2><h3 id="3-2-1-data-tables组件"><a href="#3-2-1-data-tables组件" class="headerlink" title="3.2.1.data-tables组件"></a>3.2.1.data-tables组件</h3><p>大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526023540226.png" srcset="/img/loading.gif" alt="1526023540226"></p><p>仔细阅读，发现<code>v-data-table</code>中有以下核心属性：</p><ul><li><p>dark：是否使用黑暗色彩主题，默认是false</p></li><li><p>expand：表格的行是否可以展开，默认是false</p></li><li><p>headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构：</p><div class="hljs"><pre><code class="hljs js">&#123;  text: string, <span class="hljs-comment">// 表头的显示文本</span>  value: string, <span class="hljs-comment">// 表头对应的每行数据的key</span>  align: <span class="hljs-string">'left'</span> | <span class="hljs-string">'center'</span> | <span class="hljs-string">'right'</span>, <span class="hljs-comment">// 位置</span>  sortable: boolean, <span class="hljs-comment">// 是否可排序</span>  class: string[] | string,// 样式  width: string,<span class="hljs-comment">// 宽度</span>&#125;</code></pre></div></li><li><p>items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致</p></li><li><p>loading：是否显示加载数据的进度条，默认是false</p></li><li><p>no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值</p></li><li><p>pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构：</p><div class="hljs"><pre><code class="hljs js">&#123;    page: <span class="hljs-number">1</span>, <span class="hljs-comment">// 当前页</span>    rowsPerPage: <span class="hljs-number">5</span>, <span class="hljs-comment">// 每页大小</span>    sortBy: <span class="hljs-string">''</span>, <span class="hljs-comment">// 排序字段</span>    descending:<span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否降序</span>&#125;</code></pre></div></li><li><p>total-items：分页的总条数信息，number类型，无默认值</p></li><li><p>select-all ：是否显示每一行的复选框，Boolean类型，无默认值</p></li><li><p>value：当表格可选的时候，返回选中的行</p></li></ul><p>我们向下翻，找找有没有看起来牛逼的案例。</p><p>找到这样一条：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526023837773.png" srcset="/img/loading.gif" alt="1526023837773"></p><p>其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。</p><p>点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中</p><p>模板：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;desserts&quot;      :search&#x3D;&quot;search&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalDesserts&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><h3 id="3-2-2-分析"><a href="#3-2-2-分析" class="headerlink" title="3.2.2.分析"></a>3.2.2.分析</h3><p>接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。</p><p>先看模板中table上的一些属性：</p><div class="hljs"><pre><code class="hljs vue">&lt;v-data-table              :headers&#x3D;&quot;headers&quot;              :items&#x3D;&quot;desserts&quot;              :search&#x3D;&quot;search&quot;              :pagination.sync&#x3D;&quot;pagination&quot;              :total-items&#x3D;&quot;totalDesserts&quot;              :loading&#x3D;&quot;loading&quot;              class&#x3D;&quot;elevation-1&quot;              &gt;&lt;&#x2F;v-data-table&gt;</code></pre></div><ul><li><p>headers：表头信息，是一个数组</p></li><li><p>items：要在表格中展示的数据，数组结构，每一个元素是一行</p></li><li><p>search：搜索过滤字段，用不到，暂时不管</p></li><li><p>pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。</p></li><li><p>total-items：总条数</p></li><li><p>loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526029254159.png" srcset="/img/loading.gif" alt="1526029254159"></p></li></ul><p>另外，在<code>v-data-tables</code>中，我们还看到另一段代码：</p><div class="hljs"><pre><code class="hljs vue">&lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;&#x2F;td&gt;&lt;&#x2F;template&gt;</code></pre></div><p>这段就是在渲染每一行的数据。Vue会自动遍历上面传递的<code>items</code>属性，并把得到的对象传递给这段<code>template</code>中的<code>props.item</code>属性。我们从中得到数据，渲染在页面即可。</p><p>我们需要做的事情，主要有两件：</p><ul><li>给items和totalItems赋值</li><li>当pagination变化时，重新获取数据，再次给items和totalItems赋值</li></ul><h3 id="3-2-3-初步实现"><a href="#3-2-3-初步实现" class="headerlink" title="3.2.3.初步实现"></a>3.2.3.初步实现</h3><p>我们先弄点假品牌数据：</p><div class="hljs"><pre><code class="hljs json">[  &#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">2032</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"OPPO"</span>,    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg"</span>,    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"O"</span>  &#125;,  &#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">2033</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"飞利浦（PHILIPS）"</span>,    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg"</span>,    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"F"</span>  &#125;,  &#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">2034</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"华为（HUAWEI）"</span>,    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg"</span>,    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"H"</span>  &#125;,  &#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">2036</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"酷派（Coolpad）"</span>,    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg"</span>,    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"K"</span>  &#125;,  &#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">2037</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"魅族（MEIZU）"</span>,    <span class="hljs-attr">"image"</span>: <span class="hljs-string">"http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg"</span>,    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"M"</span>  &#125;]</code></pre></div><p>品牌中有id,name,image,letter字段。</p><h4 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h4><div class="hljs"><pre><code class="hljs vue">&lt;div&gt;  &lt;v-data-table    :headers&#x3D;&quot;headers&quot;    :items&#x3D;&quot;brands&quot;    :search&#x3D;&quot;search&quot;    :pagination.sync&#x3D;&quot;pagination&quot;    :total-items&#x3D;&quot;totalBrands&quot;    :loading&#x3D;&quot;loading&quot;    class&#x3D;&quot;elevation-1&quot;  &gt;    &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;      &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;        &lt;img v-if&#x3D;&quot;props.item.image&quot; :src&#x3D;&quot;props.item.image&quot; width&#x3D;&quot;130&quot; height&#x3D;&quot;40&quot;&gt;        &lt;span v-else&gt;无&lt;&#x2F;span&gt;      &lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;    &lt;&#x2F;template&gt;  &lt;&#x2F;v-data-table&gt;&lt;&#x2F;div&gt;</code></pre></div><p>我们修改了以下部分：</p><ul><li>items：指向一个brands变量，等下在js代码中定义</li><li>total-items：指向了totalBrands变量，等下在js代码中定义</li><li>template模板中，渲染了四个字段：<ul><li>id：</li><li>name</li><li>image，注意，我们不是以文本渲染，而是赋值到一个<code>img</code>标签的src属性中，并且做了非空判断</li><li>letter</li></ul></li></ul><h4 id="编写数据"><a href="#编写数据" class="headerlink" title="编写数据"></a>编写数据</h4><p>接下来编写要用到的数据：</p><div class="hljs"><pre><code class="hljs js">&#123;data() &#123;      <span class="hljs-keyword">return</span> &#123;        search: <span class="hljs-string">''</span>, <span class="hljs-comment">// 搜索过滤字段</span>        totalBrands: <span class="hljs-number">0</span>, <span class="hljs-comment">// 总条数</span>        brands: [], <span class="hljs-comment">// 当前页品牌数据</span>        loading: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在加载中</span>        pagination: &#123;&#125;, <span class="hljs-comment">// 分页信息</span>        headers: [ <span class="hljs-comment">// 头信息</span>          &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>&#125;,          &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'名称'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'name'</span>&#125;,          &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'LOGO'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'image'</span>&#125;,          &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首字母'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'letter'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">true</span>,&#125;        ]      &#125;  &#125;&#125;</code></pre></div><h4 id="编写函数，初始化数据"><a href="#编写函数，初始化数据" class="headerlink" title="编写函数，初始化数据"></a>编写函数，初始化数据</h4><p>接下来就是对brands和totalBrands完成赋值动作了。</p><p>我们编写一个函数来完成赋值，提高复用性：</p><div class="hljs"><pre><code class="hljs js">methods:&#123;      getDataFromServer()&#123; <span class="hljs-comment">// 从服务的加载数据的方法。</span>        <span class="hljs-comment">// 伪造假数据</span>        <span class="hljs-keyword">const</span> brands = [          &#123;            <span class="hljs-string">"id"</span>: <span class="hljs-number">2032</span>,            <span class="hljs-string">"name"</span>: <span class="hljs-string">"OPPO"</span>,            <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg"</span>,            <span class="hljs-string">"letter"</span>: <span class="hljs-string">"O"</span>,            <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>          &#125;,          &#123;            <span class="hljs-string">"id"</span>: <span class="hljs-number">2033</span>,            <span class="hljs-string">"name"</span>: <span class="hljs-string">"飞利浦（PHILIPS）"</span>,            <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg"</span>,            <span class="hljs-string">"letter"</span>: <span class="hljs-string">"F"</span>,            <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>          &#125;,          &#123;            <span class="hljs-string">"id"</span>: <span class="hljs-number">2034</span>,            <span class="hljs-string">"name"</span>: <span class="hljs-string">"华为（HUAWEI）"</span>,            <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg"</span>,            <span class="hljs-string">"letter"</span>: <span class="hljs-string">"H"</span>,            <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>          &#125;,          &#123;            <span class="hljs-string">"id"</span>: <span class="hljs-number">2036</span>,            <span class="hljs-string">"name"</span>: <span class="hljs-string">"酷派（Coolpad）"</span>,            <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg"</span>,            <span class="hljs-string">"letter"</span>: <span class="hljs-string">"K"</span>,            <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>          &#125;,          &#123;            <span class="hljs-string">"id"</span>: <span class="hljs-number">2037</span>,            <span class="hljs-string">"name"</span>: <span class="hljs-string">"魅族（MEIZU）"</span>,            <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg"</span>,            <span class="hljs-string">"letter"</span>: <span class="hljs-string">"M"</span>,            <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>          &#125;        ];        <span class="hljs-comment">// 模拟延迟一段时间，随后进行赋值</span>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-comment">// 然后赋值给brands</span>          <span class="hljs-keyword">this</span>.brands = brands;          <span class="hljs-keyword">this</span>.totalBrands = brands.length;          <span class="hljs-comment">// 完成赋值后，把加载状态赋值为false</span>          <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>;        &#125;,<span class="hljs-number">400</span>)      &#125;&#125;</code></pre></div><p>然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数：</p><div class="hljs"><pre><code class="hljs js">mounted()&#123; <span class="hljs-comment">// 渲染后执行</span>    <span class="hljs-comment">// 查询数据</span>    <span class="hljs-keyword">this</span>.getDataFromServer();&#125;</code></pre></div><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;brands&quot;      :search&#x3D;&quot;search&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalBrands&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img :src&#x3D;&quot;props.item.image&quot;&gt;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    name: &quot;my-brand&quot;,    data() &#123;      return &#123;        search: &#39;&#39;, &#x2F;&#x2F; 搜索过滤字段        totalBrands: 0, &#x2F;&#x2F; 总条数        brands: [], &#x2F;&#x2F; 当前页品牌数据        loading: true, &#x2F;&#x2F; 是否在加载中        pagination: &#123;&#125;, &#x2F;&#x2F; 分页信息        headers: [          &#123;text: &#39;id&#39;, align: &#39;center&#39;, value: &#39;id&#39;&#125;,          &#123;text: &#39;名称&#39;, align: &#39;center&#39;, sortable: false, value: &#39;name&#39;&#125;,          &#123;text: &#39;LOGO&#39;, align: &#39;center&#39;, sortable: false, value: &#39;image&#39;&#125;,          &#123;text: &#39;首字母&#39;, align: &#39;center&#39;, value: &#39;letter&#39;, sortable: true,&#125;        ]      &#125;    &#125;,    mounted()&#123; &#x2F;&#x2F; 渲染后执行      &#x2F;&#x2F; 查询数据      this.getDataFromServer();    &#125;,    methods:&#123;      getDataFromServer()&#123; &#x2F;&#x2F; 从服务的加载数的方法。        &#x2F;&#x2F; 伪造假数据        const brands &#x3D; [          &#123;            &quot;id&quot;: 2032,            &quot;name&quot;: &quot;OPPO&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img10.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t2119&#x2F;133&#x2F;2264148064&#x2F;4303&#x2F;b8ab3755&#x2F;56b2f385N8e4eb051.jpg&quot;,            &quot;letter&quot;: &quot;O&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2033,            &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img12.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t18361&#x2F;122&#x2F;1318410299&#x2F;1870&#x2F;36fe70c9&#x2F;5ac43a4dNa44a0ce0.jpg&quot;,            &quot;letter&quot;: &quot;F&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2034,            &quot;name&quot;: &quot;华为（HUAWEI）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img10.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t5662&#x2F;36&#x2F;8888655583&#x2F;7806&#x2F;1c629c01&#x2F;598033b4Nd6055897.jpg&quot;,            &quot;letter&quot;: &quot;H&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2036,            &quot;name&quot;: &quot;酷派（Coolpad）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img10.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t2521&#x2F;347&#x2F;883897149&#x2F;3732&#x2F;91c917ec&#x2F;5670cf96Ncffa2ae6.jpg&quot;,            &quot;letter&quot;: &quot;K&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2037,            &quot;name&quot;: &quot;魅族（MEIZU）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img13.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t3511&#x2F;131&#x2F;31887105&#x2F;4943&#x2F;48f83fa9&#x2F;57fdf4b8N6e95624d.jpg&quot;,            &quot;letter&quot;: &quot;M&quot;,            &quot;categories&quot;: null          &#125;        ];        &#x2F;&#x2F; 模拟延迟一段时间，随后进行赋值        setTimeout(() &#x3D;&gt; &#123;          &#x2F;&#x2F; 然后赋值给brands          this.brands &#x3D; brands;          this.totalBrands &#x3D; brands.length;          &#x2F;&#x2F; 完成赋值后，把加载状态赋值为false          this.loading &#x3D; false;        &#125;,400)      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>刷新页面查看：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526029445561.png" srcset="/img/loading.gif" alt="1526029445561"></p><h3 id="3-2-4-优化页面"><a href="#3-2-4-优化页面" class="headerlink" title="3.2.4.优化页面"></a>3.2.4.优化页面</h3><h4 id="编辑和删除按钮"><a href="#编辑和删除按钮" class="headerlink" title="编辑和删除按钮"></a>编辑和删除按钮</h4><p>我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526029907794.png" srcset="/img/loading.gif" alt="1526029907794"></p><p>其实就是多了一列，只是这一列没有数据，而是两个按钮而已。</p><p>我们先在头（headers）中添加一列：</p><div class="hljs"><pre><code class="hljs js">headers: [    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'名称'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'name'</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'LOGO'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'image'</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首字母'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'letter'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">true</span>,&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'操作'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;]</code></pre></div><p>然后在模板中添加按钮：</p><div class="hljs"><pre><code class="hljs vue">&lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;  &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;  &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;  &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img :src&#x3D;&quot;props.item.image&quot;&gt;&lt;&#x2F;td&gt;  &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;  &lt;td class&#x3D;&quot;justify-center&quot;&gt;    编辑&#x2F;删除  &lt;&#x2F;td&gt;&lt;&#x2F;template&gt;</code></pre></div><p>因为不知道按钮怎么写，先放个普通文本看看：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526030236992.png" srcset="/img/loading.gif" alt="1526030236992"></p><p>然后在官方文档中找到按钮的用法：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526030329303.png" srcset="/img/loading.gif" alt="1526030329303"></p><p>修改我们的模板：</p><div class="hljs"><pre><code class="hljs vue">&lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;    &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;    &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;    &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img :src&#x3D;&quot;props.item.image&quot;&gt;&lt;&#x2F;td&gt;    &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;    &lt;td class&#x3D;&quot;justify-center layout&quot;&gt;        &lt;v-btn color&#x3D;&quot;info&quot;&gt;编辑&lt;&#x2F;v-btn&gt;        &lt;v-btn color&#x3D;&quot;warning&quot;&gt;删除&lt;&#x2F;v-btn&gt;    &lt;&#x2F;td&gt;&lt;&#x2F;template&gt;</code></pre></div><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526030431704.png" srcset="/img/loading.gif" alt="1526030431704"></p><h4 id="新增按钮"><a href="#新增按钮" class="headerlink" title="新增按钮"></a>新增按钮</h4><p>因为新增根某个品牌无关，是独立的，因此我们可以放到表格的外面：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526030663178.png" srcset="/img/loading.gif" alt="1526030663178"></p><p>效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526030540341.png" srcset="/img/loading.gif" alt="1526030540341"></p><h4 id="卡片（card）"><a href="#卡片（card）" class="headerlink" title="卡片（card）"></a>卡片（card）</h4><p>为了不让按钮显得过于孤立，我们可以将按<code>新增按钮</code>和<code>表格</code>放到一张卡片（card）中。</p><p>我们去官网查看卡片的用法：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526031159242.png" srcset="/img/loading.gif" alt="1526031159242"></p><p>卡片<code>v-card</code>包含四个基本组件：</p><ul><li>v-card-media：一般放图片或视频</li><li>v-card-title：卡片的标题，一般位于卡片顶部</li><li>v-card-text：卡片的文本（主体内容），一般位于卡片正中</li><li>v-card-action：卡片的按钮，一般位于卡片底部</li></ul><p>我们可以把<code>新增的按钮</code>放到<code>v-card-title</code>位置，把<code>table</code>放到下面，这样就成一个上下关系。</p><div class="hljs"><pre><code class="hljs vue">&lt;v-card&gt;  &lt;!-- 卡片的头部 --&gt;  &lt;v-card-title&gt;    &lt;v-btn color&#x3D;&quot;primary&quot;&gt;新增&lt;&#x2F;v-btn&gt;  &lt;&#x2F;v-card-title&gt;  &lt;!-- 分割线 --&gt;  &lt;v-divider&#x2F;&gt;  &lt;!--卡片的中部--&gt;  &lt;v-data-table    :headers&#x3D;&quot;headers&quot;    :items&#x3D;&quot;brands&quot;    :search&#x3D;&quot;search&quot;    :pagination.sync&#x3D;&quot;pagination&quot;    :total-items&#x3D;&quot;totalBrands&quot;    :loading&#x3D;&quot;loading&quot;    class&#x3D;&quot;elevation-1&quot;  &gt;    &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;      &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img :src&#x3D;&quot;props.item.image&quot;&gt;&lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;      &lt;td class&#x3D;&quot;justify-center layout&quot;&gt;        &lt;v-btn color&#x3D;&quot;info&quot;&gt;编辑&lt;&#x2F;v-btn&gt;        &lt;v-btn color&#x3D;&quot;warning&quot;&gt;删除&lt;&#x2F;v-btn&gt;      &lt;&#x2F;td&gt;    &lt;&#x2F;template&gt;  &lt;&#x2F;v-data-table&gt;&lt;&#x2F;v-card&gt;</code></pre></div><p>效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526031720583.png" srcset="/img/loading.gif" alt="1526031720583"></p><h4 id="添加搜索框"><a href="#添加搜索框" class="headerlink" title="添加搜索框"></a>添加搜索框</h4><p>我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。</p><p>查看官网中，文本框的用法：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526031897445.png" srcset="/img/loading.gif" alt="1526031897445"></p><ul><li>name：字段名，表单中会用到</li><li>label：提示文字</li><li>value：值。可以用v-model代替，实现双向绑定</li></ul><p>修改模板，添加输入框：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>新增品牌<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>    <span class="hljs-comment">&lt;!--搜索框，与search属性关联--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526032177687.png" srcset="/img/loading.gif" alt="1526032177687"></p><p>发现输入框变的超级长！！！</p><p>这个时候，我们可以使用Vuetify提供的一个空间隔离工具：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526032321057.png" srcset="/img/loading.gif" alt="1526032321057"></p><p>修改代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>新增品牌<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>  <span class="hljs-comment">&lt;!--空间隔离组件--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span> /&gt;</span>  <span class="hljs-comment">&lt;!--搜索框，与search属性关联--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span></code></pre></div><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526032398630.png" srcset="/img/loading.gif" alt="1526032398630"></p><h4 id="给搜索框添加搜索图标"><a href="#给搜索框添加搜索图标" class="headerlink" title="给搜索框添加搜索图标"></a>给搜索框添加搜索图标</h4><p>查看textfiled的文档，发现：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526033007616.png" srcset="/img/loading.gif" alt="1526033007616"></p><p>通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 <a href="https://material.io/tools/icons/" target="_blank" rel="noopener">material-icons官网</a>去查看。</p><p>修改我们的代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">append-icon</span>=<span class="hljs-string">"search"</span>/&gt;</span></code></pre></div><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526033167381.png" srcset="/img/loading.gif" alt="1526033167381"></p><h4 id="把文本框变紧凑"><a href="#把文本框变紧凑" class="headerlink" title="把文本框变紧凑"></a>把文本框变紧凑</h4><p>搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526033439890.png" srcset="/img/loading.gif" alt="1526033439890"></p><p>修改代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">append-icon</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">hide-details</span>/&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526033500219.png" srcset="/img/loading.gif" alt="1526033500219"></p><p>几乎已经达到了原来一样的效果了吧！</p><h2 id="3-3-后台提供查询接口"><a href="#3-3-后台提供查询接口" class="headerlink" title="3.3.后台提供查询接口"></a>3.3.后台提供查询接口</h2><p>前台页面已经准备好，接下来就是后台提供数据接口了。</p><h3 id="3-3-1-数据库表"><a href="#3-3-1-数据库表" class="headerlink" title="3.3.1.数据库表"></a>3.3.1.数据库表</h3><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_brand&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;品牌id&#39;,  &#96;name&#96; varchar(50) NOT NULL COMMENT &#39;品牌名称&#39;,  &#96;image&#96; varchar(200) DEFAULT &#39;&#39; COMMENT &#39;品牌图片地址&#39;,  &#96;letter&#96; char(1) DEFAULT &#39;&#39; COMMENT &#39;品牌的首字母&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;325400 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;品牌表，一个品牌下有多个商品（spu），一对多关系&#39;;</code></pre></div><p>简单的四个字段，不多解释。</p><p>这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系：</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_category_brand&#96; (  &#96;category_id&#96; bigint(20) NOT NULL COMMENT &#39;商品类目id&#39;,  &#96;brand_id&#96; bigint(20) NOT NULL COMMENT &#39;品牌id&#39;,  PRIMARY KEY (&#96;category_id&#96;,&#96;brand_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品分类和品牌的中间表，两者是多对多关系&#39;;</code></pre></div><p>但是，你可能会发现，这张表中并<strong>没有设置外键约束</strong>，似乎与数据库的设计范式不符。为什么这么做？</p><ul><li>外键会严重影响数据库读写的效率</li><li>数据删除时会比较麻烦</li></ul><p>在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。</p><h3 id="3-3-2-实体类"><a href="#3-3-2-实体类" class="headerlink" title="3.3.2.实体类"></a>3.3.2.实体类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_brand"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brand</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 品牌名称</span>    <span class="hljs-keyword">private</span> String image;<span class="hljs-comment">// 品牌图片</span>    <span class="hljs-keyword">private</span> Character letter;    <span class="hljs-comment">// getter setter 略</span>&#125;</code></pre></div><h3 id="3-3-3-mapper"><a href="#3-3-3-mapper" class="headerlink" title="3.3.3.mapper"></a>3.3.3.mapper</h3><p>通用mapper来简化开发：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BrandMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Brand</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="3-3-4-controller"><a href="#3-3-4-controller" class="headerlink" title="3.3.4.controller"></a>3.3.4.controller</h3><p>编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定</p><ul><li><p>请求方式：查询，肯定是Get</p></li><li><p>请求路径：分页查询，/brand/page</p></li><li><p>请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数：</p><ul><li>page：当前页，int</li><li>rows：每页大小，int</li><li>sortBy：排序字段，String</li><li>desc：是否为降序，boolean</li><li>key：搜索关键词，String</li></ul></li><li><p>响应结果：分页结果一般至少需要两个数据</p><ul><li>total：总条数</li><li>items：当前页数据</li><li>totalPage：有些还需要总页数</li></ul><p>这里我们封装一个类，来表示分页结果：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageResult</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Long total;<span class="hljs-comment">// 总条数</span>    <span class="hljs-keyword">private</span> Long totalPage;<span class="hljs-comment">// 总页数</span>    <span class="hljs-keyword">private</span> List&lt;T&gt; items;<span class="hljs-comment">// 当前页数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">(Long total, List&lt;T&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.total = total;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">(Long total, Long totalPage, List&lt;T&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.total = total;        <span class="hljs-keyword">this</span>.totalPage = totalPage;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> total;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(Long total)</span> </span>&#123;        <span class="hljs-keyword">this</span>.total = total;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getItems</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItems</span><span class="hljs-params">(List&lt;T&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotalPage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> totalPage;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalPage</span><span class="hljs-params">(Long totalPage)</span> </span>&#123;        <span class="hljs-keyword">this</span>.totalPage = totalPage;    &#125;&#125;</code></pre></div><p>另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到<code>ly-common</code>中，提高复用性：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526046620269.png" srcset="/img/loading.gif" alt="1526046620269"></p></li></ul><p>接下来，我们编写Controller</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"brand"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrandController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BrandService brandService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"page"</span>)    <span class="hljs-keyword">public</span> ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage(            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"page"</span>, defaultValue = <span class="hljs-string">"1"</span>) Integer page,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"rows"</span>, defaultValue = <span class="hljs-string">"5"</span>) Integer rows,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"sortBy"</span>, required = <span class="hljs-keyword">false</span>) String sortBy,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"desc"</span>, defaultValue = <span class="hljs-string">"false"</span>) Boolean desc,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"key"</span>, required = <span class="hljs-keyword">false</span>) String key) &#123;        PageResult&lt;Brand&gt; result = <span class="hljs-keyword">this</span>.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key);        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result.getItems().size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);    &#125;&#125;</code></pre></div><h3 id="3-3-5-Service"><a href="#3-3-5-Service" class="headerlink" title="3.3.5.Service"></a>3.3.5.Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrandService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BrandMapper brandMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> PageResult&lt;Brand&gt; <span class="hljs-title">queryBrandByPageAndSort</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            Integer page, Integer rows, String sortBy, Boolean desc, String key)</span> </span>&#123;        <span class="hljs-comment">// 开始分页</span>        PageHelper.startPage(page, rows);        <span class="hljs-comment">// 过滤</span>        Example example = <span class="hljs-keyword">new</span> Example(Brand<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(key)) &#123;            example.createCriteria().andLike(<span class="hljs-string">"name"</span>, <span class="hljs-string">"%"</span> + key + <span class="hljs-string">"%"</span>)                    .orEqualTo(<span class="hljs-string">"letter"</span>, key);        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(sortBy)) &#123;            <span class="hljs-comment">// 排序</span>            String orderByClause = sortBy + (desc ? <span class="hljs-string">" DESC"</span> : <span class="hljs-string">" ASC"</span>);            example.setOrderByClause(orderByClause);        &#125;        <span class="hljs-comment">// 查询</span>        Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example);        <span class="hljs-comment">// 返回结果</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo);    &#125;&#125;</code></pre></div><h3 id="3-3-6-测试"><a href="#3-3-6-测试" class="headerlink" title="3.3.6.测试"></a>3.3.6.测试</h3><p>通过浏览器访问试试：<a href="http://api.leyou.com/api/item/brand/page" target="_blank" rel="noopener">http://api.leyou.com/api/item/brand/page</a></p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526047708748.png" srcset="/img/loading.gif" alt="1526047708748"></p><p>接下来，去页面请求数据并渲染</p><h2 id="4-4-异步查询工具axios"><a href="#4-4-异步查询工具axios" class="headerlink" title="4.4.异步查询工具axios"></a>4.4.异步查询工具axios</h2><p>异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。</p><h3 id="4-3-1-axios入门"><a href="#4-3-1-axios入门" class="headerlink" title="4.3.1.axios入门"></a>4.3.1.axios入门</h3><p>Vue官方推荐的ajax请求框架叫做：axios，看下demo：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526033988251.png" srcset="/img/loading.gif" alt="1526033988251"></p><p>axios的Get请求语法：</p><div class="hljs"><pre><code class="hljs js">axios.get(<span class="hljs-string">"/item/category/list?pid=0"</span>) <span class="hljs-comment">// 请求路径和请求参数拼接</span>    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;    <span class="hljs-comment">// 成功回调函数</span>&#125;)    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// 失败回调函数</span>&#125;)<span class="hljs-comment">// 参数较多时，可以通过params来传递参数</span>axios.get(<span class="hljs-string">"/item/category/list"</span>, &#123;        params:&#123;            pid:<span class="hljs-number">0</span>        &#125;&#125;)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;&#125;)<span class="hljs-comment">// 成功时的回调</span>    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;&#125;)<span class="hljs-comment">// 失败时的回调</span></code></pre></div><p>axios的POST请求语法：</p><p>比如新增一个用户</p><div class="hljs"><pre><code class="hljs js">axios.post(<span class="hljs-string">"/user"</span>,&#123;    name:<span class="hljs-string">"Jack"</span>,    age:<span class="hljs-number">21</span>&#125;)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;&#125;)    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;&#125;)</code></pre></div><ul><li>注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数</li></ul><p>PUT和DELETE请求与POST请求类似</p><h3 id="4-3-2-axios的全局配置"><a href="#4-3-2-axios的全局配置" class="headerlink" title="4.3.2.axios的全局配置"></a>4.3.2.axios的全局配置</h3><p>而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526034150067.png" srcset="/img/loading.gif" alt="1526034150067"></p><p>http.js中对axios进行了一些默认配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span><span class="hljs-comment">// config中定义的基础路径是：http://api.leyou.com/api</span>axios.defaults.baseURL = config.api; <span class="hljs-comment">// 设置axios的基础请求路径</span>axios.defaults.timeout = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 设置axios的请求时间</span>Vue.prototype.$http = axios;<span class="hljs-comment">// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象</span></code></pre></div><ul><li><p>http.js中导入了config的配置，还记得吗？</p><p>  <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526041205846.png" srcset="/img/loading.gif" alt="1526041205846"></p></li><li><p>http.js对axios进行了全局配置：<code>baseURL=config.api</code>，即<code>http://api.leyou.com/api</code>。因此以后所有用axios发起的请求，都会以这个地址作为前缀。</p></li><li><p>通过<code>Vue.property.$http = axios</code>，将<code>axios</code>赋值给了 Vue原型中的<code>$http</code>。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。</p></li></ul><h3 id="4-3-3-测试一下："><a href="#4-3-3-测试一下：" class="headerlink" title="4.3.3.测试一下："></a>4.3.3.测试一下：</h3><p>我们在组件<code>MyBrand.vue</code>的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据：</p><p>   <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526048079191.png" srcset="/img/loading.gif" alt="1526048221750"></p><p>网络监视：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526048143014.png" srcset="/img/loading.gif" alt="1526048143014"></p><p>控制台结果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526048275064.png" srcset="/img/loading.gif" alt="1526048275064"></p><p>可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。</p><p>响应结果中与我们设计的一致，包含3个内容：</p><ul><li>total：总条数，目前是165</li><li>items：当前页数据</li><li>totalPage：总页数，我们没有返回</li></ul><h2 id="4-5-异步加载品牌数据"><a href="#4-5-异步加载品牌数据" class="headerlink" title="4.5.异步加载品牌数据"></a>4.5.异步加载品牌数据</h2><p>虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数：</p><ul><li>page：当前页，int</li><li>rows：每页大小，int</li><li>sortBy：排序字段，String</li><li>desc：是否为降序，boolean</li><li>key：搜索关键词，String</li></ul><p>而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526042136135.png" srcset="/img/loading.gif" alt></p><p>分别是：</p><ul><li>descending：是否是降序，对应请求参数的desc</li><li>page：当前页，对应参数的page</li><li>rowsPerpage：每页大小，对应参数中的rows</li><li>sortBy：排序字段，对应参数的sortBy</li></ul><p>缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。</p><p>另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。</p><p>接下来，我们在<code>getDataFromServer</code>方法中完善请求参数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 发起请求</span><span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/brand/page"</span>,&#123;        params:&#123;            key: <span class="hljs-keyword">this</span>.search, <span class="hljs-comment">// 搜索条件</span>            page: <span class="hljs-keyword">this</span>.pagination.page,<span class="hljs-comment">// 当前页</span>            rows: <span class="hljs-keyword">this</span>.pagination.rowsPerPage,<span class="hljs-comment">// 每页大小</span>            sortBy: <span class="hljs-keyword">this</span>.pagination.sortBy,<span class="hljs-comment">// 排序字段</span>            desc: <span class="hljs-keyword">this</span>.pagination.descending<span class="hljs-comment">// 是否降序</span>        &#125;    &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123; <span class="hljs-comment">// 这里使用箭头函数</span>        <span class="hljs-comment">// 将得到的数据赋值给本地属性</span>        <span class="hljs-keyword">this</span>.brands = resp.data.items;        <span class="hljs-keyword">this</span>.totalBrands = resp.data.total;        <span class="hljs-comment">// 完成赋值后，把加载状态赋值为false</span>        <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>;    &#125;)</code></pre></div><p>查看网络请求：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526049810351.png" srcset="/img/loading.gif" alt="1526049810351"></p><p>效果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526049139244.png" srcset="/img/loading.gif" alt="1526049139244"></p><h2 id="4-6-完成分页和过滤"><a href="#4-6-完成分页和过滤" class="headerlink" title="4.6.完成分页和过滤"></a>4.6.完成分页和过滤</h2><h3 id="4-6-1-分页"><a href="#4-6-1-分页" class="headerlink" title="4.6.1.分页"></a>4.6.1.分页</h3><p>现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？</p><p>虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/9.gif" srcset="/img/loading.gif" alt></p><p>我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！</p><p>具体实现：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526049643506.png" srcset="/img/loading.gif" alt="1526049643506"></p><p>成功实现分页功能：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526049720200.png" srcset="/img/loading.gif" alt="1526049720200"></p><h3 id="4-6-2-过滤"><a href="#4-6-2-过滤" class="headerlink" title="4.6.2.过滤"></a>4.6.2.过滤</h3><p>分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可:</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526049939985.png" srcset="/img/loading.gif" alt="1526049939985"></p><p>查看网络请求：</p><p> <img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526050032436.png" srcset="/img/loading.gif" alt="1526050032436"></p><p>页面结果：</p><p><img src="/2020/09/24/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday07/1526050071442.png" srcset="/img/loading.gif" alt="1526050071442"></p><h2 id="4-7-完整代码"><a href="#4-7-完整代码" class="headerlink" title="4.7.完整代码"></a>4.7.完整代码</h2><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;v-card&gt;    &lt;v-card-title&gt;      &lt;v-btn color&#x3D;&quot;primary&quot; @click&#x3D;&quot;addBrand&quot;&gt;新增品牌&lt;&#x2F;v-btn&gt;      &lt;!--搜索框，与search属性关联--&gt;      &lt;v-spacer&#x2F;&gt;      &lt;v-text-field label&#x3D;&quot;输入关键字搜索&quot; v-model.lazy&#x3D;&quot;search&quot; append-icon&#x3D;&quot;search&quot; hide-details&#x2F;&gt;    &lt;&#x2F;v-card-title&gt;    &lt;v-divider&#x2F;&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;brands&quot;      :search&#x3D;&quot;search&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalBrands&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img :src&#x3D;&quot;props.item.image&quot;&gt;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;justify-center layout&quot;&gt;          &lt;v-btn color&#x3D;&quot;info&quot;&gt;编辑&lt;&#x2F;v-btn&gt;          &lt;v-btn color&#x3D;&quot;warning&quot;&gt;删除&lt;&#x2F;v-btn&gt;        &lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;v-card&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import MyBrandForm from &#39;.&#x2F;MyBrandForm&#39;  export default &#123;    name: &quot;my-brand&quot;,    data() &#123;      return &#123;        search: &#39;&#39;, &#x2F;&#x2F; 搜索过滤字段        totalBrands: 0, &#x2F;&#x2F; 总条数        brands: [], &#x2F;&#x2F; 当前页品牌数据        loading: true, &#x2F;&#x2F; 是否在加载中        pagination: &#123;&#125;, &#x2F;&#x2F; 分页信息        headers: [          &#123;text: &#39;id&#39;, align: &#39;center&#39;, value: &#39;id&#39;&#125;,          &#123;text: &#39;名称&#39;, align: &#39;center&#39;, sortable: false, value: &#39;name&#39;&#125;,          &#123;text: &#39;LOGO&#39;, align: &#39;center&#39;, sortable: false, value: &#39;image&#39;&#125;,          &#123;text: &#39;首字母&#39;, align: &#39;center&#39;, value: &#39;letter&#39;, sortable: true,&#125;,          &#123;text: &#39;操作&#39;, align: &#39;center&#39;, value: &#39;id&#39;, sortable: false&#125;        ]      &#125;    &#125;,    mounted() &#123; &#x2F;&#x2F; 渲染后执行      &#x2F;&#x2F; 查询数据      this.getDataFromServer();    &#125;,    watch: &#123;      pagination: &#123; &#x2F;&#x2F; 监视pagination属性的变化        deep: true, &#x2F;&#x2F; deep为true，会监视pagination的属性及属性中的对象属性变化        handler() &#123;          &#x2F;&#x2F; 变化后的回调函数，这里我们再次调用getDataFromServer即可          this.getDataFromServer();        &#125;      &#125;,      search: &#123; &#x2F;&#x2F; 监视搜索字段        handler() &#123;          this.getDataFromServer();        &#125;      &#125;    &#125;,    methods: &#123;      getDataFromServer() &#123; &#x2F;&#x2F; 从服务的加载数的方法。        &#x2F;&#x2F; 发起请求        this.$http.get(&quot;&#x2F;item&#x2F;brand&#x2F;page&quot;, &#123;          params: &#123;            key: this.search, &#x2F;&#x2F; 搜索条件            page: this.pagination.page,&#x2F;&#x2F; 当前页            rows: this.pagination.rowsPerPage,&#x2F;&#x2F; 每页大小            sortBy: this.pagination.sortBy,&#x2F;&#x2F; 排序字段            desc: this.pagination.descending&#x2F;&#x2F; 是否降序          &#125;        &#125;).then(resp &#x3D;&gt; &#123; &#x2F;&#x2F; 这里使用箭头函数          this.brands &#x3D; resp.data.items;          this.totalBrands &#x3D; resp.data.total;          &#x2F;&#x2F; 完成赋值后，把加载状态赋值为false          this.loading &#x3D; false;        &#125;)      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>cors</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day06：webpack</title>
    <link href="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/"/>
    <url>/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解vue-router使用</li><li>了解webpack使用</li><li>会使用vue-cli搭建项目</li><li>独立搭建后台管理系统</li><li>了解系统基本结构</li></ul><h1 id="1-路由vue-router"><a href="#1-路由vue-router" class="headerlink" title="1.路由vue-router"></a>1.路由vue-router</h1><h2 id="1-1-场景模拟"><a href="#1-1-场景模拟" class="headerlink" title="1.1.场景模拟"></a>1.1.场景模拟</h2><p>现在我们来实现这样一个功能：</p><p>一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/8.gif" srcset="/img/loading.gif" alt="8gif"></p><h3 id="1-1-1-编写父组件"><a href="#1-1-1-编写父组件" class="headerlink" title="1.1.1.编写父组件"></a>1.1.1.编写父组件</h3><p>为了让接下来的功能比较清晰，我们先新建一个文件夹：src:</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525868223969.png" srcset="/img/loading.gif" alt="1525868223969"></p><p>然后新建一个HTML文件，作为入口：index.html</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525868284332.png" srcset="/img/loading.gif" alt="1525868284332"></p><p>然后编写页面的基本结构：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        登录页/注册页    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span></span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>样式：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525868623712.png" srcset="/img/loading.gif" alt="1525868623712"></p><h3 id="1-1-2-编写登录组件"><a href="#1-1-2-编写登录组件" class="headerlink" title="1.1.2.编写登录组件"></a>1.1.2.编写登录组件</h3><p>接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放如独立的JS文件中，我们新建一个login.js</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525868736799.png" srcset="/img/loading.gif" alt="1525868736799"></p><p>编写组件，这里我们只写模板，不写功能：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loginForm = &#123;    template:<span class="hljs-string">'\</span><span class="hljs-string">    &lt;div&gt;\</span><span class="hljs-string">    &lt;h2&gt;登录页&lt;/h2&gt; \</span><span class="hljs-string">    用户名：&lt;input type="text"&gt;&lt;br/&gt;\</span><span class="hljs-string">    密码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    &lt;/div&gt;\</span><span class="hljs-string">    '</span>&#125;</code></pre></div><h3 id="1-1-3-编写注册组件"><a href="#1-1-3-编写注册组件" class="headerlink" title="1.1.3.编写注册组件"></a>1.1.3.编写注册组件</h3><p>新建单文件组件：register.js</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525869269916.png" srcset="/img/loading.gif" alt="1525869269916"></p><p>编写模板：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> registerForm = &#123;    template:<span class="hljs-string">'\</span><span class="hljs-string">    &lt;div&gt;\</span><span class="hljs-string">    &lt;h2&gt;注册页&lt;/h2&gt; \</span><span class="hljs-string">    用户名：&lt;input type="text"&gt;&lt;br/&gt;\</span><span class="hljs-string">    密码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    确认密码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    &lt;/div&gt;\</span><span class="hljs-string">    '</span>&#125;</code></pre></div><h3 id="1-1-4-在父组件中引用"><a href="#1-1-4-在父组件中引用" class="headerlink" title="1.1.4.在父组件中引用"></a>1.1.4.在父组件中引用</h3><p>在index.html中使用刚刚编写的两个组件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">login-form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">login-form</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">register-form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">register-form</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/login.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/register.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span><span class="actionscript">        components:&#123;<span class="hljs-comment">// 引用登录和注册组件</span></span>            loginForm,            registerForm        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525869621647.png" srcset="/img/loading.gif" alt="1525869621647"></p><h3 id="1-1-5-问题"><a href="#1-1-5-问题" class="headerlink" title="1.1.5.问题"></a>1.1.5.问题</h3><p>我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。</p><p>但是，如何才能动态加载组件，实现组件切换呢？</p><p>虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。</p><h2 id="1-2-vue-router简介和安装"><a href="#1-2-vue-router简介和安装" class="headerlink" title="1.2.vue-router简介和安装"></a>1.2.vue-router简介和安装</h2><p>使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。</p><p>官网：<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/</a></p><p>使用npm安装：<code>npm install vue-router --save</code> </p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525870170532.png" srcset="/img/loading.gif" alt="1525870170532"></p><p>在index.html中引入依赖：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/vue-router/dist/vue-router.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3.快速入门"></a>1.3.快速入门</h2><p>新建vue-router对象，并且指定路由规则：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 创建VueRouter对象</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    routes:[ <span class="hljs-comment">// 编写多个路由规则</span>        &#123;            path:<span class="hljs-string">"/login"</span>, <span class="hljs-comment">// 请求路径</span>            component:loginForm <span class="hljs-comment">// 组件名称</span>        &#125;,        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">"/register"</span>,<span class="hljs-attr">component</span>:registerForm&#125;,    ]&#125;)</code></pre></div><ul><li>创建VueRouter对象，并指定路由参数</li><li>routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性：<ul><li>path：路由的路径</li><li>component：组件名称</li></ul></li></ul><p>在父组件中引入router对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    components:&#123;<span class="hljs-comment">// 引用登录和注册组件</span>        loginForm,        registerForm    &#125;,    router <span class="hljs-comment">// 引用上面定义的router对象</span>&#125;)</code></pre></div><p>页面跳转控制：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--router-link来指定跳转的路径--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/register"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!--vue-router的锚点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><ul><li>通过<code>&lt;router-view&gt;</code>来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染</li><li>通过<code>&lt;router-link&gt;</code>指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变</li></ul><p>效果：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/8.gif" srcset="/img/loading.gif" alt="a3212"></p><p><strong>注意</strong>：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。</p><p>事实上，我们总共就一个HTML：index.html</p><h2 id="1-4-父子组件"><a href="#1-4-父子组件" class="headerlink" title="1.4.父子组件"></a>1.4.父子组件</h2><h1 id="2-webpack"><a href="#2-webpack" class="headerlink" title="2.webpack"></a>2.webpack</h1><h2 id="2-1-认识webpack"><a href="#2-1-认识webpack" class="headerlink" title="2.1.认识webpack"></a>2.1.认识webpack</h2><p>Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。</p><p>中文官方网站：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525866284055.png" srcset="/img/loading.gif" alt="1525866284055"></p><p>官网给出的解释：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525866410437.png" srcset="/img/loading.gif" alt="1525866410437"></p><p>为什么需要打包？</p><ul><li>将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。</li><li>将ES6的高级语法进行转换编译，以兼容老版本的浏览器。</li><li>将代码打包的同时进行混淆，提高代码的安全性。</li></ul><h2 id="2-2-四个核心概念"><a href="#2-2-四个核心概念" class="headerlink" title="2.2.四个核心概念"></a>2.2.四个核心概念</h2><p>学习Webpack，你需要先理解四个<strong>核心概念</strong>：</p><ul><li><p>入口(entry)</p><p>webpack打包的启点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据</p></li><li><p>输出(output)</p><p>出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。</p></li><li><p>加载器（loader）</p><p>webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。</p></li><li><p>插件(plugins)</p><p>插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。</p></li></ul><h2 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3.安装"></a>2.3.安装</h2><p>webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。</p><p>输入命令：<code>npm install webpack webpack-cli --save-dev</code></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525873000269.png" srcset="/img/loading.gif" alt="1525873000269"></p><p>此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了）</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525873145475.png" srcset="/img/loading.gif" alt="1525873145475"></p><p>打开文件，可以看到我们之前用npm安装过的文件都会出现在这里：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525873343908.png" srcset="/img/loading.gif" alt="1525873343908"></p><h2 id="2-4-编写webpack配置"><a href="#2-4-编写webpack配置" class="headerlink" title="2.4.编写webpack配置"></a>2.4.编写webpack配置</h2><p>接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525873610812.png" srcset="/img/loading.gif" alt="1525873610812"></p><p>配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。</p><p>不过，加载器和插件是可选的。我们先编写入口和出口</p><h3 id="2-4-1-入口entry"><a href="#2-4-1-入口entry" class="headerlink" title="2.4.1.入口entry"></a>2.4.1.入口entry</h3><p>webpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？</p><p>我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525874002350.png" srcset="/img/loading.gif" alt="1525874002350"></p><p>然后把原来index.html中的js代码全部移动到main.js中</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用es6的语法导入js模块</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'../node_modules/vue/dist/vue'</span>;<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'../node_modules/vue-router/dist/vue-router'</span><span class="hljs-keyword">import</span> loginForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./js/login'</span><span class="hljs-keyword">import</span> registerForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./js/register'</span>Vue.use(VueRouter)<span class="hljs-comment">// 创建VueRouter对象</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    routes:[ <span class="hljs-comment">// 编写多个路由规则</span>        &#123;            path:<span class="hljs-string">"/login"</span>, <span class="hljs-comment">// 请求路径</span>            component:loginForm <span class="hljs-comment">// 组件名称</span>        &#125;,        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">"/register"</span>,<span class="hljs-attr">component</span>:registerForm&#125;,    ]&#125;)<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    components:&#123;<span class="hljs-comment">// 引用登录和注册组件</span>        loginForm,        registerForm    &#125;,    router&#125;)</code></pre></div><ul><li><p>原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。</p><p>注意，要使用import，就需要在login.js和register.js中添加export导出语句：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loginForm = &#123;    template:<span class="hljs-string">`</span><span class="hljs-string">    &lt;div&gt; </span><span class="hljs-string">    &lt;h2&gt;登录页&lt;/h2&gt; </span><span class="hljs-string">    用户名：&lt;input type="text"&gt;&lt;br/&gt;</span><span class="hljs-string">    密码：&lt;input type="password"&gt;&lt;br/&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">    `</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> loginForm;</code></pre></div><p>register.js:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> registerForm = &#123;    template:<span class="hljs-string">`</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">    &lt;h2&gt;注册页&lt;/h2&gt; </span><span class="hljs-string">    用户名：&lt;input type="text"&gt;&lt;br/&gt;</span><span class="hljs-string">    密码：&lt;input type="password"&gt;&lt;br/&gt;</span><span class="hljs-string">    确认密码：&lt;input type="password"&gt;&lt;br/&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">    `</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> registerForm;</code></pre></div></li></ul><ul><li>vue-router使用模块话加载后，必须增加一句：Vue.use(VueRouter)</li></ul><p>这样，main.js就成了我们整个配置的入口了。</p><p>我们在webpack.config.js中添加以下内容：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>&#125;</code></pre></div><h3 id="2-4-2-出口output"><a href="#2-4-2-出口output" class="headerlink" title="2.4.2.出口output"></a>2.4.2.出口output</h3><p>出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525875474187.png" srcset="/img/loading.gif" alt="1525875474187"></p><p>然后，编写webpack.config.js，添加出口配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>    output:&#123;        <span class="hljs-comment">// path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径</span>        path : __dirname+<span class="hljs-string">'/dist'</span>,          filename:<span class="hljs-string">'build.js'</span> <span class="hljs-comment">//输出的js文件名</span>    &#125;&#125;</code></pre></div><h2 id="2-5-执行打包"><a href="#2-5-执行打包" class="headerlink" title="2.5.执行打包"></a>2.5.执行打包</h2><p>在控制台输入以下命令：</p><div class="hljs"><pre><code class="hljs arduino">npx webpack --<span class="hljs-built_in">config</span> webpack.<span class="hljs-built_in">config</span>.js</code></pre></div><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525875749502.png" srcset="/img/loading.gif" alt="1525875749502"></p><p>随后，查看dist目录：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525875792078.png" srcset="/img/loading.gif" alt="1525875792078"></p><p>尝试打开build.js，你根本看不懂：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525876060602.png" srcset="/img/loading.gif" alt="1525876060602"></p><p>所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。</p><h2 id="2-6-测试运行"><a href="#2-6-测试运行" class="headerlink" title="2.6.测试运行"></a>2.6.测试运行</h2><p>在index.html中引入刚刚生成的build.js文件，</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!--router-link来指定跳转的路径--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/register"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-comment">&lt;!--vue-router的锚点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../dist/build.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>然后运行：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525875932114.png" srcset="/img/loading.gif" alt="1525875932114"></p><h2 id="2-7-打包CSS"><a href="#2-7-打包CSS" class="headerlink" title="2.7.打包CSS"></a>2.7.打包CSS</h2><h3 id="2-7-1-编写css文件"><a href="#2-7-1-编写css文件" class="headerlink" title="2.7.1.编写css文件"></a>2.7.1.编写css文件</h3><p>我们来编写一段CSS代码，对index的样式做一些美化：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525877099220.png" srcset="/img/loading.gif" alt="1525877099220"></p><p>内容：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">a</span>&#123;    <span class="hljs-attribute">display</span>: inline-block;    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">background-color</span>: dodgerblue;    <span class="hljs-attribute">color</span>: white;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;    <span class="hljs-attribute">text-decoration</span>: none;&#125;<span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;    <span class="hljs-attribute">background-color</span>: whitesmoke;    <span class="hljs-attribute">color</span>: dodgerblue;&#125;<span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;&#125;<span class="hljs-selector-id">#app</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">305px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid dodgerblue;&#125;</code></pre></div><h3 id="2-7-2-安装加载器"><a href="#2-7-2-安装加载器" class="headerlink" title="2.7.2.安装加载器"></a>2.7.2.安装加载器</h3><p>前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器：</p><p>命令：</p><div class="hljs"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">style</span>-loader css-loader <span class="hljs-comment">--save-dev</span></code></pre></div><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525877313725.png" srcset="/img/loading.gif" alt="1525877313725"></p><p>此时，在package.json中能看到新安装的：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525877634350.png" srcset="/img/loading.gif" alt="1525877634350"></p><h3 id="2-7-3-在main-js引入css文件"><a href="#2-7-3-在main-js引入css文件" class="headerlink" title="2.7.3.在main.js引入css文件"></a>2.7.3.在main.js引入css文件</h3><p>因为入口在main.js，因此css文件也要在这里引入。依然使用ES6 的模块语法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'./css/main.css'</span></code></pre></div><h3 id="2-7-4-在webpack-config-js添加加载器"><a href="#2-7-4-在webpack-config-js添加加载器" class="headerlink" title="2.7.4.在webpack.config.js添加加载器"></a>2.7.4.在webpack.config.js添加加载器</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    entry: <span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>    output: &#123;        path: __dirname + <span class="hljs-string">'/dist'</span>, <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>        filename: <span class="hljs-string">'build.js'</span>  <span class="hljs-comment">//输出文件</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 通过正则表达式匹配所有以.css后缀的文件</span>                use: [ <span class="hljs-comment">// 要使用的加载器，这两个顺序一定不要乱</span>                    <span class="hljs-string">'style-loader'</span>,                    <span class="hljs-string">'css-loader'</span>                ]            &#125;        ]    &#125;&#125;</code></pre></div><h3 id="2-7-5-重新打包"><a href="#2-7-5-重新打包" class="headerlink" title="2.7.5.重新打包"></a>2.7.5.重新打包</h3><p>再次输入打包指令：<code>npx webpack --config webpack.config.js</code></p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525877746191.png" srcset="/img/loading.gif" alt="1525877746191"></p><p>效果：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525877882425.png" srcset="/img/loading.gif" alt="1525877882425"></p><h2 id="2-8-script脚本"><a href="#2-8-script脚本" class="headerlink" title="2.8.script脚本"></a>2.8.script脚本</h2><p>我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。</p><p>我们可以把webpack的命令编入其中：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525878015255.png" srcset="/img/loading.gif" alt="1525878015255"></p><p>以后，如果要打包，就可以直接输入：<code>npm run build</code>即可。</p><ul><li><code>npm run</code> ：执行npm脚本，后面跟的是脚本的名称<code>build</code></li></ul><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525878133337.png" srcset="/img/loading.gif" alt="1525878133337"></p><h2 id="2-9-打包HTML"><a href="#2-9-打包HTML" class="headerlink" title="2.9.打包HTML"></a>2.9.打包HTML</h2><p>之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。</p><p>webpack中的一个插件：html-webpack-plugin，可以解决这个问题。</p><p>1）安装插件：<code>npm install --save-dev html-webpack-plugin</code></p><p>需要在webpack.config.js中添加插件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    entry: <span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>    output: &#123;        path: __dirname + <span class="hljs-string">'/dist'</span>,  <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>        filename: <span class="hljs-string">'build.js'</span>   <span class="hljs-comment">//输出文件</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 通过正则表达式匹配所有以.css后缀的文件</span>                use: [ <span class="hljs-comment">// 要使用的加载器，这两个顺序一定不要乱</span>                    <span class="hljs-string">'style-loader'</span>,                    <span class="hljs-string">'css-loader'</span>                ]            &#125;        ]    &#125;,    plugins:[        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            title: <span class="hljs-string">'首页'</span>,  <span class="hljs-comment">//生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;</span>            filename: <span class="hljs-string">'index.html'</span>, <span class="hljs-comment">// dist目录下生成的文件名</span>            template: <span class="hljs-string">'./src/index.html'</span> <span class="hljs-comment">// 我们原来的index.html，作为模板</span>        &#125;)    ]&#125;</code></pre></div><p>2）将原来HTML中的引入js代码删除：</p><p>  <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1527390662284.png" srcset="/img/loading.gif" alt="1527390662284"></p><p>3）再次打包：<code>npm run build</code></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525879126478.png" srcset="/img/loading.gif" alt="1525879126478"></p><p>4）查看dist目录：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525879160040.png" srcset="/img/loading.gif" alt="1525879160040"></p><p>打开index.html，发现已经自动添加了当前目录下的build.js</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!--router-link来指定跳转的路径--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/register"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-comment">&lt;!--vue-router的锚点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"build.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="2-10-热更新的web服务"><a href="#2-10-热更新的web服务" class="headerlink" title="2.10.热更新的web服务"></a>2.10.热更新的web服务</h2><p>刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。</p><p>webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果：</p><p>1）安装插件：</p><div class="hljs"><pre><code class="hljs q">npm install webpack-<span class="hljs-built_in">dev</span>-server --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>2）添加启动脚本</p><p>在package.json中配置script</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">"scripts"</span>: &#123;  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"</span>&#125;,</code></pre></div><p>–inline：自动刷新</p><p>–hot：热加载</p><p>–port：指定端口</p><p>–open：自动在默认浏览器打开</p><p>–host：可以指定服务器的 ip，不指定则为127.0.0.1</p><p>3）运行脚本：</p><div class="hljs"><pre><code class="hljs dockerfile">npm <span class="hljs-keyword">run</span><span class="bash"> dev</span></code></pre></div><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525912021845.png" srcset="/img/loading.gif" alt="1525912021845"></p><p>4）效果：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525912255757.png" srcset="/img/loading.gif" alt="1525912255757"></p><h1 id="3-vue-cli"><a href="#3-vue-cli" class="headerlink" title="3.vue-cli"></a>3.vue-cli</h1><h2 id="3-1-介绍和安装"><a href="#3-1-介绍和安装" class="headerlink" title="3.1.介绍和安装"></a>3.1.介绍和安装</h2><p>在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。</p><p>幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli</p><p>使用它能快速的构建一个web工程模板。</p><p>官网：<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli</a></p><p>安装命令：</p><div class="hljs"><pre><code class="hljs avrasm">npm install -g vue-<span class="hljs-keyword">cli</span></code></pre></div><h2 id="3-2-快速上手"><a href="#3-2-快速上手" class="headerlink" title="3.2.快速上手"></a>3.2.快速上手</h2><p>我们新建一个module：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525912928592.png" srcset="/img/loading.gif" alt="1525912928592"></p><p>打开终端并进入目录：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913049617.png" srcset="/img/loading.gif" alt="1525913049617"></p><p>用vue-cli命令，快速搭建一个webpack的项目：<code>vue init webpack</code></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913141066.png" srcset="/img/loading.gif" alt="1525913141066"></p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913197139.png" srcset="/img/loading.gif" alt="1525913197139"></p><p>前面几项都走默认或yes</p><p>下面这些我们选no</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913230564.png" srcset="/img/loading.gif" alt="1525913230564"></p><p>最后，再选yes，使用 npm安装</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913263487.png" srcset="/img/loading.gif" alt="1525913263487"></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913307569.png" srcset="/img/loading.gif" alt="1525913307569"></p><h2 id="3-3-项目结构"><a href="#3-3-项目结构" class="headerlink" title="3.3.项目结构"></a>3.3.项目结构</h2><p>安装好的项目结构：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913435086.png" srcset="/img/loading.gif" alt="1525913435086"></p><p>入口文件：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525913687860.png" srcset="/img/loading.gif" alt="1525913687860"></p><h2 id="3-4-单文件组件"><a href="#3-4-单文件组件" class="headerlink" title="3.4.单文件组件"></a>3.4.单文件组件</h2><p>需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525914072353.png" srcset="/img/loading.gif" alt="1525914072353"></p><p>每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的loginForm.js和registerForm.js</p><p>只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。</p><p>而单文件组件中包含三部分内容：</p><ul><li>template：模板，支持html语法高亮和提示</li><li>script：js脚本，这里编写的就是vue的组件对象，看到上面的data(){}了吧</li><li>style：样式，支持CSS语法高亮和提示</li></ul><p>每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。</p><h2 id="3-5-运行"><a href="#3-5-运行" class="headerlink" title="3.5.运行"></a>3.5.运行</h2><p>看看生成的package.json：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525914618504.png" srcset="/img/loading.gif" alt="1525914618504"></p><ul><li>可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。</li><li>运行时依赖只有vue和vue-router</li><li>脚本有三个：<ul><li>dev：使用了webpack-dev-server命令，开发时热部署使用</li><li>start：使用了npm run dev命令，与上面的dev效果完全一样</li><li>build：等同于webpack的打包功能，会打包到dist目录下。</li></ul></li></ul><p>我们执行<code>npm run dev</code> 或者 <code>npm start</code> 都可以启动项目：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525914808164.png" srcset="/img/loading.gif" alt="1525914808164"></p><p>页面：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525914871848.png" srcset="/img/loading.gif" alt="1525914871848"></p><h1 id="4-搭建后台管理前端"><a href="#4-搭建后台管理前端" class="headerlink" title="4.搭建后台管理前端"></a>4.搭建后台管理前端</h1><h2 id="4-1-导入已有资源"><a href="#4-1-导入已有资源" class="headerlink" title="4.1.导入已有资源"></a>4.1.导入已有资源</h2><p>后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525955154460.png" srcset="/img/loading.gif" alt="1525955154460"></p><p>我们解压缩，放到工作目录中：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525955615381.png" srcset="/img/loading.gif" alt="1525955615381"></p><p>然后在eclipse中导入新的工程：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525955644681.png" srcset="/img/loading.gif" alt="1525955644681"></p><p>选中我们的工程：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525955709334.png" srcset="/img/loading.gif" alt="1525955709334"></p><p>这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525955811416.png" srcset="/img/loading.gif" alt="1525955811416"></p><h2 id="4-2-安装依赖"><a href="#4-2-安装依赖" class="headerlink" title="4.2.安装依赖"></a>4.2.安装依赖</h2><p>你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525956016683.png" srcset="/img/loading.gif" alt="1525956016683"></p><p>我们只需要通过命令来安装所需依赖即可。打开终端，进入项目目录，输入：<code>npm install</code></p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525957503521.png" srcset="/img/loading.gif" alt="1525957503521"></p><p>大概需要1分钟。</p><h2 id="4-3-运行一下看看"><a href="#4-3-运行一下看看" class="headerlink" title="4.3.运行一下看看"></a>4.3.运行一下看看</h2><p>输入命令：</p><div class="hljs"><pre><code class="hljs dockerfile">npm <span class="hljs-keyword">run</span><span class="bash"> dev</span></code></pre></div><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525957604219.png" srcset="/img/loading.gif" alt="1525957604219"></p><p>发现默认的端口是9001。访问：<a href="http://localhost:9001" target="_blank" rel="noopener">http://localhost:9001</a></p><p>会自动进行跳转：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525958950616.png" srcset="/img/loading.gif" alt="1525958950616"></p><h1 id="5-Vuetify框架"><a href="#5-Vuetify框架" class="headerlink" title="5.Vuetify框架"></a>5.Vuetify框架</h1><h2 id="5-1-为什么要学习UI框架"><a href="#5-1-为什么要学习UI框架" class="headerlink" title="5.1.为什么要学习UI框架"></a>5.1.为什么要学习UI框架</h2><p>Vue负责的是虽然会帮我们进行视图的渲染，但是样式是有我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如：</p><ul><li>BootStrap</li><li>LayUI</li><li>EasyUI</li><li>ZUI</li></ul><p>然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。</p><p>而目前与Vue吻合的UI框架也非常的多，国内比较知名的如：</p><ul><li>element-ui：饿了么出品</li><li>i-view：某公司出品</li></ul><p>然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify</p><p>官方网站：<a href="https://vuetifyjs.com/zh-Hans/" target="_blank" rel="noopener">https://vuetifyjs.com/zh-Hans/</a></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525960652724.png" srcset="/img/loading.gif" alt="1525960652724"></p><h2 id="5-2-为什么是Vuetify"><a href="#5-2-为什么是Vuetify" class="headerlink" title="5.2.为什么是Vuetify"></a>5.2.为什么是Vuetify</h2><p>有中国的为什么还要用外国的？原因如下：</p><ul><li>Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写</li><li>Vuetify从底层构建起来的语义化组件。简单易学，容易记住。</li><li>Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一</li></ul><p>这是官网的说明：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525959769978.png" srcset="/img/loading.gif" alt="1525959769978"></p><p>缺陷：</p><ul><li>目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。</li></ul><h2 id="5-3-怎么用？"><a href="#5-3-怎么用？" class="headerlink" title="5.3.怎么用？"></a>5.3.怎么用？</h2><p>基于官方网站的文档进行学习：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525960312939.png" srcset="/img/loading.gif" alt="1525960312939"></p><p>我们重点关注<code>UI components</code>即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525961862771.png" srcset="/img/loading.gif" alt="1525961862771"></p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525961875288.png" srcset="/img/loading.gif" alt="1525961875288"></p><p>以后用到什么组件，就来查询即可。</p><h1 id="6-项目结构"><a href="#6-项目结构" class="headerlink" title="6.项目结构"></a>6.项目结构</h1><p>开始编码前，我们先了解下项目的结构：</p><h2 id="6-1-目录结构"><a href="#6-1-目录结构" class="headerlink" title="6.1.目录结构"></a>6.1.目录结构</h2><p>首先是目录结构图：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525962755237.png" srcset="/img/loading.gif" alt="1525962755237"></p><h2 id="6-2-调用关系"><a href="#6-2-调用关系" class="headerlink" title="6.2.调用关系"></a>6.2.调用关系</h2><p>我们最主要理清index.html、main.js、App.vue之间的关系：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525964023585.png" srcset="/img/loading.gif" alt="1525964023585"></p><p>理一下：</p><ul><li>index.html中定义了空的<code>div</code>，其id为<code>app</code>。</li><li>main.js中定义了Vue对象，并且绑定通过id选择器，绑定到index.html的div中，因此<strong>main.js的内容都将在index.html的div中显示</strong>。</li><li>而main.js中只有一行内容：<code>&lt;App/&gt;</code>,这是使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。</li><li>App.vue中也没有内容，而是定义了vue-router的锚点：<code>&lt;router-view&gt;</code>,我们之前讲过，vue-router路由后的组件将会在锚点展示。</li><li>最终的结论是：<strong>一切路由后的内容都将通过App.vue在index.html中显示。</strong></li></ul><h2 id="6-3-页面布局"><a href="#6-3-页面布局" class="headerlink" title="6.3.页面布局"></a>6.3.页面布局</h2><p>接下来我们一起看下页面布局：</p><p>Layout组件是我们的整个页面的布局组件：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525965105184.png" srcset="/img/loading.gif" alt="1525965105184"></p><p>一个典型的三块布局。包含左，上，中三部分：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525965779366.png" srcset="/img/loading.gif" alt="1525965779366"></p><p>里面使用了Vuetify中的2个组件和一个布局元素：</p><ul><li><p><code>v-navigation-drawer</code> ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 </p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525965560286.png" srcset="/img/loading.gif" alt="1525965560286"></p></li><li><p><code>v-toolbar</code>：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525965585695.png" srcset="/img/loading.gif" alt="1525965585695"></p></li><li><p><code>v-content</code>：并不是一个组件，而是标记页面布局的元素。可以根据您指定的<strong>app</strong>组件的结构动态调整大小，使得您可以创建高度可定制的组件。</p></li></ul><p>那么问题来了：<code>v-content</code>中的内容来自哪里？</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06-webpack/1525966180568.png" srcset="/img/loading.gif" alt="1525966180568"></p><ul><li>Layout映射的路径是<code>/</code></li><li>除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是<code>/</code>的下面</li><li>因此当路由到子组件时，会在Layout中定义的锚点中显示。</li><li>并且Layout中的其它部分不会变化，这就实现了布局的共享。</li></ul>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>vue-cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day06</title>
    <link href="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/"/>
    <url>/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>使用资料搭建后台系统</li><li>会使用nginx进行反向代理</li><li>实现商品分类查询功能</li><li>掌握cors解决跨域</li><li>实现品牌查询功能</li></ul><h1 id="1-搭建后台管理前端"><a href="#1-搭建后台管理前端" class="headerlink" title="1.搭建后台管理前端"></a>1.搭建后台管理前端</h1><h2 id="1-1-导入已有资源"><a href="#1-1-导入已有资源" class="headerlink" title="1.1.导入已有资源"></a>1.1.导入已有资源</h2><p>后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530555871804.png" srcset="/img/loading.gif" alt="1530555871804"></p><p>我们解压缩，放到工作目录中：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530367369490.png" srcset="/img/loading.gif" alt="1530367369490"></p><p>然后在Intellij idea中导入新的工程：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530367589197.png" srcset="/img/loading.gif" alt="1530367589197"></p><p>选中我们的工程：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530367781173.png" srcset="/img/loading.gif" alt="1530367781173"></p><p>这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530368191250.png" srcset="/img/loading.gif" alt="1530368191250"></p><h2 id="1-2-安装依赖"><a href="#1-2-安装依赖" class="headerlink" title="1.2.安装依赖"></a>1.2.安装依赖</h2><p>你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530368695265.png" srcset="/img/loading.gif" alt="1530368695265"></p><p>我们只需要打开终端，进入项目目录，输入：<code>npm install</code>命令，即可安装这些依赖。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530374769782.png" srcset="/img/loading.gif" alt="1530374769782"></p><p>大概需要几分钟。</p><p><strong>如果安装过程出现以下问题</strong>：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530374827792.png" srcset="/img/loading.gif" alt="1530374827792"></p><p>建议删除node_modules目录，重新安装。</p><h2 id="1-3-运行一下看看"><a href="#1-3-运行一下看看" class="headerlink" title="1.3.运行一下看看"></a>1.3.运行一下看看</h2><p>输入命令：<code>npm run dev</code></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530374954209.png" srcset="/img/loading.gif" alt="1530374954209"></p><p>发现默认的端口是9001。访问：<a href="http://localhost:9001" target="_blank" rel="noopener">http://localhost:9001</a></p><p>会自动进行跳转：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530375152204.png" srcset="/img/loading.gif" alt="1525958950616"></p><h1 id="2-Vuetify框架"><a href="#2-Vuetify框架" class="headerlink" title="2.Vuetify框架"></a>2.Vuetify框架</h1><h2 id="2-1-为什么要学习UI框架"><a href="#2-1-为什么要学习UI框架" class="headerlink" title="2.1.为什么要学习UI框架"></a>2.1.为什么要学习UI框架</h2><p>Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如：</p><ul><li>BootStrap</li><li>LayUI</li><li>EasyUI</li><li>ZUI</li></ul><p>然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。</p><p>而目前与Vue吻合的UI框架也非常的多，国内比较知名的如：</p><ul><li>element-ui：饿了么出品</li><li>i-view：某公司出品</li></ul><p>然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify</p><p>官方网站：<a href="https://vuetifyjs.com/zh-Hans/" target="_blank" rel="noopener">https://vuetifyjs.com/zh-Hans/</a></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525960652724.png" srcset="/img/loading.gif" alt="1525960652724"></p><h2 id="2-2-为什么是Vuetify"><a href="#2-2-为什么是Vuetify" class="headerlink" title="2.2.为什么是Vuetify"></a>2.2.为什么是Vuetify</h2><p>有中国的为什么还要用外国的？原因如下：</p><ul><li>Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写</li><li>Vuetify从底层构建起来的语义化组件。简单易学，容易记住。</li><li>Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一</li></ul><p>这是官网的说明：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530555978248.png" srcset="/img/loading.gif" alt="1530555978248"></p><p>缺陷：</p><ul><li>目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。</li></ul><h2 id="2-3-怎么用？"><a href="#2-3-怎么用？" class="headerlink" title="2.3.怎么用？"></a>2.3.怎么用？</h2><p>基于官方网站的文档进行学习：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525960312939.png" srcset="/img/loading.gif" alt="1525960312939"></p><p>我们重点关注<code>UI components</code>即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525961862771.png" srcset="/img/loading.gif" alt="1525961862771"></p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525961875288.png" srcset="/img/loading.gif" alt="1525961875288"></p><p>以后用到什么组件，就来查询即可。</p><h1 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3.项目结构"></a>3.项目结构</h1><p>开始编码前，我们先了解下项目的结构。</p><h2 id="3-1-目录结构"><a href="#3-1-目录结构" class="headerlink" title="3.1.目录结构"></a>3.1.目录结构</h2><p>首先是目录结构图：<img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525962755237.png" srcset="/img/loading.gif" alt="1525962755237"></p><h2 id="3-2-调用关系"><a href="#3-2-调用关系" class="headerlink" title="3.2.调用关系"></a>3.2.调用关系</h2><p>我们最主要理清index.html、main.js、App.vue之间的关系：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/%E4%B9%90%E4%BC%98/day06-%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525964023585.png" srcset="/img/loading.gif" alt="1525964023585"></p><p>理一下：</p><ul><li>index.html：html模板文件。定义了空的<code>div</code>，其id为<code>app</code>。</li><li>main.js：<strong>实例化vue对象</strong>，并且绑定通过id选择器，绑定到index.html的div中，因此<strong>main.js的内容都将在index.html的div中显示</strong>。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），所以，main.js也是<strong>webpack打包的入口</strong>。</li><li>index.js：定义请求路径和组件的映射关系。相当于之前的<code>&lt;vue-router&gt;</code></li><li>App.vue中也没有内容，而是定义了vue-router的锚点：<code>&lt;router-view&gt;</code>,我们之前讲过，vue-router路由后的组件将会在锚点展示。</li><li>最终结论：<strong>一切路由后的内容都将通过App.vue在index.html中显示。</strong></li><li>访问流程：用户在浏览器输入路径，例如：<a href="http://localhost:9001/#/item/brand" target="_blank" rel="noopener">http://localhost:9001/#/item/brand</a> –&gt; index.js(/item/brand路径对应pages/item/Brand.vue组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中）</li></ul><h2 id="3-3-页面布局"><a href="#3-3-页面布局" class="headerlink" title="3.3.页面布局"></a>3.3.页面布局</h2><p>接下来我们一起看下页面布局。</p><p>Layout组件是我们的整个页面的布局组件：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530380040278.png" srcset="/img/loading.gif" alt="1530380040278"></p><p>一个典型的三块布局。包含左，上，中三部分：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525965779366.png" srcset="/img/loading.gif" alt="1525965779366"></p><p>里面使用了Vuetify中的2个组件和一个布局元素：</p><ul><li><p><code>v-navigation-drawer</code> ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 </p><div class="hljs"><pre><code>![1530380237867](乐优商城/1530380237867.png)</code></pre></div></li><li><p><code>v-toolbar</code>：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530380292558.png" srcset="/img/loading.gif" alt="1530380292558"></p></li><li><p><code>v-content</code>：并不是一个组件，而是标记页面布局的元素。可以根据您指定的<strong>app</strong>组件的结构动态调整大小，使得您可以创建高度可定制的组件。</p></li></ul><p>那么问题来了：<code>v-content</code>中的内容来自哪里？</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525966180568.png" srcset="/img/loading.gif" alt="1525966180568"></p><ul><li>Layout映射的路径是<code>/</code></li><li>除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是<code>/</code>的下面</li><li>因此当路由到子组件时，会在Layout中定义的锚点中显示。</li><li>并且Layout中的其它部分不会变化，这就实现了布局的共享。</li></ul><h1 id="4-使用域名访问本地项目"><a href="#4-使用域名访问本地项目" class="headerlink" title="4.使用域名访问本地项目"></a>4.使用域名访问本地项目</h1><h2 id="4-1-统一环境"><a href="#4-1-统一环境" class="headerlink" title="4.1.统一环境"></a>4.1.统一环境</h2><p>我们现在访问页面使用的是：<a href="http://localhost:9001" target="_blank" rel="noopener">http://localhost:9001</a></p><p>有没有什么问题？</p><p>实际开发中，会有不同的环境：</p><ul><li>开发环境：自己的电脑</li><li>测试环境：提供给测试人员使用的环境</li><li>预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试</li><li>生产环境：项目最终发布上线的环境</li></ul><p>如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。</p><p>我们将使用以下域名：</p><ul><li>主域名是：<a href="http://www.leyou.com，" target="_blank" rel="noopener">www.leyou.com，</a></li><li>管理系统域名：manage.leyou.com</li><li>网关域名：api.leyou.com</li><li>…</li></ul><p>但是最终，我们希望这些域名指向的还是我们本机的某个端口。</p><p>那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？</p><h2 id="4-2-域名解析"><a href="#4-2-域名解析" class="headerlink" title="4.2.域名解析"></a>4.2.域名解析</h2><p>一个域名一定会被解析为一个或多个ip。这一般会包含两步：</p><ul><li><p>本地域名解析</p><p>浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。</p><ul><li>Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts</li><li>Linux下的hosts文件所在路径： /etc/hosts </li></ul><p>样式：</p><div class="hljs"><pre><code class="hljs accesslog"># My hosts<span class="hljs-number">127.0.0.1</span> localhost<span class="hljs-number">0.0.0.0</span> account.jetbrains.com<span class="hljs-number">127.0.0.1</span> www.xmind.net</code></pre></div></li><li><p>域名服务器解析</p><p>本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。</p></li></ul><h2 id="4-3-解决域名解析问题"><a href="#4-3-解决域名解析问题" class="headerlink" title="4.3.解决域名解析问题"></a>4.3.解决域名解析问题</h2><p>我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为：</p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> api.leyou.com<span class="hljs-number">127.0.0.1</span> manage.leyou.com</code></pre></div><p>这样就实现了域名的关系映射了。</p><p>每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530556073565.png" srcset="/img/loading.gif" alt="1530556073565"></p><p>解压，运行exe文件，效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530382550630.png" srcset="/img/loading.gif" alt="1530382550630"></p><p>我们添加了两个映射关系（中间用空格隔开）：</p><ul><li>127.0.0.1 api.leyou.com ：我们的网关Zuul</li><li>127.0.0.1 manage.leyou.com：我们的后台系统地址</li></ul><p>现在，ping一下域名试试是否畅通：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530382601757.png" srcset="/img/loading.gif" alt="1530382601757"></p><p>OK！</p><p>通过域名访问：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530383586463.png" srcset="/img/loading.gif" alt="1530383586463"></p><p>原因：我们配置了项目访问的路径，虽然manage.leyou.com映射的ip也是127.0.0.1，但是webpack会验证host是否符合配置。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530383612716.png" srcset="/img/loading.gif" alt="1530383612716"></p><p>在webpack.dev.conf.js中取消host验证：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530383927461.png" srcset="/img/loading.gif" alt="1530383927461"></p><p>重新执行<code>npm run dev</code>，刷新浏览器：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530384150852.png" srcset="/img/loading.gif" alt="1530384150852"></p><p>OK！</p><h2 id="4-4-nginx解决端口问题"><a href="#4-4-nginx解决端口问题" class="headerlink" title="4.4.nginx解决端口问题"></a>4.4.nginx解决端口问题</h2><p>域名问题解决了，但是现在要访问后台页面，还得自己加上端口：<code>http://manage.taotao.com:9001</code>。</p><p>这就不够优雅了。我们希望的是直接域名访问：<code>http://manage.taotao.com</code>。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？</p><p>这里就要用到反向代理工具：Nginx</p><h3 id="4-4-1-什么是Nginx"><a href="#4-4-1-什么是Nginx" class="headerlink" title="4.4.1.什么是Nginx"></a>4.4.1.什么是Nginx</h3><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526187409033.png" srcset="/img/loading.gif" alt="1526187409033"></p><p>nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能：</p><ul><li>反向代理</li><li>负载均衡</li><li>动态路由</li><li>请求过滤</li></ul><h3 id="4-4-2-nginx作为web服务器"><a href="#4-4-2-nginx作为web服务器" class="headerlink" title="4.4.2.nginx作为web服务器"></a>4.4.2.nginx作为web服务器</h3><p>Web服务器分2类：</p><ul><li>web应用服务器，如：<ul><li>tomcat</li><li>resin</li><li>jetty</li></ul></li><li>web服务器，如：<ul><li>Apache 服务器</li><li>Nginx</li><li>IIS</li></ul></li></ul><p>区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。<br>并发：web服务器的并发能力远高于web应用服务器。</p><h3 id="4-4-3-nginx作为反向代理"><a href="#4-4-3-nginx作为反向代理" class="headerlink" title="4.4.3.nginx作为反向代理"></a>4.4.3.nginx作为反向代理</h3><p>什么是反向代理？</p><ul><li>代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。</li><li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li></ul><p>nginx可以当做反向代理服务器来使用：</p><ul><li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li><li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li></ul><p>利用反向代理，就可以解决我们前面所说的端口问题，如图</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526016663674.png" srcset="/img/loading.gif" alt="1526016663674"></p><h3 id="4-4-4-安装和使用"><a href="#4-4-4-安装和使用" class="headerlink" title="4.4.4.安装和使用"></a>4.4.4.安装和使用</h3><blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote><p>安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/0C36B84E.gif" srcset="/img/loading.gif" alt="img"> </p><p>我们在本地安装一台nginx：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530556268445.png" srcset="/img/loading.gif" alt="1530556268445"></p><p>解压后，目录结构：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530384792790.png" srcset="/img/loading.gif" alt="1530384792790"></p><ol><li>conf：配置目录</li><li>contrib：第三方依赖</li><li>html：默认的静态资源目录，类似于tomcat的webapps</li><li>logs：日志目录</li><li>nginx.exe：启动程序。可双击运行，但不建议这么做。</li></ol><blockquote><h3 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h3></blockquote><p>示例：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526188831504.png" srcset="/img/loading.gif" alt="1526188831504"></p><p>nginx中的每个server就是一个反向代理配置，可以有多个server</p><p>完整配置：</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<span class="hljs-section">events</span> &#123;    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;&#125;<span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">include</span>       mime.types;    <span class="hljs-attribute">default_type</span>  application/octet-stream;    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;       <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;    <span class="hljs-attribute">gzip</span>  <span class="hljs-literal">on</span>;<span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  manage.leyou.com;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Server <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        <span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:9001;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;        &#125;    &#125;<span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;        <span class="hljs-attribute">server_name</span>  api.leyou.com;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Host <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Server <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        <span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:10010;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">600</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">600</span>;        &#125;    &#125;&#125;</code></pre></div><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></blockquote><p>nginx可以通过命令行来启动，操作命令：</p><ul><li>启动：<code>start nginx.exe</code></li><li>停止：<code>nginx.exe -s stop</code></li><li>重新加载：<code>nginx.exe -s reload</code></li></ul><p>启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530385404783.png" srcset="/img/loading.gif" alt="1530385404783"></p><h2 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5.测试"></a>4.5.测试</h2><p>启动nginx，然后用域名访问后台管理系统：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530385593052.png" srcset="/img/loading.gif" alt="1530385593052"></p><p>现在实现了域名访问网站了，中间的流程是怎样的呢？</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526189945180.png" srcset="/img/loading.gif" alt="1526189945180"></p><ol><li><p>浏览器准备发起请求，访问<a href="http://mamage.leyou.com，但需要进行域名解析" target="_blank" rel="noopener">http://mamage.leyou.com，但需要进行域名解析</a></p></li><li><p>优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1</p></li><li><p>请求被发往解析得到的ip，并且默认使用80端口：<a href="http://127.0.0.1:80" target="_blank" rel="noopener">http://127.0.0.1:80</a></p><p>本机的nginx一直监听80端口，因此捕获这个请求</p></li><li><p>nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发</p></li><li><p>后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx</p></li><li><p>nginx将得到的结果返回到浏览器</p></li></ol><h1 id="5-实现商品分类查询"><a href="#5-实现商品分类查询" class="headerlink" title="5.实现商品分类查询"></a>5.实现商品分类查询</h1><p>商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525999005260.png" srcset="/img/loading.gif" alt="1525999005260"></p><ul><li>一个商品分类下有很多商品</li><li>一个商品分类下有很多品牌</li><li>而一个品牌，可能属于不同的分类</li><li>一个品牌下也会有很多商品</li></ul><p>因此，我们需要依次去完成：商品分类、品牌、商品的开发。</p><h2 id="5-1-导入数据"><a href="#5-1-导入数据" class="headerlink" title="5.1.导入数据"></a>5.1.导入数据</h2><p>首先导入课前资料提供的sql：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530556389224.png" srcset="/img/loading.gif" alt="1530556389224"></p><p>我们先看商品分类表：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1525999774439.png" srcset="/img/loading.gif" alt="1525999774439"></p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_category&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;类目id&#39;,  &#96;name&#96; varchar(20) NOT NULL COMMENT &#39;类目名称&#39;,  &#96;parent_id&#96; bigint(20) NOT NULL COMMENT &#39;父类目id,顶级类目填0&#39;,  &#96;is_parent&#96; tinyint(1) NOT NULL COMMENT &#39;是否为父节点，0为否，1为是&#39;,  &#96;sort&#96; int(4) NOT NULL COMMENT &#39;排序指数，越小越靠前&#39;,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;key_parent_id&#96; (&#96;parent_id&#96;) USING BTREE) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1424 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&#39;;</code></pre></div><p>因为商品分类会有层级关系，因此这里我们加入了<code>parent_id</code>字段，对本表中的其它分类进行自关联。</p><h2 id="5-2-页面实现"><a href="#5-2-页面实现" class="headerlink" title="5.2.页面实现"></a>5.2.页面实现</h2><h3 id="5-2-1-页面分析"><a href="#5-2-1-页面分析" class="headerlink" title="5.2.1.页面分析"></a>5.2.1.页面分析</h3><p>首先我们看下要实现的效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530413709515.png" srcset="/img/loading.gif" alt="1530413709515"></p><p>商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。</p><p>一起来看页面，对应的是/pages/item/Category.vue：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530386186299.png" srcset="/img/loading.gif" alt="1530386186299"></p><p>页面模板：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-card</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">v-flex</span> <span class="hljs-attr">xs12</span> <span class="hljs-attr">sm10</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">v-tree</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/item/category/list"</span></span><span class="hljs-tag">                <span class="hljs-attr">:treeData</span>=<span class="hljs-string">"treeData"</span></span><span class="hljs-tag">                <span class="hljs-attr">:isEdit</span>=<span class="hljs-string">"isEdit"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleAdd</span>=<span class="hljs-string">"handleAdd"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleEdit</span>=<span class="hljs-string">"handleEdit"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleDelete</span>=<span class="hljs-string">"handleDelete"</span></span><span class="hljs-tag">                @<span class="hljs-attr">handleClick</span>=<span class="hljs-string">"handleClick"</span></span><span class="hljs-tag">        /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">v-flex</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">v-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><ul><li><p><code>v-card</code>：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526000692741.png" srcset="/img/loading.gif" alt="1526000692741"></p></li><li><p><code>v-flex</code>：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526001573140.png" srcset="/img/loading.gif" alt="1526001573140"></p><p>本例中，我们用<code>sm10</code>控制在小屏幕及以上时，显示宽度为10格</p></li><li><p><code>v-tree</code>：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件：</p><p>  <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526001762446.png" srcset="/img/loading.gif" alt="1526001762446"></p><p>里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。</p></li></ul><h3 id="5-2-2-树组件的用法"><a href="#5-2-2-树组件的用法" class="headerlink" title="5.2.2.树组件的用法"></a>5.2.2.树组件的用法</h3><p>也可参考课前资料中的：《自定义Vue组件的用法.md》</p><p>这里我贴出树组件的用法指南。</p><blockquote><p>属性列表：</p></blockquote><table><thead><tr><th align="left">属性名称</th><th align="left">说明</th><th align="left">数据类型</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">用来加载数据的地址，即延迟加载</td><td align="left">String</td><td align="left">-</td></tr><tr><td align="left">isEdit</td><td align="left">是否开启树的编辑功能</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">treeData</td><td align="left">整颗树数据，这样就不用远程加载了</td><td align="left">Array</td><td align="left">-</td></tr></tbody></table><p>这里推荐使用url进行延迟加载，<strong>每当点击父节点时，就会发起请求，根据父节点id查询子节点信息</strong>。</p><p>当有treeData属性时，就不会触发url加载</p><p>远程请求返回的结果格式：</p><div class="hljs"><pre><code class="hljs json">[    &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">74</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"手机"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">2</span>&#125;,     &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">75</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"家用电器"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">3</span>&#125;]</code></pre></div><blockquote><p>事件：</p></blockquote><table><thead><tr><th align="left">事件名称</th><th align="left">说明</th><th align="left">回调参数</th></tr></thead><tbody><tr><td align="left">handleAdd</td><td align="left">新增节点时触发，isEdit为true时有效</td><td align="left">新增节点node对象，包含属性：name、parentId和sort</td></tr><tr><td align="left">handleEdit</td><td align="left">当某个节点被编辑后触发，isEdit为true时有效</td><td align="left">被编辑节点的id和name</td></tr><tr><td align="left">handleDelete</td><td align="left">当删除节点时触发，isEdit为true时有效</td><td align="left">被删除节点的id</td></tr><tr><td align="left">handleClick</td><td align="left">点击某节点时触发</td><td align="left">被点击节点的node对象,包含完整的node信息</td></tr></tbody></table><blockquote><p>完整node的信息</p></blockquote><p>回调函数中返回完整的node节点会包含以下数据：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">76</span>, <span class="hljs-comment">// 节点id</span>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"手机"</span>, <span class="hljs-comment">// 节点名称</span>    <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">75</span>, <span class="hljs-comment">// 父节点id</span>    <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否是父节点</span>    <span class="hljs-attr">"sort"</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 顺序</span>    <span class="hljs-attr">"path"</span>: [<span class="hljs-string">"手机"</span>, <span class="hljs-string">"手机通讯"</span>, <span class="hljs-string">"手机"</span>] <span class="hljs-comment">// 所有父节点的名称数组</span>&#125;</code></pre></div><h2 id="5-3-实现功能"><a href="#5-3-实现功能" class="headerlink" title="5.3.实现功能"></a>5.3.实现功能</h2><h3 id="5-3-1-url异步请求"><a href="#5-3-1-url异步请求" class="headerlink" title="5.3.1.url异步请求"></a>5.3.1.url异步请求</h3><p>给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-tree</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/item/category/list"</span></span><span class="hljs-tag">        <span class="hljs-attr">:isEdit</span>=<span class="hljs-string">"isEdit"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleAdd</span>=<span class="hljs-string">"handleAdd"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleEdit</span>=<span class="hljs-string">"handleEdit"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleDelete</span>=<span class="hljs-string">"handleDelete"</span></span><span class="hljs-tag">        @<span class="hljs-attr">handleClick</span>=<span class="hljs-string">"handleClick"</span></span><span class="hljs-tag">        /&gt;</span></code></pre></div><p>刷新页面，可以看到：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530427294644.png" srcset="/img/loading.gif" alt="1530427294644"></p><p>页面中的树没有了，并且发起了一条请求：<a href="http://localhost/api/item/category/list?pid=0" target="_blank" rel="noopener">http://localhost/api/item/category/list?pid=0</a> </p><p>大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是：</p><p><a href="http://manage.leyou.com/item/category/list" target="_blank" rel="noopener">http://manage.leyou.com/item/category/list</a></p><p>但实际却是：</p><p><a href="http://localhost/api/item/category/list?pid=0" target="_blank" rel="noopener">http://localhost/api/item/category/list?pid=0</a> </p><p>这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530427514123.png" srcset="/img/loading.gif" alt="1530427514123"></p><p>路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名。</p><p>接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。</p><h3 id="5-3-2-实体类"><a href="#5-3-2-实体类" class="headerlink" title="5.3.2.实体类"></a>5.3.2.实体类</h3><p>在<code>ly-item-interface</code>中添加category实体类：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530444682670.png" srcset="/img/loading.gif" alt="1530444682670"></p><p>内容：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_category"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Category</span> </span>&#123;<span class="hljs-meta">@Id</span><span class="hljs-meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)<span class="hljs-keyword">private</span> Long id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> Long parentId;<span class="hljs-keyword">private</span> Boolean isParent; <span class="hljs-comment">// 注意isParent生成的getter和setter方法需要手动加上Is</span><span class="hljs-keyword">private</span> Integer sort;<span class="hljs-comment">// getter和setter略</span>&#125;</code></pre></div><p>需要注意的是，这里要用到jpa的注解，因此我们在<code>ly-item-iterface</code>中添加jpa依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.persistence<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>persistence-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="5-3-3-controller"><a href="#5-3-3-controller" class="headerlink" title="5.3.3.controller"></a>5.3.3.controller</h3><p>编写一个controller一般需要知道四个内容：</p><ul><li>请求方式：决定我们用GetMapping还是PostMapping</li><li>请求路径：决定映射路径</li><li>请求参数：决定方法的参数</li><li>返回值结果：决定方法的返回值</li></ul><p>在刚才页面发起的请求中，我们就能得到绝大多数信息：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530445885707.png" srcset="/img/loading.gif" alt="1530445885707"></p><ul><li><p>请求方式：Get</p></li><li><p>请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list</p></li><li><p>请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目</p></li><li><p>返回结果：？？</p><p>根据前面tree组件的用法我们知道，返回的应该是json数组：</p><div class="hljs"><pre><code class="hljs json">[    &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">74</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"手机"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">2</span>&#125;,     &#123;         <span class="hljs-attr">"id"</span>: <span class="hljs-number">75</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"家用电器"</span>,        <span class="hljs-attr">"parentId"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"isParent"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"sort"</span>: <span class="hljs-number">3</span>&#125;]</code></pre></div><p>对应的java类型可以是List集合，里面的元素就是类目对象了。也就是<code>List&lt;Category&gt;</code></p></li></ul><p>添加Controller：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530450599897.png" srcset="/img/loading.gif" alt="1530450599897"></p><p>controller代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"category"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CategoryService categoryService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据parentId查询类目</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pid</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"list"</span>)    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryListByParentId(<span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"pid"</span>, defaultValue = <span class="hljs-string">"0"</span>) Long pid) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (pid == <span class="hljs-keyword">null</span> || pid.longValue() &lt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// pid为null或者小于等于0，响应400</span>                <span class="hljs-keyword">return</span> ResponseEntity.badRequest().build();            &#125;            <span class="hljs-comment">// 执行查询操作</span>            List&lt;Category&gt; categoryList = <span class="hljs-keyword">this</span>.categoryService.queryCategoryListByParentId(pid);            <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(categoryList))&#123;                <span class="hljs-comment">// 返回结果集为空，响应404</span>                <span class="hljs-keyword">return</span> ResponseEntity.notFound().build();            &#125;            <span class="hljs-comment">// 响应200</span>            <span class="hljs-keyword">return</span> ResponseEntity.ok(categoryList);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">// 响应500</span>        <span class="hljs-keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    &#125;&#125;</code></pre></div><h3 id="5-3-4-service"><a href="#5-3-4-service" class="headerlink" title="5.3.4.service"></a>5.3.4.service</h3><p>一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530450744567.png" srcset="/img/loading.gif" alt="1530450744567"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> CategoryMapper categoryMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据parentId查询子类目</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pid</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Category&gt; <span class="hljs-title">queryCategoryListByParentId</span><span class="hljs-params">(Long pid)</span> </span>&#123;        Category record = <span class="hljs-keyword">new</span> Category();        record.setParentId(pid);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.categoryMapper.select(record);    &#125;&#125;</code></pre></div><h3 id="5-3-5-mapper"><a href="#5-3-5-mapper" class="headerlink" title="5.3.5.mapper"></a>5.3.5.mapper</h3><p>我们使用通用mapper来简化开发：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Category</span>&gt; </span>&#123;&#125;</code></pre></div><p>要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？</p><p>我们在启动类上添加一个扫描包功能：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">"com.leyou.item.mapper"</span>) <span class="hljs-comment">// mapper接口的包扫描</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeyouItemServiceApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(LeyouItemServiceApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="5-3-6-启动并测试"><a href="#5-3-6-启动并测试" class="headerlink" title="5.3.6.启动并测试"></a>5.3.6.启动并测试</h3><p>我们不经过网关，直接访问：<a href="http://localhost:8081/category/list" target="_blank" rel="noopener">http://localhost:8081/category/list</a></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530455133230.png" srcset="/img/loading.gif" alt="1530455133230"></p><p>然后试试网关是否畅通：<a href="http://api.leyou.com/api/item/category/list" target="_blank" rel="noopener">http://api.leyou.com/api/item/category/list</a></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530455291468.png" srcset="/img/loading.gif" alt="1530455291468"></p><p>一切OK！</p><p>然后刷新后台管理页面查看：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530455437899.png" srcset="/img/loading.gif" alt="1530455437899"></p><p>发现报错了！</p><p>浏览器直接访问没事，但是这里却报错，什么原因？</p><h1 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6.跨域问题"></a>6.跨域问题</h1><p>跨域：浏览器对于javascript的同源策略的限制 。</p><p>以下情况都属于跨域：</p><table><thead><tr><th>跨域原因说明</th><th>示例</th></tr></thead><tbody><tr><td>域名不同</td><td><code>www.jd.com</code> 与 <code>www.taobao.com</code></td></tr><tr><td>域名相同，端口不同</td><td><code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code></td></tr><tr><td>二级域名不同</td><td><code>item.jd.com</code> 与 <code>miaosha.jd.com</code></td></tr></tbody></table><p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p><p><code>www.jd.com/item</code> </p><p><code>www.jd.com/goods</code></p><p>而我们刚才是从<code>manage.leyou.com</code>去访问<code>api.leyou.com</code>，这属于二级域名不同，跨域了。</p><h2 id="6-1-为什么有跨域问题？"><a href="#6-1-为什么有跨域问题？" class="headerlink" title="6.1.为什么有跨域问题？"></a>6.1.为什么有跨域问题？</h2><p>跨域不一定会有跨域问题。</p><p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是与当前页域名相同的路径</strong>，这能有效的阻止跨站攻击。</p><p>因此：<strong>跨域问题 是针对ajax的一种限制</strong>。</p><p>但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p><h2 id="6-2-解决跨域问题的方案"><a href="#6-2-解决跨域问题的方案" class="headerlink" title="6.2.解决跨域问题的方案"></a>6.2.解决跨域问题的方案</h2><p>目前比较常用的跨域解决方案有3种：</p><ul><li><p>Jsonp</p><p>最早的解决方案，利用script标签可以跨域的原理实现。</p><p>限制：</p><ul><li>需要服务的支持</li><li>只能发起GET请求</li></ul></li><li><p>nginx反向代理</p><p>思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式</p><p>缺点：需要在nginx进行额外配置，语义不清晰</p></li><li><p>CORS</p><p>规范化的跨域请求解决方案，安全可靠。</p><p>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul></li></ul><p>我们这里会采用<strong>cors的跨域方案</strong>。</p><h2 id="6-3-cors解决跨域"><a href="#6-3-cors解决跨域" class="headerlink" title="6.3.cors解决跨域"></a>6.3.cors解决跨域</h2><h3 id="6-3-1-什么是cors"><a href="#6-3-1-什么是cors" class="headerlink" title="6.3.1.什么是cors"></a>6.3.1.什么是cors</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><ul><li><p>浏览器端：</p><p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p></li><li><p>服务端：</p><p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p></li></ul><h3 id="6-3-2-原理有点复杂"><a href="#6-3-2-原理有点复杂" class="headerlink" title="6.3.2.原理有点复杂"></a>6.3.2.原理有点复杂</h3><p>浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。</p><h4 id="6-3-2-1-简单请求"><a href="#6-3-2-1-简单请求" class="headerlink" title="6.3.2.1.简单请求"></a>6.3.2.1.简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。：</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><p>当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：<code>Origin</code>.</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530460311064.png" srcset="/img/loading.gif" alt="1530460311064"></p><p>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p><p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com<span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true<span class="hljs-attribute">Content-Type</span>: text/html; charset=utf-8</code></pre></div><ul><li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li><li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li></ul><blockquote><p>有关cookie：</p></blockquote><p>要想操作cookie，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax需要指定withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><h4 id="6-3-2-2-特殊请求"><a href="#6-3-2-2-特殊请求" class="headerlink" title="6.3.2.2.特殊请求"></a>6.3.2.2.特殊请求</h4><p>不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。</p><blockquote><p>预检请求</p></blockquote><p>特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>一个“预检”请求的样板：</p><div class="hljs"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/cors</span> HTTP/1.1<span class="hljs-attribute">Origin</span>: http://manage.leyou.com<span class="hljs-attribute">Access-Control-Request-Method</span>: PUT<span class="hljs-attribute">Access-Control-Request-Headers</span>: X-Custom-Header<span class="hljs-attribute">Host</span>: api.leyou.com<span class="hljs-attribute">Accept-Language</span>: en-US<span class="hljs-attribute">Connection</span>: keep-alive<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0...</code></pre></div><p>与简单请求相比，除了Origin以外，多了两个头：</p><ul><li>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</li><li>Access-Control-Request-Headers：会额外用到的头信息</li></ul><blockquote><p>预检请求的响应</p></blockquote><p>服务的收到预检请求，如果许可跨域，会发出响应：</p><div class="hljs"><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">200</span> OK<span class="hljs-attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT<span class="hljs-attribute">Server</span>: Apache/2.0.61 (Unix)<span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com<span class="hljs-attribute">Access-Control-Allow-Credentials</span>: true<span class="hljs-attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT<span class="hljs-attribute">Access-Control-Allow-Headers</span>: X-Custom-Header<span class="hljs-attribute">Access-Control-Max-Age</span>: 1728000<span class="hljs-attribute">Content-Type</span>: text/html; charset=utf-8<span class="hljs-attribute">Content-Encoding</span>: gzip<span class="hljs-attribute">Content-Length</span>: 0<span class="hljs-attribute">Keep-Alive</span>: timeout=2, max=100<span class="hljs-attribute">Connection</span>: Keep-Alive<span class="hljs-attribute">Content-Type</span>: text/plain</code></pre></div><p>除了<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li></ul><p>如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。</p><h3 id="6-3-3-实现非常简单"><a href="#6-3-3-实现非常简单" class="headerlink" title="6.3.3.实现非常简单"></a>6.3.3.实现非常简单</h3><p>虽然原理比较复杂，但是前面说过：</p><ul><li>浏览器端都有浏览器自动完成，我们无需操心</li><li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li></ul><p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p><p>在<code>leyou-gateway</code>中编写一个配置类，并且注册CorsFilter：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.web.cors.CorsConfiguration;<span class="hljs-keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;<span class="hljs-keyword">import</span> org.springframework.web.filter.CorsFilter;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1.添加CORS配置信息</span>        CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();        <span class="hljs-comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span>        config.addAllowedOrigin(<span class="hljs-string">"http://manage.leyou.com"</span>);        <span class="hljs-comment">//2) 是否发送Cookie信息</span>        config.setAllowCredentials(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//3) 允许的请求方式</span>        config.addAllowedMethod(<span class="hljs-string">"OPTIONS"</span>);        config.addAllowedMethod(<span class="hljs-string">"HEAD"</span>);        config.addAllowedMethod(<span class="hljs-string">"GET"</span>);        config.addAllowedMethod(<span class="hljs-string">"PUT"</span>);        config.addAllowedMethod(<span class="hljs-string">"POST"</span>);        config.addAllowedMethod(<span class="hljs-string">"DELETE"</span>);        config.addAllowedMethod(<span class="hljs-string">"PATCH"</span>);        <span class="hljs-comment">// 4）允许的头信息</span>        config.addAllowedHeader(<span class="hljs-string">"*"</span>);        <span class="hljs-comment">//2.添加映射路径，我们拦截一切请求</span>        UrlBasedCorsConfigurationSource configSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();        configSource.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, config);        <span class="hljs-comment">//3.返回新的CorsFilter.</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(configSource);    &#125;&#125;</code></pre></div><p>结构：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530462650711.png" srcset="/img/loading.gif" alt="1530462650711"></p><p>重启测试，访问正常：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530463010927.png" srcset="/img/loading.gif" alt="1530463010927"></p><p>分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。</p><h1 id="7-从0开始品牌的查询"><a href="#7-从0开始品牌的查询" class="headerlink" title="7.从0开始品牌的查询"></a>7.从0开始品牌的查询</h1><p>商品分类完成以后，自然轮到了品牌功能了。</p><p>先看看我们要实现的效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526021968036.png" srcset="/img/loading.gif" alt="1526021968036"></p><p>接下来，我们从0开始，实现下从前端到后端的完整开发。</p><h2 id="7-1-设计前端页面"><a href="#7-1-设计前端页面" class="headerlink" title="7.1.设计前端页面"></a>7.1.设计前端页面</h2><p>为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530464178834.png" srcset="/img/loading.gif" alt="1530464178834"></p><p>内容初始化一下：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;span&gt;    hello  &lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    name: &quot;myBrand&quot;  &#125;&lt;&#x2F;script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>改变router新的index.js，将路由地址指向MyBrand.vue</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530464255544.png" srcset="/img/loading.gif" alt="1530464255544"></p><p>打开服务器，再次查看页面：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530464304721.png" srcset="/img/loading.gif" alt="1530464304721"></p><p>干干净净了。只剩hello</p><h3 id="7-1-1-查询表格"><a href="#7-1-1-查询表格" class="headerlink" title="7.1.1.查询表格"></a>7.1.1.查询表格</h3><p>大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526023540226.png" srcset="/img/loading.gif" alt="1526023540226"></p><p>仔细阅读，发现<code>v-data-table</code>中有以下核心属性：</p><ul><li><p>dark：是否使用黑暗色彩主题，默认是false</p></li><li><p>expand：表格的行是否可以展开，默认是false</p></li><li><p>headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构：</p><div class="hljs"><pre><code class="hljs js">&#123;  text: string, <span class="hljs-comment">// 表头的显示文本</span>  value: string, <span class="hljs-comment">// 表头对应的每行数据的key</span>  align: <span class="hljs-string">'left'</span> | <span class="hljs-string">'center'</span> | <span class="hljs-string">'right'</span>, <span class="hljs-comment">// 位置</span>  sortable: boolean, <span class="hljs-comment">// 是否可排序</span>  class: string[] | string,// 样式  width: string,<span class="hljs-comment">// 宽度</span>&#125;</code></pre></div></li><li><p>items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致</p></li><li><p>loading：是否显示加载数据的进度条，默认是false</p></li><li><p>no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值</p></li><li><p>pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构：</p><div class="hljs"><pre><code class="hljs js">&#123;    page: <span class="hljs-number">1</span>, <span class="hljs-comment">// 当前页</span>    rowsPerPage: <span class="hljs-number">5</span>, <span class="hljs-comment">// 每页大小</span>    sortBy: <span class="hljs-string">''</span>, <span class="hljs-comment">// 排序字段</span>    descending:<span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否降序</span>&#125;</code></pre></div></li><li><p>total-items：分页的总条数信息，number类型，无默认值</p></li><li><p>select-all ：是否显示每一行的复选框，Boolean类型，无默认值</p></li><li><p>value：当表格可选的时候，返回选中的行</p></li></ul><p>我们向下翻，找找有没有看起来牛逼的案例。</p><p>找到这样一条：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526023837773.png" srcset="/img/loading.gif" alt="1526023837773"></p><p>其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。</p><p>点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中</p><p>模板：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;desserts&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalDesserts&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><h3 id="7-1-2-表格分析"><a href="#7-1-2-表格分析" class="headerlink" title="7.1.2.表格分析"></a>7.1.2.表格分析</h3><p>接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。</p><p>先看模板中table上的一些属性：</p><div class="hljs"><pre><code class="hljs vue">&lt;v-data-table              :headers&#x3D;&quot;headers&quot;              :items&#x3D;&quot;desserts&quot;              :pagination.sync&#x3D;&quot;pagination&quot;              :total-items&#x3D;&quot;totalDesserts&quot;              :loading&#x3D;&quot;loading&quot;              class&#x3D;&quot;elevation-1&quot;              &gt;&lt;&#x2F;v-data-table&gt;</code></pre></div><ul><li><p>headers：表头信息，是一个数组</p></li><li><p>items：要在表格中展示的数据，数组结构，每一个元素是一行。在这里应该是品牌集合</p></li><li><p>pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。</p></li><li><p>total-items：总条数，在这里是品牌的总记录数</p></li><li><p>loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526029254159.png" srcset="/img/loading.gif" alt="1526029254159"></p></li></ul><p>另外，在<code>v-data-tables</code>中，我们还看到另一段代码：</p><div class="hljs"><pre><code class="hljs vue">&lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;&#x2F;td&gt;&lt;&#x2F;template&gt;</code></pre></div><p>这段就是在渲染每一行的数据。Vue会自动遍历上面传递的<code>items</code>属性，并把得到的对象传递给这段<code>template</code>中的<code>props.item</code>属性。我们从中得到数据，渲染在页面即可。</p><p>我们需要做的事情，主要有两件：</p><ul><li>给items和totalItems赋值</li><li>当pagination变化时，重新获取数据，再次给items和totalItems赋值</li></ul><h3 id="7-1-3-动手实现"><a href="#7-1-3-动手实现" class="headerlink" title="7.1.3.动手实现"></a>7.1.3.动手实现</h3><p>表格中具体有哪些列呢？参照品牌表：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530518876942.png" srcset="/img/loading.gif" alt="1530518876942"></p><p>品牌中有id,name,image,letter字段。</p><h4 id="7-1-3-1-修改模板"><a href="#7-1-3-1-修改模板" class="headerlink" title="7.1.3.1.修改模板"></a>7.1.3.1.修改模板</h4><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;brands&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalBrands&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img v-if&#x3D;&quot;props.item.image&quot; :src&#x3D;&quot;props.item.image&quot; width&#x3D;&quot;130&quot; height&#x3D;&quot;40&quot;&#x2F;&gt;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><p>我们修改了以下部分：</p><ul><li>items：指向一个brands变量，等下在js代码中定义</li><li>total-items：指向了totalBrands变量，等下在js代码中定义</li><li>template模板中，渲染了四个字段：<ul><li>id：</li><li>name</li><li>image，注意，我们不是以文本渲染，而是赋值到一个<code>img</code>标签的src属性中，并且做了非空判断</li><li>letter</li></ul></li></ul><h4 id="7-1-3-2-编写数据模型"><a href="#7-1-3-2-编写数据模型" class="headerlink" title="7.1.3.2.编写数据模型"></a>7.1.3.2.编写数据模型</h4><p>接下来编写要用到的数据：</p><div class="hljs"><pre><code class="hljs js">data () &#123;  <span class="hljs-keyword">return</span> &#123;    totalBrands: <span class="hljs-number">0</span>, <span class="hljs-comment">// 总条数</span>    brands: [], <span class="hljs-comment">// 当前页品牌数据</span>    loading: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在加载中</span>    pagination: &#123;&#125;, <span class="hljs-comment">// 分页信息</span>    headers: [ <span class="hljs-comment">// 头信息</span>      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'名称'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'name'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'LOGO'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'image'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首字母'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'letter'</span>&#125;,    ]  &#125;&#125;</code></pre></div><h4 id="7-1-3-3-数据初始化"><a href="#7-1-3-3-数据初始化" class="headerlink" title="7.1.3.3.数据初始化"></a>7.1.3.3.数据初始化</h4><p>接下来就是对brands和totalBrands完成赋值动作了。</p><p>我们编写一个函数来完成赋值，提高复用性：</p><div class="hljs"><pre><code class="hljs js">methods: &#123;  getDataFromServer()&#123; <span class="hljs-comment">// 从服务端加载数据的函数</span>    <span class="hljs-comment">// 伪造演示数据</span>    <span class="hljs-keyword">const</span> brands = [      &#123;        <span class="hljs-string">"id"</span>: <span class="hljs-number">2032</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"OPPO"</span>,        <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg"</span>,        <span class="hljs-string">"letter"</span>: <span class="hljs-string">"O"</span>,        <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>      &#125;,      &#123;        <span class="hljs-string">"id"</span>: <span class="hljs-number">2033</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"飞利浦（PHILIPS）"</span>,        <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg"</span>,        <span class="hljs-string">"letter"</span>: <span class="hljs-string">"F"</span>,        <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>      &#125;,      &#123;        <span class="hljs-string">"id"</span>: <span class="hljs-number">2034</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"华为（HUAWEI）"</span>,        <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg"</span>,        <span class="hljs-string">"letter"</span>: <span class="hljs-string">"H"</span>,        <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>      &#125;,      &#123;        <span class="hljs-string">"id"</span>: <span class="hljs-number">2036</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"酷派（Coolpad）"</span>,        <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg"</span>,        <span class="hljs-string">"letter"</span>: <span class="hljs-string">"K"</span>,        <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>      &#125;,      &#123;        <span class="hljs-string">"id"</span>: <span class="hljs-number">2037</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"魅族（MEIZU）"</span>,        <span class="hljs-string">"image"</span>: <span class="hljs-string">"http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg"</span>,        <span class="hljs-string">"letter"</span>: <span class="hljs-string">"M"</span>,        <span class="hljs-string">"categories"</span>: <span class="hljs-literal">null</span>      &#125;    ];    <span class="hljs-comment">// 延迟一段时间，模拟数据请求时间</span>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;      <span class="hljs-keyword">this</span>.brands = brands; <span class="hljs-comment">// 赋值给品牌数组</span>      <span class="hljs-keyword">this</span>.totalBrands = brands.length; <span class="hljs-comment">// 赋值数据总条数</span>      <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 数据加载完成</span>    &#125;, <span class="hljs-number">1000</span>);  &#125;&#125;</code></pre></div><p>然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 渲染后执行</span>mounted()&#123;  <span class="hljs-keyword">this</span>.getDataFromServer() <span class="hljs-comment">// 调用数据初始化函数</span>&#125;</code></pre></div><h4 id="6-2-3-4-完整代码"><a href="#6-2-3-4-完整代码" class="headerlink" title="6.2.3.4.完整代码"></a>6.2.3.4.完整代码</h4><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;brands&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalBrands&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img v-if&#x3D;&quot;props.item.image&quot; :src&#x3D;&quot;props.item.image&quot; width&#x3D;&quot;130&quot; height&#x3D;&quot;40&quot;&#x2F;&gt;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    name: &quot;myBrand&quot;,    data () &#123;      return &#123;        totalBrands: 0, &#x2F;&#x2F; 总条数        brands: [], &#x2F;&#x2F; 当前页品牌数据        loading: true, &#x2F;&#x2F; 是否在加载中        pagination: &#123;&#125;, &#x2F;&#x2F; 分页信息        headers: [ &#x2F;&#x2F; 头信息          &#123;text: &#39;id&#39;, align: &#39;center&#39;, value: &#39;id&#39;&#125;,          &#123;text: &#39;名称&#39;, align: &#39;center&#39;, value: &#39;name&#39;, sortable: false&#125;,          &#123;text: &#39;LOGO&#39;, align: &#39;center&#39;, value: &#39;image&#39;, sortable: false&#125;,          &#123;text: &#39;首字母&#39;, align: &#39;center&#39;, value: &#39;letter&#39;&#125;,        ]      &#125;    &#125;,    methods: &#123;      getDataFromServer()&#123; &#x2F;&#x2F; 从服务端加载数据的函数        &#x2F;&#x2F; 伪造演示数据        const brands &#x3D; [          &#123;            &quot;id&quot;: 2032,            &quot;name&quot;: &quot;OPPO&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img10.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t2119&#x2F;133&#x2F;2264148064&#x2F;4303&#x2F;b8ab3755&#x2F;56b2f385N8e4eb051.jpg&quot;,            &quot;letter&quot;: &quot;O&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2033,            &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img12.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t18361&#x2F;122&#x2F;1318410299&#x2F;1870&#x2F;36fe70c9&#x2F;5ac43a4dNa44a0ce0.jpg&quot;,            &quot;letter&quot;: &quot;F&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2034,            &quot;name&quot;: &quot;华为（HUAWEI）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img10.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t5662&#x2F;36&#x2F;8888655583&#x2F;7806&#x2F;1c629c01&#x2F;598033b4Nd6055897.jpg&quot;,            &quot;letter&quot;: &quot;H&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2036,            &quot;name&quot;: &quot;酷派（Coolpad）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img10.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t2521&#x2F;347&#x2F;883897149&#x2F;3732&#x2F;91c917ec&#x2F;5670cf96Ncffa2ae6.jpg&quot;,            &quot;letter&quot;: &quot;K&quot;,            &quot;categories&quot;: null          &#125;,          &#123;            &quot;id&quot;: 2037,            &quot;name&quot;: &quot;魅族（MEIZU）&quot;,            &quot;image&quot;: &quot;http:&#x2F;&#x2F;img13.360buyimg.com&#x2F;popshop&#x2F;jfs&#x2F;t3511&#x2F;131&#x2F;31887105&#x2F;4943&#x2F;48f83fa9&#x2F;57fdf4b8N6e95624d.jpg&quot;,            &quot;letter&quot;: &quot;M&quot;,            &quot;categories&quot;: null          &#125;        ];        &#x2F;&#x2F; 延迟一段时间，模拟数据请求时间        setTimeout(()&#x3D;&gt;&#123;          this.brands &#x3D; brands; &#x2F;&#x2F; 赋值给品牌数组          this.totalBrands &#x3D; brands.length; &#x2F;&#x2F; 赋值数据总条数          this.loading &#x3D; false; &#x2F;&#x2F; 数据加载完成        &#125;, 1000);      &#125;    &#125;,    &#x2F;&#x2F; 渲染后执行    mounted()&#123;      this.getDataFromServer() &#x2F;&#x2F; 调用数据初始化函数    &#125;  &#125;&lt;&#x2F;script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>刷新页面查看：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/%E4%B9%90%E4%BC%98/day06-%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526029445561.png" srcset="/img/loading.gif" alt="1526029445561"></p><h3 id="7-1-4-优化页面"><a href="#7-1-4-优化页面" class="headerlink" title="7.1.4.优化页面"></a>7.1.4.优化页面</h3><h4 id="7-1-4-1-编辑和删除按钮"><a href="#7-1-4-1-编辑和删除按钮" class="headerlink" title="7.1.4.1.编辑和删除按钮"></a>7.1.4.1.编辑和删除按钮</h4><p>我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列。</p><p>其实就是多了一列，只是这一列没有数据，而是两个按钮而已。可以在官方文档中找一个带有操作按钮的表格，作为参考。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530523252532.png" srcset="/img/loading.gif" alt="1530523252532"></p><p>我们先在头（headers）中添加一列：</p><div class="hljs"><pre><code class="hljs js">headers: [ <span class="hljs-comment">// 头信息</span>    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'名称'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'name'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'LOGO'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'image'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首字母'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'letter'</span>&#125;,    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'操作'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span> &#125;]</code></pre></div><p>然后在模板中添加按钮：</p><div class="hljs"><pre><code class="hljs vue">&lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;&lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img v-if&#x3D;&quot;props.item.image&quot; :src&#x3D;&quot;props.item.image&quot; width&#x3D;&quot;130&quot; height&#x3D;&quot;40&quot;&#x2F;&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;text-xs-center&quot;&gt;        &lt;v-icon small class&#x3D;&quot;mr-2&quot; @click&#x3D;&quot;editItem(props.item)&quot;&gt;            edit        &lt;&#x2F;v-icon&gt;        &lt;v-icon small @click&#x3D;&quot;deleteItem(props.item)&quot;&gt;            delete        &lt;&#x2F;v-icon&gt;    &lt;&#x2F;td&gt;&lt;&#x2F;template&gt;</code></pre></div><p>效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530523838357.png" srcset="/img/loading.gif" alt="1530523838357"></p><h4 id="7-1-4-2-新增按钮"><a href="#7-1-4-2-新增按钮" class="headerlink" title="7.1.4.2.新增按钮"></a>7.1.4.2.新增按钮</h4><p>在官方文档中找到按钮的用法：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530524238344.png" srcset="/img/loading.gif" alt="1530524238344"></p><p>因为新增跟某个品牌无关，是独立的，因此我们可以放到表格的外面。</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530527129881.png" srcset="/img/loading.gif" alt="1530527129881"></p><p>效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530527160208.png" srcset="/img/loading.gif" alt="1530527160208"></p><h4 id="7-1-4-3-卡片（card）"><a href="#7-1-4-3-卡片（card）" class="headerlink" title="7.1.4.3.卡片（card）"></a>7.1.4.3.卡片（card）</h4><p>为了不让按钮显得过于孤立，我们可以将按<code>新增按钮</code>和<code>表格</code>放到一张卡片（card）中。</p><p>我们去官网查看卡片的用法：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526031159242.png" srcset="/img/loading.gif" alt="1526031159242"></p><p>卡片<code>v-card</code>包含四个基本组件：</p><ul><li>v-card-media：一般放图片或视频</li><li>v-card-title：卡片的标题，一般位于卡片顶部</li><li>v-card-text：卡片的文本（主体内容），一般位于卡片正中</li><li>v-card-action：卡片的按钮，一般位于卡片底部</li></ul><p>我们可以把<code>新增的按钮</code>放到<code>v-card-title</code>位置，把<code>table</code>放到下面，这样就成一个上下关系。</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;v-card&gt;    &lt;v-card-title flat color&#x3D;&quot;white&quot;&gt;      &lt;v-btn color&#x3D;&quot;primary&quot;&gt;新增&lt;&#x2F;v-btn&gt;    &lt;&#x2F;v-card-title&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;brands&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalBrands&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img v-if&#x3D;&quot;props.item.image&quot; :src&#x3D;&quot;props.item.image&quot; width&#x3D;&quot;130&quot; height&#x3D;&quot;40&quot;&#x2F;&gt;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;          &lt;v-icon small class&#x3D;&quot;mr-2&quot; @click&#x3D;&quot;editItem(props.item)&quot;&gt;            edit          &lt;&#x2F;v-icon&gt;          &lt;v-icon small @click&#x3D;&quot;deleteItem(props.item)&quot;&gt;            delete          &lt;&#x2F;v-icon&gt;        &lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;v-card&gt;&lt;&#x2F;template&gt;</code></pre></div><p>效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530532504861.png" srcset="/img/loading.gif" alt="1530532504861"></p><h4 id="7-1-4-4-添加搜索框"><a href="#7-1-4-4-添加搜索框" class="headerlink" title="7.1.4.4.添加搜索框"></a>7.1.4.4.添加搜索框</h4><p>我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。</p><p>查看官网中，文本框的用法：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526031897445.png" srcset="/img/loading.gif" alt="1526031897445"></p><ul><li>name：字段名，表单中会用到</li><li>label/placeholder：提示文字</li><li>value：值。可以用v-model代替，实现双向绑定</li></ul><p>修改模板，添加输入框：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>新增品牌<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>    <span class="hljs-comment">&lt;!--搜索框，与search属性关联--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span></code></pre></div><p>注意：要在数据模型中，添加search字段：</p><div class="hljs"><pre><code class="hljs js">data() &#123;  <span class="hljs-keyword">return</span> &#123;    totalBrands: <span class="hljs-number">0</span>, <span class="hljs-comment">// 总条数</span>    brands: [], <span class="hljs-comment">// 当前页品牌数据</span>    search: <span class="hljs-string">""</span>, <span class="hljs-comment">// 查询关键字</span>    loading: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在加载中</span>    pagination: &#123;&#125;, <span class="hljs-comment">// 分页信息</span>    headers: [ <span class="hljs-comment">// 头信息</span>      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'名称'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'name'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'LOGO'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'image'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首字母'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'letter'</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'操作'</span>, <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'id'</span>, <span class="hljs-attr">sortable</span>: <span class="hljs-literal">false</span>&#125;    ]  &#125;&#125;</code></pre></div><p>效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530533261856.png" srcset="/img/loading.gif" alt="1530533261856"></p><p>发现输入框超级长！！！</p><p>这个时候，我们可以使用Vuetify提供的一个空间隔离工具：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530533442878.png" srcset="/img/loading.gif" alt="1530533442878"></p><p>修改代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-card-title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>新增品牌<span class="hljs-tag">&lt;/<span class="hljs-name">v-btn</span>&gt;</span>  <span class="hljs-comment">&lt;!--空间隔离组件--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-spacer</span> /&gt;</span>  <span class="hljs-comment">&lt;!--搜索框，与search属性关联--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">v-card-title</span>&gt;</span></code></pre></div><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530534269196.png" srcset="/img/loading.gif" alt="1530534269196"></p><h4 id="7-1-4-5-添加搜索图标"><a href="#7-1-4-5-添加搜索图标" class="headerlink" title="7.1.4.5.添加搜索图标"></a>7.1.4.5.添加搜索图标</h4><p>查看textfiled的文档，发现：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526033007616.png" srcset="/img/loading.gif" alt="1526033007616"></p><p>通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 <a href="https://material.io/tools/icons/" target="_blank" rel="noopener">material-icons官网</a>去查看。</p><p>修改我们的代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">append-icon</span>=<span class="hljs-string">"search"</span>/&gt;</span></code></pre></div><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530534311458.png" srcset="/img/loading.gif" alt="1530534311458"></p><h4 id="7-1-4-6-把文本框变紧凑"><a href="#7-1-4-6-把文本框变紧凑" class="headerlink" title="7.1.4.6.把文本框变紧凑"></a>7.1.4.6.把文本框变紧凑</h4><p>搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526033439890.png" srcset="/img/loading.gif" alt="1526033439890"></p><p>修改代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">v-text-field</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"输入关键字搜索"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">append-icon</span>=<span class="hljs-string">"search"</span> <span class="hljs-attr">hide-details</span>/&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530534423194.png" srcset="/img/loading.gif" alt="1530534423194"></p><p>几乎已经达到了原来一样的效果了吧！</p><h2 id="7-2-后台提供查询接口"><a href="#7-2-后台提供查询接口" class="headerlink" title="7.2.后台提供查询接口"></a>7.2.后台提供查询接口</h2><p>前台页面已经准备好，接下来就是后台提供数据接口了。</p><h3 id="7-2-1-数据库表"><a href="#7-2-1-数据库表" class="headerlink" title="7.2.1.数据库表"></a>7.2.1.数据库表</h3><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_brand&#96; (  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;品牌id&#39;,  &#96;name&#96; varchar(50) NOT NULL COMMENT &#39;品牌名称&#39;,  &#96;image&#96; varchar(200) DEFAULT &#39;&#39; COMMENT &#39;品牌图片地址&#39;,  &#96;letter&#96; char(1) DEFAULT &#39;&#39; COMMENT &#39;品牌的首字母&#39;,  PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;325400 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;品牌表，一个品牌下有多个商品（spu），一对多关系&#39;;</code></pre></div><p>简单的四个字段，不多解释。</p><p>这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系：</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE &#96;tb_category_brand&#96; (  &#96;category_id&#96; bigint(20) NOT NULL COMMENT &#39;商品类目id&#39;,  &#96;brand_id&#96; bigint(20) NOT NULL COMMENT &#39;品牌id&#39;,  PRIMARY KEY (&#96;category_id&#96;,&#96;brand_id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;商品分类和品牌的中间表，两者是多对多关系&#39;;</code></pre></div><p>但是，你可能会发现，这张表中并<strong>没有设置外键约束</strong>，似乎与数据库的设计范式不符。为什么这么做？</p><ul><li>外键会严重影响数据库读写的效率</li><li>数据删除时会比较麻烦</li></ul><p>在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。</p><h3 id="7-2-2-实体类"><a href="#7-2-2-实体类" class="headerlink" title="7.2.2.实体类"></a>7.2.2.实体类</h3><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530541070271.png" srcset="/img/loading.gif" alt="1530541070271"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_brand"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brand</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 品牌名称</span>    <span class="hljs-keyword">private</span> String image;<span class="hljs-comment">// 品牌图片</span>    <span class="hljs-keyword">private</span> Character letter;    <span class="hljs-comment">// getter setter 略</span>&#125;</code></pre></div><h3 id="7-2-3-mapper"><a href="#7-2-3-mapper" class="headerlink" title="7.2.3.mapper"></a>7.2.3.mapper</h3><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530541222679.png" srcset="/img/loading.gif" alt="1530541222679"></p><p>通用mapper来简化开发：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BrandMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Brand</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="7-2-4-controller"><a href="#7-2-4-controller" class="headerlink" title="7.2.4.controller"></a>7.2.4.controller</h3><p>编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定</p><ul><li>请求方式：查询，肯定是Get</li><li>请求路径：分页查询，/brand/page</li><li>请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数：<ul><li>page：当前页，int</li><li>rows：每页大小，int</li><li>sortBy：排序字段，String</li><li>desc：是否为降序，boolean</li><li>key：搜索关键词，String</li></ul></li><li>响应结果：分页结果一般至少需要两个数据<ul><li>total：总条数</li><li>items：当前页数据</li><li>totalPage：有些还需要总页数</li></ul></li></ul><p>这里我们封装一个类，来表示分页结果：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageResult</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Long total;<span class="hljs-comment">// 总条数</span>    <span class="hljs-keyword">private</span> Long totalPage;<span class="hljs-comment">// 总页数</span>    <span class="hljs-keyword">private</span> List&lt;T&gt; items;<span class="hljs-comment">// 当前页数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">(Long total, List&lt;T&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.total = total;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">(Long total, Long totalPage, List&lt;T&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.total = total;        <span class="hljs-keyword">this</span>.totalPage = totalPage;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> total;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(Long total)</span> </span>&#123;        <span class="hljs-keyword">this</span>.total = total;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getItems</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItems</span><span class="hljs-params">(List&lt;T&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotalPage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> totalPage;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalPage</span><span class="hljs-params">(Long totalPage)</span> </span>&#123;        <span class="hljs-keyword">this</span>.totalPage = totalPage;    &#125;&#125;</code></pre></div><p>另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到<code>leyou-common</code>中，提高复用性：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530543778541.png" srcset="/img/loading.gif" alt="1530543778541"></p><p><strong>不要忘记在leyou-item-service工程的pom.xml中引入leyou-common的依赖</strong>：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.common<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>leyou-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>接下来，我们编写Controller</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530549253999.png" srcset="/img/loading.gif" alt="1530549253999"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"brand"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrandController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BrandService brandService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"page"</span>)    <span class="hljs-keyword">public</span> ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage(            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"page"</span>, defaultValue = <span class="hljs-string">"1"</span>) Integer page,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"rows"</span>, defaultValue = <span class="hljs-string">"5"</span>) Integer rows,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"sortBy"</span>, required = <span class="hljs-keyword">false</span>) String sortBy,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"desc"</span>, defaultValue = <span class="hljs-string">"false"</span>) Boolean desc,            <span class="hljs-meta">@RequestParam</span>(value = <span class="hljs-string">"key"</span>, required = <span class="hljs-keyword">false</span>) String key) &#123;        PageResult&lt;Brand&gt; result = <span class="hljs-keyword">this</span>.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key);        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result.getItems().size() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);        &#125;        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);    &#125;&#125;</code></pre></div><h3 id="7-2-5-Service"><a href="#7-2-5-Service" class="headerlink" title="7.2.5.Service"></a>7.2.5.Service</h3><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530549286718.png" srcset="/img/loading.gif" alt="1530549286718"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrandService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BrandMapper brandMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> PageResult&lt;Brand&gt; <span class="hljs-title">queryBrandByPageAndSort</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            Integer page, Integer rows, String sortBy, Boolean desc, String key)</span> </span>&#123;        <span class="hljs-comment">// 开始分页</span>        PageHelper.startPage(page, rows);        <span class="hljs-comment">// 过滤</span>        Example example = <span class="hljs-keyword">new</span> Example(Brand<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(key)) &#123;            example.createCriteria().andLike(<span class="hljs-string">"name"</span>, <span class="hljs-string">"%"</span> + key + <span class="hljs-string">"%"</span>)                    .orEqualTo(<span class="hljs-string">"letter"</span>, key);        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(sortBy)) &#123;            <span class="hljs-comment">// 排序</span>            String orderByClause = sortBy + (desc ? <span class="hljs-string">" DESC"</span> : <span class="hljs-string">" ASC"</span>);            example.setOrderByClause(orderByClause);        &#125;        <span class="hljs-comment">// 查询</span>        Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example);        <span class="hljs-comment">// 返回结果</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo);    &#125;&#125;</code></pre></div><h3 id="7-2-6-测试"><a href="#7-2-6-测试" class="headerlink" title="7.2.6.测试"></a>7.2.6.测试</h3><p>通过浏览器访问试试：<a href="http://api.leyou.com/api/item/brand/page" target="_blank" rel="noopener">http://api.leyou.com/api/item/brand/page</a></p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530549095150.png" srcset="/img/loading.gif" alt="1530549095150"></p><p>接下来，去页面请求数据并渲染</p><h2 id="7-3-异步查询工具axios"><a href="#7-3-异步查询工具axios" class="headerlink" title="7.3.异步查询工具axios"></a>7.3.异步查询工具axios</h2><p>异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。</p><h3 id="7-3-1-axios入门"><a href="#7-3-1-axios入门" class="headerlink" title="7.3.1.axios入门"></a>7.3.1.axios入门</h3><p>Vue官方推荐的ajax请求框架叫做：axios，看下demo：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526033988251.png" srcset="/img/loading.gif" alt="1526033988251"></p><p>axios的Get请求语法：</p><div class="hljs"><pre><code class="hljs js">axios.get(<span class="hljs-string">"/item/category/list?pid=0"</span>) <span class="hljs-comment">// 请求路径和请求参数拼接</span>    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;    <span class="hljs-comment">// 成功回调函数</span>&#125;)    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// 失败回调函数</span>&#125;)<span class="hljs-comment">// 参数较多时，可以通过params来传递参数</span>axios.get(<span class="hljs-string">"/item/category/list"</span>, &#123;        params:&#123;            pid:<span class="hljs-number">0</span>        &#125;&#125;)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;&#125;)<span class="hljs-comment">// 成功时的回调</span>    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;&#125;)<span class="hljs-comment">// 失败时的回调</span></code></pre></div><p>axios的POST请求语法：</p><p>比如新增一个用户</p><div class="hljs"><pre><code class="hljs js">axios.post(<span class="hljs-string">"/user"</span>,&#123;    name:<span class="hljs-string">"Jack"</span>,    age:<span class="hljs-number">21</span>&#125;)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>)</span>&#123;&#125;)    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;&#125;)</code></pre></div><ul><li>注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数</li></ul><p>PUT和DELETE请求与POST请求类似</p><h3 id="7-3-2-axios的全局配置"><a href="#7-3-2-axios的全局配置" class="headerlink" title="7.3.2.axios的全局配置"></a>7.3.2.axios的全局配置</h3><p>而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526034150067.png" srcset="/img/loading.gif" alt="1526034150067"></p><p>http.js中对axios进行了一些默认配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span><span class="hljs-comment">// config中定义的基础路径是：http://api.leyou.com/api</span>axios.defaults.baseURL = config.api; <span class="hljs-comment">// 设置axios的基础请求路径</span>axios.defaults.timeout = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 设置axios的请求时间</span>Vue.prototype.$http = axios;<span class="hljs-comment">// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象</span></code></pre></div><ul><li><p>http.js中导入了config的配置，还记得吗？</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526041205846.png" srcset="/img/loading.gif" alt="1526041205846"></p></li><li><p>http.js对axios进行了全局配置：<code>baseURL=config.api</code>，即<code>http://api.leyou.com/api</code>。因此以后所有用axios发起的请求，都会以这个地址作为前缀。</p></li><li><p>通过<code>Vue.property.$http = axios</code>，将<code>axios</code>赋值给了 Vue原型中的<code>$http</code>。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。</p></li></ul><h3 id="7-3-3-小试一下"><a href="#7-3-3-小试一下" class="headerlink" title="7.3.3.小试一下"></a>7.3.3.小试一下</h3><p>我们在组件<code>MyBrand.vue</code>的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526048079191.png" srcset="/img/loading.gif" alt="1526048221750"></p><p>网络监视：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526048143014.png" srcset="/img/loading.gif" alt="1526048143014"></p><p>resp到底都有那些数据，查看控制台结果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526048275064.png" srcset="/img/loading.gif" alt="1526048275064"></p><p>可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。</p><p>响应结果中与我们设计的一致，包含3个内容：</p><ul><li>total：总条数，目前是165</li><li>items：当前页数据</li><li>totalPage：总页数，我们没有返回</li></ul><h2 id="7-4-异步加载品牌数据"><a href="#7-4-异步加载品牌数据" class="headerlink" title="7.4.异步加载品牌数据"></a>7.4.异步加载品牌数据</h2><p>虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数：</p><ul><li>page：当前页，int</li><li>rows：每页大小，int</li><li>sortBy：排序字段，String</li><li>desc：是否为降序，boolean</li><li>key：搜索关键词，String</li></ul><p>而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530553414937.png" srcset="/img/loading.gif" alt="1530553414937"></p><p>分别是：</p><ul><li>descending：是否是降序，对应请求参数的desc</li><li>page：当前页，对应参数的page</li><li>rowsPerpage：每页大小，对应参数中的rows</li><li>sortBy：排序字段，对应参数的sortBy</li></ul><p>缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。</p><p>另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。</p><p>接下来，我们完善请求参数：</p><div class="hljs"><pre><code class="hljs js">methods: &#123;  getDataFromServer() &#123; <span class="hljs-comment">// 从服务端加载数据的函数</span>    <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 加载数据</span>    <span class="hljs-comment">// 通过axios获取数据</span>    <span class="hljs-keyword">this</span>.$http.get(<span class="hljs-string">"/item/brand/page"</span>, &#123;      params: &#123;        page: <span class="hljs-keyword">this</span>.pagination.page, <span class="hljs-comment">// 当前页</span>        rows: <span class="hljs-keyword">this</span>.pagination.rowsPerPage, <span class="hljs-comment">// 每页条数</span>        sortBy: <span class="hljs-keyword">this</span>.pagination.sortBy, <span class="hljs-comment">// 排序字段</span>        desc: <span class="hljs-keyword">this</span>.pagination.descending, <span class="hljs-comment">// 是否降序</span>        key: <span class="hljs-keyword">this</span>.search <span class="hljs-comment">// 查询字段</span>      &#125;    &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123; <span class="hljs-comment">// 获取响应结果对象</span>      <span class="hljs-keyword">this</span>.totalBrands = resp.data.total; <span class="hljs-comment">// 总条数</span>      <span class="hljs-keyword">this</span>.brands = resp.data.items; <span class="hljs-comment">// 品牌数据</span>      <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 加载完成</span>    &#125;);  &#125;&#125;</code></pre></div><p>查看网络请求：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530554422695.png" srcset="/img/loading.gif" alt="1530554422695"></p><p>效果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530554460215.png" srcset="/img/loading.gif" alt="1530554460215"></p><h2 id="7-5-完成分页和过滤"><a href="#7-5-完成分页和过滤" class="headerlink" title="7.5.完成分页和过滤"></a>7.5.完成分页和过滤</h2><h3 id="6-6-1-分页"><a href="#6-6-1-分页" class="headerlink" title="6.6.1.分页"></a>6.6.1.分页</h3><p>现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？</p><p>虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/9.gif" srcset="/img/loading.gif" alt></p><p>我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！</p><p>具体实现：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526049643506.png" srcset="/img/loading.gif" alt="1526049643506"></p><p>成功实现分页功能：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/22.gif" srcset="/img/loading.gif" alt="1526049720200"></p><h3 id="6-6-2-过滤"><a href="#6-6-2-过滤" class="headerlink" title="6.6.2.过滤"></a>6.6.2.过滤</h3><p>分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可:</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526049939985.png" srcset="/img/loading.gif" alt="1526049939985"></p><p>查看网络请求：</p><p> <img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/%E4%B9%90%E4%BC%98/day06-%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1526050032436.png" srcset="/img/loading.gif" alt="1526050032436"></p><p>页面结果：</p><p><img src="/2020/09/22/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday06/1530555740595.png" srcset="/img/loading.gif" alt="1530555740595"></p><h2 id="6-7-完整代码"><a href="#6-7-完整代码" class="headerlink" title="6.7.完整代码"></a>6.7.完整代码</h2><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;v-card&gt;    &lt;v-card-title flat color&#x3D;&quot;white&quot;&gt;      &lt;v-btn color&#x3D;&quot;primary&quot;&gt;新增&lt;&#x2F;v-btn&gt;      &lt;!--空间隔离组件--&gt;      &lt;v-spacer &#x2F;&gt;      &lt;!--搜索框，与search属性关联--&gt;      &lt;v-text-field label&#x3D;&quot;输入关键字搜索&quot; append-icon&#x3D;&quot;search&quot; v-model&#x3D;&quot;search&quot; hide-details&#x2F;&gt;    &lt;&#x2F;v-card-title&gt;    &lt;v-data-table      :headers&#x3D;&quot;headers&quot;      :items&#x3D;&quot;brands&quot;      :pagination.sync&#x3D;&quot;pagination&quot;      :total-items&#x3D;&quot;totalBrands&quot;      :loading&#x3D;&quot;loading&quot;      class&#x3D;&quot;elevation-1&quot;    &gt;      &lt;template slot&#x3D;&quot;items&quot; slot-scope&#x3D;&quot;props&quot;&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&lt;img v-if&#x3D;&quot;props.item.image&quot; :src&#x3D;&quot;props.item.image&quot; width&#x3D;&quot;130&quot; height&#x3D;&quot;40&quot;&#x2F;&gt;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;&#x2F;td&gt;        &lt;td class&#x3D;&quot;text-xs-center&quot;&gt;          &lt;v-icon small class&#x3D;&quot;mr-2&quot; @click&#x3D;&quot;editItem(props.item)&quot;&gt;            edit          &lt;&#x2F;v-icon&gt;          &lt;v-icon small @click&#x3D;&quot;deleteItem(props.item)&quot;&gt;            delete          &lt;&#x2F;v-icon&gt;        &lt;&#x2F;td&gt;      &lt;&#x2F;template&gt;    &lt;&#x2F;v-data-table&gt;  &lt;&#x2F;v-card&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    name: &quot;myBrand&quot;,    data() &#123;      return &#123;        totalBrands: 0, &#x2F;&#x2F; 总条数        brands: [], &#x2F;&#x2F; 当前页品牌数据        search: &quot;&quot;, &#x2F;&#x2F; 查询关键字        loading: true, &#x2F;&#x2F; 是否在加载中        pagination: &#123;&#125;, &#x2F;&#x2F; 分页信息        headers: [ &#x2F;&#x2F; 头信息          &#123;text: &#39;id&#39;, align: &#39;center&#39;, value: &#39;id&#39;&#125;,          &#123;text: &#39;名称&#39;, align: &#39;center&#39;, value: &#39;name&#39;, sortable: false&#125;,          &#123;text: &#39;LOGO&#39;, align: &#39;center&#39;, value: &#39;image&#39;, sortable: false&#125;,          &#123;text: &#39;首字母&#39;, align: &#39;center&#39;, value: &#39;letter&#39;&#125;,          &#123;text: &#39;操作&#39;, align: &#39;center&#39;, value: &#39;id&#39;, sortable: false&#125;        ]      &#125;    &#125;,    watch: &#123;      pagination:&#123;        deep: true, &#x2F;&#x2F; 深度监视        handler()&#123;          this.getDataFromServer();        &#125;      &#125;,      search()&#123;        this.pagination.page &#x3D; 1;        this.getDataFromServer();      &#125;    &#125;,    methods: &#123;      getDataFromServer() &#123; &#x2F;&#x2F; 从服务端加载数据的函数        this.loading &#x3D; true; &#x2F;&#x2F; 加载数据        &#x2F;&#x2F; 通过axios获取数据        this.$http.get(&quot;&#x2F;item&#x2F;brand&#x2F;page&quot;, &#123;          params: &#123;            page: this.pagination.page, &#x2F;&#x2F; 当前页            rows: this.pagination.rowsPerPage, &#x2F;&#x2F; 每页条数            sortBy: this.pagination.sortBy, &#x2F;&#x2F; 排序字段            desc: this.pagination.descending, &#x2F;&#x2F; 是否降序            key: this.search &#x2F;&#x2F; 查询字段          &#125;        &#125;).then(resp &#x3D;&gt; &#123; &#x2F;&#x2F; 获取响应结果对象          this.totalBrands &#x3D; resp.data.total; &#x2F;&#x2F; 总条数          this.brands &#x3D; resp.data.items; &#x2F;&#x2F; 品牌数据          this.loading &#x3D; false; &#x2F;&#x2F; 加载完成        &#125;);      &#125;    &#125;,    &#x2F;&#x2F; 渲染后执行    mounted() &#123;      this.getDataFromServer() &#x2F;&#x2F; 调用数据初始化函数    &#125;  &#125;&lt;&#x2F;script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre></div><p>大家下去可以尝试实现品牌的增删改功能</p>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>cors</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day05：vue入门</title>
    <link href="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/"/>
    <url>/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/</url>
    
    <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>会创建Vue实例，知道Vue的常见属性</li><li>会使用Vue的生命周期的钩子函数</li><li>会使用vue常见指令</li><li>会使用vue计算属性和watch监控</li><li>会编写Vue组件</li><li>掌握组件间通信</li><li>了解vue-router使用</li><li>了解webpack使用</li><li>会使用vue-cli搭建项目</li></ul><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>前几天我们已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。接下来要做的事情就是功能开发了。但是没有前端页面，我们肯定无从下手，因此今天我们就要来了解一下前端的一些技术，完成前端页面搭建。</p><p>先聊一下前端开发模式的发展。</p><blockquote><p>静态页面</p></blockquote><p>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</p><blockquote><p>异步刷新，操作DOM</p></blockquote><p>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言.</p><p>随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。</p><p>ajax盛行：</p><ul><li>2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。</li><li>此时的<strong>开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果</strong>。比较流行的框架如Jquery就是典型代表。</li></ul><blockquote><p>MVVM，关注模型和视图</p></blockquote><p>2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。</p><p>2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。</p><ul><li>基于事件循环的异步IO</li><li>单线程运行，避免多线程的变量同步问题</li><li>JS可以编写后台代码，前后台统一编程语言</li></ul><p>node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。</p><p>2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。</p><p>随后，在node的基础上，涌现出了一大批的前端框架：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1525825983230.png" srcset="/img/loading.gif" alt="1525825983230"></p><blockquote><p>MVVM模式</p></blockquote><ul><li>M：即Model，模型，包括数据和一些基本操作</li><li>V：即View，视图，页面渲染结果</li><li>VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉）</li></ul><p>在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。</p><p>而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的：</p><ul><li>只要我们Model发生了改变，View上自然就会表现出来。</li><li>当用户修改了View，Model中的数据也会跟着改变。</li></ul><p>把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1525828854056.png" srcset="/img/loading.gif" alt="1525828854056"></p><p>而我们今天要学习的，就是一款MVVM模式的框架：Vue</p><h1 id="1-认识Vue"><a href="#1-认识Vue" class="headerlink" title="1.认识Vue"></a>1.认识Vue</h1><p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>​    前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。</p><p>官网：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p><p>参考：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1525829249048.png" srcset="/img/loading.gif" alt="1525829249048"></p><p>Git地址：<a href="https://github.com/vuejs" target="_blank" rel="noopener">https://github.com/vuejs</a></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1525829030730.png" srcset="/img/loading.gif" alt="1525829030730"></p><p><strong>尤雨溪</strong>，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。</p><h1 id="2-Node和NPM"><a href="#2-Node和NPM" class="headerlink" title="2.Node和NPM"></a>2.Node和NPM</h1><p>前面说过，NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。为了后面学习方便，我们先安装node及NPM工具。</p><h2 id="2-1-下载Node-js"><a href="#2-1-下载Node-js" class="headerlink" title="2.1.下载Node.js"></a>2.1.下载Node.js</h2><p>下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529594451775.png" srcset="/img/loading.gif" alt="1529594451775"></p><p>推荐下载LTS版本。</p><p>课程中采用的是8.11.3版本。也是目前最新的。大家自行下载或者使用课前资料中提供的安装包。然后下一步安装即可。</p><p>完成以后，在控制台输入：</p><div class="hljs"><pre><code class="hljs powershell">node <span class="hljs-literal">-v</span></code></pre></div><p>看到版本信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529595770482.png" srcset="/img/loading.gif" alt="1529595770482"></p><h2 id="2-2-NPM"><a href="#2-2-NPM" class="headerlink" title="2.2.NPM"></a>2.2.NPM</h2><p>Node自带了NPM了，在控制台输入<code>npm -v</code>查看：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529595810923.png" srcset="/img/loading.gif" alt="1529595810923"></p><p>npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm</p><p>我们首先安装nrm，这里<code>-g</code>代表全局安装。可能需要一点儿时间</p><div class="hljs"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> nrm -g</code></pre></div><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529596099952.png" srcset="/img/loading.gif" alt="1529596099952"></p><p>然后通过<code>nrm ls</code>命令查看npm的仓库列表,带*的就是当前选中的镜像仓库：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529596219439.png" srcset="/img/loading.gif" alt="1529596219439"></p><p>通过<code>nrm use taobao</code>来指定要使用的镜像源：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529596312671.png" srcset="/img/loading.gif" alt="1529596312671"></p><p>然后通过<code>nrm test npm</code>来测试速度：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529596566134.png" srcset="/img/loading.gif" alt="1529596566134"></p><p>注意：</p><ul><li>有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。</li><li>安装完成请一定要重启下电脑！！！</li><li>安装完成请一定要重启下电脑！！！</li><li>安装完成请一定要重启下电脑！！！</li></ul><h1 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h1><p>接下来，我们快速领略下vue的魅力</p><h2 id="3-1-创建工程"><a href="#3-1-创建工程" class="headerlink" title="3.1.创建工程"></a>3.1.创建工程</h2><p>创建一个新的空工程：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529596874127.png" srcset="/img/loading.gif" alt="1529596874127"></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529597228506.png" srcset="/img/loading.gif" alt="1529597228506"></p><p>然后新建一个module：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529597325121.png" srcset="/img/loading.gif" alt="1529597325121"></p><p>选中static web，静态web项目：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529597573453.png" srcset="/img/loading.gif" alt="1529597573453"></p><p>位置信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529597672429.png" srcset="/img/loading.gif" alt="1529597672429"></p><h2 id="3-2-安装vue"><a href="#3-2-安装vue" class="headerlink" title="3.2.安装vue"></a>3.2.安装vue</h2><h3 id="3-2-1-下载安装"><a href="#3-2-1-下载安装" class="headerlink" title="3.2.1.下载安装"></a>3.2.1.下载安装</h3><p>下载地址：<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></p><p>可以下载2.5.16版本<a href="https://github.com/vuejs/vue/archive/v2.5.16.zip" target="_blank" rel="noopener">https://github.com/vuejs/vue/archive/v2.5.16.zip</a></p><p>下载解压，得到vue.js文件。</p><h3 id="3-2-2-使用CDN"><a href="#3-2-2-使用CDN" class="headerlink" title="3.2.2.使用CDN"></a>3.2.2.使用CDN</h3><p>或者也可以直接使用公共的CDN服务：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>或者：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h3 id="3-2-3-推荐npm安装"><a href="#3-2-3-推荐npm安装" class="headerlink" title="3.2.3.推荐npm安装"></a>3.2.3.推荐npm安装</h3><p>在idea的左下角，有个Terminal按钮，点击打开控制台：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529598030268.png" srcset="/img/loading.gif" alt="1529598030268"></p><p>进入hello-vue目录，先输入：<code>npm init -y</code> 进行初始化</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529598244471.png" srcset="/img/loading.gif" alt="1529598244471"></p><p>安装Vue，输入命令：<code>npm install vue --save</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529598444504.png" srcset="/img/loading.gif" alt="1529598444504"></p><p>然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529602488684.png" srcset="/img/loading.gif" alt="1529602488684"></p><p>node_modules是通过npm安装的所有模块的默认位置。</p><h2 id="3-3-vue入门案例"><a href="#3-3-vue入门案例" class="headerlink" title="3.3.vue入门案例"></a>3.3.vue入门案例</h2><h3 id="3-3-1-HTML模板"><a href="#3-3-1-HTML模板" class="headerlink" title="3.3.1.HTML模板"></a>3.3.1.HTML模板</h3><p> 在hello-vue目录新建一个HTML</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529719572523.png" srcset="/img/loading.gif" alt="1529719572523"></p><p>在hello.html中，我们编写一段简单的代码：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529719673944.png" srcset="/img/loading.gif" alt="1529719673944"></p><p>h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。</p><h3 id="3-3-2-vue声明式渲染"><a href="#3-3-2-vue声明式渲染" class="headerlink" title="3.3.2.vue声明式渲染"></a>3.3.2.vue声明式渲染</h3><p>然后我们通过Vue进行渲染：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;，非常帅！！！<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"node_modules/vue/dist/vue.js"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-comment">// 创建vue实例</span></span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>, <span class="hljs-comment">// el即element，该vue实例要渲染的页面元素</span></span><span class="actionscript">        data:&#123; <span class="hljs-comment">// 渲染页面需要的数据</span></span><span class="actionscript">            name: <span class="hljs-string">"峰哥"</span></span>        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>首先通过 new Vue()来创建Vue实例</li><li>然后构造函数接收一个对象，对象中有一些属性：<ul><li>el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div</li><li>data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中<ul><li>name：这里我们指定了一个name属性</li></ul></li></ul></li><li>页面中的<code>h2</code>元素中，我们通过的方式，来渲染刚刚定义的name属性。</li></ul><p>打开页面查看效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529722898366.png" srcset="/img/loading.gif" alt="1529722898366"></p><p>更神奇的在于，当你修改name属性时，页面会跟着变化：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529723206508.png" srcset="/img/loading.gif" alt="1529723206508"></p><h3 id="3-3-3-双向绑定"><a href="#3-3-3-双向绑定" class="headerlink" title="3.3.3.双向绑定"></a>3.3.3.双向绑定</h3><p>我们对刚才的案例进行简单修改：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"num"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>            &#123;&#123;name&#125;&#125;，非常帅！！！有&#123;&#123;num&#125;&#125;位女神为他着迷。        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"node_modules/vue/dist/vue.js"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-comment">// 创建vue实例</span></span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>, <span class="hljs-comment">// el即element，该vue实例要渲染的页面元素</span></span><span class="actionscript">        data: &#123; <span class="hljs-comment">// 渲染页面需要的数据</span></span><span class="actionscript">            name: <span class="hljs-string">"峰哥"</span>,</span>            num: 5        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>我们在data添加了新的属性：<code>num</code></li><li>在页面中有一个<code>input</code>元素，通过<code>v-model</code>与<code>num</code>进行绑定。</li><li>同时通过<code></code>在页面输出</li></ul><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/52.gif" srcset="/img/loading.gif" alt="1529723206508"></p><p>我们可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。</p><ul><li>input与num绑定，input的value值变化，影响到了data中的num值</li><li>页面<code></code>与数据num绑定，因此num值变化，引起了页面效果变化。</li></ul><p>没有任何dom操作，这就是双向绑定的魅力。</p><h3 id="3-3-4-事件处理"><a href="#3-3-4-事件处理" class="headerlink" title="3.3.4.事件处理"></a>3.3.4.事件处理</h3><p>我们在页面添加一个按钮：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"num++"</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><ul><li>这里用<code>v-on</code>指令绑定点击事件，而不是普通的<code>onclick</code>，然后直接操作num</li><li>普通click是无法直接操作num的。</li></ul><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/53.gif" srcset="/img/loading.gif" alt></p><h1 id="4-Vue实例"><a href="#4-Vue实例" class="headerlink" title="4.Vue实例"></a>4.Vue实例</h1><h2 id="4-1-创建Vue实例"><a href="#4-1-创建Vue实例" class="headerlink" title="4.1.创建Vue实例"></a>4.1.创建Vue实例</h2><p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;  <span class="hljs-comment">// 选项</span>&#125;)</code></pre></div><p>在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括：</p><ul><li>el</li><li>data</li><li>methods</li></ul><p>等等</p><p>接下来我们一 一介绍。</p><h2 id="4-2-模板或元素"><a href="#4-2-模板或元素" class="headerlink" title="4.2.模板或元素"></a>4.2.模板或元素</h2><p>每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。</p><p>我们可以通过el属性来指定。</p><p>例如一段html模板：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>然后创建Vue实例，关联这个div</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;el:<span class="hljs-string">"#app"</span>&#125;)</code></pre></div><p>这样，Vue就可以基于id为<code>app</code>的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。</p><h2 id="4-3-数据"><a href="#4-3-数据" class="headerlink" title="4.3.数据"></a>4.3.数据</h2><p>当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。</p><p>html：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"name"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>js:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    data:&#123;        name:<span class="hljs-string">"刘德华"</span>    &#125;&#125;)</code></pre></div><ul><li>name的变化会影响到<code>input</code>的值</li><li>input中输入的值，也会导致vm中的name发生改变</li></ul><h2 id="4-4-方法"><a href="#4-4-方法" class="headerlink" title="4.4.方法"></a>4.4.方法</h2><p>Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。</p><p>html:</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    &#123;&#123;num&#125;&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"add"</span>&gt;</span>加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>js:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    data:&#123;        num: <span class="hljs-number">0</span>    &#125;,    methods:&#123;        add:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-comment">// this代表的当前vue实例</span>            <span class="hljs-keyword">this</span>.num++;        &#125;    &#125;&#125;)</code></pre></div><h2 id="4-5-生命周期钩子"><a href="#4-5-生命周期钩子" class="headerlink" title="4.5.生命周期钩子"></a>4.5.生命周期钩子</h2><h3 id="4-5-1-生命周期"><a href="#4-5-1-生命周期" class="headerlink" title="4.5.1.生命周期"></a>4.5.1.生命周期</h3><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。</p><p>生命周期：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/lifecycle.png" srcset="/img/loading.gif" alt="Vue life cycle"></p><h3 id="4-5-2-钩子函数"><a href="#4-5-2-钩子函数" class="headerlink" title="4.5.2.钩子函数"></a>4.5.2.钩子函数</h3><p>beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化是调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 </p><p>created：在创建实例之后进行调用。 </p><p>beforeMount：页面加载完成，没有渲染。如：此时页面还是</p><p>mounted：我们可以将他理解为原生js中的window.onload=function({.,.}),或许大家也在用jquery，所以也可以理解为jquery中的$(document).ready(function(){….})，他的功能就是：在dom文档渲染完毕之后将要执行的函数，该函数在Vue1.0版本中名字为compiled。 此时页面中的已被渲染成峰哥</p><p>beforeDestroy：该函数将在销毁实例前进行调用 。</p><p>destroyed：改函数将在销毁实例时进行调用。</p><p>beforeUpdate：组件更新之前。</p><p>updated：组件更新之后。</p><p>例如：created代表在vue实例创建后；</p><p>我们可以在Vue中定义一个created函数，代表这个时期的钩子函数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 创建vue实例</span><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">"#app"</span>, <span class="hljs-comment">// el即element，该vue实例要渲染的页面元素</span>    data: &#123; <span class="hljs-comment">// 渲染页面需要的数据</span>        name: <span class="hljs-string">"峰哥"</span>,        num: <span class="hljs-number">5</span>    &#125;,    methods: &#123;        add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">this</span>.num--;        &#125;    &#125;,    created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.num = <span class="hljs-number">100</span>;    &#125;&#125;);</code></pre></div><p>结果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529835200236.png" srcset="/img/loading.gif" alt="1529835200236"></p><h3 id="4-5-3-this"><a href="#4-5-3-this" class="headerlink" title="4.5.3.this"></a>4.5.3.this</h3><p>我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this</p><div class="hljs"><pre><code class="hljs js">methods: &#123;    add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">this</span>.num--;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);    &#125;&#125;,</code></pre></div><p> 控制台的输出：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529835379275.png" srcset="/img/loading.gif" alt="1529835379275"></p><h1 id="5-指令"><a href="#5-指令" class="headerlink" title="5.指令"></a>5.指令</h1><p>什么是指令？</p><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊特性。指令特性的预期值是：<strong>单个 JavaScript 表达式</strong>。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 </p><p>例如我们在入门案例中的v-on，代表绑定事件。</p><h2 id="5-1-插值表达式"><a href="#5-1-插值表达式" class="headerlink" title="5.1.插值表达式"></a>5.1.插值表达式</h2><h3 id="5-1-1-花括号"><a href="#5-1-1-花括号" class="headerlink" title="5.1.1.花括号"></a>5.1.1.花括号</h3><p>格式：</p><div class="hljs"><pre><code class="hljs vue">&#123;&#123;表达式&#125;&#125;</code></pre></div><p>说明：</p><ul><li>该表达式支持JS语法，可以调用js内置函数（必须有返回值）</li><li>表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1;</li><li>可以直接获取Vue实例中定义的数据或函数</li></ul><p>示例：</p><p>HTML:</p><div id="app">{{name}}</div><p>JS:</p><p>var app = new Vue({<br>    el:”#app”,<br>    data:{<br>        name:”Jack”<br>    }<br>})</p><h3 id="5-1-2-插值闪烁"><a href="#5-1-2-插值闪烁" class="headerlink" title="5.1.2.插值闪烁"></a>5.1.2.插值闪烁</h3><p>使用{{}}方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的<code>{{}}</code>，加载完毕后才显示正确数据，我们称为插值闪烁。</p><p>我们将网速调慢一些，然后试试看刚才的案例：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529836021593.png" srcset="/img/loading.gif" alt="1529836021593"></p><p>刷新页面：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/54.gif" srcset="/img/loading.gif" alt></p><h3 id="5-1-3-v-text和v-html"><a href="#5-1-3-v-text和v-html" class="headerlink" title="5.1.3.v-text和v-html"></a>5.1.3.v-text和v-html</h3><p>使用v-text和v-html指令来替代<code>{{}}</code></p><p>说明：</p><ul><li>v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出</li><li>v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染</li></ul><p>示例：</p><p>HTML:</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    v-text:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"hello"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    v-html:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"hello"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>JS:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    data:&#123;        hello: <span class="hljs-string">"&lt;h1&gt;大家好，我是峰哥&lt;/h1&gt;"</span>    &#125;&#125;)</code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529836688083.png" srcset="/img/loading.gif" alt="1529836688083"></p><p>并且不会出现插值闪烁，当没有数据时，会显示空白。</p><h2 id="5-2-v-model"><a href="#5-2-v-model" class="headerlink" title="5.2.v-model"></a>5.2.v-model</h2><p>刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。</p><p>既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有：</p><ul><li>input</li><li>select</li><li>textarea</li><li>checkbox</li><li>radio</li><li>components（Vue中的自定义组件）</li></ul><p>基本上除了最后一项，其它都是表单的输入项。</p><p>举例：</p><p>html：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"language"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Java"</span> /&gt;</span>Java<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"language"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"PHP"</span> /&gt;</span>PHP<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"language"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Swift"</span> /&gt;</span>Swift<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>        你选择了：&#123;&#123;language.join(',')&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span>        data:&#123;            language: []        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>多个<code>CheckBox</code>对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型</li><li>radio对应的值是input的value值</li><li><code>input</code> 和<code>textarea</code> 默认对应的model是字符串</li><li><code>select</code>单选对应字符串，多选对应也是数组</li></ul><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1529837541201.png" srcset="/img/loading.gif" alt="1529837541201"></p><h2 id="5-3-v-on"><a href="#5-3-v-on" class="headerlink" title="5.3.v-on"></a>5.3.v-on</h2><h3 id="5-3-1-基本用法"><a href="#5-3-1-基本用法" class="headerlink" title="5.3.1.基本用法"></a>5.3.1.基本用法</h3><p>v-on指令用于给页面元素绑定事件。</p><p>语法：</p><div class="hljs"><pre><code class="hljs applescript">v-<span class="hljs-keyword">on</span>:事件名=<span class="hljs-string">"js片段或函数名"</span></code></pre></div><p>示例：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--事件中直接写js片段--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"num++"</span>&gt;</span>增加一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-comment">&lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"decrement"</span>&gt;</span>减少一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>有&#123;&#123;num&#125;&#125;个女神迷恋峰哥<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span>        data:&#123;            num:100        &#125;,        methods:&#123;            decrement()&#123;<span class="actionscript">                <span class="hljs-keyword">this</span>.num--;</span>            &#125;        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/55.gif" srcset="/img/loading.gif" alt></p><p>另外，事件绑定可以简写，例如<code>v-on:click=&#39;add&#39;</code>可以简写为<code>@click=&#39;add&#39;</code></p><h3 id="5-3-2-事件修饰符"><a href="#5-3-2-事件修饰符" class="headerlink" title="5.3.2.事件修饰符"></a>5.3.2.事件修饰符</h3><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code> ：阻止事件冒泡到父元素</li><li><code>.prevent</code>：阻止默认事件发生</li><li><code>.capture</code>：使用事件捕获模式</li><li><code>.self</code>：只有元素自身触发事件才执行。（冒泡或捕获的都不执行）</li><li><code>.once</code>：只执行一次</li></ul><p>阻止默认事件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--右击事件，并阻止默认事件发生--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:contextmenu.prevent</span>=<span class="hljs-string">"num++"</span>&gt;</span>增加一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-comment">&lt;!--右击事件，不阻止默认事件发生--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:contextmenu</span>=<span class="hljs-string">"decrement($event)"</span>&gt;</span>减少一个<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>有&#123;&#123;num&#125;&#125;个女神迷恋峰哥<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        data: &#123;            num: 100        &#125;,        methods: &#123;            decrement(ev) &#123;<span class="actionscript">                <span class="hljs-comment">// ev.preventDefault();</span></span><span class="actionscript">                <span class="hljs-keyword">this</span>.num--;</span>            &#125;        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：（右键“增加一个”，不会触发默认的浏览器右击事件；右键“减少一个”，会触发默认的浏览器右击事件）</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/56.gif" srcset="/img/loading.gif" alt></p><h3 id="5-3-3-按键修饰符"><a href="#5-3-3-按键修饰符" class="headerlink" title="5.3.3.按键修饰符"></a>5.3.3.按键修饰符</h3><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符： </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.13</span>=<span class="hljs-string">"submit"</span>&gt;</span></code></pre></div><p>记住所有的 <code>keyCode</code> 比较困难，所以 Vue 为最常用的按键提供了别名：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 同上 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">"submit"</span>&gt;</span><span class="hljs-comment">&lt;!-- 缩写语法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"submit"</span>&gt;</span></code></pre></div><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h3 id="5-3-4-组合按钮"><a href="#5-3-4-组合按钮" class="headerlink" title="5.3.4.组合按钮"></a>5.3.4.组合按钮</h3><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li></ul><p>例如：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Alt + C --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.alt.67</span>=<span class="hljs-string">"clear"</span>&gt;</span><span class="hljs-comment">&lt;!-- Ctrl + Click --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">"doSomething"</span>&gt;</span>Do something<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h2 id="5-4-v-for"><a href="#5-4-v-for" class="headerlink" title="5.4.v-for"></a>5.4.v-for</h2><p>遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。</p><h3 id="5-4-1-遍历数组"><a href="#5-4-1-遍历数组" class="headerlink" title="5.4.1.遍历数组"></a>5.4.1.遍历数组</h3><blockquote><p>语法：</p></blockquote><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span></code></pre></div><ul><li>items：要遍历的数组，需要在vue的data中定义好。</li><li>item：迭代得到的数组元素的别名</li></ul><blockquote><p>示例</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"user in users"</span>&gt;</span>            &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        data: &#123;            users:[<span class="actionscript">                &#123;name:<span class="hljs-string">'柳岩'</span>, gender:<span class="hljs-string">'女'</span>, age: <span class="hljs-number">21</span>&#125;,</span><span class="actionscript">                &#123;name:<span class="hljs-string">'峰哥'</span>, gender:<span class="hljs-string">'男'</span>, age: <span class="hljs-number">18</span>&#125;,</span><span class="actionscript">                &#123;name:<span class="hljs-string">'范冰冰'</span>, gender:<span class="hljs-string">'女'</span>, age: <span class="hljs-number">24</span>&#125;,</span><span class="actionscript">                &#123;name:<span class="hljs-string">'刘亦菲'</span>, gender:<span class="hljs-string">'女'</span>, age: <span class="hljs-number">18</span>&#125;,</span><span class="actionscript">                &#123;name:<span class="hljs-string">'古力娜扎'</span>, gender:<span class="hljs-string">'女'</span>, age: <span class="hljs-number">25</span>&#125;</span>            ]        &#125;,    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530006198953.png" srcset="/img/loading.gif" alt="1530006198953"></p><h3 id="5-4-2-数组角标"><a href="#5-4-2-数组角标" class="headerlink" title="5.4.2.数组角标"></a>5.4.2.数组角标</h3><p>在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数：</p><blockquote><p>语法</p></blockquote><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item,index) in items"</span></code></pre></div><ul><li>items：要迭代的数组</li><li>item：迭代得到的数组元素别名</li><li>index：迭代到的当前元素索引，从0开始。</li></ul><blockquote><p>示例</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(user, index) in users"</span>&gt;</span>        &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><blockquote><p>效果：</p></blockquote><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530006094601.png" srcset="/img/loading.gif" alt="1530006094601"></p><h3 id="5-4-3-遍历对象"><a href="#5-4-3-遍历对象" class="headerlink" title="5.4.3.遍历对象"></a>5.4.3.遍历对象</h3><p>v-for除了可以迭代数组，也可以迭代对象。语法基本类似</p><blockquote><p>语法：</p></blockquote><div class="hljs"><pre><code class="hljs javascript">v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"value in object"</span>v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key) in object"</span>v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(value,key,index) in object"</span></code></pre></div><ul><li>1个参数时，得到的是对象的属性</li><li>2个参数时，第一个是属性，第二个是键</li><li>3个参数时，第三个是索引，从0开始</li></ul><blockquote><p>示例：</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key, index) in user"</span>&gt;</span>            &#123;&#123;index + 1&#125;&#125;. &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span>        data:&#123;<span class="actionscript">            user:&#123;name:<span class="hljs-string">'峰哥'</span>, gender:<span class="hljs-string">'男'</span>, age: <span class="hljs-number">18</span>&#125;</span>        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><blockquote><p>效果：</p></blockquote><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530006251975.png" srcset="/img/loading.gif" alt="1530006251975"></p><h3 id="5-4-4-key"><a href="#5-4-4-key" class="headerlink" title="5.4.4.key"></a>5.4.4.key</h3><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 </p><p>这个功能可以有效的提高渲染的效率。</p><p>但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。理想的 <code>key</code> 值是每项都有的且唯一的 id。 </p><p>示例：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item,index) in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">index</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><ul><li>这里使用了一个特殊语法：<code>:key=&quot;&quot;</code> 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性</li><li>这里我们绑定的key是数组的索引，应该是唯一的</li></ul><h2 id="5-5-v-if和v-show"><a href="#5-5-v-if和v-show" class="headerlink" title="5.5.v-if和v-show"></a>5.5.v-if和v-show</h2><h3 id="5-5-1-基本使用"><a href="#5-5-1-基本使用" class="headerlink" title="5.5.1.基本使用"></a>5.5.1.基本使用</h3><p>v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。</p><blockquote><p>语法：</p></blockquote><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">v-if</span>=<span class="hljs-string">"布尔表达式"</span></code></pre></div><blockquote><p>示例：</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span>点我呀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>        看到我啦？！    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"show"</span>&gt;</span>        看到我啦？！show    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        data: &#123;<span class="actionscript">            show: <span class="hljs-literal">true</span></span>        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><blockquote><p>效果：</p></blockquote><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/57.gif" srcset="/img/loading.gif" alt></p><h3 id="5-5-2-与v-for结合"><a href="#5-5-2-与v-for结合" class="headerlink" title="5.5.2.与v-for结合"></a>5.5.2.与v-for结合</h3><p>当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。</p><p>修改v-for中的案例，添加v-if：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(user, index) in users"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"user.gender == '女'"</span>&gt;</span>        &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530013415911.png" srcset="/img/loading.gif" alt="1530013415911"></p><p>只显示女性用户信息</p><h3 id="5-5-3-v-else"><a href="#5-5-3-v-else" class="headerlink" title="5.5.3.v-else"></a>5.5.3.v-else</h3><p>你可以使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"Math.random() &gt; 0.5"</span>&gt;</span>        看到我啦？！if    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>        看到我啦？！else    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p><p><code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"random=Math.random()"</span>&gt;</span>点我呀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;random&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"random &gt;= 0.75"</span>&gt;</span>        看到我啦？！if    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"random &gt; 0.5"</span>&gt;</span>        看到我啦？！if 0.5    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"random &gt; 0.25"</span>&gt;</span>        看到我啦？！if 0.25    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>        看到我啦？！else    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        data: &#123;            random: 1        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</p><p>演示：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/58.gif" srcset="/img/loading.gif" alt="1530013415911"></p><h3 id="5-5-4-v-show"><a href="#5-5-4-v-show" class="headerlink" title="5.5.4.v-show"></a>5.5.4.v-show</h3><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"ok"</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p><p>示例：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--事件中直接写js片段--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span>点击切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>        你好    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span>        data:&#123;<span class="actionscript">            show:<span class="hljs-literal">true</span></span>        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>代码：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/59.gif" srcset="/img/loading.gif" alt></p><h2 id="5-6-v-bind"><a href="#5-6-v-bind" class="headerlink" title="5.6.v-bind"></a>5.6.v-bind</h2><p>html属性不能使用双大括号形式绑定，只能使用v-bind指令。</p><p>在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--可以是数据模型，可以是具有返回值的js代码块或者函数--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid red; width: 50px; height: 50px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        data: &#123;<span class="actionscript">            title: <span class="hljs-string">"title"</span>,</span>        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530025378843.png" srcset="/img/loading.gif" alt="1530025378843"></p><p>在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 </p><h3 id="5-6-1-绑定class样式"><a href="#5-6-1-绑定class样式" class="headerlink" title="5.6.1.绑定class样式"></a>5.6.1.绑定class样式</h3><blockquote><p>数组语法</p></blockquote><p>我们可以借助于<code>v-bind</code>指令来实现：</p><p>HTML：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"activeClass"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"errorClass"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"[activeClass, errorClass]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        data: &#123;<span class="actionscript">            activeClass: <span class="hljs-string">'active'</span>,</span><span class="actionscript">            errorClass: [<span class="hljs-string">'text-danger'</span>, <span class="hljs-string">'text-error'</span>]</span>        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>渲染后的效果：（具有active和hasError的样式）</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530026818515.png" srcset="/img/loading.gif" alt="1530026818515"></p><blockquote><p>对象语法</p></blockquote><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"&#123; active: isActive &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>上面的语法表示 <code>active</code> 这个 <strong>class 存在与否将取决于数据属性 <code>isActive</code></strong> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">truthiness</a>（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。</p><p>你可以在对象中传入更多属性来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class 属性共存。如下模板:</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"static"</span></span><span class="hljs-tag">     <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>和如下 data：</p><div class="hljs"><pre><code class="hljs js">data: &#123;  isActive: <span class="hljs-literal">true</span>,  hasError: <span class="hljs-literal">false</span>&#125;</code></pre></div><p>结果渲染为：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"static active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。</p><p><strong>通常情况下，绑定的数据对象不必内联定义在模板里</strong>： </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"static"</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"classObject"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>数据：</p><div class="hljs"><pre><code class="hljs javascript">data: &#123;  classObject: &#123;    active: <span class="hljs-literal">true</span>,    <span class="hljs-string">'text-danger'</span>: <span class="hljs-literal">false</span>  &#125;&#125;</code></pre></div><p>效果和之前一样：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"static active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h3 id="5-6-2-绑定style样式"><a href="#5-6-2-绑定style样式" class="headerlink" title="5.6.2.绑定style样式"></a>5.6.2.绑定style样式</h3><blockquote><p>数组语法</p></blockquote><p>数组语法可以将多个样式对象应用到同一个元素上： </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>数据：</p><div class="hljs"><pre><code class="hljs javascript">data: &#123;    baseStyles: &#123;<span class="hljs-string">'background-color'</span>: <span class="hljs-string">'red'</span>&#125;,    overridingStyles: &#123;<span class="hljs-attr">border</span>: <span class="hljs-string">'1px solid black'</span>&#125;&#125;</code></pre></div><p>渲染后的结果：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background-color: red; border: 1px solid black;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><blockquote><p>对象语法</p></blockquote><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>数据：</p><div class="hljs"><pre><code class="hljs JavaScript">data: &#123;  activeColor: <span class="hljs-string">'red'</span>,  fontSize: <span class="hljs-number">30</span>&#125;</code></pre></div><p>效果：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: red; font-size: 30px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p><strong>直接绑定到一个样式对象通常更好，这会让模板更清晰</strong>： </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"styleObject"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs javascript">data: &#123;  styleObject: &#123;    color: <span class="hljs-string">'red'</span>,    fontSize: <span class="hljs-string">'13px'</span>  &#125;&#125;</code></pre></div><p>效果同上。</p><h3 id="5-6-3-简写"><a href="#5-6-3-简写" class="headerlink" title="5.6.3.简写"></a>5.6.3.简写</h3><p><code>v-bind:class</code>可以简写为<code>:class</code></p><h2 id="5-7-计算属性"><a href="#5-7-计算属性" class="headerlink" title="5.7.计算属性"></a>5.7.计算属性</h2><p>在插值表达式中使用js表达式是非常方便的，而且也经常被用到。</p><p>但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值：</p><div class="hljs"><pre><code class="hljs js">data:&#123;    birthday:<span class="hljs-number">1529032123201</span> <span class="hljs-comment">// 毫秒值</span>&#125;</code></pre></div><p>我们在页面渲染，希望得到yyyy-MM-dd的样式：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>您的生日是：&#123;&#123;    new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay()    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>虽然能得到结果，但是非常麻烦。</p><p>Vue中提供了计算属性，来替代复杂的表达式：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    data:&#123;        birthday:<span class="hljs-number">1429032123201</span> <span class="hljs-comment">// 毫秒值</span>    &#125;,    computed:&#123;        birth()&#123;<span class="hljs-comment">// 计算属性本质是一个方法，但是必须返回结果</span>            <span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">this</span>.birthday);            <span class="hljs-keyword">return</span> d.getFullYear() + <span class="hljs-string">"-"</span> + d.getMonth() + <span class="hljs-string">"-"</span> + d.getDay();        &#125;    &#125;&#125;)</code></pre></div><ul><li>计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。</li></ul><p>页面使用：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>您的生日是：&#123;&#123;birth&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530029950644.png" srcset="/img/loading.gif" alt="1530029950644"></p><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的依赖进行缓存的</strong>。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<code>birthday</code>还没有发生改变，多次访问 <code>birthday</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p><h2 id="5-8-watch"><a href="#5-8-watch" class="headerlink" title="5.8.watch"></a>5.8.watch</h2><p>watch可以让我们监控一个值的变化。从而做出相应的反应。</p><p>示例：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span>        data:&#123;<span class="actionscript">            message:<span class="hljs-string">""</span></span>        &#125;,        watch:&#123;            message(newVal, oldVal)&#123;<span class="javascript">                <span class="hljs-built_in">console</span>.log(newVal, oldVal);</span>            &#125;        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530030506879.png" srcset="/img/loading.gif" alt="1530030506879"></p><h1 id="6-组件化"><a href="#6-组件化" class="headerlink" title="6.组件化"></a>6.组件化</h1><p>在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。</p><p>但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。</p><h2 id="6-1-全局组件"><a href="#6-1-全局组件" class="headerlink" title="6.1.全局组件"></a>6.1.全局组件</h2><p>我们通过Vue的component方法来定义一个全局组件。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--使用定义好的全局组件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-comment">// 定义全局组件，两个参数：1，组件名称。2，组件参数</span></span><span class="actionscript">    Vue.component(<span class="hljs-string">"counter"</span>,&#123;</span><span class="handlebars"><span class="xml">        template:'<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"count++"</span>&gt;</span>你点了我 </span><span class="hljs-template-variable">&#123;&#123; count &#125;&#125;</span><span class="xml"> 次，我记住了.<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>',</span></span>        data()&#123;<span class="actionscript">            <span class="hljs-keyword">return</span> &#123;</span>                count:0            &#125;        &#125;    &#125;)<span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span></span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等</li><li>不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。</li><li>但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板</li><li>全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。</li><li>data必须是一个函数，不再是一个对象。</li></ul><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/60.gif" srcset="/img/loading.gif" alt></p><h2 id="6-2-组件的复用"><a href="#6-2-组件的复用" class="headerlink" title="6.2.组件的复用"></a>6.2.组件的复用</h2><p>定义好的组件，可以任意复用多次：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--使用定义好的全局组件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530084943778.png" srcset="/img/loading.gif" alt="1530084943778"></p><p>你会发现每个组件互不干扰，都有自己的count值。怎么实现的？</p><blockquote><p><strong>组件的data属性必须是函数</strong>！</p></blockquote><p>当我们定义这个 <code>&lt;counter&gt;</code> 组件时，它的data 并不是像这样直接提供一个对象：</p><div class="hljs"><pre><code class="hljs js">data: &#123;  count: <span class="hljs-number">0</span>&#125;</code></pre></div><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：</p><div class="hljs"><pre><code class="hljs js">data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> &#123;    count: <span class="hljs-number">0</span>  &#125;&#125;</code></pre></div><p>如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！</p><h2 id="6-3-局部注册"><a href="#6-3-局部注册" class="headerlink" title="6.3.局部注册"></a>6.3.局部注册</h2><p>一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。</p><p>因此，对于一些并不频繁使用的组件，我们会采用局部注册。</p><p>我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> counter = &#123;    template:<span class="hljs-string">'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;'</span>,    data()&#123;        <span class="hljs-keyword">return</span> &#123;            count:<span class="hljs-number">0</span>        &#125;    &#125;&#125;;</code></pre></div><p>然后在Vue中使用它：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    components:&#123;        counter:counter <span class="hljs-comment">// 将定义的对象注册为组件</span>    &#125;&#125;)</code></pre></div><ul><li>components就是当前vue对象子组件集合。<ul><li>其key就是子组件名称</li><li>其值就是组件对象的属性</li></ul></li><li>效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用</li></ul><h2 id="6-4-组件通信"><a href="#6-4-组件通信" class="headerlink" title="6.4.组件通信"></a>6.4.组件通信</h2><p>通常一个单页应用会以一棵嵌套的组件树的形式来组织：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1525855149491.png" srcset="/img/loading.gif" alt="1525855149491"></p><ul><li>页面首先分成了顶部导航、左侧内容区、右侧边栏三部分</li><li>左侧内容区又分为上下两个组件</li><li>右侧边栏中又包含了3个子组件</li></ul><p>各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。</p><h3 id="6-4-1-props（父向子传递）"><a href="#6-4-1-props（父向子传递）" class="headerlink" title="6.4.1.props（父向子传递）"></a>6.4.1.props（父向子传递）</h3><ol><li>父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据）</li><li>子组件通过props接收父组件属性</li></ol><p>父组件使用子组件，并自定义了title属性：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>打个招呼：<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-comment">&lt;!--使用子组件，同时传递title属性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">introduce</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"大家好，我是锋哥"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    Vue.component(<span class="hljs-string">"introduce"</span>,&#123;</span><span class="actionscript">        <span class="hljs-comment">// 直接使用props接收到的属性来渲染页面</span></span><span class="handlebars"><span class="xml">        template:'<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;title&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>',</span></span><span class="actionscript">        props:[<span class="hljs-string">'title'</span>] <span class="hljs-comment">// 通过props来接收一个父组件传递的属性</span></span>    &#125;)<span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span></span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530093525973.png" srcset="/img/loading.gif" alt="1530093525973"></p><h3 id="6-4-2-props验证"><a href="#6-4-2-props验证" class="headerlink" title="6.4.2.props验证"></a>6.4.2.props验证</h3><p>我们定义一个子组件，并接受复杂数据：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myList = &#123;    template: <span class="hljs-string">'\</span><span class="hljs-string">    &lt;ul&gt;\</span><span class="hljs-string">    &lt;li v-for="item in items" :key="item.id"&gt;&#123;&#123;item.id&#125;&#125; : &#123;&#123;item.name&#125;&#125;&lt;/li&gt;\</span><span class="hljs-string">    &lt;/ul&gt;\</span><span class="hljs-string">    '</span>,    props: &#123;        items: &#123;            type: <span class="hljs-built_in">Array</span>,            <span class="hljs-keyword">default</span>: [],            required: <span class="hljs-literal">true</span>        &#125;    &#125;&#125;;</code></pre></div><ul><li>这个子组件可以对 items 进行迭代，并输出到页面。</li><li>props：定义需要从父组件中接收的属性<ul><li>items：是要接收的属性名称<ul><li>type：限定父组件传递来的必须是数组</li><li>default：默认值</li><li>required：是否必须</li></ul></li></ul></li></ul><p><strong>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</strong> </p><p>我们在父组件中使用它：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>传智播客已开设如下课程：<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">my-list</span> <span class="hljs-attr">:items</span>=<span class="hljs-string">"lessons"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    components:&#123;        myList <span class="hljs-comment">// 当key和value一样时，可以只写一个</span>    &#125;,    data:&#123;        lessons:[            &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'java'</span>&#125;,            &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'php'</span>&#125;,            &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'ios'</span>&#125;,        ]    &#125;&#125;)</code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530107338625.png" srcset="/img/loading.gif" alt="1530107338625"></p><p>type类型，可以有：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530108427358.png" srcset="/img/loading.gif" alt="1530108427358"></p><h3 id="6-4-3-动态静态传递"><a href="#6-4-3-动态静态传递" class="headerlink" title="6.4.3.动态静态传递"></a>6.4.3.动态静态传递</h3><p>给 prop 传入一个静态的值： </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">introduce</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"大家好，我是锋哥"</span>/&gt;</span></code></pre></div><p>给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值）</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">introduce</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">"title"</span>/&gt;</span></code></pre></div><p>静态传递时，我们传入的值都是字符串类型的，但实际上<strong>任何类型</strong>的值都可以传给一个 props。 </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><span class="hljs-comment">&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">"42"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><span class="hljs-comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">"post.likes"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span></code></pre></div><h3 id="6-4-4-子向父的通信"><a href="#6-4-4-子向父的通信" class="headerlink" title="6.4.4.子向父的通信"></a>6.4.4.子向父的通信</h3><p>来看这样的一个案例：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>num: &#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!--使用子组件的时候，传递num到子组件中--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span> <span class="hljs-attr">:num</span>=<span class="hljs-string">"num"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    Vue.component(<span class="hljs-string">"counter"</span>, &#123;<span class="hljs-comment">// 子组件，定义了两个按钮，点击数字num会加或减</span></span>        template:'\<span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"num++"</span>&gt;</span>加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  \</span></span><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"num--"</span>&gt;</span>减<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  \</span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>',</span></span><span class="actionscript">        props:[<span class="hljs-string">'num'</span>]<span class="hljs-comment">// count是从父组件获取的。</span></span>    &#125;)<span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span>,</span>        data:&#123;            num:0        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>子组件接收父组件的num属性</li><li>子组件定义点击按钮，点击后对num进行加或减操作</li></ul><p>我们尝试运行，好像没问题，点击按钮试试：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530115066496.png" srcset="/img/loading.gif" alt="1525859093172"></p><p>子组件接收到父组件属性后，默认是不允许修改的。怎么办？</p><p>既然只有父组件能修改，那么加和减的操作一定是放在父组件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    data:&#123;        num:<span class="hljs-number">0</span>    &#125;,    methods:&#123; <span class="hljs-comment">// 父组件中定义操作num的方法</span>        increment()&#123;            <span class="hljs-keyword">this</span>.num++;        &#125;,        decrement()&#123;            <span class="hljs-keyword">this</span>.num--;        &#125;    &#125;&#125;)</code></pre></div><p>但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？</p><p>我们可以<strong>通过v-on指令将父组件的函数绑定到子组件</strong>上：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>num: &#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">counter</span> <span class="hljs-attr">:count</span>=<span class="hljs-string">"num"</span> @<span class="hljs-attr">inc</span>=<span class="hljs-string">"increment"</span> @<span class="hljs-attr">dec</span>=<span class="hljs-string">"decrement"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数：</p><div class="hljs"><pre><code class="hljs js">Vue.component(<span class="hljs-string">"counter"</span>, &#123;    template:<span class="hljs-string">'\</span><span class="hljs-string">        &lt;div&gt;\</span><span class="hljs-string">            &lt;button @click="plus"&gt;加&lt;/button&gt;  \</span><span class="hljs-string">            &lt;button @click="reduce"&gt;减&lt;/button&gt;  \</span><span class="hljs-string">        &lt;/div&gt;'</span>,    props:[<span class="hljs-string">'count'</span>],    methods:&#123;        plus()&#123;            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">"inc"</span>);        &#125;,        reduce()&#123;            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">"dec"</span>);        &#125;    &#125;&#125;)</code></pre></div><ul><li>vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数</li></ul><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/61.gif" srcset="/img/loading.gif" alt></p><h1 id="7-路由vue-router"><a href="#7-路由vue-router" class="headerlink" title="7.路由vue-router"></a>7.路由vue-router</h1><h2 id="7-1-场景模拟"><a href="#7-1-场景模拟" class="headerlink" title="7.1.场景模拟"></a>7.1.场景模拟</h2><p>现在我们来实现这样一个功能：</p><p>一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/%E4%B9%90%E4%BC%98/day05-Vue/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/8.gif" srcset="/img/loading.gif" alt></p><h3 id="7-1-1-编写父组件"><a href="#7-1-1-编写父组件" class="headerlink" title="7.1.1.编写父组件"></a>7.1.1.编写父组件</h3><p>为了让接下来的功能比较清晰，我们先新建一个文件夹：src</p><p>然后新建一个HTML文件，作为入口：index.html</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530148321175.png" srcset="/img/loading.gif" alt="1530148321175"></p><p>然后编写页面的基本结构：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        登录页/注册页    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el:<span class="hljs-string">"#app"</span></span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>样式：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530149363817.png" srcset="/img/loading.gif" alt="1530149363817"></p><h3 id="7-1-2-编写登录及注册组件"><a href="#7-1-2-编写登录及注册组件" class="headerlink" title="7.1.2.编写登录及注册组件"></a>7.1.2.编写登录及注册组件</h3><p>接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中，我们新建一个user目录以及login.js及register.js：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530156389366.png" srcset="/img/loading.gif" alt="1530156389366"></p><p>编写组件，这里我们只写模板，不写功能。</p><p>login.js内容如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loginForm = &#123;    template:<span class="hljs-string">'\</span><span class="hljs-string">    &lt;div&gt;\</span><span class="hljs-string">    &lt;h2&gt;登录页&lt;/h2&gt; \</span><span class="hljs-string">    用户名：&lt;input type="text"&gt;&lt;br/&gt;\</span><span class="hljs-string">    密码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    &lt;/div&gt;\</span><span class="hljs-string">    '</span>&#125;</code></pre></div><p>register.js内容：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> registerForm = &#123;    template:<span class="hljs-string">'\</span><span class="hljs-string">    &lt;div&gt;\</span><span class="hljs-string">    &lt;h2&gt;注册页&lt;/h2&gt; \</span><span class="hljs-string">    用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\</span><span class="hljs-string">    密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    确认密码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    &lt;/div&gt;\</span><span class="hljs-string">    '</span>&#125;</code></pre></div><h3 id="7-1-3-在父组件中引用"><a href="#7-1-3-在父组件中引用" class="headerlink" title="7.1.3.在父组件中引用"></a>7.1.3.在父组件中引用</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!--&lt;loginForm&gt;&lt;/loginForm&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">            疑问：为什么不采用上面的写法？</span><span class="hljs-comment">            由于html是大小写不敏感的，如果采用上面的写法，则被认为是&lt;loginform&gt;&lt;/loginform&gt;</span><span class="hljs-comment">            所以，如果是驼峰形式的组件，需要把驼峰转化为“-”的形式</span><span class="hljs-comment">         --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">login-form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">login-form</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">register-form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">register-form</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"user/login.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"user/register.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">"#app"</span>,</span>        components: &#123;            loginForm,            registerForm        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530157389501.png" srcset="/img/loading.gif" alt="1530157389501"></p><h3 id="7-1-5-问题"><a href="#7-1-5-问题" class="headerlink" title="7.1.5.问题"></a>7.1.5.问题</h3><p>我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。</p><p>但是，如何才能动态加载组件，实现组件切换呢？</p><p>虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。</p><h2 id="7-2-vue-router简介和安装"><a href="#7-2-vue-router简介和安装" class="headerlink" title="7.2.vue-router简介和安装"></a>7.2.vue-router简介和安装</h2><p>使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。</p><p>官网：<a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://router.vuejs.org/zh-cn/</a></p><p>使用npm安装：<code>npm install vue-router --save</code> </p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530161293338.png" srcset="/img/loading.gif" alt="1530161293338"></p><p>在index.html中引入依赖：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../node_modules/vue-router/dist/vue-router.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="7-3-快速入门"><a href="#7-3-快速入门" class="headerlink" title="7.3.快速入门"></a>7.3.快速入门</h2><p>新建vue-router对象，并且指定路由规则：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 创建VueRouter对象</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    routes:[ <span class="hljs-comment">// 编写路由规则</span>        &#123;            path:<span class="hljs-string">"/login"</span>, <span class="hljs-comment">// 请求路径</span>            component:loginForm <span class="hljs-comment">// 组件名称</span>        &#125;,        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">"/register"</span>,<span class="hljs-attr">component</span>:registerForm&#125;,    ]&#125;)</code></pre></div><ul><li>创建VueRouter对象，并指定路由参数</li><li>routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性：<ul><li>path：路由的路径</li><li>component：组件名称</li></ul></li></ul><p>在父组件中引入router对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,    components:&#123;<span class="hljs-comment">// 引用登录和注册组件</span>        loginForm,        registerForm    &#125;,    router <span class="hljs-comment">// 引用上面定义的router对象</span>&#125;)</code></pre></div><p>页面跳转控制：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-comment">&lt;!--router-link来指定跳转的路径--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/register"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!--vue-router的锚点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><ul><li>通过<code>&lt;router-view&gt;</code>来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染</li><li>通过<code>&lt;router-link&gt;</code>指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变</li></ul><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/62.gif" srcset="/img/loading.gif" alt></p><p><strong>注意</strong>：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。</p><p>事实上，我们总共就一个HTML：index.html</p><h1 id="8-webpack"><a href="#8-webpack" class="headerlink" title="8.webpack"></a>8.webpack</h1><p>Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。</p><p>中文官方网站：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530168661348.png" srcset="/img/loading.gif" alt="1530168661348"></p><p>官网给出的解释：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。 </p></blockquote><p>为什么需要打包？</p><ul><li>将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。</li><li>将ES6的高级语法进行转换编译，以兼容老版本的浏览器。</li><li>将代码打包的同时进行混淆，提高代码的安全性。</li></ul><h2 id="8-1-安装"><a href="#8-1-安装" class="headerlink" title="8.1.安装"></a>8.1.安装</h2><p>webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。</p><p>安装最新版本webpack，输入命令：<code>npm install --save-dev webpack</code></p><p> webpack 4+ 版本，你还需要安装 CLI ，输入命令：<code>npm install webpack webpack-cli --save-dev</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530187524815.png" srcset="/img/loading.gif" alt="1530187524815"></p><p>此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了）</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530187744149.png" srcset="/img/loading.gif" alt="1530187744149"></p><p>打开文件，可以看到我们之前用npm安装过的文件都会出现在这里：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1525873343908.png" srcset="/img/loading.gif" alt="1525873343908"></p><h2 id="8-2-核心概念"><a href="#8-2-核心概念" class="headerlink" title="8.2.核心概念"></a>8.2.核心概念</h2><p>学习Webpack，你需要先理解四个<strong>核心概念</strong>：</p><ul><li><p>入口(entry)</p><p>webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据</p></li><li><p>输出(output)</p><p>出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。</p></li><li><p>加载器（loader）</p><p>webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。</p></li><li><p>插件(plugins)</p><p>插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。</p></li></ul><h2 id="8-3-编写webpack配置"><a href="#8-3-编写webpack配置" class="headerlink" title="8.3.编写webpack配置"></a>8.3.编写webpack配置</h2><p>接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530199761226.png" srcset="/img/loading.gif" alt="1530199761226"></p><p>配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。</p><p>不过，加载器和插件是可选的。我们先编写入口和出口</p><h3 id="8-3-1-入口entry"><a href="#8-3-1-入口entry" class="headerlink" title="8.3.1.入口entry"></a>8.3.1.入口entry</h3><p>webpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？</p><p>我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530200787599.png" srcset="/img/loading.gif" alt="1530200787599"></p><p>然后把原来index.html中的js代码全部移动到index.js中</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用es6的语法导入js模块</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'../node_modules/vue/dist/vue'</span>;<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'../node_modules/vue-router/dist/vue-router'</span>;<span class="hljs-keyword">import</span> loginForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./user/login'</span>;<span class="hljs-keyword">import</span> registerForm <span class="hljs-keyword">from</span> <span class="hljs-string">'./user/register'</span>;Vue.use(VueRouter);<span class="hljs-comment">// 创建vue对象</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    routes: [ <span class="hljs-comment">// 编写路由规则</span>        <span class="hljs-comment">// path: 路由请求路径；component：组件名称</span>        &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">"/login"</span>, <span class="hljs-attr">component</span>: loginForm&#125;,        &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">"/register"</span>, <span class="hljs-attr">component</span>: registerForm&#125;    ]&#125;);<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">"#app"</span>,    components: &#123;        loginForm,        registerForm    &#125;,    router&#125;);</code></pre></div><ul><li><p>原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。</p></li><li><p>​</p><p>注意，要使用import，就需要在login.js和register.js中添加export导出语句：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loginForm=&#123;    template: <span class="hljs-string">'\</span><span class="hljs-string">       &lt;div&gt;\</span><span class="hljs-string">            &lt;h2&gt;登陆页&lt;/h2&gt;\</span><span class="hljs-string">            用户名：&lt;input type="text"&gt;&lt;br&gt;\</span><span class="hljs-string">            密&amp;emsp;码：&lt;input type="password"&gt;\</span><span class="hljs-string">       &lt;/div&gt;'</span>,&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> loginForm;</code></pre></div><p>register.js:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> registerForm = &#123;    template:<span class="hljs-string">'\</span><span class="hljs-string">    &lt;div&gt;\</span><span class="hljs-string">    &lt;h2&gt;注册页&lt;/h2&gt; \</span><span class="hljs-string">    用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\</span><span class="hljs-string">    密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    确认密码：&lt;input type="password"&gt;&lt;br/&gt;\</span><span class="hljs-string">    &lt;/div&gt;\</span><span class="hljs-string">    '</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> registerForm;</code></pre></div></li></ul><ul><li>vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter)</li></ul><p>这样，index.js就成了我们整个配置的入口了。</p><p>我们在webpack.config.js中添加以下内容：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports=&#123;    entry:<span class="hljs-string">'./src/index.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>&#125;</code></pre></div><h3 id="8-3-2-出口output"><a href="#8-3-2-出口output" class="headerlink" title="8.3.2.出口output"></a>8.3.2.出口output</h3><p>出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530201612391.png" srcset="/img/loading.gif" alt="1530201612391"></p><p>然后，编写webpack.config.js，添加出口配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>    output:&#123;        <span class="hljs-comment">// path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径</span>        path : __dirname+<span class="hljs-string">'/dist'</span>,          filename:<span class="hljs-string">'build.js'</span> <span class="hljs-comment">//输出的js文件名</span>    &#125;&#125;</code></pre></div><h2 id="8-4-执行打包"><a href="#8-4-执行打包" class="headerlink" title="8.4.执行打包"></a>8.4.执行打包</h2><p>在控制台输入以下命令：</p><div class="hljs"><pre><code class="hljs arduino">npx webpack --<span class="hljs-built_in">config</span> webpack.<span class="hljs-built_in">config</span>.js</code></pre></div><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530203361613.png" srcset="/img/loading.gif" alt="1530203361613"></p><p>随后，查看dist目录：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530203406462.png" srcset="/img/loading.gif" alt="1530203406462"></p><p>尝试打开build.js，你根本看不懂：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530203465737.png" srcset="/img/loading.gif" alt="1530203465737"></p><p>所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。</p><h2 id="8-5-测试运行"><a href="#8-5-测试运行" class="headerlink" title="8.5.测试运行"></a>8.5.测试运行</h2><p>在index.html中引入刚刚生成的build.js文件，</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!--router-link来指定跳转的路径--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/register"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-comment">&lt;!--vue-router的锚点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../dist/build.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>然后运行：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530203553915.png" srcset="/img/loading.gif" alt="1530203553915"></p><h2 id="8-6-打包CSS"><a href="#8-6-打包CSS" class="headerlink" title="8.6.打包CSS"></a>8.6.打包CSS</h2><p>我们来编写一段CSS代码，对index的样式做一些美化：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530203880056.png" srcset="/img/loading.gif" alt="1530203880056"></p><p>内容：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">a</span>&#123;    <span class="hljs-attribute">display</span>: inline-block;    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;    <span class="hljs-attribute">background-color</span>: dodgerblue;    <span class="hljs-attribute">color</span>: white;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;    <span class="hljs-attribute">text-decoration</span>: none;&#125;<span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;    <span class="hljs-attribute">background-color</span>: whitesmoke;    <span class="hljs-attribute">color</span>: dodgerblue;&#125;<span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;&#125;<span class="hljs-selector-id">#app</span>&#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">305px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid dodgerblue;&#125;</code></pre></div><h3 id="8-6-1-安装加载器"><a href="#8-6-1-安装加载器" class="headerlink" title="8.6.1.安装加载器"></a>8.6.1.安装加载器</h3><p>前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器：</p><p>命令：<code>npm install style-loader css-loader --save-dev</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530204068192.png" srcset="/img/loading.gif" alt="1530204068192"></p><p>此时，在package.json中能看到新安装的：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530204160848.png" srcset="/img/loading.gif" alt="1530204160848"></p><h3 id="8-6-3-index-js引入css文件"><a href="#8-6-3-index-js引入css文件" class="headerlink" title="8.6.3.index.js引入css文件"></a>8.6.3.index.js引入css文件</h3><p>因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'./css/main.css'</span></code></pre></div><h3 id="8-6-4-配置加载器"><a href="#8-6-4-配置加载器" class="headerlink" title="8.6.4.配置加载器"></a>8.6.4.配置加载器</h3><p>在webpack.config.js配置文件中配置css的加载器</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    entry: <span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>    output: &#123;        path: __dirname + <span class="hljs-string">'/dist'</span>, <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>        filename: <span class="hljs-string">'build.js'</span>  <span class="hljs-comment">//输出文件</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 通过正则表达式匹配所有以.css后缀的文件</span>                use: [ <span class="hljs-comment">// 要使用的加载器，这两个顺序一定不要乱</span>                    <span class="hljs-string">'style-loader'</span>,                    <span class="hljs-string">'css-loader'</span>                ]            &#125;        ]    &#125;&#125;</code></pre></div><h3 id="8-6-5-重新打包"><a href="#8-6-5-重新打包" class="headerlink" title="8.6.5.重新打包"></a>8.6.5.重新打包</h3><p>再次输入打包指令：<code>npx webpack --config webpack.config.js</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530204780240.png" srcset="/img/loading.gif" alt="1530204780240"></p><p>效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530204813013.png" srcset="/img/loading.gif" alt="1530204813013"></p><h2 id="8-7-script脚本"><a href="#8-7-script脚本" class="headerlink" title="8.7.script脚本"></a>8.7.script脚本</h2><p>我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。</p><p>我们可以把webpack的命令编入其中：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530205423730.png" srcset="/img/loading.gif" alt="1530205423730"></p><p>以后，如果要打包，就可以直接输入：<code>npm run build</code>即可。</p><p><code>npm run</code> ：执行npm脚本，后面跟的是配置脚本的名称<code>build</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530205504104.png" srcset="/img/loading.gif" alt="1530205504104"></p><h2 id="8-8-打包HTML"><a href="#8-8-打包HTML" class="headerlink" title="8.8.打包HTML"></a>8.8.打包HTML</h2><p>之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。</p><p>webpack中的一个插件：html-webpack-plugin，可以解决这个问题。</p><p>1）安装插件：<code>npm install --save-dev html-webpack-plugin</code></p><p>需要在webpack.config.js中添加插件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    entry: <span class="hljs-string">'./src/main.js'</span>,  <span class="hljs-comment">//指定打包的入口文件</span>    output: &#123;        path: __dirname + <span class="hljs-string">'/dist'</span>,  <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>        filename: <span class="hljs-string">'build.js'</span>   <span class="hljs-comment">//输出文件</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-comment">// 通过正则表达式匹配所有以.css后缀的文件</span>                use: [ <span class="hljs-comment">// 要使用的加载器，这两个顺序一定不要乱</span>                    <span class="hljs-string">'style-loader'</span>,                    <span class="hljs-string">'css-loader'</span>                ]            &#125;        ]    &#125;,    plugins:[        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            title: <span class="hljs-string">'首页'</span>,  <span class="hljs-comment">//生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;</span>            filename: <span class="hljs-string">'index.html'</span>, <span class="hljs-comment">// dist目录下生成的文件名</span>            template: <span class="hljs-string">'./src/index.html'</span> <span class="hljs-comment">// 我们原来的index.html，作为模板</span>        &#125;)    ]&#125;</code></pre></div><p>2）将原来HTML中的引入js代码删除：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530207035782.png" srcset="/img/loading.gif" alt="1530207035782"></p><p>3）再次打包：<code>npm run build</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530206990349.png" srcset="/img/loading.gif" alt="1530206990349"></p><p>4）查看dist目录：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530207132261.png" srcset="/img/loading.gif" alt="1530207132261"></p><p>打开index.html，发现已经自动添加了当前目录下的build.js</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!--router-link来指定跳转的路径--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/register"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-comment">&lt;!--vue-router的锚点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"build.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="8-9-热更新的web服务"><a href="#8-9-热更新的web服务" class="headerlink" title="8.9.热更新的web服务"></a>8.9.热更新的web服务</h2><p>刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。</p><p>webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果：</p><p>1）安装插件：<code>npm install webpack-dev-server --save-dev</code></p><p>2）添加启动脚本</p><p>在package.json中配置script</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">"scripts"</span>: &#123;  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"</span>&#125;,</code></pre></div><p>–inline：自动刷新</p><p>–hot：热加载</p><p>–port：指定端口</p><p>–open：自动在默认浏览器打开</p><p>–host：可以指定服务器的 ip，不指定则为127.0.0.1</p><p>3）运行脚本：<code>npm run dev</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530207667660.png" srcset="/img/loading.gif" alt="1530207667660"></p><p>4）效果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530207505226.png" srcset="/img/loading.gif" alt="1530207505226"></p><h1 id="9-vue-cli"><a href="#9-vue-cli" class="headerlink" title="9.vue-cli"></a>9.vue-cli</h1><h2 id="9-1-介绍和安装"><a href="#9-1-介绍和安装" class="headerlink" title="9.1.介绍和安装"></a>9.1.介绍和安装</h2><p>在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。</p><p>幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli</p><p>使用它能快速的构建一个web工程模板。</p><p>官网：<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli</a></p><p>安装命令：<code>npm install -g vue-cli</code></p><h2 id="9-2-快速上手"><a href="#9-2-快速上手" class="headerlink" title="9.2.快速上手"></a>9.2.快速上手</h2><p>我们新建一个module：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208068828.png" srcset="/img/loading.gif" alt="1530208068828"></p><p>切换到该目录：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208139922.png" srcset="/img/loading.gif" alt="1530208139922"></p><p>用vue-cli命令，快速搭建一个webpack的项目：<code>vue init webpack</code></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208650256.png" srcset="/img/loading.gif" alt="1530208556831"></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208708000.png" srcset="/img/loading.gif" alt="1530208708000"></p><p>前面几项都走默认或yes</p><p>下面这些我们选no</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208850418.png" srcset="/img/loading.gif" alt="1530208850418"></p><p>最后，再选yes，使用 npm安装</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208897063.png" srcset="/img/loading.gif" alt="1530208897063"></p><p>开始初始化项目，并安装依赖，可能需要</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530208932814.png" srcset="/img/loading.gif" alt="1530208932814"></p><p>安装成功！</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530209062090.png" srcset="/img/loading.gif" alt="1530209062090"></p><p>可以使用<code>npm run dev</code>命令启动。</p><h2 id="9-3-项目结构"><a href="#9-3-项目结构" class="headerlink" title="9.3.项目结构"></a>9.3.项目结构</h2><p>安装好的项目结构：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530209146349.png" srcset="/img/loading.gif" alt="1530209146349"></p><p>入口文件：main.js</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530209503007.png" srcset="/img/loading.gif" alt="1525913687860"></p><h2 id="9-4-单文件组件"><a href="#9-4-单文件组件" class="headerlink" title="9.4.单文件组件"></a>9.4.单文件组件</h2><p>需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530209769323.png" srcset="/img/loading.gif" alt="1530209769323"></p><p>每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js</p><p>只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。</p><p>而单文件组件中包含三部分内容：</p><ul><li>template：模板，支持html语法高亮和提示</li><li>script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等</li><li>style：样式，支持CSS语法高亮和提示</li></ul><p>每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。</p><h2 id="9-5-运行"><a href="#9-5-运行" class="headerlink" title="9.5.运行"></a>9.5.运行</h2><p>看看生成的package.json：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530210016103.png" srcset="/img/loading.gif" alt="1530210016103"></p><ul><li>可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。</li><li>运行时依赖只有vue和vue-router</li><li>脚本有三个：<ul><li>dev：使用了webpack-dev-server命令，开发时热部署使用</li><li>start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 </li><li>build：等同于webpack的打包功能，会打包到dist目录下。</li></ul></li></ul><p>我们执行<code>npm run dev</code> 或者 <code>npm start</code> 都可以启动项目：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530210411076.png" srcset="/img/loading.gif" alt="1530210411076"></p><p>页面：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday05/1530210349704.png" srcset="/img/loading.gif" alt="1530210349704"></p>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>webpack</tag>
      
      <tag>vue-cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day04：项目搭建</title>
    <link href="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/"/>
    <url>/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解电商行业</li><li>了解乐优商城项目结构</li><li>能独立搭建项目基本框架</li><li>能参考使用ES6的新语法</li></ul><h1 id="1-了解电商行业"><a href="#1-了解电商行业" class="headerlink" title="1.了解电商行业"></a>1.了解电商行业</h1><p>学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业</p><h2 id="1-1-项目分类"><a href="#1-1-项目分类" class="headerlink" title="1.1.项目分类"></a>1.1.项目分类</h2><p>主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同</p><h3 id="1-1-1-传统项目"><a href="#1-1-1-传统项目" class="headerlink" title="1.1.1.传统项目"></a>1.1.1.传统项目</h3><p>各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。）</p><ul><li>需求方：公司、企业内部</li><li>盈利模式：项目本身卖钱</li><li>技术侧重点：业务功能</li></ul><h3 id="1-1-2-互联网项目"><a href="#1-1-2-互联网项目" class="headerlink" title="1.1.2.互联网项目"></a>1.1.2.互联网项目</h3><p>门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com  …… </p><ul><li>需求方：广大用户群体</li><li>盈利模式：虚拟币、增值服务、广告收益……</li><li>技术侧重点：网站性能、业务功能</li></ul><p>而我们今天要聊的就是互联网项目中的重要角色：电商</p><h2 id="1-2-电商行业的发展"><a href="#1-2-电商行业的发展" class="headerlink" title="1.2.电商行业的发展"></a>1.2.电商行业的发展</h2><h3 id="1-2-1-钱景"><a href="#1-2-1-钱景" class="headerlink" title="1.2.1.钱景"></a>1.2.1.钱景</h3><p>近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。</p><p>中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。</p><div class="hljs"><pre><code>![1525686041466](乐优商城day04/1525686041466.png)</code></pre></div><h3 id="1-2-2-数据"><a href="#1-2-2-数据" class="headerlink" title="1.2.2.数据"></a>1.2.2.数据</h3><p>来看看双十一的成交数据：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525686135308.png" srcset="/img/loading.gif" alt="1525686135308"></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525686160411.png" srcset="/img/loading.gif" alt="1525686160411"></p><p>2016双11开场30分钟，创造<strong>每秒交易峰值17.5万笔</strong>，<strong>每秒</strong>支付峰值<strong>12万笔</strong>的新纪录。菜鸟单日物流订单量超过<strong>4.67亿</strong>，创历史新高。</p><h3 id="1-2-3-技术特点"><a href="#1-2-3-技术特点" class="headerlink" title="1.2.3.技术特点"></a>1.2.3.技术特点</h3><p>从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？</p><ul><li>技术范围广</li><li>技术新</li><li>高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列）</li><li>高可用（集群、负载均衡、限流、降级、熔断）</li><li>数据量大</li><li>业务复杂</li><li>数据安全</li></ul><h2 id="1-3-常见电商模式"><a href="#1-3-常见电商模式" class="headerlink" title="1.3.常见电商模式"></a>1.3.常见电商模式</h2><p>电商行业的一些常见模式：</p><ul><li>B2C：商家对个人，如：亚马逊、当当等</li><li>C2C平台：个人对个人，如：咸鱼、拍拍网、ebay</li><li>B2B平台：商家对商家，如：阿里巴巴、八方资源网等</li><li>O2O：线上和线下结合，如：饿了么、电影票、团购等</li><li>P2P：在线金融，贷款，如：网贷之家、人人聚财等。</li><li>B2C平台：天猫、京东、一号店等</li></ul><h2 id="1-4-一些专业术语"><a href="#1-4-一些专业术语" class="headerlink" title="1.4.一些专业术语"></a>1.4.一些专业术语</h2><ul><li><p>SaaS：软件即服务</p></li><li><p>SOA：面向服务</p></li><li><p>RPC：远程过程调用</p></li><li><p>RMI：远程方法调用</p></li><li><p>PV：(page view)，即页面浏览量；</p><p>用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计</p></li><li><p>UV：(unique visitor)，独立访客</p><p>指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。</p></li><li><p>PV与带宽：</p><ul><li>计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。</li><li>计算公式是：网站带宽= ( PV * 平均页面大小（单位MB）* 8 )/统计时间（换算到秒）</li><li>为什么要乘以8？<ul><li>网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit</li></ul></li><li>这个计算的是平均带宽，高峰期还需要扩大一定倍数</li></ul></li><li><p>PV、QPS、并发</p><ul><li><p>QPS：每秒处理的请求数量。8000/s</p><ul><li>比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。</li></ul></li><li><p>由PV和QPS如何需要部署的服务器数量？</p><ul><li>根据二八原则，80%的请求集中在20%的时间来计算峰值压力：</li><li>（每日PV * 80%） / （3600s * 24 * 20%） * 每个页面的请求数  = 每个页面每秒的请求数量</li><li>然后除以服务器的QPS值，即可计算得出需要部署的服务器数量</li></ul></li></ul></li></ul><h2 id="1-5-项目开发流程"><a href="#1-5-项目开发流程" class="headerlink" title="1.5.项目开发流程"></a>1.5.项目开发流程</h2><p>项目经理：管人</p><p>产品经理：设计需求原型</p><p>测试：</p><p>前端：大前端。node</p><p>后端：</p><p>移动端：</p><p>项目开发流程图：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525697632643.png" srcset="/img/loading.gif" alt="1525697632643">    </p><p>公司现状：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525697681975.png" srcset="/img/loading.gif" alt="1525697681975"></p><h1 id="2-乐优商城介绍"><a href="#2-乐优商城介绍" class="headerlink" title="2.乐优商城介绍"></a>2.乐优商城介绍</h1><h2 id="2-1-项目介绍"><a href="#2-1-项目介绍" class="headerlink" title="2.1.项目介绍"></a>2.1.项目介绍</h2><ul><li>乐优商城是一个全品类的电商购物网站（B2C）。</li><li>用户可以在线购买商品、加入购物车、下单、秒杀商品</li><li>可以品论已购买商品</li><li>管理员可以在后台管理商品的上下架、促销活动</li><li>管理员可以监控商品销售状况</li><li>客服可以在后台处理退款操作</li><li>希望未来3到5年可以支持千万用户的使用</li></ul><h2 id="2-2-系统架构"><a href="#2-2-系统架构" class="headerlink" title="2.2.系统架构"></a>2.2.系统架构</h2><h3 id="2-2-1-架构图"><a href="#2-2-1-架构图" class="headerlink" title="2.2.1.架构图"></a>2.2.1.架构图</h3><p>乐优商城架构缩略图，大图请参考课前资料：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525703759035.png" srcset="/img/loading.gif" alt="1525703759035"></p><h3 id="2-2-2-系统架构解读"><a href="#2-2-2-系统架构解读" class="headerlink" title="2.2.2.系统架构解读"></a>2.2.2.系统架构解读</h3><p>整个乐优商城可以分为两部分：后台管理系统、前台门户系统。</p><ul><li><p>后台管理：</p><ul><li>后台系统主要包含以下功能：<ul><li>商品管理，包括商品分类、品牌、商品规格等信息的管理</li><li>销售管理，包括订单统计、订单退款处理、促销活动生成等</li><li>用户管理，包括用户控制、冻结、解锁等</li><li>权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制</li><li>统计，各种数据的统计分析展示</li></ul></li><li>后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。</li><li>预览图：</li></ul><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525704185158.png" srcset="/img/loading.gif" alt="1525704185158"></p></li><li><p>前台门户</p><ul><li>前台门户面向的是客户，包含与客户交互的一切功能。例如：<ul><li>搜索商品</li><li>加入购物车</li><li>下单</li><li>评价商品等等</li></ul></li><li>前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。</li></ul><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525704277126.png" srcset="/img/loading.gif" alt="1525704277126"></p></li></ul><p>无论是前台还是后台系统，都共享相同的微服务集群，包括：</p><ul><li>商品微服务：商品及商品分类、品牌、库存等的服务</li><li>搜索微服务：实现搜索功能</li><li>订单微服务：实现订单相关</li><li>购物车微服务：实现购物车相关功能</li><li>用户中心：用户的登录注册等功能</li><li>Eureka注册中心</li><li>Zuul网关服务</li><li>Spring Cloud Config配置中心</li><li>…</li></ul><h1 id="3-项目搭建"><a href="#3-项目搭建" class="headerlink" title="3.项目搭建"></a>3.项目搭建</h1><h2 id="3-1-技术选型"><a href="#3-1-技术选型" class="headerlink" title="3.1.技术选型"></a>3.1.技术选型</h2><p>前端技术：</p><ul><li>基础的HTML、CSS、JavaScript（基于ES6标准）</li><li>JQuery</li><li>Vue.js 2.0以及基于Vue的框架：Vuetify</li><li>前端构建工具：WebPack</li><li>前端安装包工具：NPM</li><li>Vue脚手架：Vue-cli</li><li>Vue路由：vue-router</li><li>ajax框架：axios</li><li>基于Vue的富文本框架：quill-editor</li></ul><p>后端技术：</p><ul><li>基础的SpringMVC、Spring 5.0和MyBatis3</li><li>Spring Boot 2.0.1版本</li><li>Spring Cloud 最新版 Finchley.RC1</li><li>Redis-4.0</li><li>RabbitMQ-3.4</li><li>Elasticsearch-5.6.8</li><li>nginx-1.10.2：</li><li>FastDFS - 5.0.8</li><li>MyCat</li><li>Thymeleaf</li></ul><h2 id="3-2-开发环境"><a href="#3-2-开发环境" class="headerlink" title="3.2.开发环境"></a>3.2.开发环境</h2><p>为了保证开发环境的统一，希望每个人都按照我的环境来配置：</p><ul><li>IDE：我们使用Idea 2017.3 版本</li><li>JDK：统一使用JDK1.8</li><li>项目构建：maven3.3.9以上版本即可</li><li>版本控制工具：git</li></ul><p>idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》</p><h2 id="3-3-域名"><a href="#3-3-域名" class="headerlink" title="3.3.域名"></a>3.3.域名</h2><p>我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。</p><p>一级域名：<a href="http://www.leyou.com" target="_blank" rel="noopener">www.leyou.com</a></p><p>二级域名：manage.leyou.com , api.leyou.com</p><p>我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。</p><p>switchhost可以去课前资料寻找。</p><h2 id="3-4-创建父工程"><a href="#3-4-创建父工程" class="headerlink" title="3.4.创建父工程"></a>3.4.创建父工程</h2><p>创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525706200704.png" srcset="/img/loading.gif" alt="1525706200704"></p><p>填写项目信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525707023009.png" srcset="/img/loading.gif" alt="1525707023009"></p><p>注意：</p><p>父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖</p><p>跳过依赖选择。</p><p>填写保存的位置信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525706600181.png" srcset="/img/loading.gif" alt="1525706600181"></p><p>然后将pom文件修改成我这个样子：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.parent<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>leyou<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>leyou<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mybatis.starter.version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.starter.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper.starter.version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">mapper.starter.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">druid.starter.version</span>&gt;</span>1.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">druid.starter.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.32<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pageHelper.starter.version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">pageHelper.starter.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">leyou.latest.version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">leyou.latest.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">fastDFS.client.version</span>&gt;</span>1.26.1-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">fastDFS.client.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!-- springCloud --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- mybatis启动器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 通用Mapper启动器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 分页助手启动器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pageHelper.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--FastDFS客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.tobato<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fastDFS.client.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。</p><p>最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。</p><h2 id="3-5-创建EurekaServer"><a href="#3-5-创建EurekaServer" class="headerlink" title="3.5.创建EurekaServer"></a>3.5.创建EurekaServer</h2><h3 id="3-5-1-创建工程"><a href="#3-5-1-创建工程" class="headerlink" title="3.5.1.创建工程"></a>3.5.1.创建工程</h3><p>这个大家应该比较熟悉了。</p><p>我们的注册中心，起名为：ly-registry</p><p>这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖：</p><p>选择新建module：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525707765104.png" srcset="/img/loading.gif" alt="1525707765104"></p><p>选择maven安装，但是不要选择骨架：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525707850047.png" srcset="/img/loading.gif" alt="1525707850047"></p><p>然后填写项目坐标，我们的项目名称为ly-registry:</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525707949252.png" srcset="/img/loading.gif" alt="1525707949252"></p><p>选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525708053551.png" srcset="/img/loading.gif" alt="1525708053551"></p><h3 id="3-5-2-添加依赖"><a href="#3-5-2-添加依赖" class="headerlink" title="3.5.2.添加依赖"></a>3.5.2.添加依赖</h3><p>添加EurekaServer的依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>leyou<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.parent<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.common<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-registry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="3-5-3-编写启动类"><a href="#3-5-3-编写启动类" class="headerlink" title="3.5.3.编写启动类"></a>3.5.3.编写启动类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LyRegistry</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(LyRegistry<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="3-5-4-配置文件"><a href="#3-5-4-配置文件" class="headerlink" title="3.5.4.配置文件"></a>3.5.4.配置文件</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">ly-registry</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span>  <span class="hljs-attr">server:</span>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭自我保护</span>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">5000</span> <span class="hljs-comment"># 每隔5秒进行一次服务列表清理</span></code></pre></div><h3 id="3-5-5-项目的结构："><a href="#3-5-5-项目的结构：" class="headerlink" title="3.5.5.项目的结构："></a>3.5.5.项目的结构：</h3><p>目前，整个项目的结构如图：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525708460522.png" srcset="/img/loading.gif" alt="1525708460522"></p><h2 id="3-6-创建Zuul网关"><a href="#3-6-创建Zuul网关" class="headerlink" title="3.6.创建Zuul网关"></a>3.6.创建Zuul网关</h2><h3 id="3-6-1-创建工程"><a href="#3-6-1-创建工程" class="headerlink" title="3.6.1.创建工程"></a>3.6.1.创建工程</h3><p>与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525708626562.png" srcset="/img/loading.gif" alt="1525708626562"></p><p>填写保存的目录：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525708677719.png" srcset="/img/loading.gif" alt="1525708677719"></p><h3 id="3-6-2-添加依赖"><a href="#3-6-2-添加依赖" class="headerlink" title="3.6.2.添加依赖"></a>3.6.2.添加依赖</h3><p>这里我们需要添加Zuul和EurekaClient的依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>leyou<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.parent<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.common<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-api-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="3-6-3-编写启动类"><a href="#3-6-3-编写启动类" class="headerlink" title="3.6.3.编写启动类"></a>3.6.3.编写启动类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@EnableZuulProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LyApiGateway</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(LyApiGateway<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="3-6-4-配置文件"><a href="#3-6-4-配置文件" class="headerlink" title="3.6.4.配置文件"></a>3.6.4.配置文件</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api</span> <span class="hljs-comment"># 添加路由前缀</span>  <span class="hljs-attr">retryable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">2000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span><span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">command:</span>    <span class="hljs-attr">default:</span>      <span class="hljs-attr">execution:</span>        <span class="hljs-attr">isolation:</span>          <span class="hljs-attr">thread:</span>            <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">10000</span> <span class="hljs-comment"># 熔断超时时长：10000ms</span></code></pre></div><h3 id="3-6-5-项目结构"><a href="#3-6-5-项目结构" class="headerlink" title="3.6.5.项目结构"></a>3.6.5.项目结构</h3><p>目前，leyou下有两个子模块：</p><ul><li>ly-registry：服务的注册中心（EurekaServer）</li><li>ly-api-gateway：服务网关（Zuul）</li></ul><p>目前，服务的结构如图所示：</p><div class="hljs"><pre><code>![1525709241440](乐优商城day04/1525709241440.png)</code></pre></div><p>截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。</p><h2 id="3-7-创建商品微服务"><a href="#3-7-创建商品微服务" class="headerlink" title="3.7.创建商品微服务"></a>3.7.创建商品微服务</h2><p>既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括：</p><ul><li>商品分类管理</li><li>品牌管理</li><li>商品规格参数管理</li><li>商品管理</li><li>库存管理</li></ul><p>我们先完成项目的搭建：</p><h3 id="3-7-1-微服务的结构"><a href="#3-7-1-微服务的结构" class="headerlink" title="3.7.1.微服务的结构"></a>3.7.1.微服务的结构</h3><p>因为与商品的品类相关，我们的工程命名为<code>ly-item</code>.</p><p>需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。</p><p>因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。</p><p>我们会在ly-item中创建两个子工程：</p><ul><li>ly-item-interface：主要是对外暴露的接口及相关实体类</li><li>ly-item-service：所有业务逻辑及内部使用接口</li></ul><p>调用关系如图所示：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525744281610.png" srcset="/img/loading.gif" alt="1525744281610"></p><h3 id="3-7-2-创建父工程ly-item"><a href="#3-7-2-创建父工程ly-item" class="headerlink" title="3.7.2.创建父工程ly-item"></a>3.7.2.创建父工程ly-item</h3><p>依然是使用maven构建：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525744570533.png" srcset="/img/loading.gif" alt="1525744570533"></p><p>保存的位置：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525744595793.png" srcset="/img/loading.gif" alt="1525744595793"></p><p>不需要任何依赖，我们可以把项目打包方式设置为pom</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>leyou<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.parent<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-item<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 打包方式为pom --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="3-7-3-创建ly-item-interface"><a href="#3-7-3-创建ly-item-interface" class="headerlink" title="3.7.3.创建ly-item-interface"></a>3.7.3.创建ly-item-interface</h3><p>在ly-item工程上点击右键，选择new &gt; module:</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525744768694.png" srcset="/img/loading.gif" alt="1525744768694"></p><p>依然是使用maven构建，注意父工程是ly-item：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525744875078.png" srcset="/img/loading.gif" alt="1525744875078"></p><p><strong>注意</strong>：接下来填写的目录结构需要自己手动完成，保存到<code>ly-item</code>下的<code>ly-item-interface</code>目录中：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525744973026.png" srcset="/img/loading.gif" alt="1525744973026"></p><p>点击Finish完成。</p><p>此时的项目结构：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525745119573.png" srcset="/img/loading.gif" alt="1525745119573"></p><h3 id="3-7-4-创建ly-item-service"><a href="#3-7-4-创建ly-item-service" class="headerlink" title="3.7.4.创建ly-item-service"></a>3.7.4.创建ly-item-service</h3><p>与<code>ly-item-interface</code>类似，我们选择在<code>ly-item</code>上右键，新建module，然后填写项目信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525745247195.png" srcset="/img/loading.gif" alt="1525745247195"></p><p>填写存储位置，是在<code>/ly-item/ly-item-service</code>目录</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525745303365.png" srcset="/img/loading.gif" alt="1525745303365"></p><p>点击Finish完成。</p><h3 id="3-7-5-整个微服务结构"><a href="#3-7-5-整个微服务结构" class="headerlink" title="3.7.5.整个微服务结构"></a>3.7.5.整个微服务结构</h3><p>如图所示：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525745407047.png" srcset="/img/loading.gif" alt="1525745407047"></p><p>我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525745475108.png" srcset="/img/loading.gif" alt="1525745475108"></p><h3 id="3-7-6-添加依赖"><a href="#3-7-6-添加依赖" class="headerlink" title="3.7.6.添加依赖"></a>3.7.6.添加依赖</h3><p>接下来我们给<code>ly-item-service</code>中添加依赖：</p><p>思考一下我们需要什么？</p><ul><li>Eureka客户端</li><li>web启动器</li><li>mybatis启动器</li><li>通用mapper启动器</li><li>分页助手启动器</li><li>连接池，我们用默认的Hykira</li><li>mysql驱动</li><li>千万不能忘了，我们自己也需要<code>ly-item-interface</code>中的实体类</li></ul><p>这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-item<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-item-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--Eureka客户端--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--web启动器--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- mybatis启动器 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 通用Mapper启动器 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 分页助手启动器 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;pageHelper.starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ly-item-interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;leyou.latest.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>ly-item-interface中需要什么我们暂时不清楚，所以先不管。</p><p>整个结构：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525747398193.png" srcset="/img/loading.gif" alt="1525747398193"></p><h3 id="3-7-7-编写启动和配置"><a href="#3-7-7-编写启动和配置" class="headerlink" title="3.7.7.编写启动和配置"></a>3.7.7.编写启动和配置</h3><p>在整个<code>ly-item工程</code>中，只有<code>ly-item-service</code>是需要启动的。因此在其中编写启动类即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LyItemService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(LyItemService<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>然后是全局属性文件：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/heima</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">30</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">10</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 每隔5秒发送一次心跳</span>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 10秒不发送就过期</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></code></pre></div><h2 id="3-8-添加商品微服务的路由规则"><a href="#3-8-添加商品微服务的路由规则" class="headerlink" title="3.8.添加商品微服务的路由规则"></a>3.8.添加商品微服务的路由规则</h2><p>既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api</span> <span class="hljs-comment"># 添加路由前缀</span>  <span class="hljs-attr">retryable:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">item-service:</span> <span class="hljs-string">/item/**</span> <span class="hljs-comment"># 将商品微服务映射到/item/**</span></code></pre></div><h2 id="3-9-启动测试"><a href="#3-9-启动测试" class="headerlink" title="3.9.启动测试"></a>3.9.启动测试</h2><p>我们分别启动：ly-registry，ly-api-gateway，ly-item-service</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525749186008.png" srcset="/img/loading.gif" alt="1525749186008"></p><p>查看Eureka面板：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525749215954.png" srcset="/img/loading.gif" alt="1525749215954"></p><h2 id="3-10-测试路由规则"><a href="#3-10-测试路由规则" class="headerlink" title="3.10.测试路由规则"></a>3.10.测试路由规则</h2><p>为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？</p><p>其实不需要，Spring提供了一个依赖：actuator</p><p>只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口：</p><ul><li>/info</li><li>/health</li><li>/refresh</li><li>…</li></ul><p>添加依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>重启后访问Eureka控制台：</p><p>鼠标悬停在item-service上，会显示一个地址：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525749683060.png" srcset="/img/loading.gif" alt="1525749683060"></p><p>这就是actuator提供的接口，我们点击访问：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525749711606.png" srcset="/img/loading.gif" alt="1525749711606"></p><p>因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。</p><p>接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是：</p><p><a href="http://127.0.0.1:10010/api/item/actuator/info" target="_blank" rel="noopener">http://127.0.0.1:10010/api/item/actuator/info</a></p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1525749803191.png" srcset="/img/loading.gif" alt="1525749803191"></p><h2 id="3-11-通用工具模块"><a href="#3-11-通用工具模块" class="headerlink" title="3.11.通用工具模块"></a>3.11.通用工具模块</h2><p>有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：<code>ly-common</code></p><p>使用maven来构建module：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526046318620.png" srcset="/img/loading.gif" alt="1526046318620"></p><p>位置信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526046349379.png" srcset="/img/loading.gif" alt="1526046349379"></p><p>结构：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526046432347.png" srcset="/img/loading.gif" alt="1526046432347"></p><p>目前还不需要编码。</p><h1 id="4、ES6-语法指南"><a href="#4、ES6-语法指南" class="headerlink" title="4、ES6 语法指南"></a>4、ES6 语法指南</h1><p>后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。</p><p>什么是ES6？就是ECMAScript第6版标准。</p><h2 id="4-1-什么是ECMAScript？"><a href="#4-1-什么是ECMAScript？" class="headerlink" title="4.1.什么是ECMAScript？"></a>4.1.什么是ECMAScript？</h2><p>来看下前端的发展历程：</p><blockquote><p>web1.0时代：</p></blockquote><ul><li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li></ul><blockquote><p>web2.0时代：</p></blockquote><ul><li>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。</li><li>1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。</li><li>1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了<code>ECMAscript</code>标准规范。JavaScript和JScript都是<code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</li></ul><p>所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。</p><h2 id="4-2-ECMAScript的快速发展"><a href="#4-2-ECMAScript的快速发展" class="headerlink" title="4.2.ECMAScript的快速发展"></a>4.2.ECMAScript的快速发展</h2><p>而后，ECMAScript就进入了快速发展期。</p><ul><li><p>1998年6月，ECMAScript 2.0 发布。</p></li><li><p>1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。</p></li><li><p>2007年10月。。。。ECMAScript 4.0 草案发布。</p><p>这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。</p><ul><li>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</li><li>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</li></ul><p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中</p></li><li><p>2009年12月，ECMAScript 5 发布。</p></li><li><p>2011年6月，ECMAScript 5.1 发布。</p></li><li><p>2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 </p></li></ul><h2 id="4-3-ES5和6的一些新特性"><a href="#4-3-ES5和6的一些新特性" class="headerlink" title="4.3.ES5和6的一些新特性"></a>4.3.ES5和6的一些新特性</h2><p>我们这里只把一些常用的进行学习，更详细的大家参考：<a href="http://es6.ruanyifeng.com/?search=reduce&x=0&y=0#README" target="_blank" rel="noopener">阮一峰的ES6教程</a></p><h3 id="4-3-1-let-和-const-命令"><a href="#4-3-1-let-和-const-命令" class="headerlink" title="4.3.1.let 和 const 命令"></a>4.3.1.let 和 const 命令</h3><blockquote><p>var</p></blockquote><p>之前，js定义变量只有一个关键字：<code>var</code></p><p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。</p><p>例如这样的一段代码：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;    <span class="hljs-built_in">console</span>.log(i);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"循环外："</span> + i)</code></pre></div><p>你猜下打印的结果是什么？</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526107278999.png" srcset="/img/loading.gif" alt="1526107278999"></p><blockquote><p>let</p></blockquote><p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p>我们把刚才的<code>var</code>改成<code>let</code>试试：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;    <span class="hljs-built_in">console</span>.log(i);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"循环外："</span> + i)</code></pre></div><p>结果：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526107347275.png" srcset="/img/loading.gif" alt="1526107347275"></p><blockquote><p>const</p></blockquote><p><code>const</code>声明的变量是常量，不能被修改</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526107425000.png" srcset="/img/loading.gif" alt="1526107425000"></p><h3 id="4-3-2-字符串扩展"><a href="#4-3-2-字符串扩展" class="headerlink" title="4.3.2.字符串扩展"></a>4.3.2.字符串扩展</h3><blockquote><p>新的API</p></blockquote><p>ES6为字符串扩展了几个新的API：</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>实验一下：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526107640349.png" srcset="/img/loading.gif" alt="1526107640349"></p><blockquote><p>字符串模板</p></blockquote><p>ES6中提供了`来作为字符串模板标记。我们可以这么玩：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526108070980.png" srcset="/img/loading.gif" alt="1526108070980"></p><p>在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本</p><p>键盘是的1的左侧，tab的上侧，esc的正下方</p><h3 id="4-3-3-解构表达式"><a href="#4-3-3-解构表达式" class="headerlink" title="4.3.3.解构表达式"></a>4.3.3.解构表达式</h3><blockquote><p>数组解构</p></blockquote><p>比如有一个数组：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</code></pre></div><p>我想获取其中的值，只能通过角标。ES6可以这样：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [x,y,z] = arr;<span class="hljs-comment">// x，y，z将与arr中的每个位置对应来取值</span><span class="hljs-comment">// 然后打印</span><span class="hljs-built_in">console</span>.log(x,y,z);</code></pre></div><p>结果：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526109778368.png" srcset="/img/loading.gif" alt="1526109778368"></p><blockquote><p>对象解构</p></blockquote><p>例如有个person对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name:<span class="hljs-string">"jack"</span>,    age:<span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>,<span class="hljs-string">'js'</span>,<span class="hljs-string">'css'</span>]&#125;</code></pre></div><p>我们可以这么做：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 解构表达式获取值</span><span class="hljs-keyword">const</span> &#123;name,age,language&#125; = person;<span class="hljs-comment">// 打印</span><span class="hljs-built_in">console</span>.log(name);<span class="hljs-built_in">console</span>.log(age);<span class="hljs-built_in">console</span>.log(language);</code></pre></div><p>结果：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526109984544.png" srcset="/img/loading.gif" alt="1526109984544"></p><p>如过想要用其它变量接收，需要额外指定别名：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526110159450.png" srcset="/img/loading.gif" alt="1526110159450"></p><ul><li><code>{name:n}</code>：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。</li></ul><h3 id="4-3-4-函数优化"><a href="#4-3-4-函数优化" class="headerlink" title="4.3.4.函数优化"></a>4.3.4.函数优化</h3><blockquote><p>函数参数默认值</p></blockquote><p>在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a , b</span>) </span>&#123;    <span class="hljs-comment">// 判断b是否为空，为空就给默认值1</span>    b = b || <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-comment">// 传一个参数</span><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>));</code></pre></div><p>现在可以这么写：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a , b = <span class="hljs-number">1</span></span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-comment">// 传一个参数</span><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>));</code></pre></div><blockquote><p>箭头函数</p></blockquote><p>ES6中定义函数的简写方式：</p><p>一个参数时：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(obj);&#125;<span class="hljs-comment">// 简写为：</span><span class="hljs-keyword">var</span> print2 = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(obj);</code></pre></div><p>多个参数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 两个参数的情况：</span><span class="hljs-keyword">var</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a , b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-comment">// 简写为：</span><span class="hljs-keyword">var</span> sum2 = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a+b;</code></pre></div><p>代码不止一行，可以用<code>{}</code>括起来</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sum3 = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> a + b;&#125;</code></pre></div><blockquote><p>对象的函数属性简写</p></blockquote><p>比如一个Person对象，里面有eat方法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;    name: <span class="hljs-string">"jack"</span>,    <span class="hljs-comment">// 以前：</span>    eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food);    &#125;,    <span class="hljs-comment">// 箭头函数版：</span>    eat2: <span class="hljs-function"><span class="hljs-params">food</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(person.name + <span class="hljs-string">"在吃"</span> + food),<span class="hljs-comment">// 这里拿不到this</span>    <span class="hljs-comment">// 简写版：</span>    eat3(food)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">"在吃"</span> + food);    &#125;&#125;</code></pre></div><blockquote><p>箭头函数结合解构表达式</p></blockquote><p>比如有一个函数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name:<span class="hljs-string">"jack"</span>,    age:<span class="hljs-number">21</span>,    language: [<span class="hljs-string">'java'</span>,<span class="hljs-string">'js'</span>,<span class="hljs-string">'css'</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">person</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello,"</span> + person.name)&#125;</code></pre></div><p>如果用箭头函数和解构表达式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> hi = <span class="hljs-function">(<span class="hljs-params">&#123;name&#125;</span>) =&gt;</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello,"</span> + name);</code></pre></div><h3 id="4-3-5-map和reduce"><a href="#4-3-5-map和reduce" class="headerlink" title="4.3.5.map和reduce"></a>4.3.5.map和reduce</h3><p>数组中新增了map和reduce方法。</p><blockquote><p>map</p></blockquote><p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><p>举例：有一个字符串数组，我们希望转为int数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'1'</span>,<span class="hljs-string">'20'</span>,<span class="hljs-string">'-5'</span>,<span class="hljs-string">'3'</span>];<span class="hljs-built_in">console</span>.log(arr)arr = arr.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(s));<span class="hljs-built_in">console</span>.log(arr)</code></pre></div><p>  <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526110796839.png" srcset="/img/loading.gif" alt="1526110796839"></p><blockquote><p>reduce</p></blockquote><p><code>reduce()</code>：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：</p><ul><li>第一个参数是上一次reduce处理的结果</li><li>第二个参数是数组中要处理的下一个元素</li></ul><p><code>reduce()</code>会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数</p><p>举例：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">20</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">3</span>]</code></pre></div><p>没有初始值：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526111537204.png" srcset="/img/loading.gif" alt="1526111537204"></p><p>指定初始值：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526111580742.png" srcset="/img/loading.gif" alt="1526111580742"></p><h3 id="4-3-6-promise"><a href="#4-3-6-promise" class="headerlink" title="4.3.6.promise"></a>4.3.6.promise</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>感觉跟java的Future类很像啊，有木有！</p><p>我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。</p><p>语法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ... 执行异步操作</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;    resolve(value);<span class="hljs-comment">// 调用resolve，代表Promise将返回成功的结果</span>  &#125; <span class="hljs-keyword">else</span> &#123;    reject(error);<span class="hljs-comment">// 调用reject，代表Promise会返回失败结果</span>  &#125;&#125;);</code></pre></div><p>这样，在promise中就封装了一段异步执行的结果。</p><p>如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法：</p><div class="hljs"><pre><code class="hljs js">promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;    <span class="hljs-comment">// 异步执行成功后的回调</span>&#125;);</code></pre></div><p>如果想要处理promise异步执行失败的事件，还可以跟上catch：</p><div class="hljs"><pre><code class="hljs js">promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;    <span class="hljs-comment">// 异步执行成功后的回调</span>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;    <span class="hljs-comment">// 异步执行失败后的回调</span>&#125;)</code></pre></div><p>示例：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-comment">// 这里我们用定时任务模拟异步</span>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">Math</span>.random();        <span class="hljs-comment">// 随机返回成功或失败</span>        <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0.5</span>) &#123;            resolve(<span class="hljs-string">"成功！num:"</span> + num)        &#125; <span class="hljs-keyword">else</span> &#123;            reject(<span class="hljs-string">"出错了！num:"</span> + num)        &#125;    &#125;, <span class="hljs-number">300</span>)&#125;)<span class="hljs-comment">// 调用promise</span>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(msg);&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(msg);&#125;)</code></pre></div><p>结果：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526113115887.png" srcset="/img/loading.gif" alt="1526113115887"></p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526113140074.png" srcset="/img/loading.gif" alt="1526113140074"></p><h3 id="4-3-7-set和map（了解）"><a href="#4-3-7-set和map（了解）" class="headerlink" title="4.3.7.set和map（了解）"></a>4.3.7.set和map（了解）</h3><p>ES6提供了Set和Map的数据结构。</p><p>Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。</p><p>构造函数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// Set构造函数可以接收一个数组或空</span><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> = new Set();<span class="hljs-keyword">set</span>.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5]</code></pre></div><p>普通方法：</p><div class="hljs"><pre><code class="hljs gams"><span class="hljs-keyword">set</span>.add(1);<span class="hljs-comment">// 添加</span><span class="hljs-keyword">set</span>.clear();<span class="hljs-comment">// 清空</span><span class="hljs-keyword">set</span>.delete(2);<span class="hljs-comment">// 删除指定元素</span><span class="hljs-keyword">set</span>.has(2); <span class="hljs-comment">// 判断是否存在</span><span class="hljs-keyword">set</span>.keys();<span class="hljs-comment">// 返回所有key</span><span class="hljs-keyword">set</span>.values();<span class="hljs-comment">// 返回所有值</span><span class="hljs-keyword">set</span>.entries();<span class="hljs-comment">// 返回键值对集合</span><span class="hljs-comment">// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。</span><span class="hljs-keyword">set</span>.size; <span class="hljs-comment">// 元素个数。是属性，不是方法。</span></code></pre></div><p>map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即：</p><ul><li>object是 &lt;string,object&gt;集合</li><li>map是&lt;object,object&gt;集合</li></ul><p>构造函数：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// map接收一个数组，数组中的元素是键值对数组</span><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-string">'key1'</span>,<span class="hljs-string">'value1'</span>],    [<span class="hljs-string">'key2'</span>,<span class="hljs-string">'value2'</span>],])<span class="hljs-comment">// 或者接收一个set</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">set</span> = new Set([    ['key1','value1'],    ['key2','value2'],])const map2 = new Map(<span class="hljs-keyword">set</span>)// 或者其它mapconst map3 = new Map(map);</code></pre></div><p>方法：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1526114799767.png" srcset="/img/loading.gif" alt="1526114799767"></p><h3 id="4-3-8-模块化"><a href="#4-3-8-模块化" class="headerlink" title="4.3.8.模块化"></a>4.3.8.模块化</h3><h4 id="4-3-8-1-什么是模块化"><a href="#4-3-8-1-什么是模块化" class="headerlink" title="4.3.8.1.什么是模块化"></a>4.3.8.1.什么是模块化</h4><p>模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。</p><p>而JS中没有包的概念，换来的是 模块。</p><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p><ul><li><code>export</code>命令用于规定模块的对外接口，</li><li><code>import</code>命令用于导入其他模块提供的功能。</li></ul><h4 id="4-3-8-2-export"><a href="#4-3-8-2-export" class="headerlink" title="4.3.8.2.export"></a>4.3.8.2.export</h4><p>比如我定义一个js文件:hello.js，里面有一个对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> util = &#123;    sum(a,b)&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;&#125;</code></pre></div><p>我可以使用export将这个对象导出：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> util = &#123;    sum(a,b)&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;&#125;<span class="hljs-keyword">export</span> util;</code></pre></div><p>当然，也可以简写为：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> util = &#123;    sum(a,b)&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;&#125;</code></pre></div><p><code>export</code>不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。</p><p>当要导出多个值时，还可以简写。比如我有一个文件：user.js：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"jack"</span><span class="hljs-keyword">var</span> age = <span class="hljs-number">21</span><span class="hljs-keyword">export</span> &#123;name,age&#125;</code></pre></div><blockquote><p>省略名称</p></blockquote><p>上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。</p><p>因此js提供了<code>default</code>关键字，可以对导出的变量名进行省略</p><p>例如：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 无需声明对象的名字</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;sum(a,b)&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;&#125;</code></pre></div><p>这样，当使用者导入时，可以任意起名字</p><h4 id="4-3-8-3-import"><a href="#4-3-8-3-import" class="headerlink" title="4.3.8.3.import"></a>4.3.8.3.import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><p>例如我要使用上面导出的util：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 导入util</span><span class="hljs-keyword">import</span> util <span class="hljs-keyword">from</span> <span class="hljs-string">'hello.js'</span><span class="hljs-comment">// 调用util中的属性</span>util.sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</code></pre></div><p>要批量导入前面导出的name和age： </p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;name, age&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'user.js'</span><span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">" , 今年"</span>+ age +<span class="hljs-string">"岁了"</span>)</code></pre></div><p>但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如<code>Babel-cli</code>工具</p><p> 我们暂时不做测试，大家了解即可。</p><h3 id="4-3-9-对象扩展"><a href="#4-3-9-对象扩展" class="headerlink" title="4.3.9.对象扩展"></a>4.3.9.对象扩展</h3><p>ES6给Object拓展了许多新的方法，如：</p><ul><li><p>keys(obj)：获取对象的所有key形成的数组</p></li><li><p>values(obj)：获取对象的所有value形成的数组</p></li><li><p>entries(obj)：获取对象的所有key和value形成的二维数组。格式：<code>[[k1,v1],[k2,v2],...]</code></p></li><li><p>assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday04/1527210872966.png" srcset="/img/loading.gif" alt="1527210872966"></p></li></ul><h3 id="4-3-10-数组扩展"><a href="#4-3-10-数组扩展" class="headerlink" title="4.3.10.数组扩展"></a>4.3.10.数组扩展</h3><p>ES6给数组新增了许多方法：</p><ul><li>find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素</li><li>findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引</li><li>includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day03：认识微服务2</title>
    <link href="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/"/>
    <url>/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>会配置Hystix熔断</li><li>会使用Feign进行远程调用</li><li>能独立搭建Zuul网关</li><li>能编写Zuul的拦截器</li></ul><h1 id="1-Hystix"><a href="#1-Hystix" class="headerlink" title="1.Hystix"></a>1.Hystix</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>Hystix，即熔断器。</p><p>主页：<a href="https://github.com/Netflix/Hystrix/" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/</a></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525658740266.png" srcset="/img/loading.gif" alt="1525658740266"></p><p>Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525658562507.png" srcset="/img/loading.gif" alt="1525658562507"></p><h2 id="1-2-熔断器的工作机制："><a href="#1-2-熔断器的工作机制：" class="headerlink" title="1.2.熔断器的工作机制："></a>1.2.熔断器的工作机制：</h2><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525658640314.png" srcset="/img/loading.gif" alt="1525658640314"></p><p>正常工作的情况下，客户端请求调用服务API接口：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525658906255.png" srcset="/img/loading.gif" alt="1525658906255"></p><p>当有服务出现异常时，直接进行失败回滚，服务降级处理：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525658983518.png" srcset="/img/loading.gif" alt="1525658983518"></p><p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。</p><p>这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。</p><p>系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。</p><h2 id="1-3-动手实践"><a href="#1-3-动手实践" class="headerlink" title="1.3.动手实践"></a>1.3.动手实践</h2><h3 id="1-3-1-引入依赖"><a href="#1-3-1-引入依赖" class="headerlink" title="1.3.1.引入依赖"></a>1.3.1.引入依赖</h3><p>首先在user-consumer中引入Hystix依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="1-3-2-开启熔断"><a href="#1-3-2-开启熔断" class="headerlink" title="1.3.2.开启熔断"></a>1.3.2.开启熔断</h3><h3 id="1-3-2-改造消费者"><a href="#1-3-2-改造消费者" class="headerlink" title="1.3.2.改造消费者"></a>1.3.2.改造消费者</h3><p>我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"queryUserByIdFallback"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span></span>&#123;        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();        String url = <span class="hljs-string">"http://user-service/user/"</span> + id;        User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(url, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        <span class="hljs-comment">// 记录访问用时：</span>        logger.info(<span class="hljs-string">"访问用时：&#123;&#125;"</span>, end - begin);        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByIdFallback</span><span class="hljs-params">(Long id)</span></span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setName(<span class="hljs-string">"用户信息查询出现异常！"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><ul><li><code>@HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)</code>：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</li><li>为了方便查看熔断的触发时机，我们记录请求访问时间。</li></ul><p>在原来的业务逻辑中调用这个DAO：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDao userDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.userDao.queryUserById(id));        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre></div><h3 id="1-3-3-改造服务提供者"><a href="#1-3-3-改造服务提供者" class="headerlink" title="1.3.3.改造服务提供者"></a>1.3.3.改造服务提供者</h3><p>改造服务提供者，随机休眠一段时间，以触发熔断：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒</span>        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">2000</span>));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userMapper.selectByPrimaryKey(id);    &#125;&#125;</code></pre></div><h3 id="1-3-4-启动测试"><a href="#1-3-4-启动测试" class="headerlink" title="1.3.4.启动测试"></a>1.3.4.启动测试</h3><p>然后运行并查看日志：</p><p>id为9、10、11的访问时间分别是：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525661641660.png" srcset="/img/loading.gif" alt="1525661641660"></p><p>id为12的访问时间：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525661669136.png" srcset="/img/loading.gif" alt="1525661669136"></p><p>因此，只有12是正常访问，其它都会触发熔断，我们来查看结果：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525661720656.png" srcset="/img/loading.gif" alt="1525661720656"></p><h3 id="1-3-5-优化"><a href="#1-3-5-优化" class="headerlink" title="1.3.5.优化"></a>1.3.5.优化</h3><p>虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？</p><p>其实这里是因为我们的Ribbon超时时间设置的是1000ms:</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525666632542.png" srcset="/img/loading.gif" alt="1525666632542"></p><p>而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。</p><p>所以，Ribbon的超时时间一定要小于Hystix的超时时间。</p><p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">command:</span>  <span class="hljs-attr">default:</span>        <span class="hljs-attr">execution:</span>          <span class="hljs-attr">isolation:</span>            <span class="hljs-attr">thread:</span>              <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">6000</span> <span class="hljs-comment"># 设置hystrix的超时时间为6000ms</span></code></pre></div><h1 id="2-Feign"><a href="#2-Feign" class="headerlink" title="2.Feign"></a>2.Feign</h1><p>在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：</p><div class="hljs"><pre><code class="hljs java">String baseUrl = <span class="hljs-string">"http://user-service/user/"</span>;User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre></div><p>如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？</p><p>这就是我们接下来要学的Feign的功能了。</p><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h2><p>有道词典的英文解释：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525662976679.png" srcset="/img/loading.gif" alt="1525662976679"></p><p>为什么叫伪装？</p><p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p><p>项目主页：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525652009416.png" srcset="/img/loading.gif" alt="1525652009416"></p><h2 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2.快速入门"></a>2.2.快速入门</h2><h3 id="2-2-1-导入依赖"><a href="#2-2-1-导入依赖" class="headerlink" title="2.2.1.导入依赖"></a>2.2.1.导入依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="2-2-2-Feign的客户端"><a href="#2-2-2-Feign的客户端" class="headerlink" title="2.2.2.Feign的客户端"></a>2.2.2.Feign的客户端</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(<span class="hljs-string">"user-service"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre></div><ul><li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li><li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li><li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li></ul><p>改造原来的调用逻辑，不再调用UserDao：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserFeignClient userFeignClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.userFeignClient.queryUserById(id));        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre></div><h3 id="2-2-3-开启Feign功能"><a href="#2-2-3-开启Feign功能" class="headerlink" title="2.2.3.开启Feign功能"></a>2.2.3.开启Feign功能</h3><p>我们在启动类上，添加注解，开启Feign功能</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@EnableHystrix</span><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 开启Feign功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><ul><li>你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了</li></ul><h3 id="2-2-4-启动测试："><a href="#2-2-4-启动测试：" class="headerlink" title="2.2.4.启动测试："></a>2.2.4.启动测试：</h3><p>访问接口：</p><p> <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525666476326.png" srcset="/img/loading.gif" alt="1525666476326"></p><p>正常获取到了结果。</p><h2 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3.负载均衡"></a>2.3.负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525672070679.png" srcset="/img/loading.gif" alt="1525672070679"></p><p>因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p><p>另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过<code>ribbon.xx</code>来进行全局配置。也可以通过<code>服务名.ribbon.xx</code>来对指定服务配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">user-service:</span>  <span class="hljs-attr">ribbon:</span>    <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>    <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>    <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>    <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>    <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span></code></pre></div><h2 id="2-4-Hystix支持"><a href="#2-4-Hystix支持" class="headerlink" title="2.4.Hystix支持"></a>2.4.Hystix支持</h2><p>Feign默认也有对Hystix的集成：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525672466192.png" srcset="/img/loading.gif" alt="1525672466192"></p><p>只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">hystrix:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Feign的熔断功能</span></code></pre></div><p>但是，Feign中的Fallback配置不像Ribbon中那样简单了。</p><p>1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFeignClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setName(<span class="hljs-string">"用户查询出现异常！"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><p>2）然后在UserFeignClient中，指定刚才编写的实现类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"user-service"</span>, fallback = UserFeignClientFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre></div><p>3）重启测试：</p><p>我们关闭user-service服务，然后在页面访问：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525673049875.png" srcset="/img/loading.gif" alt="1525673049875"></p><h2 id="2-5-请求压缩-了解"><a href="#2-5-请求压缩-了解" class="headerlink" title="2.5.请求压缩(了解)"></a>2.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">compression:</span>    <span class="hljs-attr">request:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span>    <span class="hljs-attr">response:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启响应压缩</span></code></pre></div><p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">compression:</span>    <span class="hljs-attr">request:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span>      <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/html,application/xml,application/json</span> <span class="hljs-comment"># 设置压缩的数据类型</span>      <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span> <span class="hljs-comment"># 设置触发压缩的大小下限</span></code></pre></div><p>注：上面的数据类型、压缩大小下限均为默认值。</p><h2 id="2-6-日志级别-了解"><a href="#2-6-日志级别-了解" class="headerlink" title="2.6.日志级别(了解)"></a>2.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p><p>1）设置com.leyou包下的日志级别都为debug</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">com.leyou:</span> <span class="hljs-string">debug</span></code></pre></div><p>2）编写配置类，定义日志级别</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre></div><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525674373507.png" srcset="/img/loading.gif" alt="1525674373507"></p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>3）在FeignClient中指定配置类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"user-service"</span>, fallback = UserFeignClientFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">configuration</span> </span>= FeignConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre></div><p>4）重启项目，即可看到每次访问的日志：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525674544569.png" srcset="/img/loading.gif" alt="1525674544569"></p><h1 id="3-Zuul网关"><a href="#3-Zuul网关" class="headerlink" title="3.Zuul网关"></a>3.Zuul网关</h1><p>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525674644660.png" srcset="/img/loading.gif" alt="1525674644660"></p><p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p><p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p><p>先来说说这样架构需要做的一些事儿以及存在的不足：</p><ul><li>首先，破坏了服务无状态特点。<ul><li>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</li><li>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</li></ul></li><li>其次，无法直接复用既有接口。<ul><li>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</li></ul></li></ul><p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p><p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。</p><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了<code>权限控制</code>等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525675037152.png" srcset="/img/loading.gif" alt="1525675037152"></p><p>Zuul：维基百科：</p><p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p><p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525675168152.png" srcset="/img/loading.gif" alt="1525675168152"></p><h2 id="3-2-Zuul加入后的架构"><a href="#3-2-Zuul加入后的架构" class="headerlink" title="3.2.Zuul加入后的架构"></a>3.2.Zuul加入后的架构</h2><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525675648881.png" srcset="/img/loading.gif" alt="1525675648881"></p><ul><li>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</li></ul><h2 id="3-3-快速入门"><a href="#3-3-快速入门" class="headerlink" title="3.3.快速入门"></a>3.3.快速入门</h2><h3 id="3-3-1-新建工程"><a href="#3-3-1-新建工程" class="headerlink" title="3.3.1.新建工程"></a>3.3.1.新建工程</h3><p>填写基本信息：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525675928548.png" srcset="/img/loading.gif" alt="1525675928548"></p><p>添加Zuul依赖：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525675991833.png" srcset="/img/loading.gif" alt="1525675991833"></p><h3 id="3-3-2-编写启动类"><a href="#3-3-2-编写启动类" class="headerlink" title="3.3.2.编写启动类"></a>3.3.2.编写启动类</h3><p>通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(ZuulDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre></div><h3 id="3-3-3-编写配置"><a href="#3-3-3-编写配置" class="headerlink" title="3.3.3.编写配置"></a>3.3.3.编写配置</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment">#服务端口</span><span class="hljs-attr">spring:</span>   <span class="hljs-attr">application:</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span></code></pre></div><h3 id="3-3-4-编写路由规则"><a href="#3-3-4-编写路由规则" class="headerlink" title="3.3.4.编写路由规则"></a>3.3.4.编写路由规则</h3><p>我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525676797879.png" srcset="/img/loading.gif" alt="1525676797879"></p><ul><li>ip为：127.0.0.1</li><li>端口为：8081</li></ul><p>映射规则：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>      <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:8081</span> <span class="hljs-comment"># 映射路径对应的实际url地址</span></code></pre></div><p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p><p>本例中，我们将 <code>/user-service/**</code>开头的请求，代理到<a href="http://127.0.0.1:8081" target="_blank" rel="noopener">http://127.0.0.1:8081</a></p><h3 id="3-3-5-启动测试："><a href="#3-3-5-启动测试：" class="headerlink" title="3.3.5.启动测试："></a>3.3.5.启动测试：</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<a href="http://127.0.0.1:8081/user-service/user/10" target="_blank" rel="noopener">http://127.0.0.1:8081/user-service/user/10</a></p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525677046705.png" srcset="/img/loading.gif" alt="1525677046705"></p><h2 id="3-4-面向服务的路由"><a href="#3-4-面向服务的路由" class="headerlink" title="3.4.面向服务的路由"></a>3.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。</p><p>我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p><h3 id="3-4-1-添加Eureka客户端依赖"><a href="#3-4-1-添加Eureka客户端依赖" class="headerlink" title="3.4.1.添加Eureka客户端依赖"></a>3.4.1.添加Eureka客户端依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="3-4-2-开启Eureka客户端发现功能"><a href="#3-4-2-开启Eureka客户端发现功能" class="headerlink" title="3.4.2.开启Eureka客户端发现功能"></a>3.4.2.开启Eureka客户端发现功能</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(ZuulDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre></div><h3 id="3-4-3-添加Eureka配置，获取服务信息"><a href="#3-4-3-添加Eureka配置，获取服务信息" class="headerlink" title="3.4.3.添加Eureka配置，获取服务信息"></a>3.4.3.添加Eureka配置，获取服务信息</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 获取服务列表的周期：5s</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre></div><h3 id="3-4-4-修改映射配置，通过服务名称获取"><a href="#3-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="3.4.4.修改映射配置，通过服务名称获取"></a>3.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 指定服务名称</span></code></pre></div><h3 id="3-4-5-启动测试"><a href="#3-4-5-启动测试" class="headerlink" title="3.4.5.启动测试"></a>3.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525677821212.png" srcset="/img/loading.gif" alt="1525677821212"></p><p>日志中可以看到使用了负载均衡器：</p><p><img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525677891119.png" srcset="/img/loading.gif" alt="1525677891119"></p><h2 id="3-5-简化的路由配置"><a href="#3-5-简化的路由配置" class="headerlink" title="3.5.简化的路由配置"></a>3.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p><ul><li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li><li><code>zuul.routes.&lt;route&gt;.serviceId=/user-service</code>：来指定服务名。</li></ul><p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>比方说上面我们关于user-service的配置可以简化为一条：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">user-service:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span></code></pre></div><p>省去了对服务名称的配置。</p><h2 id="3-6-默认的路由规则"><a href="#3-6-默认的路由规则" class="headerlink" title="3.6.默认的路由规则"></a>3.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p><ul><li>默认情况下，一切服务的映射路径就是服务名本身。<ul><li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li></ul></li></ul><p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p><h2 id="3-7-路由前缀"><a href="#3-7-路由前缀" class="headerlink" title="3.7.路由前缀"></a>3.7.路由前缀</h2><p>配置示例：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api</span> <span class="hljs-comment"># 添加路由前缀</span>  <span class="hljs-attr">routes:</span>      <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>        <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>        <span class="hljs-attr">service-id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 指定服务名称</span></code></pre></div><p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p><p>路径<code>/api/user-service/user/1</code>将会被代理到<code>/user-service/user/1</code></p><h2 id="3-8-过滤器"><a href="#3-8-过滤器" class="headerlink" title="3.8.过滤器"></a>3.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p><h3 id="3-8-1-ZuulFilter"><a href="#3-8-1-ZuulFilter" class="headerlink" title="3.8.1.ZuulFilter"></a>3.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span></span>;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 来自IZuulFilter</span>    <span class="hljs-function">Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException</span>;<span class="hljs-comment">// IZuulFilter</span>&#125;</code></pre></div><ul><li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li><li><code>run</code>：过滤器的具体业务逻辑。</li><li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul><li><code>pre</code>：请求在被路由之前执行</li><li><code>routing</code>：在路由请求时调用</li><li><code>post</code>：在routing和errror过滤器之后调用</li><li><code>error</code>：处理请求时发生错误调用</li></ul></li><li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li></ul><h3 id="3-8-2-过滤器执行生命周期："><a href="#3-8-2-过滤器执行生命周期：" class="headerlink" title="3.8.2.过滤器执行生命周期："></a>3.8.2.过滤器执行生命周期：</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525681866862.png" srcset="/img/loading.gif" alt="1525681866862"></p><ul><li>正常流程：<ul><li>请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li></ul></li><li>异常流程：<ul><li>整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li><li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。</li><li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。</li></ul></li></ul><p>所有内置过滤器列表：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525682427811.png" srcset="/img/loading.gif" alt="1525682427811"></p><h3 id="3-8-3-使用场景"><a href="#3-8-3-使用场景" class="headerlink" title="3.8.3.使用场景"></a>3.8.3.使用场景</h3><p>场景非常多：</p><ul><li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li><li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li><li>服务调用时长统计：pre和post结合使用。</li></ul><h2 id="3-9-自定义过滤器"><a href="#3-9-自定义过滤器" class="headerlink" title="3.9.自定义过滤器"></a>3.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><h3 id="3-9-1-定义过滤器类"><a href="#3-9-1-定义过滤器类" class="headerlink" title="3.9.1.定义过滤器类"></a>3.9.1.定义过滤器类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 登录校验，肯定是在前置拦截</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"pre"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 顺序设置为1</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 返回true，代表过滤器生效。</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;        <span class="hljs-comment">// 登录校验逻辑。</span>        <span class="hljs-comment">// 1）获取Zuul提供的请求上下文对象</span>        RequestContext ctx = RequestContext.getCurrentContext();        <span class="hljs-comment">// 2) 从上下文中获取request对象</span>        HttpServletRequest req = ctx.getRequest();        <span class="hljs-comment">// 3) 从请求中获取token</span>        String token = req.getParameter(<span class="hljs-string">"access-token"</span>);        <span class="hljs-comment">// 4) 判断</span>        <span class="hljs-keyword">if</span>(token == <span class="hljs-keyword">null</span> || <span class="hljs-string">""</span>.equals(token.trim()))&#123;            <span class="hljs-comment">// 没有token，登录校验失败，拦截</span>            ctx.setSendZuulResponse(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">// 返回401状态码。也可以考虑重定向到登录页。</span>            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());        &#125;        <span class="hljs-comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><h3 id="3-9-2-测试"><a href="#3-9-2-测试" class="headerlink" title="3.9.2.测试"></a>3.9.2.测试</h3><p>没有token参数时，访问失败：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525683285697.png" srcset="/img/loading.gif" alt="1525683285697"></p><p>添加token参数后：</p><p>​    <img src="/2020/09/21/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday03/1525683354113.png" srcset="/img/loading.gif" alt="1525683354113"></p><h2 id="3-10-负载均衡和熔断"><a href="#3-10-负载均衡和熔断" class="headerlink" title="3.10.负载均衡和熔断"></a>3.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">retryable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">2000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span><span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">command:</span>  <span class="hljs-attr">default:</span>        <span class="hljs-attr">execution:</span>          <span class="hljs-attr">isolation:</span>            <span class="hljs-attr">thread:</span>              <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">6000</span> <span class="hljs-comment"># 熔断超时时长：6000ms</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Feign</tag>
      
      <tag>Hystix</tag>
      
      <tag>Zuul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day02：认识微服务</title>
    <link href="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/"/>
    <url>/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解系统架构的演变</li><li>了解RPC与Http的区别</li><li>掌握HttpClient的简单使用</li><li>知道什么是SpringCloud</li><li>独立搭建Eureka注册中心</li><li>独立配置Robbin负载均衡</li></ul><p>-Xms128m -Xmx128m</p><h1 id="1-系统架构演变"><a href="#1-系统架构演变" class="headerlink" title="1.系统架构演变"></a>1.系统架构演变</h1><p>随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？</p><p>其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。</p><h2 id="1-1-集中式架构"><a href="#1-1-集中式架构" class="headerlink" title="1.1. 集中式架构"></a>1.1. 集中式架构</h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525529091749.png" srcset="/img/loading.gif" alt="1525529091749"></p><p>存在的问题：</p><ul><li>代码耦合，开发维护困难</li><li>无法针对不同模块进行针对性优化</li><li>无法水平扩展</li><li>单点容错率低，并发能力差</li></ul><h2 id="1-2-垂直拆分"><a href="#1-2-垂直拆分" class="headerlink" title="1.2.垂直拆分"></a>1.2.垂直拆分</h2><p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525529671801.png" srcset="/img/loading.gif" alt="1525529671801"></p><p>优点：</p><ul><li>系统拆分实现了流量分担，解决了并发问题</li><li>可以针对不同模块进行优化</li><li>方便水平扩展，负载均衡，容错率提高</li></ul><p>缺点：</p><ul><li>系统间相互独立，会有很多重复开发工作，影响开发效率</li></ul><h2 id="1-3-分布式服务"><a href="#1-3-分布式服务" class="headerlink" title="1.3.分布式服务"></a>1.3.分布式服务</h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525530657919.png" srcset="/img/loading.gif" alt="1525530657919"></p><p>优点：</p><ul><li>将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</li></ul><p>缺点：</p><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h2 id="1-4-服务治理（SOA）"><a href="#1-4-服务治理（SOA）" class="headerlink" title="1.4.服务治理（SOA）"></a>1.4.服务治理（SOA）</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525530804753.png" srcset="/img/loading.gif" alt="1525530804753"></p><p>以前出现了什么问题？</p><ul><li>服务越来越多，需要管理每个服务的地址</li><li>调用关系错综复杂，难以理清依赖关系</li><li>服务过多，服务状态难以管理，无法根据服务情况动态管理</li></ul><p>服务治理要做什么？</p><ul><li>服务注册中心，实现服务自动注册和发现，无需人为记录服务地址</li><li>服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</li><li>动态监控服务状态监控报告，人为控制服务状态</li></ul><p>缺点：</p><ul><li>服务间会有依赖关系，一旦某个环节出错会影响较大</li><li>服务关系复杂，运维、测试部署困难，不符合DevOps思想</li></ul><h2 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5.微服务"></a>1.5.微服务</h2><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525532344817.png" srcset="/img/loading.gif" alt="1525532344817"></p><p>微服务的特点：</p><ul><li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li>面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li><li>自治：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源</li><li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul><p>微服务结构图：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1526860071166.png" srcset="/img/loading.gif" alt="1526860071166"></p><h1 id="2-远程调用方式"><a href="#2-远程调用方式" class="headerlink" title="2.远程调用方式"></a>2.远程调用方式</h1><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p><p>常见的远程调用方式有以下几种：</p><ul><li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型</p></li><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</p><p>现在热门的Rest风格，就可以通过http协议来实现。</p></li></ul><h2 id="2-1-认识RPC"><a href="#2-1-认识RPC" class="headerlink" title="2.1.认识RPC"></a>2.1.认识RPC</h2><p>RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。</p><p>通过上面的概念，我们可以知道，实现RPC主要是做到两点： </p><ul><li>实现远程调用其他计算机的服务<ul><li>要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点：<ul><li>1）采用何种网络通讯协议？<ul><li>现在比较流行的RPC框架，都会采用TCP作为底层传输协议</li></ul></li><li>2）数据传输的格式怎样？<ul><li>两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。</li></ul></li></ul></li></ul></li><li>像调用本地服务一样调用远程服务 <ul><li>如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装</li></ul></li></ul><p>RPC调用流程图：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525568965976.png" srcset="/img/loading.gif" alt="1525568965976"></p><p>想要了解详细的RPC实现，给大家推荐一篇文章：<a href="https://legacy.gitbook.com/book/huge0612/tour-of-rpc/details" target="_blank" rel="noopener">自己动手实现RPC</a></p><h2 id="2-2-认识Http"><a href="#2-2-认识Http" class="headerlink" title="2.2.认识Http"></a>2.2.认识Http</h2><p>Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。</p><ul><li>RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。</li><li>Http中还定义了资源定位的路径，RPC中并不需要</li><li>最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。<ul><li>优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台</li><li>缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。</li></ul></li></ul><p>例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525569352313.png" srcset="/img/loading.gif" alt="1525569352313"></p><h2 id="2-3-如何选择？"><a href="#2-3-如何选择？" class="headerlink" title="2.3.如何选择？"></a>2.3.如何选择？</h2><p>既然两种方式都可以实现远程调用，我们该如何选择呢？</p><ul><li>速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。</li><li>难度来看，RPC实现较为复杂，http相对比较简单</li><li>灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。</li></ul><p>因此，两者都有不同的使用场景：</p><ul><li>如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。</li><li>如果需要更加灵活，跨语言、跨平台，显然http更合适</li></ul><p>那么我们该怎么选择呢？</p><p>微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。</p><h1 id="3-Http客户端工具"><a href="#3-Http客户端工具" class="headerlink" title="3.Http客户端工具"></a>3.Http客户端工具</h1><p>既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：</p><ul><li>HttpClient</li><li>OKHttp</li><li>URLConnection</li></ul><p>接下来，我们就一起了解一款比较流行的客户端工具：HttpClient</p><h2 id="3-1-HttpClient"><a href="#3-1-HttpClient" class="headerlink" title="3.1.HttpClient"></a>3.1.HttpClient</h2><h3 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1.介绍"></a>3.1.1.介绍</h3><p>HttpClient是Apache公司的产品，是Http Components下的一个组件。</p><p><a href="http://hc.apache.org/index.html" target="_blank" rel="noopener">官网地址：http://hc.apache.org/index.html</a></p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525570921966.png" srcset="/img/loading.gif" alt="1525570921966"></p><p>特点：</p><ul><li>基于标准、纯净的Java语言。实现了Http1.0和Http1.1</li><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）</li><li>支持HTTPS协议。</li><li>通过Http代理建立透明的连接。</li><li>自动处理Set-Cookie中的Cookie。</li></ul><h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a>3.1.2.使用</h3><p>我们导入课前资料提供的demo工程：《http-demo》</p><p>发起get请求：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    HttpGet request = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">"http://www.baidu.com"</span>);    String response = <span class="hljs-keyword">this</span>.httpClient.execute(request, <span class="hljs-keyword">new</span> BasicResponseHandler());    System.out.println(response);&#125;</code></pre></div><p>发起Post请求：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    HttpPost request = <span class="hljs-keyword">new</span> HttpPost(<span class="hljs-string">"http://www.oschina.net/"</span>);    request.setHeader(<span class="hljs-string">"User-Agent"</span>,                      <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"</span>);    String response = <span class="hljs-keyword">this</span>.httpClient.execute(request, <span class="hljs-keyword">new</span> BasicResponseHandler());    System.out.println(response);&#125;</code></pre></div><p>尝试访问昨天编写的接口：<a href="http://localhost/hello" target="_blank" rel="noopener">http://localhost/hello</a></p><p>这个接口返回一个User对象</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetPojo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    HttpGet request = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">"http://localhost/hello"</span>);    String response = <span class="hljs-keyword">this</span>.httpClient.execute(request, <span class="hljs-keyword">new</span> BasicResponseHandler());    System.out.println(response);&#125;</code></pre></div><p>我们实际得到的是一个json字符串：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">8</span>,    <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"liuyan"</span>,    <span class="hljs-attr">"password"</span>: <span class="hljs-string">"123456"</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"柳岩"</span>,    <span class="hljs-attr">"age"</span>: <span class="hljs-number">21</span>,    <span class="hljs-attr">"sex"</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">"birthday"</span>: <span class="hljs-string">"1995-08-07T16:00:00.000+0000"</span>,    <span class="hljs-attr">"created"</span>: <span class="hljs-string">"2014-09-20T03:41:15.000+0000"</span>,    <span class="hljs-attr">"updated"</span>: <span class="hljs-string">"2014-09-20T03:41:15.000+0000"</span>,    <span class="hljs-attr">"note"</span>: <span class="hljs-string">"柳岩同学在传智播客学表演"</span>&#125;</code></pre></div><p>如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。</p><h3 id="3-1-3-Json转换工具"><a href="#3-1-3-Json转换工具" class="headerlink" title="3.1.3.Json转换工具"></a>3.1.3.Json转换工具</h3><p>HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。</p><p><code>JacksonJson</code>是SpringMVC内置的json处理工具，其中有一个<code>ObjectMapper</code>类，可以方便的实现对json的处理：</p><h4 id="对象转json"><a href="#对象转json" class="headerlink" title="对象转json"></a>对象转json</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span>    <span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">8L</span>);        user.setAge(<span class="hljs-number">21</span>);        user.setName(<span class="hljs-string">"柳岩"</span>);        user.setUserName(<span class="hljs-string">"liuyan"</span>);        <span class="hljs-comment">// 序列化</span>        String json = mapper.writeValueAsString(user);        System.out.println(<span class="hljs-string">"json = "</span> + json);    &#125;</code></pre></div><p>结果：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1526877496885.png" srcset="/img/loading.gif" alt="1526877496885"></p><h4 id="json转普通对象"><a href="#json转普通对象" class="headerlink" title="json转普通对象"></a>json转普通对象</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span><span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">8L</span>);    user.setAge(<span class="hljs-number">21</span>);    user.setName(<span class="hljs-string">"柳岩"</span>);    user.setUserName(<span class="hljs-string">"liuyan"</span>);    <span class="hljs-comment">// 序列化</span>    String json = mapper.writeValueAsString(user);    <span class="hljs-comment">// 反序列化，接收两个参数：json数据，反序列化的目标类字节码</span>    User result = mapper.readValue(json, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(<span class="hljs-string">"result = "</span> + result);&#125;</code></pre></div><p>结果：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1526877647406.png" srcset="/img/loading.gif" alt="1526877647406"></p><h4 id="json转集合"><a href="#json转集合" class="headerlink" title="json转集合"></a>json转集合</h4><p>json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。</p><p>因此Jackson做了一个类型工厂，用来解决这个问题：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span><span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">8L</span>);    user.setAge(<span class="hljs-number">21</span>);    user.setName(<span class="hljs-string">"柳岩"</span>);    user.setUserName(<span class="hljs-string">"liuyan"</span>);    <span class="hljs-comment">// 序列化,得到对象集合的json字符串</span>    String json = mapper.writeValueAsString(Arrays.asList(user, user));    <span class="hljs-comment">// 反序列化，接收两个参数：json数据，反序列化的目标类字节码</span>    List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">User</span>.<span class="hljs-title">class</span>))</span>;    <span class="hljs-keyword">for</span> (User u : users) &#123;        System.out.println(<span class="hljs-string">"u = "</span> + u);    &#125;&#125;</code></pre></div><p>结果：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1526877995530.png" srcset="/img/loading.gif" alt="1526877995530"></p><h4 id="json转任意复杂类型"><a href="#json转任意复杂类型" class="headerlink" title="json转任意复杂类型"></a>json转任意复杂类型</h4><p>当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span><span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">8L</span>);    user.setAge(<span class="hljs-number">21</span>);    user.setName(<span class="hljs-string">"柳岩"</span>);    user.setUserName(<span class="hljs-string">"liuyan"</span>);    <span class="hljs-comment">// 序列化,得到对象集合的json字符串</span>    String json = mapper.writeValueAsString(Arrays.asList(user, user));    <span class="hljs-comment">// 反序列化，接收两个参数：json数据，反序列化的目标类字节码</span>    List&lt;User&gt; users = mapper.readValue(json, <span class="hljs-keyword">new</span> TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);    <span class="hljs-keyword">for</span> (User u : users) &#123;        System.out.println(<span class="hljs-string">"u = "</span> + u);    &#125;&#125;</code></pre></div><p>结果：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1526877988488.png" srcset="/img/loading.gif" alt="1526877988488"></p><h2 id="3-3-Spring的RestTemplate"><a href="#3-3-Spring的RestTemplate" class="headerlink" title="3.3.Spring的RestTemplate"></a>3.3.Spring的RestTemplate</h2><p>Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p><ul><li>HttpClient</li><li>OkHttp</li><li>JDK原生的URLConnection（默认的）</li></ul><p>首先在项目中注册一个<code>RestTemplate</code>对象，可以在启动类位置注册：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(HttpDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 默认的RestTemplate，底层是走JDK的URLConnection方式。</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;&#125;</code></pre></div><p>在测试类中直接<code>@Autowired</code>注入：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= HttpDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">HttpDemoApplicationTests</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">httpGet</span><span class="hljs-params">()</span> </span>&#123;User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(<span class="hljs-string">"http://localhost/hello"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(user);&#125;&#125;</code></pre></div><ul><li>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。</li></ul><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525573702492.png" srcset="/img/loading.gif" alt="1525573702492"></p><p>学习完了Http客户端工具，接下来就可以正式学习微服务了。</p><h1 id="4-初始SpringCloud"><a href="#4-初始SpringCloud" class="headerlink" title="4.初始SpringCloud"></a>4.初始SpringCloud</h1><p>微服务是一种架构方式，最终肯定需要技术架构去实施。</p><p>微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？</p><ul><li>后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。</li><li>技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了</li><li>群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。</li><li>使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建</li></ul><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1.简介"></a>4.1.简介</h2><p>SpringCloud是Spring旗下的项目之一，<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">官网地址：http://projects.spring.io/spring-cloud/</a></p><p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p><p>SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p><p>netflix</p><ul><li>Eureka：注册中心</li><li>Zuul：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：服务调用</li><li>Hystix：熔断器</li></ul><p>以上只是其中一部分，架构图：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525575656796.png" srcset="/img/loading.gif" alt="1525575656796"></p><h2 id="4-2-版本"><a href="#4-2-版本" class="headerlink" title="4.2.版本"></a>4.2.版本</h2><p>SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525575903675.png" srcset="/img/loading.gif" alt="1525575903675"></p><p>我们在项目中，会是以Finchley的版本。</p><p>其中包含的组件，也都有各自的版本，如下表：</p><table><thead><tr><th>Component</th><th>Edgware.SR3</th><th>Finchley.RC1</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR3</td><td>Elmhurst.RELEASE</td><td>Elmhurst.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.10.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.RELEASE</td></tr><tr><td>spring-cloud-vault</td><td>1.1.0.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr></tbody></table><p>接下来，我们就一一学习SpringCloud中的重要组件。</p><h1 id="5-微服务场景模拟"><a href="#5-微服务场景模拟" class="headerlink" title="5.微服务场景模拟"></a>5.微服务场景模拟</h1><p>首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构</p><h2 id="5-1-服务提供者"><a href="#5-1-服务提供者" class="headerlink" title="5.1.服务提供者"></a>5.1.服务提供者</h2><p>我们新建一个项目，对外提供查询用户的服务。</p><h3 id="5-1-1-Spring脚手架创建工程"><a href="#5-1-1-Spring脚手架创建工程" class="headerlink" title="5.1.1.Spring脚手架创建工程"></a>5.1.1.Spring脚手架创建工程</h3><p>借助于Spring提供的快速搭建工具：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525576816916.png" srcset="/img/loading.gif" alt="1525576816916"></p><p>填写项目信息：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525576909381.png" srcset="/img/loading.gif" alt="1525576909381"></p><p>添加web依赖：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525576950842.png" srcset="/img/loading.gif" alt="1525576950842"></p><p>添加mybatis依赖：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525576999052.png" srcset="/img/loading.gif" alt="1525576999052"></p><p>填写项目位置：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525577029150.png" srcset="/img/loading.gif" alt="1525577029150"></p><p>生成的项目结构：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525577106711.png" srcset="/img/loading.gif" alt="1525577106711"></p><p>依赖也已经全部自动引入：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>user-service-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>user-service-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>当然，因为要使用通用mapper，所以我们需要手动加一条依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>非常快捷啊！</p><h3 id="5-1-2-编写代码"><a href="#5-1-2-编写代码" class="headerlink" title="5.1.2.编写代码"></a>5.1.2.编写代码</h3><p>添加一个对外查询的接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userService.queryById(id);    &#125;&#125;</code></pre></div><p>Service：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userMapper.selectByPrimaryKey(id);    &#125;&#125;</code></pre></div><p>mapper:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">tk</span>.<span class="hljs-title">mybatis</span>.<span class="hljs-title">mapper</span>.<span class="hljs-title">common</span>.<span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">User</span>&gt;</span>&#123;&#125;</code></pre></div><p>实体类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-comment">// 用户名</span>    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-comment">// 密码</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// 姓名</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 年龄</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">// 性别，1男性，2女性</span>    <span class="hljs-keyword">private</span> Integer sex;    <span class="hljs-comment">// 出生日期</span>    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-comment">// 创建时间</span>    <span class="hljs-keyword">private</span> Date created;    <span class="hljs-comment">// 更新时间</span>    <span class="hljs-keyword">private</span> Date updated;    <span class="hljs-comment">// 备注</span>    <span class="hljs-keyword">private</span> String note;   <span class="hljs-comment">// 。。。省略getters和setters</span>&#125;</code></pre></div><p>属性文件,这里我们采用了yaml语法，而不是properties：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mydb01</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">10</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.leyou.userservice.pojo</span></code></pre></div><p>项目结构：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525577911331.png" srcset="/img/loading.gif" alt="1525577911331"></p><h3 id="5-1-3-启动并测试："><a href="#5-1-3-启动并测试：" class="headerlink" title="5.1.3.启动并测试："></a>5.1.3.启动并测试：</h3><p>启动项目，访问接口：<a href="http://localhost:8081/user/7" target="_blank" rel="noopener">http://localhost:8081/user/7</a></p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525593139364.png" srcset="/img/loading.gif" alt="1525593139364"></p><h2 id="5-2-服务调用者"><a href="#5-2-服务调用者" class="headerlink" title="5.2.服务调用者"></a>5.2.服务调用者</h2><h3 id="5-2-1-创建工程"><a href="#5-2-1-创建工程" class="headerlink" title="5.2.1.创建工程"></a>5.2.1.创建工程</h3><p>与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。</p><p>pom：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>user-consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>user-consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 添加OkHttp支持 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="5-2-2-编写代码"><a href="#5-2-2-编写代码" class="headerlink" title="5.2.2.编写代码"></a>5.2.2.编写代码</h3><p>首先在启动类中注册<code>RestTemplate</code>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 这次我们使用了OkHttp客户端,只需要注入工厂即可</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span></span>&#123;        String url = <span class="hljs-string">"http://localhost:8081/user/"</span> + id;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restTemplate.getForObject(url, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre></div><p>然后编写user-service，循环查询UserDAO信息：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDao userDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">querUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span></span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Long id : ids) &#123;            User user = <span class="hljs-keyword">this</span>.userDao.queryUserById(id);            users.add(user);        &#125;        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre></div><p>编写controller：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"consume"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">consume</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"ids"</span>)</span> List&lt;Long&gt; ids) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userService.queryUserByIds(ids);    &#125;&#125;</code></pre></div><h3 id="5-2-3-启动测试："><a href="#5-2-3-启动测试：" class="headerlink" title="5.2.3.启动测试："></a>5.2.3.启动测试：</h3><p>因为我们没有配置端口，那么默认就是8080，我们访问：<a href="http://localhost:8080/consume?ids=6,7,8" target="_blank" rel="noopener">http://localhost:8080/consume?ids=6,7,8</a></p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525594222408.png" srcset="/img/loading.gif" alt="1525594222408"></p><p>一个简单的远程服务调用案例就实现了。</p><h2 id="5-3-有没有问题？"><a href="#5-3-有没有问题？" class="headerlink" title="5.3.有没有问题？"></a>5.3.有没有问题？</h2><p>简单回顾一下，刚才我们写了什么：</p><ul><li>use-service-demo：一个提供根据id查询用户的微服务</li><li>consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo</li></ul><p>流程如下：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525595012668.png" srcset="/img/loading.gif" alt="1525595012668"></p><p>存在什么问题？</p><ul><li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li><li>consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效</li><li>consumer不清楚user-service的状态，服务宕机也不知道</li><li>user-service只有1台服务，不具备高可用性</li><li>即便user-service形成集群，consumer还需自己实现负载均衡</li></ul><p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><p>以上的问题，我们都将在SpringCloud中得到答案。</p><h1 id="6-Eureka注册中心"><a href="#6-Eureka注册中心" class="headerlink" title="6.Eureka注册中心"></a>6.Eureka注册中心</h1><h2 id="6-1-认识Eureka"><a href="#6-1-认识Eureka" class="headerlink" title="6.1.认识Eureka"></a>6.1.认识Eureka</h2><p>首先我们来解决第一问题，服务的管理。</p><blockquote><p>问题分析</p></blockquote><p>在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。</p><blockquote><p>网约车</p></blockquote><p>这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。</p><p>此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。</p><p>此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！</p><blockquote><p>Eureka做什么？</p></blockquote><p>Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。</p><p>同时，服务提供方与Eureka之间通过<code>“心跳”</code>机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</p><p>这就实现了服务的自动注册、发现、状态监控。</p><h2 id="6-2-原理图"><a href="#6-2-原理图" class="headerlink" title="6.2.原理图"></a>6.2.原理图</h2><blockquote><p>基本架构：</p></blockquote><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525597885059.png" srcset="/img/loading.gif" alt="1525597885059"></p><ul><li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li><li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li><li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li><li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li></ul><h2 id="6-3-入门案例"><a href="#6-3-入门案例" class="headerlink" title="6.3.入门案例"></a>6.3.入门案例</h2><h3 id="6-3-1-编写EurekaServer"><a href="#6-3-1-编写EurekaServer" class="headerlink" title="6.3.1.编写EurekaServer"></a>6.3.1.编写EurekaServer</h3><p>接下来我们创建一个项目，启动一个EurekaServer：</p><p>依然使用spring提供的快速搭建工具：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525598231170.png" srcset="/img/loading.gif" alt="1525598231170"></p><p>选择依赖：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525598312368.png" srcset="/img/loading.gif" alt="1525598312368"></p><p>完整的Pom文件：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>eureka-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-comment">&lt;!-- SpringCloud版本，是最新的F系列 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Eureka服务端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-comment">&lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>编写启动类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span> <span class="hljs-comment">// 声明这个应用是一个EurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(EurekaDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre></div><p>编写配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span> <span class="hljs-comment"># 端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中显示</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否注册自己的信息到EurekaServer，默认是true</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否拉取其它服务的信息，默认是true</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></code></pre></div><p>启动服务，并访问：<a href="http://127.0.0.1:10086/eureka" target="_blank" rel="noopener">http://127.0.0.1:10086/eureka</a></p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525604959508.png" srcset="/img/loading.gif" alt="1525604959508"></p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525605081129.png" srcset="/img/loading.gif" alt="1525605081129"></p><h3 id="6-3-2-将user-service注册到Eureka"><a href="#6-3-2-将user-service注册到Eureka" class="headerlink" title="6.3.2.将user-service注册到Eureka"></a>6.3.2.将user-service注册到Eureka</h3><p>注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。</p><blockquote><p>我们在user-service-demo中添加Eureka客户端依赖：</p></blockquote><p>先添加SpringCloud依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringCloud的依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- Spring的仓库地址 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre></div><p>然后是Eureka客户端：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><blockquote><p>在启动类上开启Eureka客户端功能</p></blockquote><p>通过添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 开启EurekaClient功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(UserServiceDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre></div><blockquote><p>编写配置</p></blockquote><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mydb01</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">10</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 应用名称</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.leyou.userservice.pojo</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 指定自己的ip信息，不指定的话会自己寻找</span></code></pre></div><p>注意：</p><ul><li>这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。</li><li>不用指定register-with-eureka和fetch-registry，因为默认是true</li></ul><blockquote><p>重启项目，访问<a href="http://127.0.0.1:10086/eureka" target="_blank" rel="noopener">Eureka监控页面</a>查看</p></blockquote><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525609225152.png" srcset="/img/loading.gif" alt="1525609225152"></p><p>我们发现user-service服务已经注册成功了</p><h3 id="6-3-3-消费者从Eureka获取服务"><a href="#6-3-3-消费者从Eureka获取服务" class="headerlink" title="6.3.3.消费者从Eureka获取服务"></a>6.3.3.消费者从Eureka获取服务</h3><p>接下来我们修改consumer-demo，尝试从EurekaServer获取服务。</p><p>方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p><p>1）添加依赖：</p><p>先添加SpringCloud依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringCloud的依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- Spring的仓库地址 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre></div><p>然后是Eureka客户端：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2）在启动类开启Eureka客户端</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 开启Eureka客户端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>3）修改配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">consumer</span> <span class="hljs-comment"># 应用名称</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 当其它服务获取地址时提供ip而不是hostname</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 指定自己的ip信息，不指定的话会自己寻找</span></code></pre></div><p>4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<span class="hljs-comment">// Eureka客户端，可以获取到服务实例信息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// String baseUrl = "http://localhost:8081/user/";</span>        <span class="hljs-comment">// 根据服务名称，获取服务实例</span>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">"user-service"</span>);        <span class="hljs-comment">// 因为只有一个UserService,因此我们直接get(0)获取</span>        ServiceInstance instance = instances.get(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 获取ip和端口信息</span>        String baseUrl = <span class="hljs-string">"http://"</span>+instance.getHost() + <span class="hljs-string">":"</span> + instance.getPort()+<span class="hljs-string">"/user/"</span>;        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;            <span class="hljs-comment">// 每次间隔500毫秒</span>            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre></div><p>5）Debug跟踪运行：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525613025086.png" srcset="/img/loading.gif" alt="1525613025086"></p><p>生成的URL：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525613051210.png" srcset="/img/loading.gif" alt="1525613051210"></p><p>访问结果：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525613160920.png" srcset="/img/loading.gif" alt="1525613160920"></p><h2 id="6-4-Eureka详解"><a href="#6-4-Eureka详解" class="headerlink" title="6.4.Eureka详解"></a>6.4.Eureka详解</h2><p>接下来我们详细讲解Eureka的原理及配置。</p><h3 id="6-4-1-基础架构"><a href="#6-4-1-基础架构" class="headerlink" title="6.4.1.基础架构"></a>6.4.1.基础架构</h3><p>Eureka架构中的三个核心角色：</p><ul><li><p>服务注册中心</p><p>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo</p></li><li><p>服务提供者</p><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo</p></li><li><p>服务消费者</p><p>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo</p></li></ul><h3 id="6-4-2-高可用的Eureka-Server"><a href="#6-4-2-高可用的Eureka-Server" class="headerlink" title="6.4.2.高可用的Eureka Server"></a>6.4.2.高可用的Eureka Server</h3><p>Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。</p><blockquote><p>服务同步</p></blockquote><p>多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现<strong>数据同步</strong>。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。</p><blockquote><p>动手搭建高可用的EurekaServer</p></blockquote><p>我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087</p><p>1）我们修改原来的EurekaServer配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span> <span class="hljs-comment"># 端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中显示</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10087/eureka</span></code></pre></div><p>所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：</p><ul><li>删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。</li><li>把service-url的值改成了另外一台EurekaServer的地址，而不是自己</li></ul><p>2）另外一台配置恰好相反：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10087</span> <span class="hljs-comment"># 端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中显示</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span></code></pre></div><p>注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525615070033.png" srcset="/img/loading.gif" alt="1525615070033"></p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525615095693.png" srcset="/img/loading.gif" alt="1525615095693"></p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525615026937.png" srcset="/img/loading.gif" alt="1525615026937"></p><p>然后启动即可。</p><p>3）启动测试：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525615165157.png" srcset="/img/loading.gif" alt="1525615165157"></p><p>4）客户端注册服务到集群</p><p>因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址,多个地址以','隔开</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></code></pre></div><h3 id="6-4-3-服务提供者"><a href="#6-4-3-服务提供者" class="headerlink" title="6.4.3.服务提供者"></a>6.4.3.服务提供者</h3><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p><blockquote><p>服务注册</p></blockquote><p>服务提供者在启动时，会检测配置属性中的：<code>eureka.client.register-with-erueka=true</code>参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。</p><blockquote><p>服务续约</p></blockquote><p>在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p><p>有两个重要参数可以修改服务续约的行为：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">90</span>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">30</span></code></pre></div><ul><li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li><li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li></ul><p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p><p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 10秒即过期</span>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 5秒一次心跳</span></code></pre></div><blockquote><p>实例id</p></blockquote><p>先来看一下服务状态信息：</p><p>在Eureka监控页面，查看服务注册信息：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525617060656.png" srcset="/img/loading.gif" alt="1525617060656"></p><p>在status一列中，显示以下信息：</p><ul><li>UP(1)：代表现在是启动了1个示例，没有集群</li><li>DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id），<ul><li>默认格式是：<code>${hostname} + ${spring.application.name} + ${server.port}</code></li><li>instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。</li></ul></li></ul><p>我们可以通过instance-id属性来修改它的构成：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></code></pre></div><p>重启服务再试试看：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525617542081.png" srcset="/img/loading.gif" alt="1525617542081"></p><h3 id="6-4-4-服务消费者"><a href="#6-4-4-服务消费者" class="headerlink" title="6.4.4.服务消费者"></a>6.4.4.服务消费者</h3><blockquote><p>获取服务列表</p></blockquote><p>当服务消费者启动是，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且<code>每隔30秒</code>会重新获取并更新数据。我们可以通过下面的参数来修改：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span></code></pre></div><p>生产环境中，我们不需要修改这个值。</p><p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p><h3 id="6-4-5-失效剔除和自我保护"><a href="#6-4-5-失效剔除和自我保护" class="headerlink" title="6.4.5.失效剔除和自我保护"></a>6.4.5.失效剔除和自我保护</h3><blockquote><p>失效剔除</p></blockquote><p>有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p><p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生成环境不要修改。</p><p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S</p><blockquote><p>自我保护</p></blockquote><p>我们关停一个服务，就会在Eureka面板看到一条警告：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525618396076.png" srcset="/img/loading.gif" alt="1525618396076"></p><p>这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。</p><p>但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">server:</span>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭自我保护模式（缺省为打开）</span>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></code></pre></div><h1 id="7-负载均衡Robbin"><a href="#7-负载均衡Robbin" class="headerlink" title="7.负载均衡Robbin"></a>7.负载均衡Robbin</h1><p>在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。</p><p>但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？</p><p>一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。</p><p>不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。</p><p>什么是Ribbon：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525619257397.png" srcset="/img/loading.gif" alt="1525619257397"></p><p>接下来，我们就来使用Ribbon实现负载均衡。</p><h2 id="7-1-启动两个服务实例"><a href="#7-1-启动两个服务实例" class="headerlink" title="7.1.启动两个服务实例"></a>7.1.启动两个服务实例</h2><p>首先我们启动两个user-service实例，一个8081，一个8082。</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525619515586.png" srcset="/img/loading.gif" alt="1525619515586"></p><p>Eureka监控面板：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525619546904.png" srcset="/img/loading.gif" alt="1525619546904"></p><h2 id="7-2-开启负载均衡"><a href="#7-2-开启负载均衡" class="headerlink" title="7.2.开启负载均衡"></a>7.2.开启负载均衡</h2><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：</p><p>在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());&#125;</code></pre></div><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 地址直接写服务名称即可</span>        String baseUrl = <span class="hljs-string">"http://user-service/user/"</span>;        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;            <span class="hljs-comment">// 每次间隔500毫秒</span>            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre></div><p>访问页面，查看结果：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525620305704.png" srcset="/img/loading.gif" alt="1525620305704"></p><p>完美！</p><h2 id="7-3-源码跟踪"><a href="#7-3-源码跟踪" class="headerlink" title="7.3.源码跟踪"></a>7.3.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code></p><p>我们进行源码跟踪：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525620483637.png" srcset="/img/loading.gif" alt="1525620483637"></p><p>继续跟入execute方法：发现获取了8082端口的服务</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525620787090.png" srcset="/img/loading.gif" alt="1525620787090"></p><p>再跟下一次，发现获取的是8081：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525620835911.png" srcset="/img/loading.gif" alt="1525620835911"></p><h2 id="7-4-负载均衡策略"><a href="#7-4-负载均衡策略" class="headerlink" title="7.4.负载均衡策略"></a>7.4.负载均衡策略</h2><p>Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：</p><p>编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622320277.png" srcset="/img/loading.gif" alt="1525622320277"></p><p>现在这个就是负载均衡获取实例的方法。</p><p>我们对注入这个类的对象，然后对其测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">LoadBalanceTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RibbonLoadBalancerClient client;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            ServiceInstance instance = <span class="hljs-keyword">this</span>.client.choose(<span class="hljs-string">"user-service"</span>);            System.out.println(instance.getHost() + <span class="hljs-string">":"</span> + instance.getPort());        &#125;    &#125;&#125;</code></pre></div><p>结果：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622357371.png" srcset="/img/loading.gif" alt="1525622357371"></p><p>符合了我们的预期推测，确实是轮询方式。</p><p>我们是否可以修改负载均衡的策略呢？</p><p>继续跟踪源码，发现这么一段代码：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622652849.png" srcset="/img/loading.gif" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622699666.png" srcset="/img/loading.gif" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622754316.png" srcset="/img/loading.gif" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>我们注意到，这个类其实是实现了接口IRule的，查看一下：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622817451.png" srcset="/img/loading.gif" alt="1525622817451"></p><p>定义负载均衡的规则接口。</p><p>它有以下实现：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525622876842.png" srcset="/img/loading.gif" alt="1525622876842"></p><p>SpringBoot也帮我们提供了修改负载均衡规则的配置入口：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">user-service:</span>  <span class="hljs-attr">ribbon:</span>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span></code></pre></div><p>格式是：<code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code>，值就是IRule的实现类。</p><p>再次测试，发现结果变成了随机：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525623193949.png" srcset="/img/loading.gif" alt="1525623193949"></p><h2 id="7-5-重试机制"><a href="#7-5-重试机制" class="headerlink" title="7.5.重试机制"></a>7.5.重试机制</h2><p>Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。</p><p>但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。</p><p>我们现在关闭一个user-service实例：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525653565855.png" srcset="/img/loading.gif" alt="1525653565855"></p><p>因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525653715488.png" srcset="/img/loading.gif" alt="1525653715488"></p><p>但是此时，8081服务其实是正常的。</p><p>因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。</p><p>只需要简单配置即可实现Ribbon的重试：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">loadbalancer:</span>      <span class="hljs-attr">retry:</span>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Spring Cloud的重试功能</span><span class="hljs-attr">user-service:</span>  <span class="hljs-attr">ribbon:</span>    <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># Ribbon的连接超时时间</span>    <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># Ribbon的数据读取超时时间</span>    <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作都进行重试</span>    <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 切换实例的重试次数</span>    <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 对当前实例的重试次数</span></code></pre></div><p>根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于<code>MaxAutoRetriesNextServer</code>参数的值</p><p>引入spring-retry依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.retry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-retry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday02/1525658269456.png" srcset="/img/loading.gif" alt="1525658269456"></p>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HttpClient</tag>
      
      <tag>SpringCloud</tag>
      
      <tag>Eureka</tag>
      
      <tag>Robbin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐优商城day01：springboot</title>
    <link href="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/"/>
    <url>/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解SpringBoot的作用</li><li>掌握java配置的方式</li><li>了解SpringBoot自动配置原理</li><li>掌握SpringBoot的基本使用</li><li>了解Thymeleaf的基本使用</li></ul><h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1. 了解SpringBoot"></a>1. 了解SpringBoot</h1><p>在这一部分，我们主要了解以下3个问题：</p><ul><li>什么是SpringBoot</li><li>为什么要学习SpringBoot</li><li>SpringBoot的特点</li></ul><h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525484756737.png" srcset="/img/loading.gif" alt="1525484756737"></p><p>我们可以看到下面的一段介绍：</p><blockquote><p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p></blockquote><p>翻译一下：</p><blockquote><p>用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。</p></blockquote><p>其实人们把Spring Boot 称为搭建程序的<code>脚手架</code>。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。</p><h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2.为什么要学习SpringBoot"></a>1.2.为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p><ul><li><p>复杂的配置，</p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p></li><li><p>一个是混乱的依赖管理。</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p></li></ul><p>而SpringBoot让这一切成为过去！</p><blockquote><p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p></blockquote><p>我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。</p><h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3.SpringBoot的特点"></a>1.3.SpringBoot的特点</h2><p>Spring Boot 主要目标是：</p><ul><li>为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验</li><li>开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。</li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等</li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><p>更多细节，大家可以到<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官网</a>查看。</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！</p><h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1.创建工程"></a>2.1.创建工程</h2><p>我们先新建一个空的工程：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525485888078.png" srcset="/img/loading.gif" alt="1525485888078"></p><p>工程名为demo：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525485977528.png" srcset="/img/loading.gif" alt="1525485977528"></p><p>新建一个model：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525486079389.png" srcset="/img/loading.gif" alt="1525486079389"></p><p>使用maven来构建：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525486188374.png" srcset="/img/loading.gif" alt="1525486188374"></p><p>然后填写项目坐标：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525486236967.png" srcset="/img/loading.gif" alt="1525486236967"></p><p>目录结构：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525486282929.png" srcset="/img/loading.gif" alt="1525486282929"></p><p>项目结构：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525486435199.png" srcset="/img/loading.gif" alt="1525486435199"></p><h2 id="2-2-添加依赖"><a href="#2-2-添加依赖" class="headerlink" title="2.2.添加依赖"></a>2.2.添加依赖</h2><p>看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？</p><p>别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！</p><h3 id="2-2-1-添加父工程坐标"><a href="#2-2-1-添加父工程坐标" class="headerlink" title="2.2.1.添加父工程坐标"></a>2.2.1.添加父工程坐标</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><h3 id="2-2-2-添加web启动器"><a href="#2-2-2-添加web启动器" class="headerlink" title="2.2.2.添加web启动器"></a>2.2.2.添加web启动器</h3><p>为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为<code>启动器</code>。因为我们是web项目，这里我们引入web启动器：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。</p><p>这个时候，我们会发现项目中多出了大量的依赖：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525486980765.png" srcset="/img/loading.gif" alt="1525486980765"></p><p>这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p><h3 id="2-2-3-管理jdk版本"><a href="#2-2-3-管理jdk版本" class="headerlink" title="2.2.3.管理jdk版本"></a>2.2.3.管理jdk版本</h3><p>默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><h3 id="2-2-4-完整pom"><a href="#2-2-4-完整pom" class="headerlink" title="2.2.4.完整pom"></a>2.2.4.完整pom</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h2 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3.启动类"></a>2.3.启动类</h2><p>Spring Boot项目通过main函数即可启动，我们需要创建一个启动类：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525487293907.png" srcset="/img/loading.gif" alt="1525487293907"></p><p>然后编写main函数：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h2 id="2-4-编写controller"><a href="#2-4-编写controller" class="headerlink" title="2.4.编写controller"></a>2.4.编写controller</h2><p>接下来，我们就可以像以前那样开发SpringMVC的项目了！</p><p>我们编写一个controller：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525487465325.png" srcset="/img/loading.gif" alt="1525487465325"></p><p>代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello, spring boot!"</span>;    &#125;&#125;</code></pre></div><h2 id="2-5-启动测试"><a href="#2-5-启动测试" class="headerlink" title="2.5.启动测试"></a>2.5.启动测试</h2><p>接下来，我们运行main函数，查看控制台：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525487613365.png" srcset="/img/loading.gif" alt="1525487613365"></p><p>并且可以看到监听的端口信息：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525487705460.png" srcset="/img/loading.gif" alt="1525487705460"></p><ul><li>1）监听的端口是8080</li><li>2）SpringMVC的映射路径是：/</li><li>3）<code>/hello</code>路径已经映射到了<code>HelloController</code>中的<code>hello()</code>方法</li></ul><p>打开页面访问：<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525487820824.png" srcset="/img/loading.gif" alt="1525487820824"></p><p>测试成功了！</p><h1 id="3-Java配置"><a href="#3-Java配置" class="headerlink" title="3.Java配置"></a>3.Java配置</h1><p>在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！</p><p>但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.alibaba.druid.pool.DruidDataSource"</span></span><span class="hljs-tag">      <span class="hljs-attr">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.username&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>现在该怎么做呢？</p><h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1.回顾历史"></a>3.1.回顾历史</h2><p>事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：</p><ul><li><p>Spring1.0时代</p><p>在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒</p></li><li><p>Spring2.0时代</p><p>Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。</p></li><li><p>Spring3.0及以后</p><p>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。</p></li></ul><p>有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。</p><h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2.尝试java配置"></a>3.2.尝试java配置</h2><p>java配置主要靠java类和一些注解，比较常用的注解有：</p><ul><li><code>@Configuration</code>：声明一个类作为配置类，代替xml文件</li><li><code>@Bean</code>：声明在方法上，将方法的返回值加入Bean容器，代替<code>&lt;bean&gt;</code>标签</li><li><code>@value</code>：属性注入</li><li><code>@PropertySource</code>：指定外部属性文件，</li></ul><p>我们接下来用java配置来尝试实现连接池配置：</p><p>首先引入Druid连接池依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>创建一个jdbc.properties文件，编写jdbc属性：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/leyou</span><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">123</span></code></pre></div><p>然后编写代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:jdbc.properties"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;jdbc.url&#125;"</span>)    String url;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;jdbc.driverClassName&#125;"</span>)    String driverClassName;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;jdbc.username&#125;"</span>)    String username;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;jdbc.password&#125;"</span>)    String password;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();        dataSource.setUrl(url);        dataSource.setDriverClassName(driverClassName);        dataSource.setUsername(username);        dataSource.setPassword(password);        <span class="hljs-keyword">return</span> dataSource;    &#125;&#125;</code></pre></div><p>解读：</p><ul><li><code>@Configuration</code>：声明我们<code>JdbcConfig</code>是一个配置类</li><li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li><li>通过<code>@Value</code>为属性注入值</li><li>通过@Bean将 <code>dataSource()</code>方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。</li></ul><p>然后我们就可以在任意位置通过<code>@Autowired</code>注入DataSource了！</p><p>我们在<code>HelloController</code>中测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DataSource dataSource;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello, spring boot!"</span> + dataSource;    &#125;&#125;</code></pre></div><p>然后Debug运行并查看：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525492528558.png" srcset="/img/loading.gif" alt="1525492528558"></p><p>属性注入成功了！</p><h2 id="3-3-SpringBoot的属性注入"><a href="#3-3-SpringBoot的属性注入" class="headerlink" title="3.3.SpringBoot的属性注入"></a>3.3.SpringBoot的属性注入</h2><p>在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。</p><p>在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。</p><p>1）我们新建一个类，用来进行属性注入：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"jdbc"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> String driverClassName;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// ... 略</span>    <span class="hljs-comment">// getters 和 setters</span>&#125;</code></pre></div><ul><li><p>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</p></li><li><p><code>prefix=&quot;jdbc&quot;</code>读取属性文件中，前缀为jdbc的值。</p></li><li><p>在类上定义各个属性，名称必须与属性文件中<code>jdbc.</code>后面部分一致</p></li><li><p>需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525496325572.png" srcset="/img/loading.gif" alt="1525496325572"></p></li></ul><p>2）在JdbcConfig中使用这个属性：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties</span>(JdbcProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">JdbcConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(JdbcProperties jdbc)</span> </span>&#123;        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();        dataSource.setUrl(jdbc.getUrl());        dataSource.setDriverClassName(jdbc.getDriverClassName());        dataSource.setUsername(jdbc.getUsername());        dataSource.setPassword(jdbc.getPassword());        <span class="hljs-keyword">return</span> dataSource;    &#125;&#125;</code></pre></div><ul><li><p>通过<code>@EnableConfigurationProperties(JdbcProperties.class)</code>来声明要使用<code>JdbcProperties</code>这个类的对象</p></li><li><p>然后你可以通过以下方式注入JdbcProperties：</p><ul><li><p>@Autowired注入</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> JdbcProperties prop;</code></pre></div></li><li><p>构造函数注入</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> JdbcProperties prop;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JdbcConfig</span><span class="hljs-params">(Jdbcproperties prop)</span></span>&#123;    <span class="hljs-keyword">this</span>.prop = prop;&#125;</code></pre></div></li><li><p>声明有@Bean的方法参数注入</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Datasource <span class="hljs-title">dataSource</span><span class="hljs-params">(JdbcProperties prop)</span></span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div></li></ul></li></ul><p>本例中，我们采用第三种方式。</p><p>3）测试结果：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525492528558.png" srcset="/img/loading.gif" alt="1525492528558"></p><p>大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525496543249.png" srcset="/img/loading.gif" alt="1525496543249"></p><p>优势：</p><ul><li><p>Relaxed binding：松散绑定</p><ul><li><p>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。</p></li><li><p>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</p><p>​</p></li></ul></li></ul><h2 id="3-4、更优雅的注入"><a href="#3-4、更优雅的注入" class="headerlink" title="3.4、更优雅的注入"></a>3.4、更优雅的注入</h2><p>事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>&#123;        <span class="hljs-meta">@Bean</span>    <span class="hljs-comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"jdbc"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();        <span class="hljs-keyword">return</span> dataSource;    &#125;&#125;</code></pre></div><p>我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用的<code>@Bean</code>的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：<strong>该类必须有对应属性的set方法！</strong></p><p>我们将jdbc的url改成：/heima，再次测试：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525497513206.png" srcset="/img/loading.gif" alt="1525497513206"></p><h1 id="4-自动配置原理"><a href="#4-自动配置原理" class="headerlink" title="4.自动配置原理"></a>4.自动配置原理</h1><p>使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？</p><p>一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525488044650.png" srcset="/img/loading.gif" alt="1525488044650"></p><p>我们发现特别的地方有两个：</p><ul><li>注解：@SpringBootApplication</li><li>run方法：SpringApplication.run()</li></ul><p>我们分别来研究这两个部分。</p><h2 id="4-1-了解-SpringBootApplication"><a href="#4-1-了解-SpringBootApplication" class="headerlink" title="4.1.了解@SpringBootApplication"></a>4.1.了解@SpringBootApplication</h2><p>点击进入，查看源码：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525488226710.png" srcset="/img/loading.gif" alt="1525488226710"></p><p>这里重点的注解有3个：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="4-1-1-SpringBootConfiguration"><a href="#4-1-1-SpringBootConfiguration" class="headerlink" title="4.1.1.@SpringBootConfiguration"></a>4.1.1.@SpringBootConfiguration</h3><p>我们继续点击查看源码：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525488518514.png" srcset="/img/loading.gif" alt="1525488518514"></p><p>通过这段我们可以看出，在这个注解上面，又有一个<code>@Configuration</code>注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code>是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p><h3 id="4-1-2-EnableAutoConfiguration"><a href="#4-1-2-EnableAutoConfiguration" class="headerlink" title="4.1.2.@EnableAutoConfiguration"></a>4.1.2.@EnableAutoConfiguration</h3><p>关于这个注解，官网上有一段说明：</p><blockquote><p>The second class-level annotation is <code>@EnableAutoConfiguration</code>. This annotation<br>tells Spring Boot to “guess” how you want to configure Spring, based on the jar<br>dependencies that you have added. Since <code>spring-boot-starter-web</code> added Tomcat<br>and Spring MVC, the auto-configuration assumes that you are developing a web<br>application and sets up Spring accordingly.</p></blockquote><p>简单翻译以下：</p><blockquote><p>第二级的注解<code>@EnableAutoConfiguration</code>，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了<code>spring-boot-starter-web</code>，而这个启动器中帮我们添加了<code>tomcat</code>、<code>SpringMVC</code>的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p></blockquote><p>总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p><p>所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。</p><h4 id="4-1-3-ComponentScan"><a href="#4-1-3-ComponentScan" class="headerlink" title="4.1.3.@ComponentScan"></a>4.1.3.@ComponentScan</h4><p>我们跟进源码：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525498265579.png" srcset="/img/loading.gif" alt="1525498265579"></p><p>并没有看到什么特殊的地方。我们查看注释：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525498351385.png" srcset="/img/loading.gif" alt="1525498351385"></p><p>大概的意思：</p><blockquote><p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p></blockquote><p>而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，<strong>一般启动类会放在一个比较前的包目录中。</strong></p><h2 id="4-2-默认配置原理"><a href="#4-2-默认配置原理" class="headerlink" title="4.2.默认配置原理"></a>4.2.默认配置原理</h2><h3 id="4-2-1默认配置类"><a href="#4-2-1默认配置类" class="headerlink" title="4.2.1默认配置类"></a>4.2.1默认配置类</h3><p>通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：</p><ul><li>这些默认配置是在哪里定义的呢？</li><li>为何依赖引入就会触发配置呢？</li></ul><p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525499397690.png" srcset="/img/loading.gif" alt="1525499397690"></p><p>还有：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525499426598.png" srcset="/img/loading.gif" alt="1525499426598"></p><p>非常多，几乎涵盖了现在主流的开源框架，例如：</p><ul><li>redis</li><li>jms</li><li>amqp</li><li>jdbc</li><li>jackson</li><li>mongodb</li><li>jpa</li><li>solr</li><li>elasticsearch</li></ul><p>… 等等</p><p>我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525499859426.png" srcset="/img/loading.gif" alt="1525499859426"></p><p>打开WebMvcAutoConfiguration：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500000816.png" srcset="/img/loading.gif" alt="1525500000816"></p><p>我们看到这个类上的4个注解：</p><ul><li><code>@Configuration</code>：声明这个类是一个配置类</li></ul><ul><li><p><code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></p><p>ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是</p></li><li><p><code>@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</code></p><p>这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！</p></li><li><p><code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p><p>这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！</p></li></ul><p>接着，我们查看该类中定义了什么：</p><p>视图解析器：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500405278.png" srcset="/img/loading.gif" alt="1525500405278"></p><p>处理器适配器（HandlerAdapter）：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500452517.png" srcset="/img/loading.gif" alt="1525500452517"></p><p>还有很多，这里就不一一截图了。</p><h3 id="4-2-2-默认配置属性"><a href="#4-2-2-默认配置属性" class="headerlink" title="4.2.2.默认配置属性"></a>4.2.2.默认配置属性</h3><p>另外，这些默认配置的属性来自哪里呢？</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500697391.png" srcset="/img/loading.gif" alt="1525500697391"></p><p>我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。</p><p>我们查看这两个属性类：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500810914.png" srcset="/img/loading.gif" alt="1525500810914"></p><p>找到了内部资源视图解析器的prefix和suffix属性。</p><p>ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500921773.png" srcset="/img/loading.gif" alt="1525500921773"></p><p>如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。</p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3.总结"></a>4.3.总结</h2><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置</li></ul><p>1）启动器</p><p>所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》</p><p>2）全局配置</p><p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》</p><h1 id="5-SpringBoot实践"><a href="#5-SpringBoot实践" class="headerlink" title="5.SpringBoot实践"></a>5.SpringBoot实践</h1><p>接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User</p><h2 id="5-1-整合SpringMVC"><a href="#5-1-整合SpringMVC" class="headerlink" title="5.1.整合SpringMVC"></a>5.1.整合SpringMVC</h2><p>虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。</p><h3 id="5-1-1-修改端口"><a href="#5-1-1-修改端口" class="headerlink" title="5.1.1.修改端口"></a>5.1.1.修改端口</h3><p>查看SpringBoot的全局属性可知，端口通过以下方式配置：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># 映射端口</span><span class="hljs-meta">server.port</span>=<span class="hljs-string">80</span></code></pre></div><p>重启服务后测试：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525511878440.png" srcset="/img/loading.gif" alt="1525511878440"></p><h3 id="5-1-2-访问静态资源"><a href="#5-1-2-访问静态资源" class="headerlink" title="5.1.2.访问静态资源"></a>5.1.2.访问静态资源</h3><p>现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p><p>回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525500921773.png" srcset="/img/loading.gif" alt="1525500921773"></p><p>默认的静态资源路径为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public</li></ul><p>只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。</p><p>我们习惯会把静态资源放在<code>classpath:/static/</code>目录下。我们创建目录，并且添加一些静态资源：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525512196866.png" srcset="/img/loading.gif" alt="1525512196866"></p><p>重启项目后测试：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525512253682.png" srcset="/img/loading.gif" alt="1525512253682"></p><h3 id="5-1-3-添加拦截器"><a href="#5-1-3-添加拦截器" class="headerlink" title="5.1.3.添加拦截器"></a>5.1.3.添加拦截器</h3><p>拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？</p><p>拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：</p><blockquote><p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p></blockquote><p>翻译：</p><blockquote><p>如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现<code>WebMvcConfigurer</code>，并且添加<code>@Configuration</code>注解，但是<strong>千万不要</strong>加<code>@EnableWebMvc</code>注解。如果你想要自定义<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ExceptionResolver</code>等组件，你可以创建一个<code>WebMvcRegistrationsAdapter</code>实例 来提供以上组件。</p><p>如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加<code>@Configuration</code>注解和<code>@EnableWebMvc</code>注解</p></blockquote><p>总结：通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p><p>首先我们定义一个拦截器：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginInterceptor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;        logger.debug(<span class="hljs-string">"preHandle method is now running!"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> </span>&#123;        logger.debug(<span class="hljs-string">"postHandle method is now running!"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;        logger.debug(<span class="hljs-string">"afterCompletion method is now running!"</span>);    &#125;&#125;</code></pre></div><p>然后，我们定义配置类，注册拦截器：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span></span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过<span class="hljs-doctag">@Bean</span>注解，将我们定义的拦截器注册到Spring容器</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LoginInterceptor <span class="hljs-title">loginInterceptor</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoginInterceptor();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        <span class="hljs-comment">// 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径</span>        registry.addInterceptor(<span class="hljs-keyword">this</span>.loginInterceptor()).addPathPatterns(<span class="hljs-string">"/**"</span>);    &#125;&#125;</code></pre></div><p>结构如下：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525513555179.png" srcset="/img/loading.gif" alt="1525513555179"></p><p>接下来运行并查看日志：</p><p>你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。</p><p>SpringBoot通过<code>logging.level.*=debug</code>来配置日志级别，*填写包名</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># 设置com.leyou包的日志级别为debug</span><span class="hljs-meta">logging.level.com.leyou</span>=<span class="hljs-string">debug</span></code></pre></div><p>再次运行查看：</p><div class="hljs"><pre><code class="hljs verilog"><span class="hljs-number">2018</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">17</span>:<span class="hljs-number">50</span>:<span class="hljs-number">01</span><span class="hljs-variable">.811</span> DEBUG <span class="hljs-number">4548</span> --- [p-nio-<span class="hljs-number">80</span>-exec-<span class="hljs-number">1</span>] com<span class="hljs-variable">.leyou</span><span class="hljs-variable">.interceptor</span><span class="hljs-variable">.LoginInterceptor</span>   : preHandle method is now running!<span class="hljs-number">2018</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">17</span>:<span class="hljs-number">50</span>:<span class="hljs-number">01</span><span class="hljs-variable">.854</span> DEBUG <span class="hljs-number">4548</span> --- [p-nio-<span class="hljs-number">80</span>-exec-<span class="hljs-number">1</span>] com<span class="hljs-variable">.leyou</span><span class="hljs-variable">.interceptor</span><span class="hljs-variable">.LoginInterceptor</span>   : postHandle method is now running!<span class="hljs-number">2018</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">17</span>:<span class="hljs-number">50</span>:<span class="hljs-number">01</span><span class="hljs-variable">.854</span> DEBUG <span class="hljs-number">4548</span> --- [p-nio-<span class="hljs-number">80</span>-exec-<span class="hljs-number">1</span>] com<span class="hljs-variable">.leyou</span><span class="hljs-variable">.interceptor</span><span class="hljs-variable">.LoginInterceptor</span>   : afterCompletion method is now running!</code></pre></div><h2 id="5-2-整合jdbc和事务"><a href="#5-2-整合jdbc和事务" class="headerlink" title="5.2.整合jdbc和事务"></a>5.2.整合jdbc和事务</h2><p>spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？</p><p>答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>至于事务，SpringBoot中通过注解来控制。就是我们熟知的<code>@Transactional</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userMapper.selectByPrimaryKey(id);    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Long id)</span></span>&#123;        <span class="hljs-keyword">this</span>.userMapper.deleteByPrimaryKey(id);    &#125;&#125;</code></pre></div><h2 id="5-3-整合连接池"><a href="#5-3-整合连接池" class="headerlink" title="5.3.整合连接池"></a>5.3.整合连接池</h2><p>其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525514424562.png" srcset="/img/loading.gif" alt="1525514424562"></p><p>HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525516441005.png" srcset="/img/loading.gif" alt="1525516441005"></p><p>因此，我们只需要指定连接池参数即可：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># 连接四大参数</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/heima</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123</span><span class="hljs-comment"># 可省略，SpringBoot自动推断</span><span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-meta">spring.datasource.hikari.idle-timeout</span>=<span class="hljs-string">60000</span><span class="hljs-meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="hljs-string">30</span><span class="hljs-meta">spring.datasource.hikari.minimum-idle</span>=<span class="hljs-string">10</span></code></pre></div><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Druid连接池 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#初始化连接数</span><span class="hljs-meta">spring.datasource.druid.initial-size</span>=<span class="hljs-string">1</span><span class="hljs-comment">#最小空闲连接</span><span class="hljs-meta">spring.datasource.druid.min-idle</span>=<span class="hljs-string">1</span><span class="hljs-comment">#最大活动连接</span><span class="hljs-meta">spring.datasource.druid.max-active</span>=<span class="hljs-string">20</span><span class="hljs-comment">#获取连接时测试是否可用</span><span class="hljs-meta">spring.datasource.druid.test-on-borrow</span>=<span class="hljs-string">true</span><span class="hljs-comment">#监控页面启动</span><span class="hljs-meta">spring.datasource.druid.stat-view-servlet.allow</span>=<span class="hljs-string">true</span></code></pre></div><h2 id="5-4-整合mybatis"><a href="#5-4-整合mybatis" class="headerlink" title="5.4.整合mybatis"></a>5.4.整合mybatis</h2><h3 id="5-4-1-mybatis"><a href="#5-4-1-mybatis" class="headerlink" title="5.4.1.mybatis"></a>5.4.1.mybatis</h3><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="noopener">官网</a>自己实现了：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>配置，基本没有需要配置的：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># mybatis 别名扫描</span><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.heima.pojo</span><span class="hljs-comment"># mapper.xml文件位置,如果没有映射文件，请注释掉</span><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mappers/*.xml</span></code></pre></div><p>需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;&#125;</code></pre></div><h3 id="5-4-2-通用mapper"><a href="#5-4-2-通用mapper" class="headerlink" title="5.4.2.通用mapper"></a>5.4.2.通用mapper</h3><p>通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通用mapper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>不需要做任何配置就可以使用了。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">tk</span>.<span class="hljs-title">mybatis</span>.<span class="hljs-title">mapper</span>.<span class="hljs-title">common</span>.<span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">User</span>&gt;</span>&#123;&#125;</code></pre></div><h2 id="5-5-启动测试"><a href="#5-5-启动测试" class="headerlink" title="5.5.启动测试"></a>5.5.启动测试</h2><p>将controller进行简单改造：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        User user = <span class="hljs-keyword">this</span>.userService.queryById(<span class="hljs-number">8L</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre></div><p>我们启动项目，查看：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525516714124.png" srcset="/img/loading.gif" alt="1525516714124"></p><h1 id="6-Thymeleaf快速入门"><a href="#6-Thymeleaf快速入门" class="headerlink" title="6.Thymeleaf快速入门"></a>6.Thymeleaf快速入门</h1><p>SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525517263421.png" srcset="/img/loading.gif" alt="1525517263421"></p><p>以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！</p><h2 id="6-1-为什么是Thymeleaf？"><a href="#6-1-为什么是Thymeleaf？" class="headerlink" title="6.1.为什么是Thymeleaf？"></a>6.1.为什么是Thymeleaf？</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><p>接下来，我们就通过入门案例来体会Thymeleaf的魅力：</p><h2 id="6-2-编写接口"><a href="#6-2-编写接口" class="headerlink" title="6.2.编写接口"></a>6.2.编写接口</h2><p>编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/all"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">all</span><span class="hljs-params">(ModelMap model)</span> </span>&#123;    <span class="hljs-comment">// 查询用户</span>    List&lt;User&gt; users = <span class="hljs-keyword">this</span>.userService.queryAll();    <span class="hljs-comment">// 放入模型</span>    model.addAttribute(<span class="hljs-string">"users"</span>, users);    <span class="hljs-comment">// 返回模板名称（就是classpath:/templates/目录下的html文件名）</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"users"</span>;&#125;</code></pre></div><h2 id="6-3-引入启动器"><a href="#6-3-引入启动器" class="headerlink" title="6.3.引入启动器"></a>6.3.引入启动器</h2><p>直接引入启动器：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>SpringBoot会自动为Thymeleaf注册一个视图解析器：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525522481007.png" srcset="/img/loading.gif" alt="1525522481007"></p><p>与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525522811359.png" srcset="/img/loading.gif" alt="1525522811359"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>一般我们无需进行修改，默认即可。</p><h2 id="6-4-静态页面"><a href="#6-4-静态页面" class="headerlink" title="6.4.静态页面"></a>6.4.静态页面</h2><p>根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：</p><p> <img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525521721279.png" srcset="/img/loading.gif" alt="1525521721279"></p><p>编写html模板，渲染模型中的数据：</p><p>注意，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">        <span class="hljs-selector-tag">table</span> &#123;<span class="hljs-attribute">border-collapse</span>: collapse; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>; <span class="hljs-attribute">margin</span>: auto&#125;</span><span class="css">        <span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> &#123;<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid darkslategray;<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>&#125;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: darkslategray; font-size: 30px"</span>&gt;</span>欢迎光临！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>生日<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>备注<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user : $&#123;users&#125;"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.id&#125;"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.name&#125;"</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.userName&#125;"</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.age&#125;"</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.sex&#125; == 1 ? '男': '女'"</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"</span>&gt;</span>1980-02-30<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;user.note&#125;"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>我们看到这里使用了以下语法：</p><ul><li><code>${}</code> ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大</li><li><code>th-</code>指令：<code>th-</code>是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用<code>data-th-</code>来代替<ul><li><code>th:each</code>：类似于<code>c:foreach</code>  遍历集合，但是语法更加简洁</li><li><code>th:text</code>：声明标签中的文本<ul><li>例如<code>&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;</code>，如果user.id有值，会覆盖默认的1</li><li>如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！</li></ul></li></ul></li></ul><h2 id="6-5-测试"><a href="#6-5-测试" class="headerlink" title="6.5.测试"></a>6.5.测试</h2><p>接下来，我们打开页面测试一下：</p><p><img src="/2020/09/20/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday01/1525523911854.png" srcset="/img/loading.gif" alt="1525523911854"></p><h2 id="6-6-模板缓存"><a href="#6-6-模板缓存" class="headerlink" title="6.6.模板缓存"></a>6.6.模板缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># 开发阶段关闭thymeleaf的模板缓存</span><span class="hljs-meta">spring.thymeleaf.cache</span>=<span class="hljs-string">false</span></code></pre></div><p><strong>注意</strong>：</p><p>​    在Idea中，我们需要在修改页面后按快捷键：<code>Ctrl + Shift + F9</code> 对项目进行rebuild才可以。</p><p>​    eclipse中没有测试过。</p><p>我们可以修改页面，测试一下。</p>]]></content>
    
    
    <categories>
      
      <category>乐优商城</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Thymeleaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>权限管理、旅游系统后篇</title>
    <link href="/2020/09/15/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AF%87/"/>
    <url>/2020/09/15/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="权限管理、旅游系统后篇"><a href="#权限管理、旅游系统后篇" class="headerlink" title="权限管理、旅游系统后篇"></a>权限管理、旅游系统后篇</h1><h1 id="SSM权限操作"><a href="#SSM权限操作" class="headerlink" title="SSM权限操作"></a>SSM权限操作</h1><h2 id="1-数据库与表结构"><a href="#1-数据库与表结构" class="headerlink" title="1.数据库与表结构"></a>1.数据库与表结构</h2><h3 id="1-1-用户表"><a href="#1-1-用户表" class="headerlink" title="1.1 用户表"></a>1.1 用户表</h3><h4 id="1-1-1-用户表信息描述users"><a href="#1-1-1-用户表信息描述users" class="headerlink" title="1.1.1 用户表信息描述users"></a>1.1.1 用户表信息描述users</h4><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2</td><td>无意义，主键uuid</td></tr><tr><td>2</td><td>email</td><td>varchar2</td><td>非空，唯一</td></tr><tr><td>3</td><td>username</td><td>varchar2</td><td>用户名</td></tr><tr><td>5</td><td>password</td><td>varchar2</td><td>密码（加密）</td></tr><tr><td>6</td><td>phoneNum</td><td>varchar2</td><td>电话</td></tr><tr><td>7</td><td>status</td><td>int</td><td>状态0 未开启 1 开启</td></tr></tbody></table><h4 id="1-1-2-sql语句"><a href="#1-1-2-sql语句" class="headerlink" title="1.1.2 sql语句"></a>1.1.2 sql语句</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">users</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> SYS_GUID() PRIMARY <span class="hljs-keyword">KEY</span>,     email <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    username <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>),     <span class="hljs-keyword">PASSWORD</span> <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>),     phoneNum <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">20</span>),     <span class="hljs-keyword">STATUS</span> <span class="hljs-built_in">INT</span>)</code></pre></div><h4 id="1-1-3-实体类"><a href="#1-1-3-实体类" class="headerlink" title="1.1.3 实体类"></a>1.1.3 实体类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-02  15:32</span><span class="hljs-comment"> * 与数据库中的users对应</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String email;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String phoneNum;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> status;    <span class="hljs-keyword">private</span> String statusStr;    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;&#125;</code></pre></div><h3 id="1-2-角色表"><a href="#1-2-角色表" class="headerlink" title="1.2 角色表"></a>1.2 角色表</h3><h4 id="1-2-1-角色表信息描述role"><a href="#1-2-1-角色表信息描述role" class="headerlink" title="1.2.1 角色表信息描述role"></a>1.2.1 角色表信息描述role</h4><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2</td><td>无意义，主键uuid</td></tr><tr><td>2</td><td>roleName</td><td>varchar2</td><td>角色名</td></tr><tr><td>3</td><td>roleDesc</td><td>varchar2</td><td>角色描述</td></tr></tbody></table><h4 id="1-2-2-sql语句"><a href="#1-2-2-sql语句" class="headerlink" title="1.2.2 sql语句"></a>1.2.2 sql语句</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">role</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> SYS_GUID() PRIMARY <span class="hljs-keyword">KEY</span>,     roleName <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>) ,roleDesc <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>))</code></pre></div><h4 id="1-2-3-实体类"><a href="#1-2-3-实体类" class="headerlink" title="1.2.3 实体类"></a>1.2.3 实体类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;<span class="hljs-keyword">private</span> String id;     <span class="hljs-keyword">private</span> String roleName;     <span class="hljs-keyword">private</span> String roleDesc;<span class="hljs-keyword">private</span> List&lt;Permission&gt; permissions;     <span class="hljs-keyword">private</span> List&lt;User&gt; users;&#125;</code></pre></div><h4 id="1-2-4-用户与角色关联关系"><a href="#1-2-4-用户与角色关联关系" class="headerlink" title="1.2.4 用户与角色关联关系"></a>1.2.4 用户与角色关联关系</h4><p>用户与角色之间是多对多关系，我们通过user_role表来描述其关联，在实体类中User中存在List，在Role中有List.而角色与权限之间也存在关系，我们会在后面介绍。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">users_role</span><span class="hljs-params">( </span></span><span class="hljs-function"><span class="hljs-params">    userId varchar2(<span class="hljs-number">32</span>)</span>, </span><span class="hljs-function">    roleId <span class="hljs-title">varchar2</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>,</span><span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(userId,roleId)</span>,</span><span class="hljs-function">FOREIGN <span class="hljs-title">KEY</span> <span class="hljs-params">(userId)</span> REFERENCES <span class="hljs-title">users</span><span class="hljs-params">(id)</span>, </span><span class="hljs-function">    FOREIGN <span class="hljs-title">KEY</span> <span class="hljs-params">(roleId)</span> REFERENCES <span class="hljs-title">role</span><span class="hljs-params">(id)</span></span><span class="hljs-function">)</span></code></pre></div><h3 id="1-3-资源权限表"><a href="#1-3-资源权限表" class="headerlink" title="1.3 资源权限表"></a>1.3 资源权限表</h3><h4 id="1-3-1-权限资源表描述permission"><a href="#1-3-1-权限资源表描述permission" class="headerlink" title="1.3.1 权限资源表描述permission"></a>1.3.1 权限资源表描述permission</h4><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2</td><td>无意义，主键uuid</td></tr><tr><td>2</td><td>permissionName</td><td>varchar2</td><td>权限名</td></tr><tr><td>3</td><td>url</td><td>varchar2</td><td>资源路径</td></tr></tbody></table><h4 id="1-3-2-sql语句"><a href="#1-3-2-sql语句" class="headerlink" title="1.3.2 sql语句"></a>1.3.2 sql语句</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> permission(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> SYS_GUID() PRIMARY <span class="hljs-keyword">KEY</span>,     permissionName <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>) ,<span class="hljs-keyword">url</span> <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>))</code></pre></div><h4 id="1-3-3-实体类"><a href="#1-3-3-实体类" class="headerlink" title="1.3.3 实体类"></a>1.3.3 实体类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Permission</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String permissionName; <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;&#125;</code></pre></div><h4 id="1-3-4-权限资源与角色关联关系"><a href="#1-3-4-权限资源与角色关联关系" class="headerlink" title="1.3.4.权限资源与角色关联关系"></a>1.3.4.权限资源与角色关联关系</h4><p>权限资源与角色是多对多关系，我们使用role_permission表来描述。在实体类Permission中存在List,在Role类中有List</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">role_permission</span><span class="hljs-params">( </span></span><span class="hljs-function"><span class="hljs-params">    permissionId varchar2(<span class="hljs-number">32</span>)</span>, </span><span class="hljs-function">    roleId <span class="hljs-title">varchar2</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span>,</span><span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span><span class="hljs-params">(permissionId,roleId)</span>,</span><span class="hljs-function">FOREIGN <span class="hljs-title">KEY</span> <span class="hljs-params">(permissionId)</span> REFERENCES <span class="hljs-title">permission</span><span class="hljs-params">(id)</span>, </span><span class="hljs-function">    FOREIGN <span class="hljs-title">KEY</span> <span class="hljs-params">(roleId)</span> REFERENCES <span class="hljs-title">role</span><span class="hljs-params">(id)</span></span><span class="hljs-function">)</span></code></pre></div><h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h2><h3 id="2-1-用户登录"><a href="#2-1-用户登录" class="headerlink" title="2.1 用户登录"></a>2.1 用户登录</h3><p>spring security的配置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">security:authentication-manager</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">security:authentication-provider</span> <span class="hljs-attr">user-service-ref</span>=<span class="hljs-string">"userService"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置加密的方式</span><span class="hljs-comment"></span><span class="hljs-comment">        &lt;security:password-encoder ref="passwordEncoder"/&gt; --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">security:authentication-provider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">security:authentication-manager</span>&gt;</span></code></pre></div><h4 id="2-1-1-登录页面login-jsp"><a href="#2-1-1-登录页面login-jsp" class="headerlink" title="2.1.1.登录页面login.jsp"></a>2.1.1.登录页面login.jsp</h4><p>详细页面请查看资料</p><h4 id="2-1-2-Service"><a href="#2-1-2-Service" class="headerlink" title="2.1.2.Service"></a>2.1.2.Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserDetailsService</span></span>&#123;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"userService"</span>)<span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IUserDao userDao;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        UserInfo userInfo = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            userInfo = userDao.findByUsername(username);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//处理自己的用户对象封装成UserDetails</span>        User user = <span class="hljs-keyword">new</span> User(userInfo.getUsername(),userInfo.getPassword(),userInfo.getStatus()== <span class="hljs-number">0</span>?<span class="hljs-keyword">false</span>:<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>, getAuthority(userInfo.getRoles()));        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-comment">//作用就是返回一个List集合，集合中装入的是角色描述</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SimpleGrantedAuthority&gt; <span class="hljs-title">getAuthority</span><span class="hljs-params">(List&lt;Role&gt; roles)</span></span>&#123;        List&lt;SimpleGrantedAuthority&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;SimpleGrantedAuthority&gt;();        <span class="hljs-keyword">for</span> (Role role : roles)&#123;            list.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(<span class="hljs-string">"ROLE_"</span> + role.getRoleName()));        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre></div><h4 id="2-1-3-IUserDao"><a href="#2-1-3-IUserDao" class="headerlink" title="2.1.3.IUserDao"></a>2.1.3.IUserDao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-02  15:32</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from users where username=#&#123;username&#125;"</span>)    <span class="hljs-meta">@Results</span>(&#123;            <span class="hljs-meta">@Result</span>(id = <span class="hljs-keyword">true</span>,property = <span class="hljs-string">"id"</span>,column = <span class="hljs-string">"id"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"username"</span>,column = <span class="hljs-string">"username"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"email"</span>,column = <span class="hljs-string">"email"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"password"</span>,column = <span class="hljs-string">"password"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"phoneNum"</span>,column = <span class="hljs-string">"phoneNum"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"status"</span>,column = <span class="hljs-string">"status"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"roles"</span>,column = <span class="hljs-string">"id"</span>,javaType = java.util.List<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">many</span> </span>= <span class="hljs-meta">@Many</span>(select = <span class="hljs-string">"com.jk.ssm.dao.IRoleDao.findRoleByUserId"</span>))    &#125;)    <span class="hljs-function">UserInfo <span class="hljs-title">findByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><h3 id="2-2-用户退出"><a href="#2-2-用户退出" class="headerlink" title="2.2 用户退出"></a>2.2 用户退出</h3><p>使用spring security完成用户退出，非常简单</p><p>配置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">security:logout</span> <span class="hljs-attr">invalidate-session</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">logout-url</span>=<span class="hljs-string">"/logout.do"</span> <span class="hljs-attr">logout-success-</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/login.jsp"</span> /&gt;</span></code></pre></div><p>页面中</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/logout.do"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-default btn-flat"</span>&gt;</span>注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><h3 id="2-3-用户查询"><a href="#2-3-用户查询" class="headerlink" title="2.3 用户查询"></a>2.3 用户查询</h3><h4 id="2-3-1-用户查询页面-user-list-jsp"><a href="#2-3-1-用户查询页面-user-list-jsp" class="headerlink" title="2.3.1.用户查询页面 user-list.jsp"></a>2.3.1.用户查询页面 user-list.jsp</h4><p>请在资料中查看具体代码</p><h4 id="2-3-2-UserController"><a href="#2-3-2-UserController" class="headerlink" title="2.3.2.UserController"></a>2.3.2.UserController</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span> <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControlller</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;         List&lt;UserInfo&gt; users = userService.findAll();         ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();         mv.addObject(<span class="hljs-string">"userlist"</span>, users);         mv.setViewName(<span class="hljs-string">"user-list"</span>);    <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><h4 id="2-3-3-Dao"><a href="#2-3-3-Dao" class="headerlink" title="2.3.3.Dao"></a>2.3.3.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;</code></pre></div><h3 id="2-4-用户添加"><a href="#2-4-用户添加" class="headerlink" title="2.4 用户添加"></a>2.4 用户添加</h3><h4 id="2-4-1-用户添加页面-user-add-jsp"><a href="#2-4-1-用户添加页面-user-add-jsp" class="headerlink" title="2.4.1.用户添加页面 user-add.jsp"></a>2.4.1.用户添加页面 user-add.jsp</h4><p>请在资料中查看具体页面码</p><h4 id="2-4-2-UserController"><a href="#2-4-2-UserController" class="headerlink" title="2.4.2.UserController"></a>2.4.2.UserController</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span> <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControlller</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IUserService userService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/save.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(UserInfo user)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        userService.save(user);        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:findAll.do"</span>;    &#125;&#125;</code></pre></div><p>2.4.3.Service</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"userService"</span>)<span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IUserDao userDao;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(UserInfo user)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; user.setPassword(passwordEncoder.encode(user.getPassword())); userDao.save(user);    &#125;&#125;</code></pre></div><p>前期我们的用户密码没有加密，现在添加用户时，我们需要对用户密码进行加密</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置加密类 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"passwordEncoder"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"</span>/&gt;</span></code></pre></div><h4 id="2-4-4-Dao"><a href="#2-4-4-Dao" class="headerlink" title="2.4.4.Dao"></a>2.4.4.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into user(email,username,password,phoneNum,status) value(#&#123;email&#125;,#</span><span class="hljs-string">&#123;username&#125;,#&#123;password&#125;,#&#123;phoneNum&#125;,#&#123;status&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(UserInfo user)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><h3 id="2-5-用户详情"><a href="#2-5-用户详情" class="headerlink" title="2.5 用户详情"></a>2.5 用户详情</h3><h4 id="3-5-1-用户详情页面user-show-jsp"><a href="#3-5-1-用户详情页面user-show-jsp" class="headerlink" title="3.5.1.用户详情页面user-show.jsp"></a>3.5.1.用户详情页面user-show.jsp</h4><p>请在资料中查看页面详细代码</p><p>注意：需要添加js</p><div class="hljs"><pre><code class="hljs js">$(<span class="hljs-string">"#collapse-table"</span>).treetable(&#123;     expandable : <span class="hljs-literal">true</span>&#125;);</code></pre></div><h4 id="3-5-2-UserController"><a href="#3-5-2-UserController" class="headerlink" title="3.5.2.UserController"></a>3.5.2.UserController</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span> <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserControlller</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IUserService userService; <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findById.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findById</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"id"</span>, required = <span class="hljs-keyword">true</span>)</span> Long id) <span class="hljs-keyword">throws</span></span><span class="hljs-function">    Exception </span>&#123;    UserInfo user = userService.findById(id);         ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();         mv.addObject(<span class="hljs-string">"user"</span>, user);         mv.setViewName(<span class="hljs-string">"user-show"</span>);    <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><h4 id="3-5-3-Dao"><a href="#3-5-3-Dao" class="headerlink" title="3.5.3.Dao"></a>3.5.3.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user where id=#&#123;id&#125;"</span>)<span class="hljs-meta">@Results</span>(&#123; <span class="hljs-meta">@Result</span>(id = <span class="hljs-keyword">true</span>, property = <span class="hljs-string">"id"</span>, column = <span class="hljs-string">"id"</span>), <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"username"</span>, property = <span class="hljs-string">"username"</span>),<span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"email"</span>, property = <span class="hljs-string">"email"</span>), <span class="hljs-meta">@Result</span>(column =<span class="hljs-string">"password"</span>, property = <span class="hljs-string">"password"</span>),<span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"phoneNum"</span>, property = <span class="hljs-string">"phoneNum"</span>), <span class="hljs-meta">@Result</span>(column =<span class="hljs-string">"status"</span>, property = <span class="hljs-string">"status"</span>),<span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"id"</span>, property = <span class="hljs-string">"roles"</span>, javaType = List<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">many</span> </span>=<span class="hljs-meta">@Many</span>(select = <span class="hljs-string">"com.itheima.ssm.dao.IRoleDao.findRoleByUserId"</span>)) &#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">findById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from role where id in( select roleId from user_role where userId=#&#123;userId&#125;)"</span>)<span class="hljs-meta">@Results</span>(&#123;<span class="hljs-meta">@Result</span>(id=<span class="hljs-keyword">true</span>,column=<span class="hljs-string">"id"</span>,property=<span class="hljs-string">"id"</span>), <span class="hljs-meta">@Result</span>(column=<span class="hljs-string">"roleName"</span>,property=<span class="hljs-string">"roleName"</span>), <span class="hljs-meta">@Result</span>(column=<span class="hljs-string">"roleDesc"</span>,property=<span class="hljs-string">"roleDesc"</span>),<span class="hljs-meta">@Result</span>(column=<span class="hljs-string">"id"</span>,property=<span class="hljs-string">"permissions"</span>,javaType=List<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">many</span></span>=<span class="hljs-meta">@Many</span>(select=<span class="hljs-string">"com.itheima.ssm</span><span class="hljs-string">.dao.IPermissionDao.findByRoleId"</span>))&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">findRoleByUserId</span><span class="hljs-params">(Long userId)</span></span>;</code></pre></div><p>我们需要将用户的所有角色及权限查询出来所以需要调用IRoleDao中的findRoleByUserId,而在IRoleDao中需要调用IPermissionDao的findByRoleId</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from permission where id in (select permissionId from role_permission where</span><span class="hljs-string">roleId=#&#123;roleId&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Permission&gt; <span class="hljs-title">findByRoleId</span><span class="hljs-params">(Long roleId)</span></span>;</code></pre></div><h2 id="3-角色管理"><a href="#3-角色管理" class="headerlink" title="3.角色管理"></a>3.角色管理</h2><h3 id="3-1-角色查询"><a href="#3-1-角色查询" class="headerlink" title="3.1 角色查询"></a>3.1 角色查询</h3><h4 id="3-1-1-角色页面role-list-jsp"><a href="#3-1-1-角色页面role-list-jsp" class="headerlink" title="3.1.1.角色页面role-list.jsp"></a>3.1.1.角色页面role-list.jsp</h4><p>请在资料中查看页面详细代码</p><h4 id="3-1-2-RoleControlller"><a href="#3-1-2-RoleControlller" class="headerlink" title="3.1.2.RoleControlller"></a>3.1.2.RoleControlller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/role"</span>)<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IRoleService roleService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;         List&lt;Role&gt; roleList = roleService.findAll();         ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();         mv.addObject(<span class="hljs-string">"roleList"</span>, roleList);         mv.setViewName(<span class="hljs-string">"role-list"</span>);    <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><h4 id="3-1-3-Dao"><a href="#3-1-3-Dao" class="headerlink" title="3.1.3.Dao"></a>3.1.3.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from role"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;</code></pre></div><h3 id="3-2-角色添加"><a href="#3-2-角色添加" class="headerlink" title="3.2 角色添加"></a>3.2 角色添加</h3><h4 id="3-2-1-角色添加页面role-add-jsp"><a href="#3-2-1-角色添加页面role-add-jsp" class="headerlink" title="3.2.1.角色添加页面role-add.jsp"></a>3.2.1.角色添加页面role-add.jsp</h4><p>请在页面中查看详细代码</p><h4 id="3-2-2-RoleControlller"><a href="#3-2-2-RoleControlller" class="headerlink" title="3.2.2.RoleControlller"></a>3.2.2.RoleControlller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/role"</span>)<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IRoleService roleService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/save.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(Role role)</span> </span>&#123;    roleService.save(role);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:findAll.do"</span>;    &#125;&#125;</code></pre></div><h4 id="3-2-3-Dao"><a href="#3-2-3-Dao" class="headerlink" title="3.2.3.Dao"></a>3.2.3.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into role(roleName,roleDesc) value(#&#123;roleName&#125;,#&#123;roleDesc&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Role role)</span></span>;</code></pre></div><h2 id="4-资源权限管理"><a href="#4-资源权限管理" class="headerlink" title="4.资源权限管理"></a>4.资源权限管理</h2><h3 id="4-1-资源权限查询"><a href="#4-1-资源权限查询" class="headerlink" title="4.1 资源权限查询"></a>4.1 资源权限查询</h3><h4 id="4-1-1-权限资源页面permission-list-jsp"><a href="#4-1-1-权限资源页面permission-list-jsp" class="headerlink" title="4.1.1.权限资源页面permission-list.jsp"></a>4.1.1.权限资源页面permission-list.jsp</h4><p>请在资料中查看详细代码</p><h4 id="4-1-2-PermissionController"><a href="#4-1-2-PermissionController" class="headerlink" title="4.1.2.PermissionController"></a>4.1.2.PermissionController</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/permission"</span>)<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PermissionController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IPermissionService permissionService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    List&lt;Permission&gt; permissionList = permissionService.findAll();         ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();         mv.addObject(<span class="hljs-string">"permissionList"</span>, permissionList);         mv.setViewName(<span class="hljs-string">"permission-list"</span>);    <span class="hljs-keyword">return</span> mv;    &#125; &#125;</code></pre></div><h4 id="4-1-3-Dao"><a href="#4-1-3-Dao" class="headerlink" title="4.1.3.Dao"></a>4.1.3.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from permission"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Permission&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;</code></pre></div><h3 id="4-2-资源权限添加"><a href="#4-2-资源权限添加" class="headerlink" title="4.2 资源权限添加"></a>4.2 资源权限添加</h3><h4 id="4-2-1-权限资源添加页面permission-add-jsp"><a href="#4-2-1-权限资源添加页面permission-add-jsp" class="headerlink" title="4.2.1.权限资源添加页面permission-add.jsp"></a>4.2.1.权限资源添加页面permission-add.jsp</h4><p>请在资料中查看页面详细代码</p><h4 id="4-2-2-PermissionController"><a href="#4-2-2-PermissionController" class="headerlink" title="4.2.2.PermissionController"></a>4.2.2.PermissionController</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/permission"</span>)<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PermissionController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IPermissionService permissionService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/save.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(Permission p)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    permissionService.save(p);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:findAll.do"</span>;    &#125;&#125;</code></pre></div><h4 id="4-2-3-Dao"><a href="#4-2-3-Dao" class="headerlink" title="4.2.3.Dao"></a>4.2.3.Dao</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into permission(permissionName,url) value(#&#123;permissionName&#125;,#&#123;url&#125;)"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Permission p)</span></span>;</code></pre></div><h2 id="5-权限关联与控制"><a href="#5-权限关联与控制" class="headerlink" title="5.权限关联与控制"></a>5.权限关联与控制</h2><h3 id="5-1-用户角色关联"><a href="#5-1-用户角色关联" class="headerlink" title="5.1 用户角色关联"></a>5.1 用户角色关联</h3><p>用户与角色之间是多对多关系，我们要建立它们之间的关系，只需要在中间表user_role插入数据即可。</p><h4 id="5-1-1-用户角色关联相关页面"><a href="#5-1-1-用户角色关联相关页面" class="headerlink" title="5.1.1. 用户角色关联相关页面"></a>5.1.1. 用户角色关联相关页面</h4><p>在user-list.jsp页面上添加链接</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"$&#123;pageContext.request.contextPath&#125;/user/findUserByIdAndAllRole.do?id=$&#123;user.id&#125;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn bg-olive btn-xs"</span>&gt;</span>添加角色<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>展示可以添加角色的页面user-roe-add.jsp</p><p>请在资料中查看页面详细代码</p><h4 id="5-1-2-UserController"><a href="#5-1-2-UserController" class="headerlink" title="5.1.2.UserController"></a>5.1.2.UserController</h4><p>findUserByIdAndAllRole(Long id)方法</p><p>此方法用于查找要操作的用户及可以添加的角色，参数是要操作的用户id</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findUserByIdAndAllRole.do"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findUserByIdAndAllRole</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;UserInfo user = userService.findById(id);List&lt;Role&gt; roleList = roleService.findOtherRole(id);     ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();     mv.addObject(<span class="hljs-string">"user"</span>, user);mv.addObject(<span class="hljs-string">"roleList"</span>, roleList);     mv.setViewName(<span class="hljs-string">"user-role-add"</span>);     <span class="hljs-keyword">return</span> mv;&#125;</code></pre></div><p>调用IUserService的findById方法获取要操作的User</p><p>调用IRoleService的findOtherRole方法用于获取可以添加的角色信息</p><p>addRoleToUser(Long userId,Long[] ids)方法</p><p>些方法用于在用户与角色之间建立关系，参数userId代表要操作的用户id,参数ids代表的是角色id数组</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/addRoleToUser.do"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addRoleToUser</span><span class="hljs-params">(Long userId, Long[] ids)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    userService.addRoleToUser(userId,ids);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:findAll.do"</span>;&#125;</code></pre></div><h4 id="5-1-3-Dao"><a href="#5-1-3-Dao" class="headerlink" title="5.1.3.Dao"></a>5.1.3.Dao</h4><p>IRoleDao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from role where id not in( select roleId from user_role where userId=# &#123;id&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">findOtherRole</span><span class="hljs-params">(Long id)</span></span>;</code></pre></div><p>用于查找可以添加的角色</p><p>IUserDao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into user_role(userId,roleId) value(#&#123;userId&#125;,#&#123;roleId&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRoleToUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"userId"</span>)</span> Long userId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"roleId"</span>)</span> Long roleId)</span>;</code></pre></div><p>用于添加用户与角色关系</p><h3 id="5-2-角色权限关联"><a href="#5-2-角色权限关联" class="headerlink" title="5.2 角色权限关联"></a>5.2 角色权限关联</h3><p>角色权限之间是多对多关系，我们要建立它们之间的关系，只需要在中间表role_permission插入数据即可。</p><h4 id="5-2-1-角色权限关联相关页面"><a href="#5-2-1-角色权限关联相关页面" class="headerlink" title="5.2.1. 角色权限关联相关页面"></a>5.2.1. 角色权限关联相关页面</h4><p>在role-list.jsp页面上添加链接</p><div class="hljs"><pre><code class="hljs html">a href="$&#123;pageContext.request.contextPath&#125;/role/findRoleByIdAndAllPermission.do?id=$&#123;role.id&#125;" class="btn bg-olive btn-xs"&gt;添加权限<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>展示可以添加权限的页面roe-permission-add.jsp</p><p>请在资料中查看页面详细代码</p><h4 id="5-2-2-RoleController"><a href="#5-2-2-RoleController" class="headerlink" title="5.2.2.RoleController"></a>5.2.2.RoleController</h4><p>findRoleByIdAndAllPermission(Long roleId)方法</p><p>此方法用于查找要操作的角色及可以添加的权限，参数是要操作的角色id</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findRoleByIdAndAllPermission.do"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findRoleByIdAndAllPermission</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"id"</span>, required = <span class="hljs-keyword">true</span>)</span> Long roleid) <span class="hljs-keyword">throws</span> Exception </span>&#123;ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();Role role = roleService.findById(roleid);     mv.addObject(<span class="hljs-string">"role"</span>, role);     List&lt;Permission&gt; permissionList =permissionService.findOtherPermission(roleid); mv.addObject(<span class="hljs-string">"permissionList"</span>, permissionList);     mv.setViewName(<span class="hljs-string">"role-permission-add"</span>);<span class="hljs-keyword">return</span> mv;&#125;</code></pre></div><p>调用IRoleService的findById方法获取要操作的Role</p><p>调用IPermissionService的findOtherPermission方法用于获取可以添加的权限信息</p><p>addPermissionToRole(Long roleId,Long[] ids)方法</p><p>些方法用于在角色与权限之间建立关系，参数roleId代表要操作的角色id,参数permissionIds代表的是权限id数组</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/addPermissionToRole.do"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addPermissionToRole</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"roleId"</span>)</span> Long roleId, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"ids"</span>)</span> Long[] permissionIds) <span class="hljs-keyword">throws</span> Exception </span>&#123;     roleService.addPermissionToRole(roleId, permissionIds);<span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:findAll.do"</span>;&#125;</code></pre></div><h4 id="5-2-3-Dao"><a href="#5-2-3-Dao" class="headerlink" title="5.2.3.Dao"></a>5.2.3.Dao</h4><p>IPermissionDao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from permission where id not in (select permissionId from role_permission where roleId=#&#123;roleId&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Permission&gt; <span class="hljs-title">findOtherPermission</span><span class="hljs-params">(Long roleid)</span></span>;</code></pre></div><p>用于查找可以添加的权限</p><p>IRoleDao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into role_permission (roleId,permissionId) value (#&#123;roleId&#125;,# &#123;permissionId&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPermissionToRole</span><span class="hljs-params">(@Param(<span class="hljs-string">"roleId"</span>)</span> Long roleId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"permissionId"</span>)</span> Long permissionId)</span>;</code></pre></div><p>用于绑定角色与权限的关系</p><h3 id="5-3-服务器端方法级权限控制"><a href="#5-3-服务器端方法级权限控制" class="headerlink" title="5.3 服务器端方法级权限控制"></a>5.3 服务器端方法级权限控制</h3><p>在服务器端我们可以通过Spring security提供的注解对方法来进行权限控制。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用</p><h4 id="5-3-1-开启注解使用"><a href="#5-3-1-开启注解使用" class="headerlink" title="5.3.1.开启注解使用"></a>5.3.1.开启注解使用</h4><p>配置文件</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">security:global-method-security</span> <span class="hljs-attr">jsr250-annotations</span>=<span class="hljs-string">"enabled"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">security:global-method-security</span> <span class="hljs-attr">secured-annotations</span>=<span class="hljs-string">"enabled"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">security:global-method-security</span> <span class="hljs-attr">pre-post-annotations</span>=<span class="hljs-string">"disabled"</span>/&gt;</span></code></pre></div><p>注解开启</p><p>@EnableGlobalMethodSecurity ：Spring Security默认是禁用注解的，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为Bean。</p><h4 id="5-3-2-JSR-250注解"><a href="#5-3-2-JSR-250注解" class="headerlink" title="5.3.2.JSR-250注解"></a>5.3.2.JSR-250注解</h4><p>@RolesAllowed表示访问对应方法时所应该具有的角色</p><div class="hljs"><pre><code class="hljs xml">示例：@RolesAllowed(&#123;"USER", "ADMIN"&#125;) 该方法只要具有"USER", "ADMIN"任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN</code></pre></div><p>@PermitAll表示允许所有的角色进行访问，也就是说不进行权限控制@DenyAll是和PermitAll相反的，表示无论什么角色都不能访问</p><h4 id="5-3-3-支持表达式的注解"><a href="#5-3-3-支持表达式的注解" class="headerlink" title="5.3.3.支持表达式的注解"></a>5.3.3.支持表达式的注解</h4><p>@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问</p> <div class="hljs"><pre><code class="hljs java">示例：<span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changePassword</span><span class="hljs-params">(@P(<span class="hljs-string">"userId"</span>)</span> <span class="hljs-keyword">long</span> userId )</span>&#123; &#125;这里表示在changePassword方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该方法。</code></pre></div><p>@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常</p><div class="hljs"><pre><code class="hljs java">示例：<span class="hljs-meta">@PostAuthorize</span><span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-string">"returnObject.userId == authentication.principal.userId or hasPermission(returnObject, 'ADMIN')"</span>)</span></span>;</code></pre></div><p>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果</p><p>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值</p><h4 id="5-3-4-Secured注解"><a href="#5-3-4-Secured注解" class="headerlink" title="5.3.4.@Secured注解"></a>5.3.4.@Secured注解</h4><p>@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。</p> <div class="hljs"><pre><code class="hljs java">示例：<span class="hljs-meta">@Secured</span>(<span class="hljs-string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">readAccount</span><span class="hljs-params">(Long id)</span></span>; <span class="hljs-meta">@Secured</span>(<span class="hljs-string">"ROLE_TELLER"</span>)</code></pre></div><h3 id="5-4-页面端标签控制权限"><a href="#5-4-页面端标签控制权限" class="headerlink" title="5.4 页面端标签控制权限"></a>5.4 页面端标签控制权限</h3><p>在jsp页面中我们可以使用spring security提供的权限标签来进行权限控制</p><h4 id="5-4-1-导入"><a href="#5-4-1-导入" class="headerlink" title="5.4.1.导入"></a>5.4.1.导入</h4><p>maven导入</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>version<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>页面导入</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@taglib</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">"http://www.springframework.org/security/tags"</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"security"</span>%&gt;</span></code></pre></div><h4 id="5-4-2-常用标签"><a href="#5-4-2-常用标签" class="headerlink" title="5.4.2.常用标签"></a>5.4.2.常用标签</h4><p>在jsp中我们可以使用以下三种标签，其中authentication代表的是当前认证对象，可以获取当前认证对象信息，例如用户名。其它两个标签我们可以用于权限控制</p><h5 id="5-4-2-1-authentication"><a href="#5-4-2-1-authentication" class="headerlink" title="5.4.2.1 authentication"></a>5.4.2.1 authentication</h5><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">security:authentication</span> <span class="hljs-attr">property</span>=<span class="hljs-string">""</span> <span class="hljs-attr">htmlEscape</span>=<span class="hljs-string">""</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">""</span> <span class="hljs-attr">var</span>=<span class="hljs-string">""</span>/&gt;</span></code></pre></div><p>property：只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，不允许直接通过方法进行调用</p><p>htmlEscape：表示是否需要将html进行转义。默认为true。</p><p>scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定</p><p>var：用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中</p><h5 id="5-4-2-2-authorize"><a href="#5-4-2-2-authorize" class="headerlink" title="5.4.2.2 authorize"></a>5.4.2.2 authorize</h5><p>authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示</p><div class="hljs"><pre><code class="hljs java">&lt;security:authorize access="" method="" url="" var=""&gt;&lt;/security:authorize&gt;</code></pre></div><p>access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限</p><p>method：method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法</p><p>url：url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中</p><h5 id="5-4-2-3-accesscontrollist"><a href="#5-4-2-3-accesscontrollist" class="headerlink" title="5.4.2.3 accesscontrollist"></a>5.4.2.3 accesscontrollist</h5><p>accesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，其中前两个是必须指定的</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">security:accesscontrollist</span> <span class="hljs-attr">hasPermission</span>=<span class="hljs-string">""</span> <span class="hljs-attr">domainObject</span>=<span class="hljs-string">""</span> <span class="hljs-attr">var</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">security:accesscontrollist</span>&gt;</span></code></pre></div><p>hasPermission：hasPermission属性用于指定以逗号分隔的权限列表</p><p>domainObject：domainObject用于指定对应的域对象</p><p>var：var则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用</p><h1 id="SSMAOP日志"><a href="#SSMAOP日志" class="headerlink" title="SSMAOP日志"></a>SSMAOP日志</h1><h2 id="1-数据库与表结构-1"><a href="#1-数据库与表结构-1" class="headerlink" title="1.数据库与表结构"></a>1.数据库与表结构</h2><h3 id="1-1-日志表信息描述sysLog"><a href="#1-1-日志表信息描述sysLog" class="headerlink" title="1.1.日志表信息描述sysLog"></a>1.1.日志表信息描述sysLog</h3><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>VARCHAR2</td><td>主键 无意义uuid</td></tr><tr><td>2</td><td>visitTime</td><td>timestamp</td><td>访问时间</td></tr><tr><td>3</td><td>username</td><td>VARCHAR2</td><td>操作者用户名</td></tr><tr><td>4</td><td>ip</td><td>VARCHAR2</td><td>访问ip</td></tr><tr><td>5</td><td>url</td><td>VARCHAR2</td><td>访问资源url</td></tr><tr><td>6</td><td>executionTime</td><td>int</td><td>执行时长</td></tr><tr><td>7</td><td>method</td><td>VARCHAR</td><td>访问方法</td></tr></tbody></table><h3 id="1-2-sql语句"><a href="#1-2-sql语句" class="headerlink" title="1.2.sql语句"></a>1.2.sql语句</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sysLog(<span class="hljs-keyword">id</span> <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> SYS_GUID() PRIMARY <span class="hljs-keyword">KEY</span>,     visitTime <span class="hljs-built_in">timestamp</span>,username <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>), ip <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">30</span>),<span class="hljs-keyword">url</span> <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">50</span>), executionTime <span class="hljs-built_in">int</span>,     method <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">200</span>))</code></pre></div><h3 id="1-3-实体类"><a href="#1-3-实体类" class="headerlink" title="1.3.实体类"></a>1.3.实体类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysLog</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;     <span class="hljs-keyword">private</span> Date visitTime;    <span class="hljs-keyword">private</span> String visitTimeStr;     <span class="hljs-keyword">private</span> String username;     <span class="hljs-keyword">private</span> String ip;    <span class="hljs-keyword">private</span> String url;    <span class="hljs-keyword">private</span> Long executionTime;    <span class="hljs-keyword">private</span> String method;｝</code></pre></div><h2 id="2-基于AOP日志处理"><a href="#2-基于AOP日志处理" class="headerlink" title="2.基于AOP日志处理"></a>2.基于AOP日志处理</h2><h3 id="2-1-页面syslog-list-jsp"><a href="#2-1-页面syslog-list-jsp" class="headerlink" title="2.1.页面syslog-list.jsp"></a>2.1.页面syslog-list.jsp</h3><p>详细内容请查看资源中页面信息</p><h3 id="2-2-创建切面类处理日志"><a href="#2-2-创建切面类处理日志" class="headerlink" title="2.2.创建切面类处理日志"></a>2.2.创建切面类处理日志</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-05  9:19</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@Aspect</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAop</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HttpServletRequest request;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ISysLogService sysLogService;    <span class="hljs-keyword">private</span> Date visitTime;<span class="hljs-comment">//开始的时间</span>    <span class="hljs-keyword">private</span> Class clazz;<span class="hljs-comment">//访问的类</span>    <span class="hljs-keyword">private</span> Method method;<span class="hljs-comment">//访问的方法</span>    <span class="hljs-comment">//前置通知  主要是获取开始时间，执行的类是哪一个，执行的是哪个方法</span>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(* com.jk.ssm.controller.*.*(..))"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">(JoinPoint jp)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;        visitTime = <span class="hljs-keyword">new</span> Date();<span class="hljs-comment">//当前时间就是开始访问的时间</span>        clazz = jp.getTarget().getClass();<span class="hljs-comment">//具体要访问的类</span>        String methodName = jp.getSignature().getName();<span class="hljs-comment">//获取访问方法的名称</span>        Object[] args = jp.getArgs();<span class="hljs-comment">//获取访问的方法的参数</span>        <span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span> || args.length == <span class="hljs-number">0</span>)&#123;            method = clazz.getMethod(methodName); <span class="hljs-comment">//只能获取无参数的方法</span>        &#125;<span class="hljs-keyword">else</span> &#123;            Class[] classArgs = <span class="hljs-keyword">new</span> Class[args.length];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;                classArgs[i] = args[i].getClass();            &#125;            clazz.getMethod(methodName,classArgs);        &#125;    &#125;    <span class="hljs-comment">//后置通知</span>    <span class="hljs-meta">@After</span>(<span class="hljs-string">"execution(* com.jk.ssm.controller.*.*(..))"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfter</span><span class="hljs-params">(JoinPoint jp)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Long time = <span class="hljs-keyword">new</span> Date().getTime() - visitTime.getTime();        String url = <span class="hljs-string">""</span>;        <span class="hljs-keyword">if</span> (clazz.getName() == <span class="hljs-string">"com.jk.ssm.controller.SysLogController"</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//获取url</span>        <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span> &amp;&amp; method != <span class="hljs-keyword">null</span> &amp;&amp; clazz != LogAop<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;            <span class="hljs-comment">//获取类上的注解</span>            RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-keyword">if</span> (classAnnotation != <span class="hljs-keyword">null</span>)&#123;                String[] classValue = classAnnotation.value();                <span class="hljs-comment">//2.获取方法上的注解</span>                RequestMapping methodAnnotation = method.getAnnotation(RequestMapping<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                <span class="hljs-keyword">if</span> (methodAnnotation != <span class="hljs-keyword">null</span>)&#123;                    String[] methodValue = methodAnnotation.value();                    url = classValue[<span class="hljs-number">0</span>] + methodValue[<span class="hljs-number">0</span>];                    <span class="hljs-comment">//获取访问的ip</span>                    String ip = request.getRemoteAddr();                    <span class="hljs-comment">//获取当前操作的用户</span>                    SecurityContext context = SecurityContextHolder.getContext();<span class="hljs-comment">//从上下文中获取当前的用户</span>                    User user = (User) context.getAuthentication().getPrincipal();                    String username = user.getUsername();                    SysLog sysLog = <span class="hljs-keyword">new</span> SysLog();                    sysLog.setExecutionTime(time);                    sysLog.setIp(ip);                    sysLog.setMethod(<span class="hljs-string">"[类名]"</span> + clazz.getName() + <span class="hljs-string">"[方法名]"</span> + method.getName());                    sysLog.setUrl(url);                    sysLog.setUsername(username);                    sysLog.setVisitTime(visitTime);                    <span class="hljs-comment">//调用</span>                    sysLogService.save(sysLog);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>在切面类中我们需要获取登录用户的username，还需要获取ip地址，我们怎么处理？</p><p>username获取SecurityContextHolder获取ip地址获取</p><p>ip地址的获取我们可以通过request.getRemoteAddr()方法获取到。</p><p>在Spring中可以通过RequestContextListener来获取request或session对象。</p><h3 id="2-3-SysLogController"><a href="#2-3-SysLogController" class="headerlink" title="2.3.SysLogController"></a>2.3.SysLogController</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sysLog"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysLogController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ISysLogService sysLogService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();        List&lt;SysLog&gt; sysLogList =  sysLogService.findAll();        mv.addObject(<span class="hljs-string">"sysLogs"</span>,sysLogList);        mv.setViewName(<span class="hljs-string">"syslog-list"</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><h3 id="2-4-Service"><a href="#2-4-Service" class="headerlink" title="2.4.Service"></a>2.4.Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-05  10:13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysLogServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ISysLogService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ISysLogDao sysLogDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(SysLog sysLog)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        sysLogDao.save(sysLog);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SysLog&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> sysLogDao.findAll();    &#125;&#125;</code></pre></div><h3 id="2-5-Dao"><a href="#2-5-Dao" class="headerlink" title="2.5.Dao"></a>2.5.Dao</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-05  10:14</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ISysLogDao</span> </span>&#123;    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into sysLog(visitTime,username,ip,url,executionTime,method) values(#&#123;visitTime&#125;,#&#123;username&#125;,#&#123;ip&#125;,#&#123;url&#125;,#&#123;executionTime&#125;,#&#123;method&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(SysLog sysLog)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from sysLog"</span>)    <span class="hljs-function">List&lt;SysLog&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>权限管理、旅游系统前篇</title>
    <link href="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/"/>
    <url>/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="权限管理、旅游系统前篇"><a href="#权限管理、旅游系统前篇" class="headerlink" title="权限管理、旅游系统前篇"></a>权限管理、旅游系统前篇</h1><h2 id="1-功能介绍"><a href="#1-功能介绍" class="headerlink" title="1.功能介绍"></a>1.功能介绍</h2><h3 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h3><p>主要讲解maven工程搭建，以及基于Oracle数据库的商品表信息，并完成SSM整合。</p><h3 id="1-2-商品查询"><a href="#1-2-商品查询" class="headerlink" title="1.2 商品查询"></a>1.2 商品查询</h3><p>基于SSM整合基础上完成商品查询，要掌握主面页面main.jsp及商品显示页面product-list.jsp页面的创建。</p><h3 id="1-3-商品添加"><a href="#1-3-商品添加" class="headerlink" title="1.3 商品添加"></a>1.3 商品添加</h3><p>进一步巩固SSM整合，并完成商品添加功能，要注意事务操作以及product-add.jsp页面生成。</p><h3 id="1-4-订单查询"><a href="#1-4-订单查询" class="headerlink" title="1.4 订单查询"></a>1.4 订单查询</h3><p>订单的查询操作，它主要完成简单的多表查询操作，查询订单时，需要查询出与订单关联的其它表中信息，所以大</p><p>家一定要了解订单及其它表关联关系</p><h3 id="1-5-订单分页查询"><a href="#1-5-订单分页查询" class="headerlink" title="1.5 订单分页查询"></a>1.5 订单分页查询</h3><p>订单分页查询，我们使用的是mybatis分页插件PageHelper，要掌握PageHelper的基本使用。</p><h3 id="1-6-订单详情查询"><a href="#1-6-订单详情查询" class="headerlink" title="1.6 订单详情查询"></a>1.6 订单详情查询</h3><p>订单详情是用于查询某一个订单的信息，这个知识点主要考核学生对复杂的多表查询操作的掌握。</p><h3 id="1-7-Spring-Security-概述"><a href="#1-7-Spring-Security-概述" class="headerlink" title="1.7 Spring Security 概述"></a>1.7 Spring Security 概述</h3><p>Spring Security是 Spring 项目组中用来提供安全认证服务的框架，它的使用很复杂，我们在课程中只介绍了spring Security的基本操作，大家要掌握spring Security框架的配置及基本的认证与授权操作。</p><h3 id="1-8-用户管理"><a href="#1-8-用户管理" class="headerlink" title="1.8 用户管理"></a>1.8 用户管理</h3><p>用户管理中我们会介绍基于spring Security的用户登录、退出操作。以及用户查询、添加、详情有等操作，这些功能的练习是对前期SSM知识点的进一步巩固。</p><h3 id="1-9-角色管理"><a href="#1-9-角色管理" class="headerlink" title="1.9 角色管理"></a>1.9 角色管理</h3><p>角色管理主要完成角色查询、角色添加</p><h3 id="1-10-资源权限管理"><a href="#1-10-资源权限管理" class="headerlink" title="1.10 资源权限管理"></a>1.10 资源权限管理</h3><p>资源权限管理主要完成查询、添加操作，它的操作与角色管理类似，角色管理以及资源权限管理都是对权限管理的</p><p>补充。</p><h3 id="1-11-权限关联与控制"><a href="#1-11-权限关联与控制" class="headerlink" title="1.11 权限关联与控制"></a>1.11 权限关联与控制</h3><p>主要会讲解用户角色关联、角色权限关联，这两个操作是为了后续我们完成授权操作的基础，关于授权操作我们会</p><p>在服务器端及页面端分别讲解</p><h3 id="1-12-AOP日志处理"><a href="#1-12-AOP日志处理" class="headerlink" title="1.12 AOP日志处理"></a>1.12 AOP日志处理</h3><p>AOP日志处理，我们使用spring AOP切面来完成系统级别的日志收集。</p><h2 id="2-数据库介绍"><a href="#2-数据库介绍" class="headerlink" title="2.数据库介绍"></a>2.数据库介绍</h2><h3 id="2-1-产品表"><a href="#2-1-产品表" class="headerlink" title="2.1 产品表"></a>2.1 产品表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069513936.png" srcset="/img/loading.gif" alt="60006951393"></p><h3 id="2-2-订单表"><a href="#2-2-订单表" class="headerlink" title="2.2 订单表"></a>2.2 订单表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069538529.png" srcset="/img/loading.gif" alt="60006953852"></p><h3 id="2-3-会员表"><a href="#2-3-会员表" class="headerlink" title="2.3 会员表"></a>2.3 会员表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069552171.png" srcset="/img/loading.gif" alt="60006955217"></p><h3 id="2-4-旅客表"><a href="#2-4-旅客表" class="headerlink" title="2.4 旅客表"></a>2.4 旅客表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069565927.png" srcset="/img/loading.gif" alt="60006956592"></p><h3 id="2-5-用户表"><a href="#2-5-用户表" class="headerlink" title="2.5 用户表"></a>2.5 用户表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069589791.png" srcset="/img/loading.gif" alt="60006958979"></p><h3 id="2-6角色表"><a href="#2-6角色表" class="headerlink" title="2.6角色表"></a>2.6角色表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069652556.png" srcset="/img/loading.gif" alt="60006965255"></p><h3 id="2-7资源权限表"><a href="#2-7资源权限表" class="headerlink" title="2.7资源权限表"></a>2.7资源权限表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069673722.png" srcset="/img/loading.gif" alt="60006967372"></p><h3 id="2-8-日志表"><a href="#2-8-日志表" class="headerlink" title="2.8 日志表"></a>2.8 日志表</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069689663.png" srcset="/img/loading.gif" alt="60006968966"></p><h1 id="SSM-环境搭建与产品操作"><a href="#SSM-环境搭建与产品操作" class="headerlink" title="SSM 环境搭建与产品操作"></a>SSM 环境搭建与产品操作</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><h3 id="1-1-数据库与表结构"><a href="#1-1-数据库与表结构" class="headerlink" title="1.1 数据库与表结构"></a>1.1 数据库与表结构</h3><h4 id="1-1-1-创建用户与授权"><a href="#1-1-1-创建用户与授权" class="headerlink" title="1.1.1 创建用户与授权"></a>1.1.1 创建用户与授权</h4><p>数据库我们使用Oracle</p><p>Oracle 为每个项目创建单独user，oracle数据表存放在表空间下，每个用户有独立表空间创建用户及密码：</p><div class="hljs"><pre><code class="hljs mysql">语法[创建用户]： create user 用户名 identified by 口令[即密码]；例子： create user test identified by test;授权语法： grant connect, resource to 用户名;例子： grant connect, resource to test;</code></pre></div><p>PL/SQL Developer是一个集成开发环境，专门面向Oracle数据库存储程序单元的开发PL/SQL Developer侧重于易用性、代码品质和生产力，充分发挥Oracle应用程序开发过程中的主要优势。</p><p>连接oracle数据库</p><p>a) 创建用户</p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069939260.png" srcset="/img/loading.gif" alt="60006993926"></p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069946562.png" srcset="/img/loading.gif" alt="60006994656"></p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069952960.png" srcset="/img/loading.gif" alt="60006995296"></p><p>b) 授权</p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600069961953.png" srcset="/img/loading.gif" alt="60006996195"></p><p>对象权限是指针对于某一张表的操作权限,系统权限是指对表的CRUD操作权限, 角色权限是系统权限的集合,我们设置 时，一般是设置角色权限，设置resource与connect</p><h4 id="1-1-2-创建表"><a href="#1-1-2-创建表" class="headerlink" title="1.1.2 创建表"></a>1.1.2 创建表</h4><p>产品表信息描述</p><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2(32)</td><td>无意义，主键uuid</td></tr><tr><td>2</td><td>productNum</td><td>varchar2(50)</td><td>产品编号，唯一，不为空</td></tr><tr><td>3</td><td>productName</td><td>varchar2(50)</td><td>产品名称（路线名称）</td></tr><tr><td>4</td><td>cityName</td><td>varchar2(50)</td><td>出发城市</td></tr><tr><td>5</td><td>DepartureTime</td><td>timestamp</td><td>出发时间</td></tr><tr><td>6</td><td>productPrice</td><td>number</td><td>产品价格</td></tr><tr><td>7</td><td>productDesc</td><td>varchar2(500)</td><td>产品描述</td></tr><tr><td>8</td><td>productStatus</td><td>int</td><td>状态(0 关闭 1 开启)</td></tr></tbody></table><p>创建表sql</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE product(id varchar2(32) default SYS_GUID() PRIMARY KEY,productNum VARCHAR2(50) NOT NULL, productName VARCHAR2(50),cityName VARCHAR2(50), DepartureTime timestamp, productPrice Number, productDesc VARCHAR2(500), productStatus INT,CONSTRAINT product UNIQUE (id, productNum))insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values (&#39;676C5BD1D35E429A8C2E114939C5685A&#39;, &#39;itcast-002&#39;, &#39;北京三日游&#39;, &#39;北京&#39;, to_timestamp(&#39;10- 10-2018 10:10:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 1200, &#39;不错的旅行&#39;, 1);insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values (&#39;12B7ABF2A4C544568B0A7C69F36BF8B7&#39;, &#39;itcast-003&#39;, &#39;上海五日游&#39;, &#39;上海&#39;, to_timestamp(&#39;25- 04-2018 14:30:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 1800, &#39;魔都我来了&#39;, 0);insert into PRODUCT (id, productnum, productname, cityname, departuretime, productprice,productdesc, productstatus)values (&#39;9F71F01CB448476DAFB309AA6DF9497F&#39;, &#39;itcast-001&#39;, &#39;北京三日游&#39;, &#39;北京&#39;, to_timestamp(&#39;10- 10-2018 10:10:00.000000&#39;, &#39;dd-mm-yyyy hh24:mi:ss.ff&#39;), 1200, &#39;不错的旅行&#39;, 1);</code></pre></div><h3 id="1-2-maven工程搭建"><a href="#1-2-maven工程搭建" class="headerlink" title="1.2 maven工程搭建"></a>1.2 maven工程搭建</h3><h4 id="1-2-1-创建maven工程"><a href="#1-2-1-创建maven工程" class="headerlink" title="1.2.1 创建maven工程"></a>1.2.1 创建maven工程</h4><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600070077414.png" srcset="/img/loading.gif" alt="60007007741"></p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600070085015.png" srcset="/img/loading.gif" alt="60007008501"></p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600070090034.png" srcset="/img/loading.gif" alt="60007009003"></p><p>创建子模块</p><p>itcast-ssm-web itcast-ssm-domain itcast-ssm-service itcast-ssm-dao itcast-ssm-utils 其中创建itcast-ssm-web时注意我们选择一个web工程</p><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600070114479.png" srcset="/img/loading.gif" alt="60007011447"></p><h4 id="1-2-2-pom-xml"><a href="#1-2-2-pom-xml" class="headerlink" title="1.2.2 pom.xml"></a>1.2.2 pom.xml</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.jk.jk_ssm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jk_ssm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 统一管理jar包版本 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">shiro.version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">shiro.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.security.version</span>&gt;</span>5.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.security.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 锁定jar包版本 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 项目依赖jar包 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- spring --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- log start --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- log end --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.security.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsr250-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 添加tomcat7插件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>jk_ssm_dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>jk_ssm_service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>jk_ssm_domain<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>jk_ssm_utils<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>jk_ssm_web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="1-3编写实体类"><a href="#1-3编写实体类" class="headerlink" title="1.3编写实体类"></a>1.3编写实体类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-01  10:52</span><span class="hljs-comment"> * 产品</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id; <span class="hljs-comment">// 主键</span>    <span class="hljs-keyword">private</span> String productNum; <span class="hljs-comment">// 编号 唯一</span>    <span class="hljs-keyword">private</span> String productName; <span class="hljs-comment">// 名称</span>    <span class="hljs-keyword">private</span> String cityName; <span class="hljs-comment">// 出发城市</span>    <span class="hljs-meta">@DateTimeFormat</span>(pattern = <span class="hljs-string">"yyyy-MM-dd HH:mm"</span>)    <span class="hljs-keyword">private</span> Date departureTime; <span class="hljs-comment">// 出发时间</span>    <span class="hljs-keyword">private</span> String departureTimeStr;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> productPrice; <span class="hljs-comment">// 产品价格</span>    <span class="hljs-keyword">private</span> String productDesc; <span class="hljs-comment">// 产品描述</span>    <span class="hljs-keyword">private</span> Integer productStatus; <span class="hljs-comment">// 状态 0 关闭 1 开启</span>    <span class="hljs-keyword">private</span> String productStatusStr;&#125;</code></pre></div><h3 id="1-4-编写业务接口"><a href="#1-4-编写业务接口" class="headerlink" title="1.4 编写业务接口"></a>1.4 编写业务接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IProductService</span> </span>&#123;<span class="hljs-function">List&lt;Product&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><h3 id="1-5-编写持久层接口"><a href="#1-5-编写持久层接口" class="headerlink" title="1.5 编写持久层接口"></a>1.5 编写持久层接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IProductDao</span> </span>&#123;<span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from product"</span>)     <span class="hljs-function">List&lt;Product&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><h2 id="2-SSM整合与产品查询"><a href="#2-SSM整合与产品查询" class="headerlink" title="2.SSM整合与产品查询"></a>2.SSM整合与产品查询</h2><h3 id="2-1-Spring环境搭建"><a href="#2-1-Spring环境搭建" class="headerlink" title="2.1 Spring环境搭建"></a>2.1 Spring环境搭建</h3><h4 id="2-1-1-编写Spring配置文件applicationContext-xml"><a href="#2-1-1-编写Spring配置文件applicationContext-xml" class="headerlink" title="2.1.1.编写Spring配置文件applicationContext.xml"></a>2.1.1.编写Spring配置文件applicationContext.xml</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span> <span class="hljs-comment">&lt;!-- 开启注解扫描，管理service和dao --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima.ssm.service"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima.ssm.dao"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><h4 id="2-1-2-使用注解配置业务层"><a href="#2-1-2-使用注解配置业务层" class="headerlink" title="2.1.2.使用注解配置业务层"></a>2.1.2.使用注解配置业务层</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IProductService</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Product&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><h3 id="2-2-Spring-MVC-环境搭建"><a href="#2-2-Spring-MVC-环境搭建" class="headerlink" title="2.2 Spring MVC 环境搭建"></a>2.2 Spring MVC 环境搭建</h3><h4 id="2-2-1-web-xml配置Spring-MVC核心控制器"><a href="#2-2-1-web-xml配置Spring-MVC核心控制器" class="headerlink" title="2.2.1.web.xml配置Spring MVC核心控制器"></a>2.2.1.web.xml配置Spring MVC核心控制器</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 前端控制器（加载classpath:spring-mvc.xml 服务器启动创建servlet） --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 解决中文乱码过滤器 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><h4 id="2-2-2-Spring-MVC配置文件springmvc-xml"><a href="#2-2-2-Spring-MVC配置文件springmvc-xml" class="headerlink" title="2.2.2.Spring MVC配置文件springmvc.xml"></a>2.2.2.Spring MVC配置文件springmvc.xml</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 扫描controller的注解，别的不扫描 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.jk.ssm.controller"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- JSP文件所在的目录 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/pages/"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 文件的后缀名 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 设置静态资源不过滤 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/css/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/css/**"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/img/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/img/**"</span> /&gt;</span><span class="hljs-comment">&lt;!--    &lt;mvc:resources location="/js/" mapping="/js/**" /&gt;--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/plugins/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/plugins/**"</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 开启对SpringMVC注解的支持 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        支持AOP的注解支持，AOP底层使用代理技术</span><span class="hljs-comment">        JDK动态代理，要求必须有接口</span><span class="hljs-comment">        cglib代理，生成子类对象，proxy-target-class="true" 默认使用cglib的方式</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">"true"</span>/&gt;</span></code></pre></div><h4 id="2-2-3-编写Controller"><a href="#2-2-3-编写Controller" class="headerlink" title="2.2.3.编写Controller"></a>2.2.3.编写Controller</h4><p>ProductController</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span> <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/product"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IProductService productService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)     <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><h3 id="2-3-Spring与Spring-MVC整合"><a href="#2-3-Spring与Spring-MVC整合" class="headerlink" title="2.3 Spring与Spring MVC整合"></a>2.3 Spring与Spring MVC整合</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置加载类路径的配置文件 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath*:applicationContext.xml,classpath*:spring-security.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 配置监听器 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div><h3 id="2-4-Spring与MyBatis整合"><a href="#2-4-Spring与MyBatis整合" class="headerlink" title="2.4 Spring与MyBatis整合"></a>2.4 Spring与MyBatis整合</h3><h4 id="2-4-1-整合思路"><a href="#2-4-1-整合思路" class="headerlink" title="2.4.1.整合思路"></a>2.4.1.整合思路</h4><p>把 mybatis 配置文件（mybatis.xml）中内容配置到 spring 配置文件中 。</p><h4 id="2-4-2-Spring接管mybatis的Session工厂"><a href="#2-4-2-Spring接管mybatis的Session工厂" class="headerlink" title="2.4.2.Spring接管mybatis的Session工厂"></a>2.4.2.Spring接管mybatis的Session工厂</h4><p>db.properties</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver </span><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8</span><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">root</span></code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:db.properties"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置连接池 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.username&#125;"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 把交给IOC管理 SqlSessionFactory --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="2-4-3-自动扫描所有Mapper接口和文件"><a href="#2-4-3-自动扫描所有Mapper接口和文件" class="headerlink" title="2.4.3.自动扫描所有Mapper接口和文件"></a>2.4.3.自动扫描所有Mapper接口和文件</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 扫描dao接口 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mapperScanner"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basePackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.itheima.ssm.dao"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="2-4-4-配置Spring事务"><a href="#2-4-4-配置Spring事务" class="headerlink" title="2.4.4.配置Spring事务"></a>2.4.4.配置Spring事务</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置Spring的声明式事务管理 --&gt;</span> <span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>/&gt;</span></code></pre></div><h3 id="2-5-测试运行"><a href="#2-5-测试运行" class="headerlink" title="2.5 测试运行"></a>2.5 测试运行</h3><h4 id="2-5-1-编写jsp页面"><a href="#2-5-1-编写jsp页面" class="headerlink" title="2.5.1.编写jsp页面"></a>2.5.1.编写jsp页面</h4><h5 id="2-5-1-1-请求发起页面-index-jsp"><a href="#2-5-1-1-请求发起页面-index-jsp" class="headerlink" title="2.5.1.1 请求发起页面 index.jsp"></a>2.5.1.1 请求发起页面 index.jsp</h5><div class="hljs"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span>pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;&lt;!DOCTYPE html PUBLIC <span class="hljs-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span><span class="hljs-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/product/findAll.do"&gt;查询产品信息&lt;/a&gt;&lt;/body&gt; &lt;/html&gt;</code></pre></div><h5 id="2-5-1-2-显示产品页面-product-list-jsp"><a href="#2-5-1-2-显示产品页面-product-list-jsp" class="headerlink" title="2.5.1.2 显示产品页面 product-list.jsp"></a>2.5.1.2 显示产品页面 product-list.jsp</h5><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600071180791.png" srcset="/img/loading.gif" alt="60007118079"></p><h4 id="2-5-2-Controller"><a href="#2-5-2-Controller" class="headerlink" title="2.5.2.Controller"></a>2.5.2.Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/product"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IProductService productService;    <span class="hljs-comment">/*</span><span class="hljs-comment">    查询全部产品</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();        List&lt;Product&gt; ps = productService.findAll();        mv.addObject(<span class="hljs-string">"productList"</span>,ps);        mv.setViewName(<span class="hljs-string">"product-list1"</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><h2 id="3-商品添加"><a href="#3-商品添加" class="headerlink" title="3.商品添加"></a>3.商品添加</h2><h3 id="3-1-商品添加页面-product-add-jsp"><a href="#3-1-商品添加页面-product-add-jsp" class="headerlink" title="3.1 商品添加页面 product-add.jsp"></a>3.1 商品添加页面 product-add.jsp</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600071236913.png" srcset="/img/loading.gif" alt="60007123691"></p><p>页面详细代码请查看今天课程资料</p><h3 id="3-2-Controller"><a href="#3-2-Controller" class="headerlink" title="3.2 Controller"></a>3.2 Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/product"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IProductService productService;    <span class="hljs-comment">//产品添加</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/save.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">save</span><span class="hljs-params">(Product product)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        productService.save(product);        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:findAll.do"</span>;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">    查询全部产品</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();        List&lt;Product&gt; ps = productService.findAll();        mv.addObject(<span class="hljs-string">"productList"</span>,ps);        mv.setViewName(<span class="hljs-string">"product-list1"</span>);        <span class="hljs-keyword">return</span> mv;    &#125;&#125;</code></pre></div><h3 id="3-3-Dao"><a href="#3-3-Dao" class="headerlink" title="3.3 Dao"></a>3.3 Dao</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IProductDao</span> </span>&#123;<span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from product"</span>)     <span class="hljs-function">List&lt;Product&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into product(productNum,productName,cityName,departureTime,productPrice,productDesc,productStatus) values(#&#123;productNum&#125;,#&#123;productName&#125;,#&#123;cityName&#125;,#&#123;departureTime&#125;,#&#123;productPrice&#125;,# &#123;productDesc&#125;,#&#123;productStatus&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Product product)</span></span>;&#125;</code></pre></div><h1 id="SSM订单操作"><a href="#SSM订单操作" class="headerlink" title="SSM订单操作"></a>SSM订单操作</h1><h2 id="1-表结构分析"><a href="#1-表结构分析" class="headerlink" title="1.表结构分析"></a>1.表结构分析</h2><h3 id="1-1-订单表信息描述orders"><a href="#1-1-订单表信息描述orders" class="headerlink" title="1.1.订单表信息描述orders"></a>1.1.订单表信息描述orders</h3><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2(32)</td><td>无意义、主键uuid</td></tr><tr><td>2</td><td>orderNum</td><td>varchar2(50)</td><td>订单编号 不为空  唯一</td></tr><tr><td>3</td><td>orderTime</td><td>timestamp</td><td>下单时间</td></tr><tr><td>4</td><td>peopleCount</td><td>int</td><td>出行人数</td></tr><tr><td>5</td><td>orderDesc</td><td>varchar2(500)</td><td>订单描述(其它信息)</td></tr><tr><td>6</td><td>payType</td><td>int</td><td>支付方式(0 支付宝 1 微信 2其它)</td></tr><tr><td>7</td><td>orderStatus</td><td>int</td><td>订单状态(0 未支付 1 已支付)</td></tr><tr><td>8</td><td>productId</td><td>int</td><td>产品id 外键</td></tr><tr><td>9</td><td>memberid</td><td>int</td><td>会员(联系人）id 外键</td></tr></tbody></table><p>productId描述了订单与产品之间的关系。</p><p>memberid描述了订单与会员之间的关系。</p><p>创建表sql</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> SYS_GUID() PRIMARY <span class="hljs-keyword">KEY</span>, orderNum <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">UNIQUE</span>,orderTime <span class="hljs-built_in">timestamp</span>, peopleCount <span class="hljs-built_in">INT</span>, orderDesc <span class="hljs-built_in">VARCHAR2</span>(<span class="hljs-number">500</span>), payType <span class="hljs-built_in">INT</span>,orderStatus <span class="hljs-built_in">INT</span>, productId <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">32</span>), memberId <span class="hljs-built_in">varchar2</span>(<span class="hljs-number">32</span>),<span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (productId) <span class="hljs-keyword">REFERENCES</span> product(<span class="hljs-keyword">id</span>), <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (memberId) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">member</span>(<span class="hljs-keyword">id</span>))<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'0E7231DC797C486290E8713CA3C6ECCC'</span>, <span class="hljs-string">'12345'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>,<span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'676C5BD1D35E429A8C2E114939C5685A'</span>,<span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'5DC6A48DD4E94592AE904930EA866AFA'</span>, <span class="hljs-string">'54321'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'676C5BD1D35E429A8C2E114939C5685A'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'2FF351C4AC744E2092DCF08CFD314420'</span>, <span class="hljs-string">'67890'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'12B7ABF2A4C544568B0A7C69F36BF8B7'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'A0657832D93E4B10AE88A2D4B70B1A28'</span>, <span class="hljs-string">'98765'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'12B7ABF2A4C544568B0A7C69F36BF8B7'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'E4DD4C45EED84870ABA83574A801083E'</span>, <span class="hljs-string">'11111'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'12B7ABF2A4C544568B0A7C69F36BF8B7'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'96CC8BD43C734CC2ACBFF09501B4DD5D'</span>, <span class="hljs-string">'22222'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'12B7ABF2A4C544568B0A7C69F36BF8B7'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'55F9AF582D5A4DB28FB4EC3199385762'</span>, <span class="hljs-string">'33333'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'9F71F01CB448476DAFB309AA6DF9497F'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'CA005CF1BE3C4EF68F88ABC7DF30E976'</span>, <span class="hljs-string">'44444'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'9F71F01CB448476DAFB309AA6DF9497F'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ORDERS (<span class="hljs-keyword">id</span>, ordernum, ordertime, peoplecount, orderdesc, paytype, orderstatus, productid, memberid)<span class="hljs-keyword">values</span> (<span class="hljs-string">'3081770BC3984EF092D9E99760FDABDE'</span>, <span class="hljs-string">'55555'</span>, to_timestamp(<span class="hljs-string">'02-03-2018 12:00:00.000000'</span>, <span class="hljs-string">'dd-mm-yyyy hh24:mi:ss.ff'</span>), <span class="hljs-number">2</span>, <span class="hljs-string">'没什么'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'9F71F01CB448476DAFB309AA6DF9497F'</span>, <span class="hljs-string">'E61D65F673D54F68B0861025C69773DB'</span>);</code></pre></div><p>实体类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-01  16:12</span><span class="hljs-comment"> * 订单</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orders</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String orderNum;    <span class="hljs-keyword">private</span> Date orderTime;    <span class="hljs-meta">@DateTimeFormat</span>(pattern = <span class="hljs-string">"yyyy-MM-dd HH:mm"</span>)    <span class="hljs-keyword">private</span> String orderTimeStr;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> orderStatus;    <span class="hljs-keyword">private</span> String orderStatusStr;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> peopleCount;    <span class="hljs-keyword">private</span> Product product;    <span class="hljs-keyword">private</span> List&lt;Traveller&gt; travellers;    <span class="hljs-keyword">private</span> Member member;    <span class="hljs-keyword">private</span> Integer payType;    <span class="hljs-keyword">private</span> String payTypeStr;    <span class="hljs-keyword">private</span> String orderDesc;&#125;</code></pre></div><h3 id="1-2-会员表信息描述member"><a href="#1-2-会员表信息描述member" class="headerlink" title="1.2 会员表信息描述member"></a>1.2 会员表信息描述member</h3><p>订单与会员之间是多对一关系，我们在订单表中创建一个外键来进行关联。</p><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2(32)</td><td>无意义、主键uuid</td></tr><tr><td>2</td><td>name</td><td>varchar2(20)</td><td>姓名</td></tr><tr><td>3</td><td>nickName</td><td>varchar2(20)</td><td>昵称</td></tr><tr><td>4</td><td>phoneNum</td><td>varchar2(20)</td><td>电话号码</td></tr><tr><td>5</td><td>email</td><td>varchar2(50)</td><td>邮箱</td></tr></tbody></table><p>创建表sql</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE member(id varchar2(32) default SYS_GUID() PRIMARY KEY, NAME VARCHAR2(20),nickname VARCHAR2(20), phoneNum VARCHAR2(20), email VARCHAR2(20))insert into MEMBER (id, name, nickname, phonenum, email)values (&#39;E61D65F673D54F68B0861025C69773DB&#39;, &#39;张三&#39;, &#39;小三&#39;, &#39;18888888888&#39;, &#39;zs@163.com&#39;);</code></pre></div><p>实体类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Member</span> </span>&#123;<span class="hljs-keyword">private</span> String id;     <span class="hljs-keyword">private</span> String name;     <span class="hljs-keyword">private</span> String nickname;     <span class="hljs-keyword">private</span> String phoneNum;     <span class="hljs-keyword">private</span> String email;     <span class="hljs-comment">//省略getter/setter</span>&#125;</code></pre></div><h3 id="1-3-旅客表信息描述traveller"><a href="#1-3-旅客表信息描述traveller" class="headerlink" title="1.3.旅客表信息描述traveller"></a>1.3.旅客表信息描述traveller</h3><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>varchar2(32)</td><td>无意义、主键uuid</td></tr><tr><td>2</td><td>name</td><td>varchar2(20)</td><td>姓名</td></tr><tr><td>3</td><td>sex</td><td>varchar2(20)</td><td>性别</td></tr><tr><td>4</td><td>phoneNum</td><td>varchar2(20)</td><td>电话号码</td></tr><tr><td>5</td><td>credentialsType</td><td>int</td><td>证件类型 0身份证 1护照 2军官证</td></tr><tr><td>6</td><td>credentialsNum</td><td>varchar2(50)</td><td>证件号码</td></tr><tr><td>7</td><td>travellerType</td><td>int</td><td>旅客类型(人群) 0 成人 1 儿童</td></tr></tbody></table><p>创建表sql</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE traveller(id varchar2(32) default SYS_GUID() PRIMARY KEY, NAME VARCHAR2(20),sex VARCHAR2(20), phoneNum VARCHAR2(20), credentialsType INT,credentialsNum VARCHAR2(50), travellerType INT)insert into TRAVELLER (id, name, sex, phonenum, credentialstype, credentialsnum, travellertype) values (&#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;, &#39;张龙&#39;, &#39;男&#39;, &#39;13333333333&#39;, 0, &#39;123456789009876543&#39;, 0);insert into TRAVELLER (id, name, sex, phonenum, credentialstype, credentialsnum, travellertype) values (&#39;EE7A71FB6945483FBF91543DBE851960&#39;, &#39;张小龙&#39;, &#39;男&#39;, &#39;15555555555&#39;, 0, &#39;987654321123456789&#39;, 1);</code></pre></div><p>实体类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-01  16:23</span><span class="hljs-comment"> * 旅客</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Traveller</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String sex;    <span class="hljs-keyword">private</span> String phoneNum;    <span class="hljs-keyword">private</span> Integer credentialsType;    <span class="hljs-keyword">private</span> String credentialsTypeStr;    <span class="hljs-keyword">private</span> String credentialsNum;    <span class="hljs-keyword">private</span> Integer travellerType;    <span class="hljs-keyword">private</span> String travellerTypeStr;&#125;</code></pre></div><p>旅客与订单之间是多对多关系，所以我们需要一张中间表（order_traveller）来描述</p><table><thead><tr><th>序号</th><th>字段名称</th><th>字段类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>orderId</td><td>varchar2(32)</td><td>订单id</td></tr><tr><td>2</td><td>travellerId</td><td>varchar2(32)</td><td>旅客id</td></tr></tbody></table><p>创建表sql</p><div class="hljs"><pre><code class="hljs mysql">CREATE TABLE order_traveller( orderId varchar2(32), travellerId varchar2(32),PRIMARY KEY (orderId,travellerId),FOREIGN KEY (orderId) REFERENCES orders(id), FOREIGN KEY (travellerId) REFERENCES traveller(id))insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;0E7231DC797C486290E8713CA3C6ECCC&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;2FF351C4AC744E2092DCF08CFD314420&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;3081770BC3984EF092D9E99760FDABDE&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;55F9AF582D5A4DB28FB4EC3199385762&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;5DC6A48DD4E94592AE904930EA866AFA&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;96CC8BD43C734CC2ACBFF09501B4DD5D&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;A0657832D93E4B10AE88A2D4B70B1A28&#39;, &#39;3FE27DF2A4E44A6DBC5D0FE4651D3D3E&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;CA005CF1BE3C4EF68F88ABC7DF30E976&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;); insert into ORDER_TRAVELLER (orderid, travellerid)values (&#39;E4DD4C45EED84870ABA83574A801083E&#39;, &#39;EE7A71FB6945483FBF91543DBE851960&#39;);</code></pre></div><h2 id="2-订单查询"><a href="#2-订单查询" class="headerlink" title="2.订单查询"></a>2.订单查询</h2><h3 id="2-1-订单查询页面-order-list-jsp"><a href="#2-1-订单查询页面-order-list-jsp" class="headerlink" title="2.1 订单查询页面 order-list.jsp"></a>2.1 订单查询页面 order-list.jsp</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600071735388.png" srcset="/img/loading.gif" alt="60007173538"></p><p>详细代码请查看今天课程资料</p><h3 id="2-2-Controller"><a href="#2-2-Controller" class="headerlink" title="2.2 Controller"></a>2.2 Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/orders"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IOrdersService ordersService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">(@RequestParam(name=<span class="hljs-string">"page"</span>,required = <span class="hljs-keyword">true</span>,defaultValue = <span class="hljs-string">"1"</span>)</span> Integer page,@<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"size"</span>,required = <span class="hljs-keyword">true</span>,defaultValue = <span class="hljs-string">"4"</span>)</span> Integer size) <span class="hljs-keyword">throws</span> Exception </span>&#123;        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();        List&lt;Orders&gt; ordersList = ordersService.findAll(page, size);        <span class="hljs-comment">//PageInfo就是一个分页Bean</span>        PageInfo pageInfo = <span class="hljs-keyword">new</span> PageInfo(ordersList);        mv.addObject(<span class="hljs-string">"pageInfo"</span>,pageInfo);        mv.setViewName(<span class="hljs-string">"orders-page-list"</span>);        <span class="hljs-keyword">return</span> mv;    &#125;</code></pre></div><h3 id="2-3-Dao"><a href="#2-3-Dao" class="headerlink" title="2.3 Dao"></a>2.3 Dao</h3><p>IOrdersDao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-05-01  16:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOrdersDao</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from orders"</span>)    <span class="hljs-meta">@Results</span>(&#123;            <span class="hljs-meta">@Result</span>(id = <span class="hljs-keyword">true</span>,property = <span class="hljs-string">"id"</span>,column = <span class="hljs-string">"id"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderNum"</span>,column = <span class="hljs-string">"orderNum"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderTime"</span>,column = <span class="hljs-string">"orderTime"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderStatus"</span>,column = <span class="hljs-string">"orderStatus"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"peopleCount"</span>,column = <span class="hljs-string">"peopleCount"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"payType"</span>,column = <span class="hljs-string">"payType"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"payTypeStr"</span>,column = <span class="hljs-string">"payTypeStr"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderDesc"</span>,column = <span class="hljs-string">"orderDesc"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"product"</span>,column = <span class="hljs-string">"productId"</span>,javaType = Product<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                    <span class="hljs-title">one</span> </span>= <span class="hljs-meta">@One</span>(select = <span class="hljs-string">"com.jk.ssm.dao.IProductDao.findById"</span>))    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Orders&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>IProductDao的findById</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from product where id=#&#123;id&#125;"</span>) <span class="hljs-function">Product <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><h2 id="3-订单分页查询"><a href="#3-订单分页查询" class="headerlink" title="3.订单分页查询"></a>3.订单分页查询</h2><h3 id="3-1-PageHelper介绍"><a href="#3-1-PageHelper介绍" class="headerlink" title="3.1 PageHelper介绍"></a>3.1 PageHelper介绍</h3><p>PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。</p><p>本项目在 github 的项目地址：<a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper</a>本项目在 gitosc 的项目地址：<a href="http://git.oschina.net/free/Mybatis_PageHelper" target="_blank" rel="noopener">http://git.oschina.net/free/Mybatis_PageHelper</a></p><h3 id="3-2-PageHelper使用"><a href="#3-2-PageHelper使用" class="headerlink" title="3.2 PageHelper使用"></a>3.2 PageHelper使用</h3><h4 id="3-2-1-集成"><a href="#3-2-1-集成" class="headerlink" title="3.2.1.集成"></a>3.2.1.集成</h4><p>引入分页插件有下面2种方式，推荐使用 Maven 方式。</p><h5 id="3-2-1-1-引入-Jar-包"><a href="#3-2-1-1-引入-Jar-包" class="headerlink" title="3.2.1.1. 引入 Jar 包"></a>3.2.1.1. 引入 Jar 包</h5><p> 你可以从下面的地址中下载最新版本的 jar 包</p><p><a href="https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/releases/com/github/pagehelper/pagehelper/</a></p><p><a href="http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/</a></p><p>由于使用了sql 解析工具，你还需要下载 jsqlparser.jar：</p><p><a href="http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/</a></p><h5 id="3-2-1-2-使用-Maven"><a href="#3-2-1-2-使用-Maven" class="headerlink" title="3.2.1.2. 使用 Maven"></a>3.2.1.2. 使用 Maven</h5><p>在 pom.xml 中添加如下依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>最新版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="3-2-2-配置"><a href="#3-2-2-配置" class="headerlink" title="3.2.2.配置"></a>3.2.2.配置</h4><p>特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor 。 com.github.pagehelper.PageHelper 现在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。</p><h5 id="3-2-2-1-在-MyBatis-配置-xml-中配置拦截器插件"><a href="#3-2-2-1-在-MyBatis-配置-xml-中配置拦截器插件" class="headerlink" title="3.2.2.1. 在 MyBatis 配置 xml 中配置拦截器插件"></a>3.2.2.1. 在 MyBatis 配置 xml 中配置拦截器插件</h5><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:</span><span class="hljs-comment">properties?, settings?, </span><span class="hljs-comment">typeAliases?, typeHandlers?,</span><span class="hljs-comment">objectFactory?,objectWrapperFactory?,</span><span class="hljs-comment">plugins?,</span><span class="hljs-comment">environments?, databaseIdProvider?, mappers?</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"param1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"value1"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></code></pre></div><h5 id="3-2-2-2-在-Spring-配置文件中配置拦截器插件"><a href="#3-2-2-2-在-Spring-配置文件中配置拦截器插件" class="headerlink" title="3.2.2.2. 在 Spring 配置文件中配置拦截器插件"></a>3.2.2.2. 在 Spring 配置文件中配置拦截器插件</h5><p>使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 注意其他配置 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"plugins"</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"properties"</span>&gt;</span>                <span class="hljs-comment">&lt;!--使用下面的方式配置参数，一行配置一个 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>                    params=value1                    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                 <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="3-2-3-分页插件参数介绍"><a href="#3-2-3-分页插件参数介绍" class="headerlink" title="3.2.3 分页插件参数介绍"></a>3.2.3 分页插件参数介绍</h4><ol><li>helperDialect ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置</li></ol><p>helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：</p><p>oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2  sqlserver201</p><p>2 , derby</p><p>特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012 ，否则会使用 SqlServer2005 的方式进行分页。</p><p>你也可以实现 AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方</p><p>法。</p><ol start="2"><li>offsetAsPageNum ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为</li></ol><p>true 时，会将 RowBounds 中的 offset 参数当成 pageNum使用，可以用页码和页面大小两个参数进行分</p><p>页。</p><ol start="3"><li>rowBoundsWithCount ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置</li></ol><p>为 true 时，使用 RowBounds 分页会进行 count 查询。</p><ol start="4"><li>pageSizeZero ：默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit =</li></ol><p>0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</p><ol start="5"><li>reasonable ：分页合理化参数，默认值为 false 。当该参数设置为 true时， pageNum&lt;=0 时会查询第一</li></ol><p>页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。</p><ol start="6"><li>params ：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认值为</li></ol><p>pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。</p><ol start="7"><li>supportMethodsArguments ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和</li></ol><p>ArgumentsObjTest 。</p><ol start="8"><li>autoRuntimeDialect ：默认值为 false 。设置为 true 时，允许在运行时根据多数据源自动识别对应方言</li></ol><p>的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。</p><ol start="9"><li>closeConn ：默认值为 true 。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类</li></ol><p>型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为</p><p>false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。</p><h4 id="3-2-4-基本使用"><a href="#3-2-4-基本使用" class="headerlink" title="3.2.4.基本使用"></a>3.2.4.基本使用</h4><p>PageHelper的基本使用有6种，大家可以查看文档，最常用的有两种</p><h5 id="3-2-4-1-RowBounds方式的调用（了解）"><a href="#3-2-4-1-RowBounds方式的调用（了解）" class="headerlink" title="3.2.4.1. RowBounds方式的调用（了解）"></a>3.2.4.1. RowBounds方式的调用（了解）</h5> <div class="hljs"><pre><code class="hljs java">List&lt;Country&gt; list = sqlSession.selectList(<span class="hljs-string">"x.y.selectIf"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));</code></pre></div><p>使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。</p><p>分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。</p><p>关于这种方式的调用，有两个特殊的参数是针对 RowBounds的，你可以参看上面的分页插件参数介绍注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//这种情况下也会进行物理分页查询</span><span class="hljs-function">List&lt;Country&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</code></pre></div><p>注意： 由于默认情况下的 RowBounds 无法获取查询总数，分页插件提供了一个继承自 RowBounds 的</p><p>PageRowBounds ，这个对象中增加了 total属性，执行分页查询后，可以从该属性得到查询总数。</p><h5 id="3-2-4-2-PageHelper-startPage静态方法调用（重点）"><a href="#3-2-4-2-PageHelper-startPage静态方法调用（重点）" class="headerlink" title="3.2.4.2. PageHelper.startPage静态方法调用（重点）"></a>3.2.4.2. PageHelper.startPage静态方法调用（重点）</h5><p>这种方式是我们要掌握的 在你需要进行分页的 MyBatis 查询方法前调用PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//获取第1页，10条内容，默认查询总数count</span>PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//紧跟着的第一个select方法会被分页</span>List&lt;Country&gt; list = countryMapper.selectIf(<span class="hljs-number">1</span>);</code></pre></div><h3 id="3-3-订单分页查询"><a href="#3-3-订单分页查询" class="headerlink" title="3.3 订单分页查询"></a>3.3 订单分页查询</h3><h4 id="3-3-1-Service"><a href="#3-3-1-Service" class="headerlink" title="3.3.1 Service"></a>3.3.1 Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Orders&gt; <span class="hljs-title">findAllByPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> pageSize)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;PageHelper.startPage(page, pageSize);     <span class="hljs-keyword">return</span> ordersDao.findAllByPage();&#125;</code></pre></div><h4 id="3-3-2-Controller"><a href="#3-3-2-Controller" class="headerlink" title="3.3.2 Controller"></a>3.3.2 Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findAll.do"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findAll</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"page"</span>, required = <span class="hljs-keyword">true</span>, defaultValue = <span class="hljs-string">"1"</span>)</span> Integer page, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"pageSize"</span>, required = <span class="hljs-keyword">true</span>, defaultValue = <span class="hljs-string">"10"</span>)</span> Integer pageSize) <span class="hljs-keyword">throws</span> Exception </span>&#123;    List&lt;Orders&gt; ordersList = ordersService.findAllByPage(page, pageSize);     PageInfo pageInfo = <span class="hljs-keyword">new</span> PageInfo(ordersList);    ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();     mv.setViewName(<span class="hljs-string">"order-list"</span>);     mv.addObject(<span class="hljs-string">"pageInfo"</span>, pageInfo);     <span class="hljs-keyword">return</span> mv;&#125;</code></pre></div><h4 id="3-3-3-订单分页查询页面Order-list-jsp"><a href="#3-3-3-订单分页查询页面Order-list-jsp" class="headerlink" title="3.3.3 订单分页查询页面Order-list.jsp"></a>3.3.3 订单分页查询页面Order-list.jsp</h4><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600072686900.png" srcset="/img/loading.gif" alt="60007268690"></p><p>详细代码请查看今天课程资料</p><h2 id="4-订单详情"><a href="#4-订单详情" class="headerlink" title="4.订单详情"></a>4.订单详情</h2><p>在order-list.jsp页面上对”详情”添加链接</p><div class="hljs"><pre><code class="hljs jsp">&lt;button type="button" class="btn bg-olive btn-xs" onclick="location.href='$&#123;pageContext.request.contextPath&#125;/orders/findById.do?id=$&#123;orders.id&#125;'"&gt;详情&lt;/button&gt;</code></pre></div><h3 id="4-1-订单详情-order-show-jsp"><a href="#4-1-订单详情-order-show-jsp" class="headerlink" title="4.1 订单详情 order-show.jsp"></a>4.1 订单详情 order-show.jsp</h3><p><img src="/2020/09/14/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%AF%87/1600072739934.png" srcset="/img/loading.gif" alt="60007273993"></p><p>详细代码请查看今天课程资料</p><h3 id="4-2-Controller"><a href="#4-2-Controller" class="headerlink" title="4.2 Controller"></a>4.2 Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/findById.do"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     Orders orders = ordersService.findById(id);    ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();     mv.setViewName(<span class="hljs-string">"order-show"</span>);mv.addObject(<span class="hljs-string">"orders"</span>, orders);     <span class="hljs-keyword">return</span> mv;&#125;</code></pre></div><h3 id="4-3-Dao"><a href="#4-3-Dao" class="headerlink" title="4.3 Dao"></a>4.3 Dao</h3><p>IOrdersDao的findById方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//多表操作</span>    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from orders where id = #&#123;orderId&#125;"</span>)    <span class="hljs-meta">@Results</span>(&#123;            <span class="hljs-meta">@Result</span>(id = <span class="hljs-keyword">true</span>,property = <span class="hljs-string">"id"</span>,column = <span class="hljs-string">"id"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderNum"</span>,column = <span class="hljs-string">"orderNum"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderTime"</span>,column = <span class="hljs-string">"orderTime"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderStatus"</span>,column = <span class="hljs-string">"orderStatus"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"peopleCount"</span>,column = <span class="hljs-string">"peopleCount"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"payType"</span>,column = <span class="hljs-string">"payType"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"payTypeStr"</span>,column = <span class="hljs-string">"payTypeStr"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"orderDesc"</span>,column = <span class="hljs-string">"orderDesc"</span>),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"product"</span>,column = <span class="hljs-string">"productId"</span>,javaType = Product<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                    <span class="hljs-title">one</span> </span>= <span class="hljs-meta">@One</span>(select = <span class="hljs-string">"com.jk.ssm.dao.IProductDao.findById"</span>)),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"member"</span>,column = <span class="hljs-string">"memberId"</span>,javaType = Member<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                    <span class="hljs-title">one</span> </span>= <span class="hljs-meta">@One</span>(select = <span class="hljs-string">"com.jk.ssm.dao.IMemberDao.findById"</span>)),            <span class="hljs-meta">@Result</span>(property = <span class="hljs-string">"travellers"</span>,column = <span class="hljs-string">"id"</span>,javaType = java.util.List<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                    <span class="hljs-title">many</span> </span>= <span class="hljs-meta">@Many</span>(select = <span class="hljs-string">"com.jk.ssm.dao.ITravellerDao.findByOrdersId"</span>))    &#125;)    <span class="hljs-function">Orders <span class="hljs-title">findById</span><span class="hljs-params">(String ordersId)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div><p>IMemberDao的findById方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMemberDao</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from member where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Member <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>ITravellerDao.findByOrdersId方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from traveller where id in (select travellerId from order_traveller where orderId=#&#123;ordersId&#125;)"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Traveller&gt; <span class="hljs-title">findByOrdersId</span><span class="hljs-params">(String ordersId)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity源码分析</title>
    <link href="/2020/09/09/SpringSecurity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/09/09/SpringSecurity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity源码分析"><a href="#SpringSecurity源码分析" class="headerlink" title="SpringSecurity源码分析"></a>SpringSecurity源码分析</h1><h2 id="1-在web-xml文件中配置"><a href="#1-在web-xml文件中配置" class="headerlink" title="1 在web.xml文件中配置"></a>1 在web.xml文件中配置</h2><p>问题:为什么DelegatingFilterProxy的filter-name必须是springSecurityFilterChain?</p><p><img src="/2020/09/09/SpringSecurity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1599660926594.png" srcset="/img/loading.gif" alt="59966092659"></p><p>来获取到</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFilterBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// If no target bean name specified, use filter name. </span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.targetBeanName == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">this</span>.targetBeanName = getFilterName();        &#125;        <span class="hljs-comment">// Fetch Spring root application context and initialize the delegate early, </span>            <span class="hljs-comment">// if possible. If the root application context will be started after this </span>            <span class="hljs-comment">// filter proxy, we'll have to resort to lazy initialization. </span>            WebApplicationContext wac = findWebApplicationContext();            <span class="hljs-keyword">if</span> (wac != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">this</span>.delegate = initDelegate(wac);             &#125;        &#125;    &#125;&#125;</code></pre></div><p>在上这代码中this.targetBeanName=getFilterName()就是获取名称叫做springSecurityFilterChain</p><p>通过在doFilter就去中我们会发现真正干活的其实是delegate这个Filter,而delegate其实就是FilterChainProxy</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">// Lazily initialize the delegate if necessary. </span>    Filter delegateToUse = <span class="hljs-keyword">this</span>.delegate;    <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;        delegateToUse = <span class="hljs-keyword">this</span>.delegate;        <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;            WebApplicationContext wac = findWebApplicationContext(); <span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No WebApplicationContext found: "</span> +            <span class="hljs-string">"no ContextLoaderListener or DispatcherServlet registered?"</span>);        &#125;    delegateToUse = initDelegate(wac);    &#125;    <span class="hljs-keyword">this</span>.delegate = delegateToUse;    &#125;  &#125;<span class="hljs-comment">// Let the delegate perform the actual doFilter operation. </span>    invokeDelegate(delegateToUse, request, response, filterChain);&#125;</code></pre></div><p>FilterChainProxy是spring在解析配置文件时装配到上下文中，并且beanName为springSecurityFilterChain，</p><p>因此在web.xml中需要配置filter-name为springSecurityFilterChain</p><h2 id="2-在spring-security-xml文件中配置"><a href="#2-在spring-security-xml文件中配置" class="headerlink" title="2.在spring-security.xml文件中配置"></a>2.在spring-security.xml文件中配置</h2><p>在配置文件中我们主要使用标签来过多成配置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置不拦截的资源 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">security:http</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/login.jsp"</span> <span class="hljs-attr">security</span>=<span class="hljs-string">"none"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">security:http</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/failer.jsp"</span> <span class="hljs-attr">security</span>=<span class="hljs-string">"none"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">security:http</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/css/**"</span> <span class="hljs-attr">security</span>=<span class="hljs-string">"none"</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">security:http</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/img/**"</span> <span class="hljs-attr">security</span>=<span class="hljs-string">"none"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">security:http</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/plugins/**"</span> <span class="hljs-attr">security</span>=<span class="hljs-string">"none"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">security:http</span> <span class="hljs-attr">auto-config</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">use-expressions</span>=<span class="hljs-string">"false"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">security:intercept-url</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/**"</span> <span class="hljs-attr">access</span>=<span class="hljs-string">"ROLE_USER,ROLE_ADMIN"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">security:form-login</span></span><span class="hljs-tag">   <span class="hljs-attr">login-page</span>=<span class="hljs-string">"/login.jsp"</span> </span><span class="hljs-tag">                         <span class="hljs-attr">login-processing-url</span>=<span class="hljs-string">"/login.do"</span> </span><span class="hljs-tag">                         <span class="hljs-attr">default-target-url</span>=<span class="hljs-string">"/index.jsp"</span> </span><span class="hljs-tag">                         <span class="hljs-attr">authentication-failure-url</span>=<span class="hljs-string">"/failer.jsp"</span> </span><span class="hljs-tag">                         <span class="hljs-attr">authentication-success-forward-url</span>=<span class="hljs-string">"/pages/main.jsp"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">security:http</span>&gt;</span></code></pre></div><p>http标签是自定义标签，我们可以在spring-security-config包中查看</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">http\://www.springframework.org/schema/security</span>=<span class="hljs-string">org.springframework.security.config.SecurityName</span><span class="hljs-attr">spaceHandler</span></code></pre></div><p>继续查看SecurityNamespaceHandler类，在其init方法</p> <div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;loadParsers();&#125;</code></pre></div><p>在loadParsers()方法中，指定由HttpSecurityBeanDefinitionParser进行解析</p><div class="hljs"><pre><code class="hljs java">parsers.put(Elements.HTTP, <span class="hljs-keyword">new</span> HttpSecurityBeanDefinitionParser());</code></pre></div><p>在HttpSecurityBeanDefinitionParser完成具体解析的parse方法中</p><div class="hljs"><pre><code class="hljs java">registerFilterChainProxyIfNecessary(pc, pc.extractSource(element));</code></pre></div><p>这里就是注册了名为springSecurityFilterChain的filterChainProxy类</p><p>接下我们在看一下注册一系列Filter的地方createFilterChain，在这个方法中我们重点关注</p><div class="hljs"><pre><code class="hljs java">AuthenticationConfigBuilder authBldr = <span class="hljs-keyword">new</span> AuthenticationConfigBuilder(element,                           forceAutoConfig, pc, httpBldr.getSessionCreationPolicy(), httpBldr.getRequestCache(), authenticationManager,                                             httpBldr.getSessionStrategy(), portMapper, portResolver,                                         httpBldr.getCsrfLogoutHandler());</code></pre></div><p>我们可以查看AuthenticationConfigBuilder创建代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticationConfigBuilder</span><span class="hljs-params">(Element element, <span class="hljs-keyword">boolean</span> forceAutoConfig, </span></span><span class="hljs-function"><span class="hljs-params">                          ParserContext pc, SessionCreationPolicy sessionPolicy, BeanReference requestCache, BeanReference authenticationManager, BeanReference sessionStrategy, BeanReference portMapper,</span></span><span class="hljs-function"><span class="hljs-params">BeanReference portResolver, BeanMetadataElement csrfLogoutHandler)</span> </span>&#123;    <span class="hljs-keyword">this</span>.httpElt = element; <span class="hljs-keyword">this</span>.pc = pc;    <span class="hljs-keyword">this</span>.requestCache = requestCache; autoConfig = forceAutoConfig    | <span class="hljs-string">"true"</span>.equals(element.getAttribute(ATT_AUTO_CONFIG));    <span class="hljs-keyword">this</span>.allowSessionCreation = sessionPolicy != SessionCreationPolicy.NEVER    &amp;&amp; sessionPolicy != SessionCreationPolicy.STATELESS;    <span class="hljs-keyword">this</span>.portMapper = portMapper; <span class="hljs-keyword">this</span>.portResolver = portResolver; <span class="hljs-keyword">this</span>.csrfLogoutHandler = csrfLogoutHandler;    createAnonymousFilter();     createRememberMeFilter(authenticationManager);     createBasicFilter(authenticationManager);     createFormLoginFilter(sessionStrategy, authenticationManager);    createOpenIDLoginFilter(sessionStrategy, authenticationManager);    createX509Filter(authenticationManager);    createJeeFilter(authenticationManager);    createLogoutFilter();    createLoginPageFilterIfNeeded();    createUserDetailsServiceFactory();    createExceptionTranslationFilter(); &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SVN概述</title>
    <link href="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="SVN概述"><a href="#SVN概述" class="headerlink" title="SVN概述"></a>SVN概述</h1><h2 id="1-SVN介绍"><a href="#1-SVN介绍" class="headerlink" title="1.SVN介绍"></a>1.SVN介绍</h2><p>SVN是Subversion的简称，是一个自由开源的版本控制系统。</p><p>Subversion将文件存放在中心版本库里，这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况，这样就可以借此将数据恢复到以前的版本，并可以查看数据的更改细节</p><p>早期版本控制使用的是CVS,后来SVN替代了CVS,随着android兴起，出现Git版本控制工具。</p><h3 id="1-1-SVN基本概念"><a href="#1-1-SVN基本概念" class="headerlink" title="1.1 SVN基本概念"></a>1.1 SVN基本概念</h3><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574106528.png" srcset="/img/loading.gif" alt="59957410652"></p><p>问题: 怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？复制-修改-合并方案(Subversion默认的模式)</p><p>在这种模型里，每一个客户读取项目配置库建立一个私有工作副本——版本库中文件和目录的本地映射。用户并行工作，修改各自的工作副本，最终，各个私有的复制合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。</p><p>锁定-修改-解锁方案</p><p> 在这样的模型里，在一个时间段里配置库的一个文件只允许被一个人修改。此模式不适合软件开发这种工作。</p><h3 id="1-2-SVN架构"><a href="#1-2-SVN架构" class="headerlink" title="1.2 SVN架构"></a>1.2 SVN架构</h3><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574215936.png" srcset="/img/loading.gif" alt="59957421593"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574226330.png" srcset="/img/loading.gif" alt="59957422633"></p><p>Subversion支持Linux和Windows，更多是安装在Linux下。</p><p>svn服务器有2种运行方式：独立服务器和借助apache运行。两种方式各有利弊，用户可以自行选择。svn存储版本数据也有2种方式：BDB一种事务安全型表类型和FSFS一种不需要数据库的存储系统。</p><p>因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。</p><h2 id="2-SVN使用"><a href="#2-SVN使用" class="headerlink" title="2 SVN使用"></a>2 SVN使用</h2><p>主要介绍常用的svn工具，如window下svn服务器VisualSVN，客户端工具TortoiseSVN以及idea svn插件的使用</p><p>SVN是一种集中式管理代码的版本控制系统，原理就是把代码都保存到一个固定的位置（仓库），每次从这个位置拷贝更新代码，进行编辑；再把修改后的代码提交到该目录中。多人协作开发也是如此。因此需要一个类似Oracle或者Mysql的服务器用于保存和管理库文件（要保存的代码等文件）的服务端——VisualSVN Server。还需要一个用户的操作端，用于提交更新检出代码，常用的有idea的Svn插件，以及TortoiseSVN（小乌龟）。</p><p> SubVersion 官网：<a href="http://subversion.apache.org/" target="_blank" rel="noopener">http://subversion.apache.org/</a></p><h3 id="2-1-服务器端VisualSVN安装与配置"><a href="#2-1-服务器端VisualSVN安装与配置" class="headerlink" title="2.1 服务器端VisualSVN安装与配置"></a>2.1 服务器端VisualSVN安装与配置</h3><h4 id="2-1-1-VisualSVN下载"><a href="#2-1-1-VisualSVN下载" class="headerlink" title="2.1.1 VisualSVN下载"></a>2.1.1 VisualSVN下载</h4><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574310954.png" srcset="/img/loading.gif" alt="59957431095"></p><h4 id="2-1-2-VisualSVN安装与创建仓库"><a href="#2-1-2-VisualSVN安装与创建仓库" class="headerlink" title="2.1.2 VisualSVN安装与创建仓库"></a>2.1.2 VisualSVN安装与创建仓库</h4><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574325226.png" srcset="/img/loading.gif" alt="59957432522"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574332322.png" srcset="/img/loading.gif" alt="59957433232"></p><p>在开始运行中录入 services.msc</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574349699.png" srcset="/img/loading.gif" alt="59957434969"></p><p>这个服务要开启 在开始运行中查找visualSVN Server Manager就可以打开图形化管理界面</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574368682.png" srcset="/img/loading.gif" alt="59957436868"></p><h4 id="2-1-3-VisualSVN创建工程目录"><a href="#2-1-3-VisualSVN创建工程目录" class="headerlink" title="2.1.3 VisualSVN创建工程目录"></a>2.1.3 VisualSVN创建工程目录</h4><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574390720.png" srcset="/img/loading.gif" alt="59957439072"></p><h4 id="2-1-4-VisualSVN-权限控制"><a href="#2-1-4-VisualSVN-权限控制" class="headerlink" title="2.1.4 VisualSVN 权限控制"></a>2.1.4 VisualSVN 权限控制</h4><p>创建用户</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574407626.png" srcset="/img/loading.gif" alt="59957440762"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574414323.png" srcset="/img/loading.gif" alt="59957441432"></p><p>创建组</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574424125.png" srcset="/img/loading.gif" alt="59957442412"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574432883.png" srcset="/img/loading.gif" alt="59957443288"></p><p>分配权限</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574444618.png" srcset="/img/loading.gif" alt="59957444461"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574458710.png" srcset="/img/loading.gif" alt="59957445871"></p><h3 id="2-2-客户端TortoiseSVN安装与使用"><a href="#2-2-客户端TortoiseSVN安装与使用" class="headerlink" title="2.2 客户端TortoiseSVN安装与使用"></a>2.2 客户端TortoiseSVN安装与使用</h3><p>TortoiseSVN是一个基于windows系统的svn客户端图形化界面.</p><h4 id="2-2-1-Tortoise-SVN下载"><a href="#2-2-1-Tortoise-SVN下载" class="headerlink" title="2.2.1 Tortoise SVN下载"></a>2.2.1 Tortoise SVN下载</h4><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574489647.png" srcset="/img/loading.gif" alt="59957448964"></p><h4 id="2-2-2-Tortoise-SVN安装"><a href="#2-2-2-Tortoise-SVN安装" class="headerlink" title="2.2.2 Tortoise SVN安装"></a>2.2.2 Tortoise SVN安装</h4><p> 安装后需要重启电脑</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574512937.png" srcset="/img/loading.gif" alt="59957451293"></p><h4 id="2-2-3-Tortoise-SVN-常用操作"><a href="#2-2-3-Tortoise-SVN-常用操作" class="headerlink" title="2.2.3 Tortoise SVN 常用操作"></a>2.2.3 Tortoise SVN 常用操作</h4><h5 id="2-2-3-1-浏览仓库"><a href="#2-2-3-1-浏览仓库" class="headerlink" title="2.2.3.1 浏览仓库"></a>2.2.3.1 浏览仓库</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574537516.png" srcset="/img/loading.gif" alt="59957453751"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574545418.png" srcset="/img/loading.gif" alt="59957454541"></p><p>正常情况下，在浏览仓库时会要求录入username与password 我们可以清空svn客户端的缓存</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574581006.png" srcset="/img/loading.gif" alt="59957458100"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574590573.png" srcset="/img/loading.gif" alt="59957459057"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574604054.png" srcset="/img/loading.gif" alt="59957460405"></p><h5 id="2-2-3-2-checkout"><a href="#2-2-3-2-checkout" class="headerlink" title="2.2.3.2 checkout"></a>2.2.3.2 checkout</h5><p>检出svn服务器上的项目</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574626916.png" srcset="/img/loading.gif" alt="59957462691"></p><p>一个.svn隐藏目录</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574638762.png" srcset="/img/loading.gif" alt="59957463876"></p><h5 id="2-2-3-3-add"><a href="#2-2-3-3-add" class="headerlink" title="2.2.3.3 add"></a>2.2.3.3 add</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574656075.png" srcset="/img/loading.gif" alt="59957465607"></p><p>这个代表的是它要添加到svn服务器</p><h5 id="2-2-3-4-commit"><a href="#2-2-3-4-commit" class="headerlink" title="2.2.3.4 commit"></a>2.2.3.4 commit</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574680262.png" srcset="/img/loading.gif" alt="59957468026"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574687190.png" srcset="/img/loading.gif" alt="59957468719"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574696118.png" srcset="/img/loading.gif" alt="59957469611"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574709667.png" srcset="/img/loading.gif" alt="59957470966"></p><h5 id="2-2-3-5-update"><a href="#2-2-3-5-update" class="headerlink" title="2.2.3.5 update"></a>2.2.3.5 update</h5><p> Update，它是更新操作,可以将svn服务器上的内容更新到本地</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574724558.png" srcset="/img/loading.gif" alt="59957472455"></p><h5 id="2-2-3-6-更新到历史版本"><a href="#2-2-3-6-更新到历史版本" class="headerlink" title="2.2.3.6 更新到历史版本"></a>2.2.3.6 更新到历史版本</h5><p>查看当前日志</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574746947.png" srcset="/img/loading.gif" alt="59957474694"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574755035.png" srcset="/img/loading.gif" alt="59957475503"></p><p>也可以通过下面的方式来更新历史版本</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574769162.png" srcset="/img/loading.gif" alt="59957476916"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574775435.png" srcset="/img/loading.gif" alt="59957477543"></p><h5 id="2-2-3-7-delete"><a href="#2-2-3-7-delete" class="headerlink" title="2.2.3.7 delete"></a>2.2.3.7 delete</h5><p> 标记删除操作，本地文件会删除，我们需要进行提交，才能真正从服务器删除</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574792131.png" srcset="/img/loading.gif" alt="59957479213"></p><h5 id="2-2-3-8-导入与导出"><a href="#2-2-3-8-导入与导出" class="headerlink" title="2.2.3.8 导入与导出"></a>2.2.3.8 导入与导出</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574804216.png" srcset="/img/loading.gif" alt="59957480421"></p><p>Import将本地资源导入到svn服务器 </p><p>Export导出项目，和checkout的区别,它不存在.svn隐藏文件 </p><h5 id="2-2-3-9-冲突问题与解决"><a href="#2-2-3-9-冲突问题与解决" class="headerlink" title="2.2.3.9 冲突问题与解决"></a>2.2.3.9 冲突问题与解决</h5><p> 多个用户同时操作同一个文件时，就可能产生冲突情况</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574822044.png" srcset="/img/loading.gif" alt="59957482204"></p><p>这个冲突产生后如何解决，我们可以采用手动Merge,解决冲突后，重新commit.</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574833001.png" srcset="/img/loading.gif" alt="59957483300"></p><p>HelloWorld.java 它是服务器上的文件与本地文件合并</p><p>HelloWorld.java.mine 本地修改后的文件</p><p>HelloWorld.java.r4 修改前的文件</p><p>HelloWorld.java.r5 对方修改后的文件</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574852196.png" srcset="/img/loading.gif" alt="59957485219"></p><h3 id="2-3-IDEA下-SVN-配置与使用"><a href="#2-3-IDEA下-SVN-配置与使用" class="headerlink" title="2.3 IDEA下 SVN 配置与使用"></a>2.3 IDEA下 SVN 配置与使用</h3><h4 id="2-3-1-IDEA下svn配置"><a href="#2-3-1-IDEA下svn配置" class="headerlink" title="2.3.1 IDEA下svn配置"></a>2.3.1 IDEA下svn配置</h4><p>前提是我们的电脑上已经安装了TortoiseSVN.</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574884010.png" srcset="/img/loading.gif" alt="59957488401"></p><p>这样安装就完成了</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574894922.png" srcset="/img/loading.gif" alt="59957489492"></p><p>1.Update Project 更新项目</p><p>2.Commit changes 提交项目上所有变化文件 </p><p>3.Compare with the Same Repository Version 当前文件与服务器上该文件通版本的内容进行比较。如果当前编辑的文件没有修改，则是灰色不可点击。</p><p>4.Show history 显示当前文件的历史记录</p><p>5.Revert 还原当前被修改的文件到违背修改的版本状态下</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574912686.png" srcset="/img/loading.gif" alt="59957491268"></p><p>1.Local Changes 本地修改过的文件都会出现在这里</p><p>2.Repository svn仓库所有提交记录</p><p>3.Incoming 本地还没有更新的别人提交的代码</p><h4 id="2-3-2-IDEA-下SVN使用"><a href="#2-3-2-IDEA-下SVN使用" class="headerlink" title="2.3.2 IDEA 下SVN使用"></a>2.3.2 IDEA 下SVN使用</h4><h5 id="2-3-2-1-share-project"><a href="#2-3-2-1-share-project" class="headerlink" title="2.3.2.1 share project"></a>2.3.2.1 share project</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574933859.png" srcset="/img/loading.gif" alt="59957493385"></p><h5 id="2-3-2-2-checkout"><a href="#2-3-2-2-checkout" class="headerlink" title="2.3.2.2 checkout"></a>2.3.2.2 checkout</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574951284.png" srcset="/img/loading.gif" alt="59957495128"></p><p>2.3.2.3 add commit update</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574972187.png" srcset="/img/loading.gif" alt="59957497218"></p><h5 id="2-3-2-4-ignor"><a href="#2-3-2-4-ignor" class="headerlink" title="2.3.2.4 ignor"></a>2.3.2.4 ignor</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599574990295.png" srcset="/img/loading.gif" alt="59957499029"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575000525.png" srcset="/img/loading.gif" alt="59957500052"></p><h5 id="2-3-2-5-解决冲突"><a href="#2-3-2-5-解决冲突" class="headerlink" title="2.3.2.5 解决冲突"></a>2.3.2.5 解决冲突</h5><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575057600.png" srcset="/img/loading.gif" alt="59957505760"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575063792.png" srcset="/img/loading.gif" alt="59957506379"></p><h2 id="3-SVN规范"><a href="#3-SVN规范" class="headerlink" title="3.SVN规范"></a>3.SVN规范</h2><h3 id="3-1-SVN目录规范"><a href="#3-1-SVN目录规范" class="headerlink" title="3.1 SVN目录规范"></a>3.1 SVN目录规范</h3><p> 在visualSVN中创建仓库时，可以选择svn目录结构</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575129609.png" srcset="/img/loading.gif" alt="59957512960"></p><p>Trunk 主干目录，此目录下的文件为基准文件Branches 用于开发的分支目录</p><p>Tags 用于发布的版本目录</p><p>假设有一个项目OA,我们完成了1.0版本，这时就可以打一个tags</p><p>后续我们在OA项目上添加一个新的模块(及时通讯),我们就可以开一个分支,又有一个公司需要在我们OA基础上添加财务管理模块，我们又可以打一个分支。</p><p>我们后续针对OA的1.0版本在升级，我们不需要原来附加功能,就可以在原来的主干上继续开发，形成OA2.0版本，开发完成后就可以在打一个tags</p><h3 id="3-2分支与标记"><a href="#3-2分支与标记" class="headerlink" title="3.2分支与标记"></a>3.2分支与标记</h3><h4 id="3-2-1-分支或标记规范"><a href="#3-2-1-分支或标记规范" class="headerlink" title="3.2.1.分支或标记规范"></a>3.2.1.分支或标记规范</h4><p>分支的定义规则: Project name+日期时间+功能点 Tags的定义规则 Project name+版本号 版本号定义为三段数字编号 xxx.xxx.xxx 第一个:革命性的产品升级版 第二个:新功能版 第三个:修正bug</p><h4 id="3-2-2-打分支或标记"><a href="#3-2-2-打分支或标记" class="headerlink" title="3.2.2.打分支或标记"></a>3.2.2.打分支或标记</h4><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575173885.png" srcset="/img/loading.gif" alt="59957517388"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575184187.png" srcset="/img/loading.gif" alt="59957518418"></p><p>Tags一般是只读，它代表的是发布的版本，所以我们不要进行改变。</p><h3 id="3-3-主干与分支或标记的合并"><a href="#3-3-主干与分支或标记的合并" class="headerlink" title="3.3 主干与分支或标记的合并"></a>3.3 主干与分支或标记的合并</h3><h4 id="3-3-1-主干合并到分支"><a href="#3-3-1-主干合并到分支" class="headerlink" title="3.3.1 主干合并到分支"></a>3.3.1 主干合并到分支</h4><p>首先保证主干是最新的(先update)，在分支这边进行操作</p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575209370.png" srcset="/img/loading.gif" alt="59957520937"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575221557.png" srcset="/img/loading.gif" alt="59957522155"></p><p><img src="/2020/09/08/SVN%E4%BB%8B%E7%BB%8D/1599575229001.png" srcset="/img/loading.gif" alt="59957522900"></p>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>书城项目后篇</title>
    <link href="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/"/>
    <url>/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="书城项目"><a href="#书城项目" class="headerlink" title="书城项目"></a>书城项目</h1><blockquote><p>几个月前刚接触JavaWeb的项目，现在回过头来对所学知识进行总结</p></blockquote><h1 id="第六阶段–购物车"><a href="#第六阶段–购物车" class="headerlink" title="第六阶段–购物车"></a>第六阶段–购物车</h1><h2 id="1、购物车模块分析"><a href="#1、购物车模块分析" class="headerlink" title="1、购物车模块分析"></a>1、购物车模块分析</h2><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599396185136.png" srcset="/img/loading.gif" alt="59939618513"></p><h2 id="2、购物车模型编写"><a href="#2、购物车模型编写" class="headerlink" title="2、购物车模型编写"></a>2、购物车模型编写</h2><h3 id="2-1、购物车模型："><a href="#2-1、购物车模型：" class="headerlink" title="2.1、购物车模型："></a>2.1、购物车模型：</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 购物车的商品项</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-08  19:50</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartItem</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer count;    <span class="hljs-keyword">private</span> BigDecimal price;    <span class="hljs-keyword">private</span> BigDecimal totalPrice;        get,set...省略&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 购物车对象</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-08  19:57</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cart</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * key是商品编号，</span><span class="hljs-comment">     * value是商品信息</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;Integer,CartItem&gt; items = <span class="hljs-keyword">new</span> LinkedHashMap&lt;Integer,CartItem&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加商品项</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cartItem</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(CartItem cartItem)</span></span>&#123;        <span class="hljs-comment">//先查看购物车是否已经添加过此商品，如果已添加，则数量累加，总金额更新，</span>        <span class="hljs-comment">//如果没有添加过，直接放到集合中</span>        CartItem item = items.get(cartItem.getId());        <span class="hljs-keyword">if</span> (item == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//之前没有添加过此商品</span>            items.put(cartItem.getId(),cartItem);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//已经添加过的情况</span>            item.setCount(item.getCount() + <span class="hljs-number">1</span>);<span class="hljs-comment">//数量累加</span>            item.setTotalPrice(item.getPrice().multiply(<span class="hljs-keyword">new</span> BigDecimal(item.getCount())));<span class="hljs-comment">//得到总金额</span>        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除商品项</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteItem</span><span class="hljs-params">(Integer id)</span></span>&#123;        items.remove(id);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清空购物车</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;        items.clear();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCount</span><span class="hljs-params">(Integer id,Integer count)</span></span>&#123;        <span class="hljs-comment">//先查看购物车中是否有此商品，如果有，修改商品数量，更新总金额</span>        CartItem cartItem = items.get(id);        <span class="hljs-keyword">if</span> (cartItem != <span class="hljs-keyword">null</span>)&#123;            cartItem.setCount(count);<span class="hljs-comment">//修改商品数量</span>            cartItem.setTotalPrice(cartItem.getPrice().multiply(<span class="hljs-keyword">new</span> BigDecimal(cartItem.getCount())));<span class="hljs-comment">//得到总金额</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cart</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cart</span><span class="hljs-params">(Map&lt;Integer,CartItem&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Cart&#123;"</span> +                <span class="hljs-string">"totalCount="</span> + getTotalCount() +                <span class="hljs-string">", totalPrice="</span> + getTotalPrice() +                <span class="hljs-string">", items="</span> + items +                <span class="hljs-string">'&#125;'</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getTotalCount</span><span class="hljs-params">()</span> </span>&#123;        Integer totalCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer,CartItem&gt;entry : items.entrySet())&#123;            totalCount += entry.getValue().getCount();        &#125;        <span class="hljs-keyword">return</span> totalCount;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getTotalPrice</span><span class="hljs-params">()</span> </span>&#123;        BigDecimal totalPrice = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer,CartItem&gt;entry : items.entrySet())&#123;            totalPrice = totalPrice.add(entry.getValue().getTotalPrice());        &#125;        <span class="hljs-keyword">return</span> totalPrice;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Integer,CartItem&gt; <span class="hljs-title">getItems</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> items;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItems</span><span class="hljs-params">(Map&lt;Integer,CartItem&gt; items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.items = items;    &#125;&#125;</code></pre></div><h3 id="2-2、购物车的测试："><a href="#2-2、购物车的测试：" class="headerlink" title="2.2、购物车的测试："></a>2.2、购物车的测试：</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-08  20:30</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartTest</span> </span>&#123;    <span class="hljs-keyword">private</span> Cart cart = <span class="hljs-keyword">new</span> Cart();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">()</span> </span>&#123;        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">2</span>,<span class="hljs-string">"数据结构"</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">200</span>)));        System.out.println(cart);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;        Cart cart = <span class="hljs-keyword">new</span> Cart();        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">2</span>,<span class="hljs-string">"数据结构"</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">200</span>)));        cart.deleteItem(<span class="hljs-number">1</span>);        System.out.println(cart);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        Cart cart = <span class="hljs-keyword">new</span> Cart();        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">2</span>,<span class="hljs-string">"数据结构"</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">200</span>)));        cart.clear();        System.out.println(cart);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCount</span><span class="hljs-params">()</span> </span>&#123;        Cart cart = <span class="hljs-keyword">new</span> Cart();        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.clear();        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">2</span>,<span class="hljs-string">"数据结构"</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">200</span>)));        cart.updateCount(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>);        System.out.println(cart);    &#125;&#125;</code></pre></div><h2 id="3、加入购物车功能的实现"><a href="#3、加入购物车功能的实现" class="headerlink" title="3、加入购物车功能的实现"></a>3、加入购物车功能的实现</h2><p>CartServlet 程序中的代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 加入购物车</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<span class="hljs-comment">//        System.out.println("加入购物车");</span><span class="hljs-comment">//        System.out.println("商品编号：" + req.getParameter("id"));</span>        <span class="hljs-comment">//获取请求的参数 商品编号</span>        <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);        <span class="hljs-comment">//调用bookServlet.queryBookById(id):Book得到图书的信息</span>        Book book = bookService.queryBookById(id);        <span class="hljs-comment">//把图书信息，转换称为CartItem商品项</span>        CartItem cartItem = <span class="hljs-keyword">new</span> CartItem(book.getId(), book.getName(), <span class="hljs-number">1</span>, book.getPrice(), book.getPrice());        <span class="hljs-comment">//调用Cart.addItem(CartItem);添加商品下个</span>        Cart cart = (Cart) req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);        <span class="hljs-keyword">if</span> (cart == <span class="hljs-keyword">null</span>)&#123;            cart = <span class="hljs-keyword">new</span> Cart();            req.getSession().setAttribute(<span class="hljs-string">"cart"</span>,cart);        &#125;        cart.addItem(cartItem);        System.out.println(cart);        System.out.println(<span class="hljs-string">"请求头Referer的值："</span> + req.getHeader(<span class="hljs-string">"Referer"</span>));        <span class="hljs-comment">//最后一个添加的商品的名称</span>        req.getSession().setAttribute(<span class="hljs-string">"lastName"</span>,cartItem.getName());        <span class="hljs-comment">//重定向回商品列表页面</span>        resp.sendRedirect(req.getHeader(<span class="hljs-string">"Referer"</span>));    &#125;</code></pre></div><p>index.jsp 页面 js 的代码：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599396752750.png" srcset="/img/loading.gif" alt="59939675275"></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">$(<span class="hljs-string">"button.addToCart"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript"><span class="hljs-keyword">var</span> bookId = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">"bookId"</span>);</span><span class="actionscript">location.href = <span class="hljs-string">"http://localhost:8080/book/cartServlet?action=addItem&amp;id="</span> + bookId;</span>&#125;);&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>图解说明，如何跳回添加商品的页面：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599396962915.png" srcset="/img/loading.gif" alt="59939696291"></p><h2 id="4、购物车的展示"><a href="#4、购物车的展示" class="headerlink" title="4、购物车的展示"></a>4、购物车的展示</h2><div class="hljs"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">"c"</span> uri=<span class="hljs-string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;&lt;title&gt;购物车&lt;/title&gt;&lt;%--  静态包含base标签,css样式,jQuery文件 --%&gt;&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">"/pages/common/head.jsp"</span>%&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=<span class="hljs-string">"header"</span>&gt;&lt;img <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"logo_img"</span> alt=<span class="hljs-string">""</span> src=<span class="hljs-string">"static/img/logo.gif"</span> &gt;&lt;span class="wel_word"&gt;购物车&lt;/span&gt;&lt;%-- 静态包含，登录成功之后的菜单--%&gt;&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">"/pages/common/login_success_menu.jsp"</span>%&gt;        &lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;            $(function () &#123;                <span class="hljs-comment">//给【删除】绑定单击事件</span>                $(<span class="hljs-string">"a.deleteItem"</span>).click(function () &#123;                    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要删除【"</span> + $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text() +<span class="hljs-string">"】吗?"</span>)                &#125;);                <span class="hljs-comment">//给清空购物车绑定单击事件</span>                $(<span class="hljs-string">"#clearCart"</span>).click(function () &#123;                    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要清空购物车嘛？"</span>);                &#125;);                <span class="hljs-comment">//给输入框绑定失去焦点事件 ==change内容发生改变事件</span>                $(<span class="hljs-string">".updateCount"</span>).change(function () &#123;                    <span class="hljs-comment">//获取商品名称</span>                    <span class="hljs-keyword">var</span> name = $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text();                    <span class="hljs-keyword">var</span> id  = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'bookId'</span>);                    <span class="hljs-comment">//获取商品数量</span>                    <span class="hljs-keyword">var</span> count = <span class="hljs-keyword">this</span>.value;                    <span class="hljs-keyword">if</span>(confirm(<span class="hljs-string">"你确定要将【"</span> + name + <span class="hljs-string">"】商品修改数量为："</span> + count + <span class="hljs-string">"嘛？"</span>))&#123;                        <span class="hljs-comment">//发起请求，给服务器保存修改</span>location.href = <span class="hljs-string">"http://localhost:8080/book/cartServlet?action=updateCount&amp;count="</span> + count +<span class="hljs-string">"&amp;id="</span> + id;                    &#125;<span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">//defaultValue属性是表单项Dom对象的属性值，他表示默认的value属性值</span>                        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.defaultValue;                    &#125;                &#125;);            &#125;);        &lt;/script&gt;&lt;/div&gt;&lt;div id=<span class="hljs-string">"main"</span>&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;商品名称&lt;/td&gt;&lt;td&gt;数量&lt;/td&gt;&lt;td&gt;单价&lt;/td&gt;&lt;td&gt;金额&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;empty sessionScope.cart.items&#125;"</span>&gt;&lt;%--如果购物车空的情况--%&gt;&lt;tr&gt;&lt;td colspan="5"&gt;&lt;a href="index.jsp"&gt;亲，当前购物车为空!快跟小伙伴们去浏览商品吧！！&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:if&gt;&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;not empty sessionScope.cart.items&#125;"</span>&gt;&lt;%--如果购物车非空的情况--%&gt;&lt;c:forEach items=<span class="hljs-string">"$&#123;sessionScope.cart.items&#125;"</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">"entry"</span>&gt;&lt;tr&gt;&lt;td&gt;$&#123;entry.value.name&#125;&lt;/td&gt;&lt;td&gt;                            &lt;input <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"updateCount"</span> style=<span class="hljs-string">"width: 50px"</span>                                   bookId=<span class="hljs-string">"$&#123;entry.value.id&#125;"</span>                                   type=<span class="hljs-string">"text"</span> value=<span class="hljs-string">"$&#123;entry.value.count&#125;"</span>&gt;                        &lt;/td&gt;&lt;td&gt;$&#123;entry.value.price&#125;&lt;/td&gt;&lt;td&gt;$&#123;entry.value.totalPrice&#125;&lt;/td&gt;&lt;td&gt;&lt;a class="deleteItem" href="cartServlet?action=deleteItem&amp;id=$&#123;entry.value.id&#125;"&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/c:if&gt;&lt;/table&gt;&lt;%--如果购物车非空才输出页面的内容 --%&gt;&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;not empty sessionScope.cart.items&#125;"</span>&gt;&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cart_info"</span>&gt;&lt;span class="cart_span"&gt;购物车中共有&lt;span class="b_count"&gt;$&#123;sessionScope.cart.totalCount&#125;&lt;/span&gt;件商品&lt;/span&gt;&lt;span class="cart_span"&gt;总金额&lt;span class="b_price"&gt;$&#123;sessionScope.cart.totalPrice&#125;&lt;/span&gt;元&lt;/span&gt;&lt;span class="cart_span"&gt;&lt;a id="clearCart" href="cartServlet?action=clear"&gt;清空购物车&lt;/a&gt;&lt;/span&gt;&lt;span class="cart_span"&gt;&lt;a href="orderServlet?action=createorder"&gt;去结账&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/c:if&gt;&lt;/div&gt;&lt;%--静态包含页脚内容--%&gt;&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">"/pages/common/footer.jsp"</span>%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><h2 id="5、删除购物车商品项"><a href="#5、删除购物车商品项" class="headerlink" title="5、删除购物车商品项"></a>5、删除购物车商品项</h2><p>CartServlet 程序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除商品项</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteItem</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">//获取商品编号</span>    <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);    <span class="hljs-comment">//获取购物车对象</span>    Cart cart = (Cart)req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);    <span class="hljs-keyword">if</span> (cart != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//删除了购物车商品项</span>        cart.deleteItem(id);        <span class="hljs-comment">//重定向回购物车展示页面</span>        resp.sendRedirect(req.getHeader(<span class="hljs-string">"Referer"</span>));    &#125;    &#125;</code></pre></div><p>购物车/pages/cart/cart.jsp 页面的代码：</p><p>删除的请求地址：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599397125599.png" srcset="/img/loading.gif" alt="59939712559"></p><p>删除的确认提示操作：</p><div class="hljs"><pre><code class="hljs jsp">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;    $(function () &#123;        <span class="hljs-comment">//给【删除】绑定单击事件</span>        $(<span class="hljs-string">"a.deleteItem"</span>).click(function () &#123;            <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要删除【"</span> + $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text() +<span class="hljs-string">"】吗?"</span>)        &#125;);        &lt;/script&gt;</code></pre></div><h2 id="6、清空购物车"><a href="#6、清空购物车" class="headerlink" title="6、清空购物车"></a>6、清空购物车</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 清空购物车</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">//1.获取购物车对象</span>    Cart cart = (Cart) req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);    <span class="hljs-keyword">if</span> (cart != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//清空购物车</span>        cart.clear();        <span class="hljs-comment">//重定向回购物车展示页面</span>        resp.sendRedirect(req.getHeader(<span class="hljs-string">"Referer"</span>));    &#125;&#125;</code></pre></div><p>cart.jsp 页面的内容</p><p>给清空购物车添加请求地址，和添加 id 属性：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599397258023.png" srcset="/img/loading.gif" alt="59939725802"></p><p>清空的确认提示操作：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 给清空购物车绑定单击事件</span>$(<span class="hljs-string">"#clearCart"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要清空购物车吗?"</span>);&#125;)</code></pre></div><h2 id="7、修改购物车商品数量"><a href="#7、修改购物车商品数量" class="headerlink" title="7、修改购物车商品数量"></a>7、修改购物车商品数量</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 修改商品数量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCount</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> count = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"count"</span>),<span class="hljs-number">0</span>);    <span class="hljs-comment">//获取Cart购物车对象</span>    Cart cart = (Cart) req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);    <span class="hljs-keyword">if</span> (cart != <span class="hljs-keyword">null</span>)&#123;        cart.updateCount(id,count);        <span class="hljs-comment">//重定向回购物车展示页面</span>        resp.sendRedirect(req.getHeader(<span class="hljs-string">"Referer"</span>));    &#125;&#125;</code></pre></div><p>修改 pages/cart/cart.jsp 购物车页面：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599397340396.png" srcset="/img/loading.gif" alt="59939734039"></p><p>修改商品数量 js 代码：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//给输入框绑定失去焦点事件 ==change内容发生改变事件</span>          $(<span class="hljs-string">".updateCount"</span>).change(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;              <span class="hljs-comment">//获取商品名称</span>              <span class="hljs-keyword">var</span> name = $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text();              <span class="hljs-keyword">var</span> id  = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'bookId'</span>);              <span class="hljs-comment">//获取商品数量</span>              <span class="hljs-keyword">var</span> count = <span class="hljs-keyword">this</span>.value;              <span class="hljs-keyword">if</span>(confirm(<span class="hljs-string">"你确定要将【"</span> + name + <span class="hljs-string">"】商品修改数量为："</span> + count + <span class="hljs-string">"嘛？"</span>))&#123;                  <span class="hljs-comment">//发起请求，给服务器保存修改</span>location.href = <span class="hljs-string">"http://localhost:8080/book/cartServlet?action=updateCount&amp;count="</span> + count +<span class="hljs-string">"&amp;id="</span> + id;              &#125;<span class="hljs-keyword">else</span> &#123;                  <span class="hljs-comment">//defaultValue属性是表单项Dom对象的属性值，他表示默认的value属性值</span>                  <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.defaultValue;              &#125;          &#125;);</code></pre></div><h2 id="8、首页，购物车数据回显"><a href="#8、首页，购物车数据回显" class="headerlink" title="8、首页，购物车数据回显"></a>8、首页，购物车数据回显</h2><p>在添加商品到购物车的时候，保存最后一个添加的商品名称：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599397411740.png" srcset="/img/loading.gif" alt="59939741174"></p><p>在 pages/client/index.jsp 页面中输出购物车信息：</p><div class="hljs"><pre><code class="hljs jsp">&lt;div style=<span class="hljs-string">"text-align: center"</span>&gt;            &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;not empty sessionScope.cart.items&#125;"</span>&gt;               &lt;%--                    购物车非空--%&gt;               &lt;span id="cartTotalCount"&gt;您的购物车中有$&#123;sessionScope.cart.totalCount&#125;件商品&lt;/span&gt;               &lt;div&gt;                  您刚刚将&lt;span style="color: red" id="cartLastName"&gt;$&#123;sessionScope.lastName&#125;&lt;/span&gt;加入到了购物车中               &lt;/div&gt;            &lt;/c:if&gt;                &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;empty sessionScope.cart.items&#125;"</span>&gt;&lt;%--                    购物车为空--%&gt;                    &lt;span id="cartTotalCount"&gt;&lt;/span&gt;                    &lt;div&gt;                        &lt;span  style="color: red" id="cartLastName" &gt;当前购物车为空&lt;/span&gt;                    &lt;/div&gt;                &lt;/c:if&gt;         &lt;/div&gt;</code></pre></div><h1 id="第七阶段–订单"><a href="#第七阶段–订单" class="headerlink" title="第七阶段–订单"></a>第七阶段–订单</h1><h2 id="1、订单模块的分析："><a href="#1、订单模块的分析：" class="headerlink" title="1、订单模块的分析："></a>1、订单模块的分析：</h2><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599397796975.png" srcset="/img/loading.gif" alt="59939779697"></p><h2 id="2、订单模块的实现"><a href="#2、订单模块的实现" class="headerlink" title="2、订单模块的实现"></a>2、订单模块的实现</h2><h3 id="2-1、创建订单模块的数据库表"><a href="#2-1、创建订单模块的数据库表" class="headerlink" title="2.1、创建订单模块的数据库表"></a>2.1、创建订单模块的数据库表</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">use</span> book;<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order(<span class="hljs-string">`order_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) primary <span class="hljs-keyword">key</span>, <span class="hljs-string">`create_time`</span> datetime,<span class="hljs-string">`price`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">11</span>,<span class="hljs-number">2</span>), <span class="hljs-string">`status`</span> <span class="hljs-built_in">int</span>,<span class="hljs-string">`user_id`</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(<span class="hljs-string">`user_id`</span>) <span class="hljs-keyword">references</span> t_user(<span class="hljs-string">`id`</span>));<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order_item(<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span> auto_increment, <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),<span class="hljs-string">`count`</span> <span class="hljs-built_in">int</span>,<span class="hljs-string">`price`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">11</span>,<span class="hljs-number">2</span>), <span class="hljs-string">`total_price`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">11</span>,<span class="hljs-number">2</span>),<span class="hljs-string">`order_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>),<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(<span class="hljs-string">`order_id`</span>) <span class="hljs-keyword">references</span> t_order(<span class="hljs-string">`order_id`</span>));</code></pre></div><h3 id="2-2、创建订单模块的数据模型"><a href="#2-2、创建订单模块的数据模型" class="headerlink" title="2.2、创建订单模块的数据模型"></a>2.2、创建订单模块的数据模型</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 订单</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  14:21</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;    <span class="hljs-keyword">private</span> String orderId;    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-keyword">private</span> BigDecimal price;    <span class="hljs-comment">//0未发货，1已发货，2表示已签收</span>    <span class="hljs-keyword">private</span> Integer status = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> Integer userId;    get,set省略&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 订单项</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  14:23</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderItem</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer count;    <span class="hljs-keyword">private</span> BigDecimal price;    <span class="hljs-keyword">private</span> BigDecimal totalPrice;    <span class="hljs-keyword">private</span> String orderId;&#125;</code></pre></div><h3 id="2-3、编写订单模块的-Dao-程序和测试"><a href="#2-3、编写订单模块的-Dao-程序和测试" class="headerlink" title="2.3、编写订单模块的 Dao 程序和测试"></a>2.3、编写订单模块的 Dao 程序和测试</h3><p>OrderDao 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderDao</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveOrder</span><span class="hljs-params">(Order order)</span></span>;&#125;</code></pre></div><p>OrderDao 实现</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderDao</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveOrder</span><span class="hljs-params">(Order order)</span> </span>&#123;    String sql = <span class="hljs-string">"insert into t_order(`order_id`,`create_time`,`price`,`status`,`user_id`)</span><span class="hljs-string">    values(?,?,?,?,?)"</span>; <span class="hljs-keyword">return</span> update(sql,order.getOrderId(),order.getCreateTime(),order.getPrice(),order.getStatus(),order.<span class="hljs-function">getUs <span class="hljs-title">erId</span><span class="hljs-params">()</span>)</span>;    &#125;&#125;</code></pre></div><p>OrderItemDao 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderItemDao</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveOrderItem</span><span class="hljs-params">(OrderItem orderItem)</span></span>;&#125;</code></pre></div><p>OrderItemDao 实现</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderItemDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderItemDao</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveOrderItem</span><span class="hljs-params">(OrderItem orderItem)</span> </span>&#123;    String sql = <span class="hljs-string">"insert into t_order_item(`name`,`count`,`price`,`total_price`,`order_id`)</span><span class="hljs-string">    values(?,?,?,?,?)"</span>;    <span class="hljs-keyword">return</span> update(sql,orderItem.getName(),orderItem.getCount(),orderItem.getPrice(),orderItem.getTotalPrice(), orderItem.getOrderId());    &#125;&#125;</code></pre></div><p>测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  15:18</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDaoImplTest</span> </span>&#123;    OrderDao orderDao = <span class="hljs-keyword">new</span> OrderDaoImpl();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span> </span>&#123;        orderDao.saveOrder(<span class="hljs-keyword">new</span> Order(<span class="hljs-string">"123456789"</span>,<span class="hljs-keyword">new</span> Date(),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  15:22</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderItemDaoImplTest</span> </span>&#123;    OrderItemDao orderItemDao = <span class="hljs-keyword">new</span> OrderItemDaoImpl();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveOrderItem</span><span class="hljs-params">()</span> </span>&#123;        orderItemDao.saveOrderItem(<span class="hljs-keyword">new</span> OrderItem(<span class="hljs-keyword">null</span>,<span class="hljs-string">"java从入门到精通"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-string">"123456789"</span>));        orderItemDao.saveOrderItem(<span class="hljs-keyword">new</span> OrderItem(<span class="hljs-keyword">null</span>,<span class="hljs-string">"c从入门到精通"</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">200</span>),<span class="hljs-string">"123456789"</span>));        orderItemDao.saveOrderItem(<span class="hljs-keyword">new</span> OrderItem(<span class="hljs-keyword">null</span>,<span class="hljs-string">"c++从入门到精通"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-string">"123456789"</span>));    &#125;&#125;</code></pre></div><p>2.4、编写订单模块的 Service 和测试</p><p>OrderService 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createOrder</span><span class="hljs-params">(Cart cart,Integer userId)</span></span>;&#125;</code></pre></div><p>OrderService 实现类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  15:31</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-keyword">private</span> OrderDao orderDao = <span class="hljs-keyword">new</span> OrderDaoImpl();    <span class="hljs-keyword">private</span> OrderItemDao orderItemDao = <span class="hljs-keyword">new</span> OrderItemDaoImpl();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createOrder</span><span class="hljs-params">(Cart cart, Integer userId)</span> </span>&#123;        <span class="hljs-comment">//订单号==唯一性</span>        String orderId = System.currentTimeMillis() + <span class="hljs-string">""</span> + userId;        <span class="hljs-comment">//创建一个订单对象</span>        Order order = <span class="hljs-keyword">new</span> Order(orderId,<span class="hljs-keyword">new</span> Date(),cart.getTotalPrice(),<span class="hljs-number">0</span>,userId);        <span class="hljs-comment">//保存订单</span>        orderDao.saveOrder(order);        <span class="hljs-comment">//制造错误500</span>        <span class="hljs-comment">//int i = 12 / 0;</span>        <span class="hljs-comment">//遍历购物车中每一个商品项转换称为订单项保存到数据库</span>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123;            <span class="hljs-comment">//获取每一个购物车中的商品项</span>            CartItem cartItem = entry.getValue();            <span class="hljs-comment">//转换为每一个订单项</span>            OrderItem orderItem = <span class="hljs-keyword">new</span> OrderItem(<span class="hljs-keyword">null</span>,cartItem.getName(),cartItem.getCount(),cartItem.getPrice(),cartItem.getTotalPrice(),orderId);            <span class="hljs-comment">//保存订单项到数据库</span>            orderItemDao.saveOrderItem(orderItem);        &#125;        <span class="hljs-comment">//清空购物车</span>        cart.clear();        <span class="hljs-keyword">return</span> orderId;    &#125;&#125;</code></pre></div><p>测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  15:43</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImplTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> </span>&#123;        Cart cart = <span class="hljs-keyword">new</span> Cart();        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">1</span>,<span class="hljs-string">"java"</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>)));        cart.addItem(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-number">2</span>,<span class="hljs-string">"数据结构"</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>),<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">200</span>)));        OrderService orderService = <span class="hljs-keyword">new</span> OrderServiceImpl();        System.out.println(<span class="hljs-string">"订单号为："</span> + orderService.createOrder(cart, <span class="hljs-number">1</span>));    &#125;&#125;</code></pre></div><p>2.5、编写订单模块的 web 层和页面联调</p><p>修改 OrderService 程序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  15:31</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-keyword">private</span> OrderDao orderDao = <span class="hljs-keyword">new</span> OrderDaoImpl();    <span class="hljs-keyword">private</span> OrderItemDao orderItemDao = <span class="hljs-keyword">new</span> OrderItemDaoImpl();    <span class="hljs-keyword">private</span> BookDao bookDao = <span class="hljs-keyword">new</span> BookDaoImpl();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createOrder</span><span class="hljs-params">(Cart cart, Integer userId)</span> </span>&#123;        <span class="hljs-comment">//订单号==唯一性</span>        String orderId = System.currentTimeMillis() + <span class="hljs-string">""</span> + userId;        <span class="hljs-comment">//创建一个订单对象</span>        Order order = <span class="hljs-keyword">new</span> Order(orderId,<span class="hljs-keyword">new</span> Date(),cart.getTotalPrice(),<span class="hljs-number">0</span>,userId);        <span class="hljs-comment">//保存订单</span>        orderDao.saveOrder(order);        <span class="hljs-comment">//制造错误500</span>        <span class="hljs-comment">//int i = 12 / 0;</span>        <span class="hljs-comment">//遍历购物车中每一个商品项转换称为订单项保存到数据库</span>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, CartItem&gt;entry:cart.getItems().entrySet())&#123;            <span class="hljs-comment">//获取每一个购物车中的商品项</span>            CartItem cartItem = entry.getValue();            <span class="hljs-comment">//转换为每一个订单项</span>            OrderItem orderItem = <span class="hljs-keyword">new</span> OrderItem(<span class="hljs-keyword">null</span>,cartItem.getName(),cartItem.getCount(),cartItem.getPrice(),cartItem.getTotalPrice(),orderId);            <span class="hljs-comment">//保存订单项到数据库</span>            orderItemDao.saveOrderItem(orderItem);            <span class="hljs-comment">//更新库存和销量</span>            Book book = bookDao.queryBookById(cartItem.getId());            book.setSales(book.getSales() + cartItem.getCount());            book.setStock(book.getStock() - cartItem.getCount());            bookDao.updateBook(book);        &#125;        <span class="hljs-comment">//清空购物车</span>        cart.clear();        <span class="hljs-keyword">return</span> orderId;    &#125;&#125;</code></pre></div><p> OrderServlet 程序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-09  15:47</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseServlet</span> </span>&#123;        <span class="hljs-keyword">private</span> OrderService orderService = <span class="hljs-keyword">new</span> OrderServiceImpl();        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生产订单</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createorder</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//先获取Cart购物车对象</span>        Cart cart = (Cart)req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);        <span class="hljs-comment">//获取用户信息，获取UserId</span>        User loginuser = (User) req.getSession().getAttribute(<span class="hljs-string">"user"</span>);        <span class="hljs-keyword">if</span> (loginuser == <span class="hljs-keyword">null</span>)&#123;            req.getRequestDispatcher(<span class="hljs-string">"/pages/user/login.jsp"</span>).forward(req,resp);            <span class="hljs-keyword">return</span>;        &#125;        Integer userId = loginuser.getId();        <span class="hljs-comment">//调用orderService.createOrder(Cart,Userid);,生产订单</span>        String orderId = orderService.createOrder(cart, userId);        <span class="hljs-comment">//req.setAttribute("orderId",orderId);</span>        <span class="hljs-comment">//请求转发</span>        <span class="hljs-comment">//req.getRequestDispatcher("/pages/cart/checkout.jsp").forward(req,resp);</span>        req.getSession().setAttribute(<span class="hljs-string">"orderId"</span>,orderId);        resp.sendRedirect(req.getContextPath()+<span class="hljs-string">"/pages/cart/checkout.jsp"</span>);    &#125;&#125;</code></pre></div><p>修改 pages/cart/cart.jsp 页面，结账的请求地址：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599398521313.png" srcset="/img/loading.gif" alt="59939852131"></p><p>修改 pages/cart/checkout.jsp 页面，输出订单号：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599398536347.png" srcset="/img/loading.gif" alt="59939853634"></p><h1 id="第八阶段–过滤器"><a href="#第八阶段–过滤器" class="headerlink" title="第八阶段–过滤器"></a>第八阶段–过滤器</h1><h2 id="1、使用-Filter-过滤器拦截-pages-manager-所有内容，实现权限检查"><a href="#1、使用-Filter-过滤器拦截-pages-manager-所有内容，实现权限检查" class="headerlink" title="1、使用 Filter 过滤器拦截/pages/manager/所有内容，实现权限检查"></a>1、使用 Filter 过滤器拦截/pages/manager/所有内容，实现权限检查</h2><p>Filter 代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-10  9:26</span><span class="hljs-comment"> * 拦截未登录进入后台</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManagerFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;        Object user = httpServletRequest.getSession().getAttribute(<span class="hljs-string">"user"</span>);        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;            httpServletRequest.getRequestDispatcher(<span class="hljs-string">"/pages/user/login.jsp"</span>).forward(servletRequest,servletResponse);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//放行</span>            filterChain.doFilter(servletRequest,servletResponse);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre></div><p>web.xml中的配置</p><div class="hljs"><pre><code class="hljs xml">web.xml 中的配置：<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>ManagerFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.atguigu.filter.ManagerFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>ManagerFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/pages/manager/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/manager/bookServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><h2 id="2、ThreadLocal-的使用"><a href="#2、ThreadLocal-的使用" class="headerlink" title="2、ThreadLocal 的使用"></a>2、ThreadLocal 的使用</h2><p>ThreadLocal 的作用，它可以解决多线程的数据安全问题。</p><p>ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合）</p><p>ThreadLocal 的特点：</p><p>1、ThreadLocal 可以为当前线程关联一个数据。（它可以像 Map 一样存取数据，key 为当前线程）</p><p>2、每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个ThreadLocal 对象实例。</p><p>3、每个 ThreadLocal 对象实例定义的时候，一般都是 static 类型</p><p>4、ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放。</p><p>测试类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span></span>&#123;    String name = Thread.currentThread().getName(); System.out.println(<span class="hljs-string">"OrderService 当前线程["</span> + name + <span class="hljs-string">"]中保存的数据是："</span> +    ThreadLocalTest.threadLocal.get());    <span class="hljs-keyword">new</span> OrderDao().saveOrder();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDao</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span></span>&#123;    String name = Thread.currentThread().getName(); System.out.println(<span class="hljs-string">"OrderDao 当前线程["</span> + name + <span class="hljs-string">"]中保存的数据是："</span> +    ThreadLocalTest.threadLocal.get());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest</span> </span>&#123; <span class="hljs-comment">//public static Map&lt;String,Object&gt; data = new Hashtable&lt;String,Object&gt;(); </span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Object&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random(); <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 在Run 方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为key 保存到map 中</span>    Integer i = random.nextInt(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 获取当前线程名</span>    String name = Thread.currentThread().getName(); System.out.println(<span class="hljs-string">"线程["</span>+name+<span class="hljs-string">"]生成的随机数是："</span> + i);    <span class="hljs-comment">//data.put(name,i);</span>    threadLocal.set(i);    <span class="hljs-keyword">try</span> &#123;    Thread.sleep(<span class="hljs-number">3000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;    e.printStackTrace();    &#125;    <span class="hljs-keyword">new</span> OrderService().createOrder();    <span class="hljs-comment">// 在Run 方法结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作</span>    <span class="hljs-comment">//Object o = data.get(name);</span>    Object o = threadLocal.get();    System.out.println(<span class="hljs-string">"在线程["</span>+name+<span class="hljs-string">"]快结束时取出关联的数据是："</span> + o);    &#125; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Task()).start();        &#125;&#125; &#125;</code></pre></div><h2 id="3、使用-Filter-和-ThreadLocal-组合管理事务"><a href="#3、使用-Filter-和-ThreadLocal-组合管理事务" class="headerlink" title="3、使用 Filter 和 ThreadLocal 组合管理事务"></a>3、使用 Filter 和 ThreadLocal 组合管理事务</h2><h3 id="3-1、使用-ThreadLocal来确保所有-dao-操作都在同一个-Connection-连接对象中完成"><a href="#3-1、使用-ThreadLocal来确保所有-dao-操作都在同一个-Connection-连接对象中完成" class="headerlink" title="3.1、使用 ThreadLocal来确保所有 dao 操作都在同一个 Connection 连接对象中完成"></a>3.1、使用 ThreadLocal来确保所有 dao 操作都在同一个 Connection 连接对象中完成</h3><p>原理分析图：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599443937060.png" srcset="/img/loading.gif" alt="59944393706"></p><p>JdbcUtils 工具类的修改：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  20:52</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DruidDataSource dataSource;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; conns = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Properties properties = <span class="hljs-keyword">new</span> Properties();            <span class="hljs-comment">//读取jdbc.properties属性配置文件</span>            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");            <span class="hljs-comment">//从流中加载数据</span>            properties.load(inputStream);            <span class="hljs-comment">//创建 数据库连接池</span>            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);            <span class="hljs-comment">//测试代码</span>            <span class="hljs-comment">//System.out.println(dataSource.getConnection());</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取数据库连接池中的连接</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回null, 说明获取连接失败，有值就是获取连接成功</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//同一个线程获取</span>        Connection conn = conns.get();        <span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//从数据库连接池获取连接</span>                conn = dataSource.getConnection();                conns.set(conn);<span class="hljs-comment">//保存到ThreadLocal对象中，供后面jdbc使用</span>                conn.setAutoCommit(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//设置为手动管理</span>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">return</span> conn;        <span class="hljs-comment">//        Connection conn = null;</span><span class="hljs-comment">//        try &#123;</span><span class="hljs-comment">//            conn = dataSource.getConnection();</span><span class="hljs-comment">//        &#125; catch (SQLException e) &#123;</span><span class="hljs-comment">//            e.printStackTrace();</span><span class="hljs-comment">//        &#125; finally &#123;</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//        return conn;</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提交事务，并关闭释放连接</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitAndClose</span><span class="hljs-params">()</span></span>&#123;        Connection conn = conns.get();        <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//如果不等于null，说明之前使用过数据库</span>            <span class="hljs-keyword">try</span> &#123;                conn.commit();<span class="hljs-comment">//提交事务</span>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();<span class="hljs-comment">//关闭连接，释放资源</span>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-comment">//一定要执行remove操作，否则就会出错，（因为Tomcat底层使用了线程池技术</span>        conns.remove();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 回滚事务，并关闭释放连接</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollbackAdnClose</span><span class="hljs-params">()</span></span>&#123;        Connection conn = conns.get();        <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//如果不等于null，说明之前使用过数据库</span>            <span class="hljs-keyword">try</span> &#123;                conn.rollback();<span class="hljs-comment">//回滚事务</span>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    conn.close();<span class="hljs-comment">//关闭连接，释放资源</span>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="hljs-comment">//一定要执行remove操作，否则就会出错，（因为Tomcat底层使用了线程池技术</span>        conns.remove();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 关闭连接，放回数据库连接池</span><span class="hljs-comment"></span><span class="hljs-comment">    public static void close(Connection conn) &#123;</span><span class="hljs-comment">        if (conn != null) &#123;</span><span class="hljs-comment">            try &#123;</span><span class="hljs-comment">                conn.close();</span><span class="hljs-comment">            &#125; catch (SQLException e) &#123;</span><span class="hljs-comment">                e.printStackTrace();</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">     */</span>&#125;</code></pre></div><p>修改 BaseDao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dao.impl;<span class="hljs-keyword">import</span> com.utils.JdbcUtils;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.QueryRunner;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;<span class="hljs-keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  21:17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDao</span> </span>&#123;    <span class="hljs-comment">//使用DbUtils操作数据库</span>    <span class="hljs-keyword">private</span> QueryRunner queryRunner = <span class="hljs-keyword">new</span> QueryRunner();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * update()方法用来执行，Insert/Update/Delete语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果返回-1，说明执行失败 返回其他表示影响的行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql,Object ...args)</span></span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.update(connection,sql,args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询返回一个javaBean的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 返回的对象类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql   执行的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args  sql对应的参数值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;   返回的类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T  <span class="hljs-title">queryForOne</span><span class="hljs-params">(Class&lt;T&gt; type,String sql,Object ...args)</span></span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.query(connection,sql,<span class="hljs-keyword">new</span> BeanHandler&lt;T&gt;(type),args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询返回多个javaBean的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 返回的对象类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql   执行的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args  sql对应的参数值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;   返回的类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">queryForList</span><span class="hljs-params">(Class&lt;T&gt; type,String sql,Object ...args)</span> </span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> BeanListHandler&lt;T&gt;(type), args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 执行返回一行一列的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql   执行的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args  sql对应的参数值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">queryForSingleValue</span><span class="hljs-params">(String sql,Object ...args)</span></span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.query(connection,sql,<span class="hljs-keyword">new</span> ScalarHandler(),args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e)&#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;&#125;</code></pre></div><h3 id="3-2、使用-Filter-过滤器统一给所有的-Service-方法都加上-try-catch。来进行实现的管理"><a href="#3-2、使用-Filter-过滤器统一给所有的-Service-方法都加上-try-catch。来进行实现的管理" class="headerlink" title="3.2、使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。来进行实现的管理"></a>3.2、使用 Filter 过滤器统一给所有的 Service 方法都加上 try-catch。来进行实现的管理</h3><p>原理分析图：</p><p><img src="/2020/09/06/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AF%87/1599444024722.png" srcset="/img/loading.gif" alt="59944402472"></p><p>Filter 类代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 为所有工程统一加上try catch</span><span class="hljs-comment"> * 并把异常都抛给Tomcat服务器处理</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-10  13:25</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        <span class="hljs-keyword">try</span> &#123;            filterChain.doFilter(servletRequest,servletResponse);            JdbcUtils.commitAndClose();<span class="hljs-comment">//提交事务</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            JdbcUtils.rollbackAdnClose();<span class="hljs-comment">//回滚事务</span>            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<span class="hljs-comment">//把异常抛给Tomcat管理展示友好错误页面</span>        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre></div><p>在 web.xml 中的配置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>TransactionFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.atguigu.filter.TransactionFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>TransactionFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span> <span class="hljs-comment">&lt;!-- /* 表示当前工程下所有请求 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div><p>一定要记得把 BaseServlet 中的异常往外抛给 Filter 过滤器</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-05  18:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doPost(req, resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);<span class="hljs-comment">//关键 解决post乱码问题</span>        <span class="hljs-comment">//解决响应的中文乱码</span>        resp.setContentType(<span class="hljs-string">"text/html; charset=UTF-8"</span>);        String action = req.getParameter(<span class="hljs-string">"action"</span>);        <span class="hljs-keyword">try</span> &#123;            Method method = <span class="hljs-keyword">this</span>.getClass().getDeclaredMethod(action,HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>)</span>;            method.invoke(<span class="hljs-keyword">this</span>,req,resp);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<span class="hljs-comment">//把异常抛给Filter过滤器</span>    &#125;    &#125;&#125;</code></pre></div><h3 id="3-3、将所有异常都统一交给-Tomcat，让-Tomcat-展示友好的错误信息页面"><a href="#3-3、将所有异常都统一交给-Tomcat，让-Tomcat-展示友好的错误信息页面" class="headerlink" title="3.3、将所有异常都统一交给 Tomcat，让 Tomcat 展示友好的错误信息页面"></a>3.3、将所有异常都统一交给 Tomcat，让 Tomcat 展示友好的错误信息页面</h3><p>在 web.xml 中我们可以通过错误页面配置来进行管理</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span>    <span class="hljs-comment">&lt;!--error-code 是错误类型--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>500<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span>    <span class="hljs-comment">&lt;!--location 标签表示。要跳转去的页面路径--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/pages/error/error500.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><span class="hljs-comment">&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span>    <span class="hljs-comment">&lt;!--error-code 是错误类型--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span>    <span class="hljs-comment">&lt;!--location 标签表示。要跳转去的页面路径--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/pages/error/error404.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span></code></pre></div><h1 id="第九阶段–Ajax"><a href="#第九阶段–Ajax" class="headerlink" title="第九阶段–Ajax"></a>第九阶段–Ajax</h1><h2 id="1、Ajax-验证用户名是否可用"><a href="#1、Ajax-验证用户名是否可用" class="headerlink" title="1、Ajax 验证用户名是否可用"></a>1、Ajax 验证用户名是否可用</h2><p>使用 Ajax 验证用户名是否可用。我们需要在页面端，给用户名输入框添加一个失去焦点事件。当用户名输入框失去</p><p>焦点的时候，触发事件。获取输入的用户名。然后发送 Ajax 请求到服务器諯去验证。</p><p>然后服务器通过 json 数据，返回是否存在，result  为 0  表示 不存在，result 为 1 表示存在。当然我们还要做一个用户名不为空的简单验证。才能让请求发送到服务器端。</p><h3 id="1-1、修改pages-user-regist-jsp-页面。给用户名输入框添加失去焦点事件"><a href="#1-1、修改pages-user-regist-jsp-页面。给用户名输入框添加失去焦点事件" class="headerlink" title="1.1、修改pages/user/regist.jsp 页面。给用户名输入框添加失去焦点事件"></a>1.1、修改pages/user/regist.jsp 页面。给用户名输入框添加失去焦点事件</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//页面加载完成后</span>        $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            $(<span class="hljs-string">"#username"</span>).blur(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;               <span class="hljs-comment">//1 获取用户名</span>               <span class="hljs-keyword">var</span> username = <span class="hljs-keyword">this</span>.value;               $.getJSON(<span class="hljs-string">"http://localhost:8080/book/userServlet"</span>,<span class="hljs-string">"action=ajaxExistsUsername&amp;username="</span> + username,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;                    <span class="hljs-comment">// console.log(data)</span>                   <span class="hljs-keyword">if</span> (data.existUsername)&#123;                       $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"用户名已存在！"</span>);                   &#125;<span class="hljs-keyword">else</span> &#123;                       $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"用户名可用！"</span>);                   &#125;               &#125;);            &#125;);</code></pre></div><h3 id="1-2、修改-UserServlet-类，添加检查用户名是否存在的方法："><a href="#1-2、修改-UserServlet-类，添加检查用户名是否存在的方法：" class="headerlink" title="1.2、修改 UserServlet 类，添加检查用户名是否存在的方法："></a>1.2、修改 UserServlet 类，添加检查用户名是否存在的方法：</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 用ajax验证用户是否存在，并将数据传输到客户端</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ajaxExistsUsername</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    <span class="hljs-comment">//获取请求的参数username</span>    String username = req.getParameter(<span class="hljs-string">"username"</span>);    <span class="hljs-comment">//调用userService.existUsername</span>    <span class="hljs-keyword">boolean</span> existUsername = userService.existUsername(username);    <span class="hljs-comment">//把返回的结果封装成为map对象</span>    Map&lt;String,Object&gt; resultMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    resultMap.put(<span class="hljs-string">"existUsername"</span>,existUsername);    Gson gson = <span class="hljs-keyword">new</span> Gson();    String json = gson.toJson(resultMap);    resp.getWriter().write(json);&#125;</code></pre></div><h2 id="2、Ajax-修改购物车模块—添加商品—修改数量"><a href="#2、Ajax-修改购物车模块—添加商品—修改数量" class="headerlink" title="2、Ajax 修改购物车模块—添加商品—修改数量"></a>2、Ajax 修改购物车模块—添加商品—修改数量</h2><p>以 Ajax 请求的方式修改购物车的模块。我们修改的功能有，添加到购物车，修改数量，以及删除商品，和清空购物车。我们以添加购物车和修改商品数量为例给大家演示</p><h3 id="2-1、添加商品"><a href="#2-1、添加商品" class="headerlink" title="2.1、添加商品"></a>2.1、添加商品</h3><p>添加商品到购物车。首先我们要把商品的编号，以 Ajax 的方式传到服务器。然后器添加成功后把购物车的数量，最后一本书的名字返回，给用户显示。</p><h4 id="2-1-1、修改"><a href="#2-1-1、修改" class="headerlink" title="2.1.1、修改"></a>2.1.1、修改</h4><p> pages/client/index.jsp 页面，添加购物车的 a 标签代码</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"book_add"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bookId</span>=<span class="hljs-string">"$&#123;book.id&#125;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"addToCart"</span>&gt;</span>加入购物车<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="2-1-2、添加-Ajax-请求的-js-代码"><a href="#2-1-2、添加-Ajax-请求的-js-代码" class="headerlink" title="2.1.2、添加 Ajax 请求的 js 代码"></a>2.1.2、添加 Ajax 请求的 js 代码</h4><div class="hljs"><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;   $(<span class="hljs-string">"button.addToCart"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">var</span> bookId = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">"bookId"</span>);      <span class="hljs-comment">//location.href = "http://localhost:8080/book/cartServlet?action=addItem&amp;id=" + bookId;</span>      $.getJSON(<span class="hljs-string">"http://localhost:8080/book/cartServlet"</span>,<span class="hljs-string">"action=ajaxAddItem&amp;id="</span> + bookId,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;         $(<span class="hljs-string">"#cartTotalCount"</span>).text(<span class="hljs-string">"您的购物车中有"</span>+ data.totalCount +<span class="hljs-string">"件商品"</span>);         $(<span class="hljs-string">"#cartLastName"</span>).text(data.lastName);      &#125;);      <span class="hljs-comment">//未解之谜，无刷新出问题，刷新一次俩次出问题，刷新三次正常</span>      <span class="hljs-built_in">window</span>.location.reload();      <span class="hljs-built_in">window</span>.location.reload();      <span class="hljs-built_in">window</span>.location.reload();   &#125;);   <span class="hljs-comment">//window.location.reload();</span>&#125;);</code></pre></div><h4 id="2-1-3、修改添加购物车后。搜索下方的购物车显示"><a href="#2-1-3、修改添加购物车后。搜索下方的购物车显示" class="headerlink" title="2.1.3、修改添加购物车后。搜索下方的购物车显示"></a>2.1.3、修改添加购物车后。搜索下方的购物车显示</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">c:if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"$&#123;not empty sessionScope.cart.items&#125;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">%--</span>                    购物车非空<span class="hljs-attr">--</span>%&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cartTotalCount"</span>&gt;</span>您的购物车中有$&#123;sessionScope.cart.totalCount&#125;件商品<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                您刚刚将<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: red"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cartLastName"</span>&gt;</span>$&#123;sessionScope.lastName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>加入到了购物车中            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">c:if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">c:if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"$&#123;empty sessionScope.cart.items&#125;"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">%--</span>                    购物车为空<span class="hljs-attr">--</span>%&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cartTotalCount"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">"color: red"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cartLastName"</span> &gt;</span>当前购物车为空<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">c:if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="2-1-4、CartServlet-中添加-Ajax-版的添加购物车代码"><a href="#2-1-4、CartServlet-中添加-Ajax-版的添加购物车代码" class="headerlink" title="2.1.4、CartServlet 中添加 Ajax 版的添加购物车代码"></a>2.1.4、CartServlet 中添加 Ajax 版的添加购物车代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用ajax异步添加购物车</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ajaxAddItem</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<span class="hljs-comment">//        System.out.println("加入购物车");</span><span class="hljs-comment">//        System.out.println("商品编号：" + req.getParameter("id"));</span>        <span class="hljs-comment">//获取请求的参数 商品编号</span>        <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);        <span class="hljs-comment">//调用bookServlet.queryBookById(id):Book得到图书的信息</span>        Book book = bookService.queryBookById(id);        <span class="hljs-comment">//把图书信息，转换称为CartItem商品项</span>        CartItem cartItem = <span class="hljs-keyword">new</span> CartItem(book.getId(), book.getName(), <span class="hljs-number">1</span>, book.getPrice(), book.getPrice());        <span class="hljs-comment">//调用Cart.addItem(CartItem);添加商品下个</span>        Cart cart = (Cart) req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);        <span class="hljs-keyword">if</span> (cart == <span class="hljs-keyword">null</span>)&#123;            cart = <span class="hljs-keyword">new</span> Cart();            req.getSession().setAttribute(<span class="hljs-string">"cart"</span>,cart);        &#125;        cart.addItem(cartItem);        System.out.println(cart);        System.out.println(<span class="hljs-string">"请求头Referer的值："</span> + req.getHeader(<span class="hljs-string">"Referer"</span>));        <span class="hljs-comment">//最后一个添加的商品的名称</span>        req.getSession().setAttribute(<span class="hljs-string">"lastName"</span>,cartItem.getName());       Map&lt;String,Object&gt; resultMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();       resultMap.put(<span class="hljs-string">"totalCount"</span>,cart.getTotalCount());       resultMap.put(<span class="hljs-string">"lastName"</span>,cartItem.getName());        Gson gson = <span class="hljs-keyword">new</span> Gson();        String resultMapJsonString = gson.toJson(resultMap);        resp.getWriter().write(resultMapJsonString);    &#125;</code></pre></div><h3 id="2-2、修改数量"><a href="#2-2、修改数量" class="headerlink" title="2.2、修改数量"></a>2.2、修改数量</h3><p>修改购物车数量，我们要把修改的商品编号和数量发送到服务器。然后服务器把修改后商品的总价 item_totalMoney，购物车的总数量 cart_totalCount，以及购物车的总金额 cart_totalMoney 返回用于前端的修改</p><h4 id="2-2-1、修改原来购物车更新数量的方法，返回修改后商品的总金额"><a href="#2-2-1、修改原来购物车更新数量的方法，返回修改后商品的总金额" class="headerlink" title="2.2.1、修改原来购物车更新数量的方法，返回修改后商品的总金额"></a>2.2.1、修改原来购物车更新数量的方法，返回修改后商品的总金额</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  更新商品数量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> count</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCount</span><span class="hljs-params">(Integer id,Integer count)</span></span>&#123;    <span class="hljs-comment">//先查看购物车中是否有此商品，如果有，修改商品数量，更新总金额</span>    CartItem cartItem = items.get(id);    <span class="hljs-keyword">if</span> (cartItem != <span class="hljs-keyword">null</span>)&#123;        cartItem.setCount(count);<span class="hljs-comment">//修改商品数量</span>        cartItem.setTotalPrice(cartItem.getPrice().multiply(<span class="hljs-keyword">new</span> BigDecimal(cartItem.getCount())));<span class="hljs-comment">//得到总金额</span>    &#125;&#125;</code></pre></div><p>修改为：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  更新商品数量，带返回值</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> count</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">updateCount</span><span class="hljs-params">(Integer id,Integer count)</span></span>&#123;    <span class="hljs-comment">//先查看购物车中是否有此商品，如果有，修改商品数量，更新总金额</span>    CartItem cartItem = items.get(id);    <span class="hljs-keyword">if</span> (cartItem != <span class="hljs-keyword">null</span>)&#123;        cartItem.setCount(count);<span class="hljs-comment">//修改商品数量</span>        cartItem.setTotalPrice(cartItem.getPrice().multiply(<span class="hljs-keyword">new</span> BigDecimal(cartItem.getCount())));<span class="hljs-comment">//得到总金额</span>        <span class="hljs-keyword">return</span> cartItem.getTotalPrice();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">0</span>);&#125;</code></pre></div><h4 id="2-2-2、修改-pages-cart-cart-jsp-页面中的内容"><a href="#2-2-2、修改-pages-cart-cart-jsp-页面中的内容" class="headerlink" title="2.2.2、修改 pages/cart/cart.jsp 页面中的内容"></a>2.2.2、修改 pages/cart/cart.jsp 页面中的内容</h4><div class="hljs"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">"c"</span> uri=<span class="hljs-string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;&lt;title&gt;购物车&lt;/title&gt;   &lt;%--  静态包含base标签,css样式,jQuery文件 --%&gt;   &lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">"/pages/common/head.jsp"</span>%&gt;&lt;/head&gt;&lt;body&gt;      &lt;div id=<span class="hljs-string">"header"</span>&gt;         &lt;img <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"logo_img"</span> alt=<span class="hljs-string">""</span> src=<span class="hljs-string">"static/img/logo.gif"</span> &gt;         &lt;span class="wel_word"&gt;购物车&lt;/span&gt;      &lt;%-- 静态包含，登录成功之后的菜单--%&gt;      &lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">"/pages/common/login_success_menu.jsp"</span>%&gt;        &lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;            $(function () &#123;                <span class="hljs-comment">//给【删除】绑定单击事件</span>                $(<span class="hljs-string">"a.deleteItem"</span>).click(function () &#123;                    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要删除【"</span> + $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text() +<span class="hljs-string">"】吗?"</span>)                &#125;);                <span class="hljs-comment">//给清空购物车绑定单击事件</span>                $(<span class="hljs-string">"#clearCart"</span>).click(function () &#123;                    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要清空购物车嘛？"</span>);                &#125;);                <span class="hljs-comment">//给输入框绑定失去焦点事件 ==change内容发生改变事件</span>                $(<span class="hljs-string">".updateCount"</span>).change(function () &#123;                    <span class="hljs-comment">//获取商品名称</span>                    <span class="hljs-keyword">var</span> name = $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text();                    <span class="hljs-keyword">var</span> id  = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'bookId'</span>);                    <span class="hljs-comment">//获取商品数量</span>                    <span class="hljs-keyword">var</span> count = <span class="hljs-keyword">this</span>.value;                    <span class="hljs-keyword">if</span>(confirm(<span class="hljs-string">"你确定要将【"</span> + name + <span class="hljs-string">"】商品修改数量为："</span> + count + <span class="hljs-string">"嘛？"</span>))&#123;                        <span class="hljs-comment">//发起请求，给服务器保存修改</span>                  <span class="hljs-comment">//location.href = "http://localhost:8080/book/cartServlet?action=updateCount&amp;count=" + count +"&amp;id=" + id;</span>                  <span class="hljs-keyword">var</span> id = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">"data"</span>); <span class="hljs-comment">// 修改请求为 Ajax</span>                  $.getJSON(<span class="hljs-string">"cartServlet?action=ajaxUpdateItem&amp;id="</span> + id +                        <span class="hljs-string">"&amp;count="</span> + count,                        function(data)&#123;                           alert( JSON.stringify(data) );                           <span class="hljs-comment">//$("#item_totalMoney_" + id).html(data.item_totalMoney);</span>                           <span class="hljs-comment">//$("#cart_totalCount").html(data.cart_totalCount);</span>                           <span class="hljs-comment">//$("#cart_totalMoney").html(data.cart_totalMoney);</span>                        &#125;);               &#125;<span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">//defaultValue属性是表单项Dom对象的属性值，他表示默认的value属性值</span>                        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.defaultValue;                    &#125;                &#125;);            &#125;);        &lt;/script&gt;   &lt;/div&gt;      &lt;div id=<span class="hljs-string">"main"</span>&gt;         &lt;table&gt;         &lt;tr&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;数量&lt;/td&gt;            &lt;td&gt;单价&lt;/td&gt;            &lt;td&gt;金额&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;         &lt;/tr&gt;         &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;empty sessionScope.cart.items&#125;"</span>&gt;            &lt;%--如果购物车空的情况--%&gt;            &lt;tr&gt;               &lt;td colspan="5"&gt;&lt;a href="index.jsp"&gt;亲，当前购物车为空!快跟小伙伴们去浏览商品吧！！&lt;/a&gt;&lt;/td&gt;            &lt;/tr&gt;         &lt;/c:if&gt;         &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;not empty sessionScope.cart.items&#125;"</span>&gt;            &lt;%--如果购物车非空的情况--%&gt;            &lt;c:forEach items=<span class="hljs-string">"$&#123;sessionScope.cart.items&#125;"</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">"entry"</span>&gt;               &lt;tr&gt;                  &lt;td&gt;$&#123;entry.value.name&#125;&lt;/td&gt;                  &lt;td&gt;                            &lt;input <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"updateCount"</span> style=<span class="hljs-string">"width: 50px"</span>                                   bookId=<span class="hljs-string">"$&#123;entry.value.id&#125;"</span>                                   type=<span class="hljs-string">"text"</span> value=<span class="hljs-string">"$&#123;entry.value.count&#125;"</span>&gt;                        &lt;/td&gt;                  &lt;td&gt;$&#123;entry.value.price&#125;&lt;/td&gt;                  &lt;td id="item_totalMoney_$&#123; cartItem.id &#125;"&gt;$&#123;entry.value.totalPrice&#125;&lt;/td&gt;                  &lt;td&gt;&lt;a class="deleteItem" href="cartServlet?action=deleteItem&amp;id=$&#123;entry.value.id&#125;"&gt;删除&lt;/a&gt;&lt;/td&gt;               &lt;/tr&gt;            &lt;/c:forEach&gt;         &lt;/c:if&gt;               &lt;/table&gt;      &lt;%--如果购物车非空才输出页面的内容 --%&gt;      &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">"$&#123;not empty sessionScope.cart.items&#125;"</span>&gt;         &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"cart_info"</span>&gt;            &lt;span class="cart_span"&gt;购物车中共有&lt;span id="cart_totalCount" class="b_count"&gt;$&#123;sessionScope.cart.totalCount&#125;&lt;/span&gt;件商品&lt;/span&gt;            &lt;span class="cart_span"&gt;总金额&lt;span id="cart_totalMoney" class="b_price"&gt;$&#123;sessionScope.cart.totalPrice&#125;&lt;/span&gt;元&lt;/span&gt;            &lt;span class="cart_span"&gt;&lt;a id="clearCart" href="cartServlet?action=clear"&gt;清空购物车&lt;/a&gt;&lt;/span&gt;            &lt;span class="cart_span"&gt;&lt;a href="orderServlet?action=createorder"&gt;去结账&lt;/a&gt;&lt;/span&gt;         &lt;/div&gt;      &lt;/c:if&gt;      &lt;/div&gt;   &lt;%--   静态包含页脚内容--%&gt;   &lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">"/pages/common/footer.jsp"</span>%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><h4 id="2-2-3、添加-CartServlet-中-ajaxUpdateItem-方法实现-Ajax-请求的修改购物车商品数量"><a href="#2-2-3、添加-CartServlet-中-ajaxUpdateItem-方法实现-Ajax-请求的修改购物车商品数量" class="headerlink" title="2.2.3、添加 CartServlet 中 ajaxUpdateItem 方法实现 Ajax 请求的修改购物车商品数量"></a>2.2.3、添加 CartServlet 中 ajaxUpdateItem 方法实现 Ajax 请求的修改购物车商品数量</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * ajax版 -- 修改商品数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ajaxUpdateCount</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> count = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"count"</span>),<span class="hljs-number">1</span>);        <span class="hljs-comment">//获取Cart购物车对象</span>        Cart cart = (Cart) req.getSession().getAttribute(<span class="hljs-string">"cart"</span>);        <span class="hljs-keyword">if</span> (cart == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//生成一个新的购物车存放到Session对象中</span>            cart = <span class="hljs-keyword">new</span> Cart();            req.getSession().setAttribute(<span class="hljs-string">"cart"</span>,cart);        &#125;        <span class="hljs-comment">//更新商品</span>        BigDecimal totalMoney = cart.updateCount(id, count);        <span class="hljs-comment">//创建一个Map返回要显示的内容</span>        Map&lt;String,Object&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        result.put(<span class="hljs-string">"item_totalMoney"</span>,<span class="hljs-string">""</span> + totalMoney);        result.put(<span class="hljs-string">"cart_totalMoney"</span>,cart.getTotalPrice());        result.put(<span class="hljs-string">"cart_totalCount"</span>,cart.getTotalCount());        Gson gson = <span class="hljs-keyword">new</span> Gson();        resp.getWriter().write(gson.toJson(result));        <span class="hljs-comment">//重定向回购物车展示页面</span><span class="hljs-comment">//        resp.sendRedirect(req.getHeader("Referer"));</span>    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>书城项目前篇</title>
    <link href="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/"/>
    <url>/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="书城项目"><a href="#书城项目" class="headerlink" title="书城项目"></a>书城项目</h1><blockquote><p>几个月前刚接触JavaWeb的项目，现在回过头来对所学知识进行总结</p></blockquote><h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><p>本项目是基于原生底层技术，核心技术点主要有：<br>Servlet程序、Filter过滤器、Listener监听器、jsp页面、EL表达式、JSTL标签库、jQuery框架、Cookie技术、Session会话、JSON使用、Ajax请求。<br>目标：、理解、会用。并为后期框架、框架的学习打下坚实的基础</p><h2 id="第一阶段–表单验证"><a href="#第一阶段–表单验证" class="headerlink" title="第一阶段–表单验证"></a>第一阶段–表单验证</h2><p>用于在用户登录和注册时使用的逻辑</p><p>验证用户名：必须由字母，数字下划线组成，并且长度为 5 到 12位验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位</p><p>验证确认密码：和密码相同    </p><p>邮箱验证：<a href="mailto:xxxxx@xxx.com">xxxxx@xxx.com</a></p><p>验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成。</p><h3 id="1、新建一个模块"><a href="#1、新建一个模块" class="headerlink" title="1、新建一个模块"></a>1、新建一个模块</h3><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599307883227.png" srcset="/img/loading.gif" alt="59930788322"></p><h3 id="2、把书城的静态资源拷贝到-05-book-static-工程下："><a href="#2、把书城的静态资源拷贝到-05-book-static-工程下：" class="headerlink" title="2、把书城的静态资源拷贝到 05_book_static 工程下："></a>2、把书城的静态资源拷贝到 05_book_static 工程下：</h3><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599307915123.png" srcset="/img/loading.gif" alt="59930791512"></p><h3 id="3、验证实现如下："><a href="#3、验证实现如下：" class="headerlink" title="3、验证实现如下："></a>3、验证实现如下：</h3><div class="hljs"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;<span class="hljs-comment">//给注册绑定单击事件</span>            $(<span class="hljs-string">"#sub_btn"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-comment">//验证用户名：必须由字母，数字下划线组成，并且长度为5到12位</span>                <span class="hljs-comment">//1 获取用户名输入框里的内容</span>                <span class="hljs-keyword">var</span> usernameTest = $(<span class="hljs-string">"#username"</span>).val();                <span class="hljs-comment">//2 创建正则表达式对象</span>                <span class="hljs-keyword">var</span> usernamePatt = <span class="hljs-regexp">/^\w&#123;5,12&#125;$/</span>;                <span class="hljs-comment">//3 使用test方法验证</span>                <span class="hljs-keyword">if</span> (!usernamePatt.test(usernameTest)) &#123;                    <span class="hljs-comment">//4 提醒用户不合法</span>                    $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"用户名不合法!"</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-comment">// 验证密码：必须由字母，数字下划线组成，并且长度为5到12位</span>                <span class="hljs-comment">//1 获取用户名输入框里的内容</span>                <span class="hljs-keyword">var</span> passwordText = $(<span class="hljs-string">"#password"</span>).val();                <span class="hljs-comment">//2 创建正则表达式对象</span>                <span class="hljs-keyword">var</span> passwordPatt = <span class="hljs-regexp">/^\w&#123;5,12&#125;$/</span>;                <span class="hljs-comment">//3 使用test方法验证</span>                <span class="hljs-keyword">if</span> (!passwordPatt.test(passwordText)) &#123;                    <span class="hljs-comment">//4 提示用户结果</span>                    $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"密码不合法！"</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-comment">//验证确认密码，和密码相同</span>                <span class="hljs-comment">//1.获取确认密码内容</span>                <span class="hljs-keyword">var</span> repwdText = $(<span class="hljs-string">"#repwd"</span>).val();                <span class="hljs-comment">//2 和密码相比较</span>                <span class="hljs-keyword">if</span> (repwdText.length != passwordText.length) &#123;                    <span class="hljs-comment">//提示用户</span>                    $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"确认密码和密码不一致！"</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-comment">//邮箱验证：xxxx@xxx.com</span>                <span class="hljs-comment">//1.获取邮箱的内容</span>                <span class="hljs-keyword">var</span> emailText = $(<span class="hljs-string">"#email"</span>).val();                <span class="hljs-comment">//2.创建正则表达式</span>                <span class="hljs-keyword">var</span> emailPatt = <span class="hljs-regexp">/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/</span>;                <span class="hljs-comment">//3.使用test方式验证是否合法</span>                <span class="hljs-keyword">if</span> (!emailPatt.test(emailText)) &#123;                    <span class="hljs-comment">//4.提示用户</span>                    $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"邮箱格式不合法！"</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-comment">//验证码</span>                <span class="hljs-keyword">var</span> codeTest = $(<span class="hljs-string">"#code"</span>).val();                <span class="hljs-comment">//去掉验证码前后空格</span>                codeTest = $.trim(codeTest);                <span class="hljs-keyword">if</span> (codeTest == <span class="hljs-literal">null</span> || codeTest == <span class="hljs-string">""</span>) &#123;                    <span class="hljs-comment">//提示用户</span>                    $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">"验证码不能为空！"</span>);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-comment">//去掉错误信息</span>                $(<span class="hljs-string">"span.errorMsg"</span>).text(<span class="hljs-string">""</span>);            &#125;);        &#125;);    &lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="第二阶段–用户注册和登陆"><a href="#第二阶段–用户注册和登陆" class="headerlink" title="第二阶段–用户注册和登陆"></a>第二阶段<strong>–用户注册和登陆</strong></h2><h3 id="1-JavaEE项目的三层架构"><a href="#1-JavaEE项目的三层架构" class="headerlink" title="1.JavaEE项目的三层架构"></a>1.JavaEE项目的三层架构</h3><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599308591538.png" srcset="/img/loading.gif" alt="59930859153"></p><p>分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级。</p><table><thead><tr><th align="left">web 层</th><th align="left">com.atguigu.web/servlet/controller</th><th align="left">Controller接口</th></tr></thead><tbody><tr><td align="left">service 层</td><td align="left">com.atguigu.service</td><td align="left">Service 接口包</td></tr><tr><td align="left"></td><td align="left">com.atguigu.service.impl</td><td align="left">Service 接口实现类</td></tr><tr><td align="left">dao 持久层</td><td align="left">com.atguigu.dao</td><td align="left">Dao 接口包</td></tr><tr><td align="left"></td><td align="left">com.atguigu.dao.impl</td><td align="left">Dao 接口实现类</td></tr><tr><td align="left">实体 bean 对象</td><td align="left">com.atguigu.pojo/entity/domain/bean</td><td align="left">JavaBean 类</td></tr><tr><td align="left">测试包</td><td align="left">com.atguigu.test/junit</td><td align="left"></td></tr><tr><td align="left">工具类</td><td align="left">com.atguigu.utils</td><td align="left"></td></tr></tbody></table><p>搭建书城项目开发环境：</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599308925889.png" srcset="/img/loading.gif" alt="59930892588"></p><h4 id="1、先创建书城需要的数据库和表。"><a href="#1、先创建书城需要的数据库和表。" class="headerlink" title="1、先创建书城需要的数据库和表。"></a>1、先创建书城需要的数据库和表。</h4><div class="hljs"><pre><code class="hljs java">drop database <span class="hljs-keyword">if</span> exists book; create database book;use book;<span class="hljs-function">create table <span class="hljs-title">t_user</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">`id` <span class="hljs-keyword">int</span> primary key auto_increment, `username` varchar(<span class="hljs-number">20</span>)</span> not <span class="hljs-keyword">null</span> unique, `password` <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> not <span class="hljs-keyword">null</span>,</span><span class="hljs-function">`email` <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">200</span>)</span></span><span class="hljs-function">)</span>;<span class="hljs-function">insert into <span class="hljs-title">t_user</span><span class="hljs-params">(`username`,`password`,`email`)</span> <span class="hljs-title">values</span><span class="hljs-params">(<span class="hljs-string">'admin'</span>,<span class="hljs-string">'admin'</span>,<span class="hljs-string">'admin@atguigu.com'</span>)</span></span>; select * from t_user;</code></pre></div><h4 id="2、编写数据库表对应的-JavaBean对象"><a href="#2、编写数据库表对应的-JavaBean对象" class="headerlink" title="2、编写数据库表对应的 JavaBean对象"></a>2、编写数据库表对应的 <code>JavaBean</code>对象</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  20:49</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String email;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String username, String password, String email)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.username = username;        <span class="hljs-keyword">this</span>.password = password;        <span class="hljs-keyword">this</span>.email = email;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", username='"</span> + username + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", password='"</span> + password + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", email='"</span> + email + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> email;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(String email)</span> </span>&#123;        <span class="hljs-keyword">this</span>.email = email;    &#125;&#125;</code></pre></div><h4 id="3、编写工具类-JdbcUtils"><a href="#3、编写工具类-JdbcUtils" class="headerlink" title="3、编写工具类 JdbcUtils"></a>3、编写工具类 JdbcUtils</h4><p>3.1、导入需要的jar 包（数据库和连接池需要）：</p><p>druid-1.1.9.jar</p><p>mysql-connector-java-5.1.7-bin.jar</p><p>以下是测试需要：</p><p>hamcrest-core-1.3.jar</p><p>junit-4.12.jar</p><p>3.2、在 src 源码目录下编写 jdbc.properties 属性配置文件</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><span class="hljs-attr">password</span>=<span class="hljs-string">123456</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/book?characterEncoding=UTF-8</span><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">initialSize</span>=<span class="hljs-string">5</span><span class="hljs-attr">maxActive</span>=<span class="hljs-string">10</span></code></pre></div><p>3.3、编写jdbcUtils工具类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DruidDataSource dataSource;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            Properties properties = <span class="hljs-keyword">new</span> Properties();            <span class="hljs-comment">//读取jdbc.properties属性配置文件</span>            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");            <span class="hljs-comment">//从流中加载数据</span>            properties.load(inputStream);            <span class="hljs-comment">//创建 数据库连接池</span>            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);            <span class="hljs-comment">//测试代码</span>            <span class="hljs-comment">//System.out.println(dataSource.getConnection());</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;               Connection conn = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;            conn = dataSource.getConnection();        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;        &#125;        <span class="hljs-keyword">return</span> conn;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Connection conn)</span> </span>&#123;        <span class="hljs-keyword">if</span> (conn != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                conn.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre></div><p>3.4、JdbcUtils 测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtilsTest</span> </span>&#123;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJdbcUtils</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;        Connection connection = JdbcUtils.getConnection();         System.out.println(connection);         JdbcUtils.close(connection);        &#125;    &#125;&#125;</code></pre></div><h4 id="4、编写BaseDao"><a href="#4、编写BaseDao" class="headerlink" title="4、编写BaseDao"></a>4、编写BaseDao</h4><p>4.1、导入 DBUtils 的 jar 包</p><p>​    commons-dbutils-1.3.jar</p><p>4.2、编写 BaseDao：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  21:17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDao</span> </span>&#123;    <span class="hljs-comment">//使用DbUtils操作数据库</span>    <span class="hljs-keyword">private</span> QueryRunner queryRunner = <span class="hljs-keyword">new</span> QueryRunner();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * update()方法用来执行，Insert/Update/Delete语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果返回-1，说明执行失败 返回其他表示影响的行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql,Object ...args)</span></span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.update(connection,sql,args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询返回一个javaBean的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 返回的对象类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql   执行的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args  sql对应的参数值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;   返回的类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T  <span class="hljs-title">queryForOne</span><span class="hljs-params">(Class&lt;T&gt; type,String sql,Object ...args)</span></span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.query(connection,sql,<span class="hljs-keyword">new</span> BeanHandler&lt;T&gt;(type),args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询返回多个javaBean的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 返回的对象类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql   执行的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args  sql对应的参数值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;   返回的类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">queryForList</span><span class="hljs-params">(Class&lt;T&gt; type,String sql,Object ...args)</span> </span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> BeanListHandler&lt;T&gt;(type), args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 执行返回一行一列的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql   执行的sql语句</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args  sql对应的参数值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">queryForSingleValue</span><span class="hljs-params">(String sql,Object ...args)</span></span>&#123;        Connection connection = JdbcUtils.getConnection();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> queryRunner.query(connection,sql,<span class="hljs-keyword">new</span> ScalarHandler(),args);        &#125; <span class="hljs-keyword">catch</span> (SQLException e)&#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;&#125;</code></pre></div><h4 id="5、编写-UserDao-和测试"><a href="#5、编写-UserDao-和测试" class="headerlink" title="5、编写 UserDao 和测试"></a>5、编写 UserDao 和测试</h4><p>​    UserDao 接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  21:34</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更加用户名查询用户信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username  用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  如果返回null，说明没有这个用户，反之亦然</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByUsername</span><span class="hljs-params">(String username)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  根据用户名和密码查询用户信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  如果返回null，说明用户名或密码错误，反之亦然</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByUsernameAndPassword</span><span class="hljs-params">(String username,String password)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存、添加用户信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user 返回-1表示操作失败，其他是sql语句影响的行数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span></span>;&#125;</code></pre></div><p>UserDaoImpl 实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  21:40</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        String sql = <span class="hljs-string">"select `id`,`username`,`password`,`email` from t_user where username = ?"</span>;        <span class="hljs-keyword">return</span> queryForOne(User<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">sql</span>,<span class="hljs-title">username</span>)</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByUsernameAndPassword</span><span class="hljs-params">(String username, String password)</span> </span>&#123;        String sql = <span class="hljs-string">"select `id`,`username`,`password`,`email` from t_user where username = ? and password = ?"</span>;        <span class="hljs-keyword">return</span> queryForOne(User<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">sql</span>,<span class="hljs-title">username</span>,<span class="hljs-title">password</span>)</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span> </span>&#123;        String sql = <span class="hljs-string">"insert into t_user(`username`,`password`,`email`) values(?,?,?)"</span>;        <span class="hljs-keyword">return</span> update(sql,user.getUsername(),user.getPassword(),user.getEmail());    &#125;&#125;</code></pre></div><p>UserDao 测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-03  21:49</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImplTest</span> </span>&#123;    UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryUserByUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(userDao.queryUserByUsername(<span class="hljs-string">"admin"</span>) == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">"用户名可用！"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"用户名已存在！"</span>);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryUserByUsernameAndPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(userDao.queryUserByUsernameAndPassword(<span class="hljs-string">"admin"</span>,<span class="hljs-string">"admin"</span>) == <span class="hljs-keyword">null</span>)&#123;            System.out.println(<span class="hljs-string">"用户名或密码错误，登陆失败"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"查询成功"</span>);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(userDao.saveUser(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>,<span class="hljs-string">"lin"</span>,<span class="hljs-string">"123456"</span>,<span class="hljs-string">"lin@qq.com"</span>)));    &#125;&#125;</code></pre></div><h4 id="6、编写-UserService-和测试"><a href="#6、编写-UserService-和测试" class="headerlink" title="6、编写 UserService 和测试"></a>6、编写 UserService 和测试</h4><p>UserService 接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-04  10:08</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注册用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果返回null，说明登录失败，返回有值，说明登录成功</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查 用户名是否可用</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回true表示用户名已存在，返回false表示用户名可用</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">existUsername</span><span class="hljs-params">(String username)</span></span>;&#125;</code></pre></div><p>UserServiceImpl实现类:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-04  10:11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-keyword">private</span> UserDao userdao = <span class="hljs-keyword">new</span> UserDaoImpl();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registUser</span><span class="hljs-params">(User user)</span> </span>&#123;            userdao.saveUser(user);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-keyword">return</span> userdao.queryUserByUsernameAndPassword(user.getUsername(),user.getPassword());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">existUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">if</span> (userdao.queryUserByUsername(username) == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//等于null，说明没查到，表示可用</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p>UserService 测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-04  10:15</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImplTest</span> </span>&#123;    UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registUser</span><span class="hljs-params">()</span> </span>&#123;        userService.registUser(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>,<span class="hljs-string">"lin"</span>,<span class="hljs-string">"123456"</span>,<span class="hljs-string">"123@qq.com"</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(userService.login(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>,<span class="hljs-string">"lin"</span>,<span class="hljs-string">"123456"</span>,<span class="hljs-string">"1"</span>)));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">existUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (userService.existUsername(<span class="hljs-string">"lin"</span>))&#123;            System.out.println(<span class="hljs-string">"用户名已存在！"</span>);        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"用户名可用!"</span>);        &#125;    &#125;&#125;</code></pre></div><h4 id="7、编写-web-层"><a href="#7、编写-web-层" class="headerlink" title="7、编写 web 层"></a>7、编写 web 层</h4><p>7.1、实现用户注册的功能</p><p>7.1.1、图解用户注册的流程：</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599310247998.png" srcset="/img/loading.gif" alt="59931024799"></p><p>7.1.2、修改 regist.html 和 regist_success.html 页面</p><p>1、添加 base 标签</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--写base 标签，永远固定相对路径跳转的结果--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/book/"</span>&gt;</span></code></pre></div><p>2、修改 base 标签对页面中所有相对路径的影响（浏览器 F12，哪个报红，改哪个）</p><div class="hljs"><pre><code class="hljs html">以下是几个修改的示例：<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"static/css/style.css"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"static/script/jquery-1.7.2.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>3、修改注册表单的提交地址和请求方式</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599310491584.png" srcset="/img/loading.gif" alt="59931049158"></p><p>7.1.3、编写 RegistServlet 程序</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-05  16:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 处理注册的功能</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">regist</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;                <span class="hljs-comment">//1.获取请求的参数</span>        String username = req.getParameter(<span class="hljs-string">"username"</span>);        String password = req.getParameter(<span class="hljs-string">"password"</span>);        String email = req.getParameter(<span class="hljs-string">"email"</span>);        String code = req.getParameter(<span class="hljs-string">"code"</span>);        User user = WebUtils.copyParmToBean(req.getParameterMap(), <span class="hljs-keyword">new</span> User());        <span class="hljs-comment">// 2、检查 验证码是否正确 === 写死,要求验证码为:abcde</span><span class="hljs-keyword">if</span> (<span class="hljs-string">"abcde"</span>.equalsIgnoreCase(code)) &#123; <span class="hljs-comment">//3、检查用户名是否可用</span> <span class="hljs-keyword">if</span> (userService.existsUsername(username)) &#123;System.out.println(<span class="hljs-string">"用户名["</span> + username + <span class="hljs-string">"]已存在!"</span>);<span class="hljs-comment">// 跳回注册页面</span>req.getRequestDispatcher(<span class="hljs-string">"/pages/user/regist.html"</span>).forward(req, resp);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//可用</span> <span class="hljs-comment">// 调用Sservice 保存到数据库</span>userService.registUser(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>, username, password, email)); <span class="hljs-comment">//跳到注册成功页面 regist_success.html</span>     req.getRequestDispatcher(<span class="hljs-string">"/pages/user/regist_success.html"</span>).forward(req, resp);    &#125;    &#125; <span class="hljs-keyword">else</span> &#123;    System.out.println(<span class="hljs-string">"验证码["</span> + code + <span class="hljs-string">"]错误"</span>);        req.getRequestDispatcher(<span class="hljs-string">"/pages/user/regist.html"</span>).forward(req, resp);    &#125;&#125;</code></pre></div><p>7.2、用户登录功能的实现</p><p>7.2.1、图解用户登录</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599310896021.png" srcset="/img/loading.gif" alt="59931089602"></p><p>7.2.2、修改 login.html 页面和 login_success.html 页面</p><p>1、添加 base 标签</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--写base 标签，永远固定相对路径跳转的结果--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/book/"</span>&gt;</span></code></pre></div><p>2、修改 base 标签对页面中所有相对路径的影响（浏览器 F12，哪个报红，改哪个）</p><p>3、修改 login.html 表单的提交地址和请求方式</p><p>2,3如上</p><p>7.2.3、LoginServlet 程序</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-05  16:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 处理登录的功能</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//1.获取连接</span>        String username = req.getParameter(<span class="hljs-string">"username"</span>);        String password = req.getParameter(<span class="hljs-string">"password"</span>);        <span class="hljs-comment">//调用userService.login登录处理业务</span>        User loginUser = userService.login(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>, username, password, <span class="hljs-keyword">null</span>));        <span class="hljs-keyword">if</span> (loginUser == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//调回登录页面</span>            req.getRequestDispatcher(<span class="hljs-string">"/pages/user/login.jsp"</span>).forward(req,resp);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//登录成功页面</span>            <span class="hljs-comment">//System.out.println("登录成功");</span>            req.getRequestDispatcher(<span class="hljs-string">"/pages/user/login_success.jsp"</span>).forward(req,resp);        &#125;    &#125;&#125;</code></pre></div><h2 id="第三阶段–前后端整合"><a href="#第三阶段–前后端整合" class="headerlink" title="第三阶段–前后端整合"></a>第三阶段–前后端整合</h2><h3 id="1-页面-jsp-动态化"><a href="#1-页面-jsp-动态化" class="headerlink" title="1.页面 jsp 动态化"></a>1.页面 jsp 动态化</h3><p>1、在html 页面顶行添加page 指令。</p><p>2、修改文件后缀名为：.jsp</p><p>3、使用 IDEA 搜索替换.html 为.jsp(快捷键：Ctrl+Shift+R)</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599314147604.png" srcset="/img/loading.gif" alt="59931414760"></p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599314156656.png" srcset="/img/loading.gif" alt="59931415665"></p><h3 id="2-抽取页面中相同的内容"><a href="#2-抽取页面中相同的内容" class="headerlink" title="2.抽取页面中相同的内容"></a>2.抽取页面中相同的内容</h3><h4 id="1、head-中-css、jquery、base-标签"><a href="#1、head-中-css、jquery、base-标签" class="headerlink" title="1、head 中 css、jquery、base 标签"></a>1、head 中 css、jquery、base 标签</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%</span></span><span class="hljs-tag"></span><span class="hljs-tag"><span class="hljs-attr">String</span> <span class="hljs-attr">basePath</span> = <span class="hljs-string">request.getScheme()</span> + "<span class="hljs-attr">:</span>//"</span><span class="hljs-tag">+ <span class="hljs-attr">request.getServerName</span>() + "<span class="hljs-attr">:</span>"</span><span class="hljs-tag">+ <span class="hljs-attr">request.getServerPort</span>()</span><span class="hljs-tag">+ <span class="hljs-attr">request.getContextPath</span>() + "/";</span><span class="hljs-tag">%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%=basePath%</span>&gt;</span><span class="hljs-comment">&lt;!--写base 标签，永远固定相对路径跳转的结果--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"&lt;%=basePath%&gt;"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"static/css/style.css"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"static/script/jquery-1.7.2.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h4 id="2、每个页面的页脚"><a href="#2、每个页面的页脚" class="headerlink" title="2、每个页面的页脚"></a>2、每个页面的页脚</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bottom"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>    尚硅谷书城.Copyright <span class="hljs-symbol">&amp;copy;</span>2015    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="3、登录成功后的菜单"><a href="#3、登录成功后的菜单" class="headerlink" title="3、登录成功后的菜单"></a>3、登录成功后的菜单</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>欢迎<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"um_span"</span>&gt;</span>韩总<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>光临尚硅谷书城<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../order/order.jsp"</span>&gt;</span>我的订单<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../../index.jsp"</span>&gt;</span>注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../../index.jsp"</span>&gt;</span>返回<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="4、manager-模块的菜单"><a href="#4、manager-模块的菜单" class="headerlink" title="4、manager 模块的菜单"></a>4、manager 模块的菜单</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"book_manager.jsp"</span>&gt;</span>图书管理<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"order_manager.jsp"</span>&gt;</span>订单管理<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../../index.jsp"</span>&gt;</span>返回商城<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h3 id="3-登录，注册错误提示，及表单回显"><a href="#3-登录，注册错误提示，及表单回显" class="headerlink" title="3.登录，注册错误提示，及表单回显"></a>3.登录，注册错误提示，及表单回显</h3><p>以登录回显为示例：</p><p>Servlet 程序端需要添加回显信息到Request 域中</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599314424641.png" srcset="/img/loading.gif" alt="59931442464"></p><p>jsp 页面，需要输出回显信息</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599314441257.png" srcset="/img/loading.gif" alt="59931444125"></p><h3 id="4-BaseServlet的抽取"><a href="#4-BaseServlet的抽取" class="headerlink" title="4.BaseServlet的抽取"></a>4.BaseServlet的抽取</h3><p>在实际的项目开发中，一个模块，一般只使用一个 <code>Servlet</code> 程序。</p><p>代码优化一：代码优化：合并 LoginServlet 和 RegistServlet 程序为 UserServlet 程序</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599314517553.png" srcset="/img/loading.gif" alt="59931451755"></p><p>UserServlet 程序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 处理登录的功能</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//1.获取连接</span>        String username = req.getParameter(<span class="hljs-string">"username"</span>);        String password = req.getParameter(<span class="hljs-string">"password"</span>);        <span class="hljs-comment">//调用userService.login登录处理业务</span>        User loginUser = userService.login(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>, username, password, <span class="hljs-keyword">null</span>));        <span class="hljs-keyword">if</span> (loginUser == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//调回登录页面</span>            <span class="hljs-comment">//把错误信息，和回显的表单项信息，保存到Request域中</span>            req.setAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"用户名或密码错误！"</span>);            req.setAttribute(<span class="hljs-string">"username"</span>,username);            <span class="hljs-comment">//System.out.println("登录失败");</span>            req.getRequestDispatcher(<span class="hljs-string">"/pages/user/login.jsp"</span>).forward(req,resp);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//登录成功页面</span>            <span class="hljs-comment">//System.out.println("登录成功");</span>            <span class="hljs-comment">//将登陆成功的信息保存报Session域</span>            req.getSession().setAttribute(<span class="hljs-string">"user"</span>,loginUser);            req.getRequestDispatcher(<span class="hljs-string">"/pages/user/login_success.jsp"</span>).forward(req,resp);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 处理注册的功能</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> req</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resp</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ServletException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">regist</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//获取Session中的验证码</span>        String token = (String)req.getSession().getAttribute(KAPTCHA_SESSION_KEY);        <span class="hljs-comment">//删除Session中的验证码</span>        req.getSession().removeAttribute(KAPTCHA_SESSION_KEY);        <span class="hljs-comment">//1.获取请求的参数</span>        String username = req.getParameter(<span class="hljs-string">"username"</span>);        String password = req.getParameter(<span class="hljs-string">"password"</span>);        String email = req.getParameter(<span class="hljs-string">"email"</span>);        String code = req.getParameter(<span class="hljs-string">"code"</span>);        User user = WebUtils.copyParmToBean(req.getParameterMap(), <span class="hljs-keyword">new</span> User());        <span class="hljs-comment">//2.检查 验证码是否正确 ==== 用谷歌验证码</span>        <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span> &amp;&amp; token.equalsIgnoreCase(code))&#123;            <span class="hljs-comment">//3.检查 用户名是否可用</span>            <span class="hljs-keyword">if</span> (userService.existUsername(username))&#123;                <span class="hljs-comment">//不可用</span>                System.out.println(<span class="hljs-string">"用户名["</span> + username + <span class="hljs-string">"]已存在！"</span>);                <span class="hljs-comment">//把回显信息，保存到Request域中</span>                req.setAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"用户名已存在!"</span>);                req.setAttribute(<span class="hljs-string">"username"</span>,username);                req.setAttribute(<span class="hljs-string">"email"</span>,email);                <span class="hljs-comment">//跳回注册页面</span>                req.getRequestDispatcher(<span class="hljs-string">"/pages/user/regist.jsp"</span>).forward(req,resp);            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//可用，调用Service保存到数据库</span>                userService.registUser(<span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>,username,password,email));                req.getRequestDispatcher(<span class="hljs-string">"/pages/user/regist_success.jsp"</span>).forward(req,resp);            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//把回显信息，保存到Request域中</span>            req.setAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"验证码错误!"</span>);            req.setAttribute(<span class="hljs-string">"username"</span>,username);            req.setAttribute(<span class="hljs-string">"email"</span>,email);            System.out.println(<span class="hljs-string">"验证码["</span> + code +<span class="hljs-string">"]错误"</span>);            req.getRequestDispatcher(<span class="hljs-string">"/pages/user/regist.jsp"</span>).forward(req,resp);        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException,IOException </span>&#123;    String action = req.getParameter(<span class="hljs-string">"action"</span>); <span class="hljs-keyword">if</span> (<span class="hljs-string">"login"</span>.equals(action)) &#123;    login(req, resp);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"regist"</span>.equals(action)) &#123;    regist(req, resp);    &#125;&#125;</code></pre></div><p>还要给<br>login.jsp  添加隐藏域和修改请求地址</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599315410319.png" srcset="/img/loading.gif" alt="59931541031"></p><p>给 tegist.jsp 页面添加隐藏域 action，和修改请求地址</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599315429115.png" srcset="/img/loading.gif" alt="59931542911"></p><p><strong>优化代码二：使用反射优化大量</strong> <strong>else</strong> <strong>if</strong> <strong>代码：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);<span class="hljs-comment">//关键 解决post乱码问题</span>        <span class="hljs-comment">//解决响应的中文乱码</span>        resp.setContentType(<span class="hljs-string">"text/html; charset=UTF-8"</span>);        String action = req.getParameter(<span class="hljs-string">"action"</span>);        <span class="hljs-keyword">try</span> &#123;            Method method = <span class="hljs-keyword">this</span>.getClass().getDeclaredMethod(action,HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>)</span>;            method.invoke(<span class="hljs-keyword">this</span>,req,resp);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();               &#125;</code></pre></div><p>代码优化三：抽取BaseServlet 程序。</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599315502225.png" srcset="/img/loading.gif" alt="59931550222"></p><p>BaseServlet 程序代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-05  18:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        doPost(req, resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        req.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);<span class="hljs-comment">//关键 解决post乱码问题</span>        <span class="hljs-comment">//解决响应的中文乱码</span>        resp.setContentType(<span class="hljs-string">"text/html; charset=UTF-8"</span>);        String action = req.getParameter(<span class="hljs-string">"action"</span>);        <span class="hljs-keyword">try</span> &#123;            Method method = <span class="hljs-keyword">this</span>.getClass().getDeclaredMethod(action,HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>)</span>;            method.invoke(<span class="hljs-keyword">this</span>,req,resp);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();              &#125;    &#125;&#125;</code></pre></div><p>修改 UserServlet 程序继承BaseServlet 程序。</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599315569499.png" srcset="/img/loading.gif" alt="59931556949"></p><h3 id="5-数据的封装和抽取-BeanUtils-的使用"><a href="#5-数据的封装和抽取-BeanUtils-的使用" class="headerlink" title="5.数据的封装和抽取 BeanUtils 的使用"></a>5.数据的封装和抽取 BeanUtils 的使用</h3><p>BeanUtils 工具类，它可以一次性的把所有请求的参数注入到 JavaBean 中。</p><p>BeanUtils 工具类，经常用于把 Map 中的值注入到 JavaBean 中，或者是对象属性值的拷贝操作。</p><p>BeanUtils 它不是 Jdk 的类。而是第三方的工具类。所以需要导包。</p><p>​    1、导入需要的 jar 包：commons-beanutils-1.8.0.jar commons-logging-1.1.1.jar</p><p>​    2、编写 WebUtils 工具类使用：</p><p>WebUtils 工具类：</p><div class="hljs"><pre><code class="hljs java">** * <span class="hljs-meta">@outhor</span> Mr.JK * <span class="hljs-meta">@create</span> <span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">05</span>  <span class="hljs-number">19</span>:<span class="hljs-number">57</span> */<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebUtils</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T  <span class="hljs-title">copyParmToBean</span><span class="hljs-params">(Map values, T bean)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//使用第三方jar包，将数据封装到Bean对象</span>            BeanUtils.populate(bean,values);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><h2 id="第四阶段–修改回显"><a href="#第四阶段–修改回显" class="headerlink" title="第四阶段–修改回显"></a>第四阶段–修改回显</h2><p>以登录为示例：</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599315713421.png" srcset="/img/loading.gif" alt="59931571342"></p><h2 id="第五阶段–图书模块"><a href="#第五阶段–图书模块" class="headerlink" title="第五阶段–图书模块"></a>第五阶段–图书模块</h2><h3 id="MVC-概念"><a href="#MVC-概念" class="headerlink" title="MVC 概念"></a>MVC 概念</h3><p>MVC  全称：Model  模型、  View  视图、 Controller  控制器。</p><p>MVC  最早出现在 JavaEE 三层中的 Web 层，它可以有效的指导 Web 层的代码如何有效分离，单独工作。</p><p>View 视图：只负责数据和界面的显示，不接受任何与显示数据无关的代码，便于程序员和美工的分工合作——</p><p>JSP/HTML。</p><p>Controller控制器：只负责接收请求，调用业务层的代码处理请求，然后派发页面，是一个“调度者”的角色——Servlet。转到某个页面。或者是重定向到某个页面。</p><p>Model 模型：将与业务逻辑相关的数据封装为具体的 JavaBean 类，其中不掺杂任何与数据处理相关的代码——</p><p>JavaBean/domain/entity/pojo。</p><p><strong>MVC</strong> <strong>是一种思想</strong></p><p>MVC的理念是将软件代码拆分成为组件，单独开发，组合使用（目的还是为了降低耦合度）</p><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599316317349.png" srcset="/img/loading.gif" alt="59931631734"></p><p><strong>MVC</strong> <strong>的作用还是为了降低耦合。让代码合理分层。方便后期升级和维护。</strong></p><h3 id="1、图书模块"><a href="#1、图书模块" class="headerlink" title="1、图书模块"></a>1、图书模块</h3><h4 id="1-1、编写图书模块的数据库表"><a href="#1-1、编写图书模块的数据库表" class="headerlink" title="1.1、编写图书模块的数据库表"></a>1.1、编写图书模块的数据库表</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_book(    <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span> auto_increment,     <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>),    <span class="hljs-string">`price`</span> <span class="hljs-built_in">decimal</span>(<span class="hljs-number">11</span>,<span class="hljs-number">2</span>),     <span class="hljs-string">`author`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>), <span class="hljs-string">`sales`</span> <span class="hljs-built_in">int</span>,    <span class="hljs-string">`stock`</span> <span class="hljs-built_in">int</span>,    <span class="hljs-string">`img_path`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">200</span>));</code></pre></div><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">## 插入初始化测试数据</span><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'java 从入门到放弃'</span> , <span class="hljs-string">'国哥'</span> , <span class="hljs-number">80</span> , <span class="hljs-number">9999</span> , <span class="hljs-number">9</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'数据结构与算法'</span> , <span class="hljs-string">'严敏君'</span> , <span class="hljs-number">78.5</span> , <span class="hljs-number">6</span> , <span class="hljs-number">13</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'怎样拐跑别人的媳妇'</span> , <span class="hljs-string">'龙伍'</span> , <span class="hljs-number">68</span>, <span class="hljs-number">99999</span> , <span class="hljs-number">52</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'木虚肉盖饭'</span> , <span class="hljs-string">'小胖'</span> , <span class="hljs-number">16</span>, <span class="hljs-number">1000</span> , <span class="hljs-number">50</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'C++编程思想'</span> , <span class="hljs-string">'刚哥'</span> , <span class="hljs-number">45.5</span> , <span class="hljs-number">14</span> , <span class="hljs-number">95</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'蛋炒饭'</span> , <span class="hljs-string">'周星星'</span> , <span class="hljs-number">9.9</span>, <span class="hljs-number">12</span> , <span class="hljs-number">53</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'赌神'</span> , <span class="hljs-string">'龙伍'</span> , <span class="hljs-number">66.5</span>, <span class="hljs-number">125</span> , <span class="hljs-number">535</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'Java 编程思想'</span> , <span class="hljs-string">'阳哥'</span> , <span class="hljs-number">99.5</span> , <span class="hljs-number">47</span> , <span class="hljs-number">36</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'JavaScript 从入门到精通'</span> , <span class="hljs-string">'婷姐'</span> , <span class="hljs-number">9.9</span> , <span class="hljs-number">85</span> , <span class="hljs-number">95</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'cocos2d-x 游戏编程入门'</span> , <span class="hljs-string">'国哥'</span> , <span class="hljs-number">49</span>, <span class="hljs-number">52</span> , <span class="hljs-number">62</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'C 语言程序设计'</span> , <span class="hljs-string">'谭浩强'</span> , <span class="hljs-number">28</span> , <span class="hljs-number">52</span> , <span class="hljs-number">74</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'Lua 语言程序设计'</span> , <span class="hljs-string">'雷丰阳'</span> , <span class="hljs-number">51.5</span> , <span class="hljs-number">48</span> , <span class="hljs-number">82</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'西游记'</span> , <span class="hljs-string">'罗贯中'</span> , <span class="hljs-number">12</span>, <span class="hljs-number">19</span> , <span class="hljs-number">9999</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'水浒传'</span> , <span class="hljs-string">'华仔'</span> , <span class="hljs-number">33.05</span> , <span class="hljs-number">22</span> , <span class="hljs-number">88</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'操作系统原理'</span> , <span class="hljs-string">'刘优'</span> , <span class="hljs-number">133.05</span> , <span class="hljs-number">122</span> , <span class="hljs-number">188</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'数据结构 java 版'</span> , <span class="hljs-string">'封大神'</span> , <span class="hljs-number">173.15</span> , <span class="hljs-number">21</span> , <span class="hljs-number">81</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'UNIX 高级环境编程'</span> , <span class="hljs-string">'乐天'</span> , <span class="hljs-number">99.15</span> , <span class="hljs-number">210</span> , <span class="hljs-number">810</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'javaScript 高级编程'</span> , <span class="hljs-string">'国哥'</span> , <span class="hljs-number">69.15</span> , <span class="hljs-number">210</span> , <span class="hljs-number">810</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'大话设计模式'</span> , <span class="hljs-string">'国哥'</span> , <span class="hljs-number">89.15</span> , <span class="hljs-number">20</span> , <span class="hljs-number">10</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_book(<span class="hljs-string">`id`</span> , <span class="hljs-string">`name`</span> , <span class="hljs-string">`author`</span> , <span class="hljs-string">`price`</span> , <span class="hljs-string">`sales`</span> , <span class="hljs-string">`stock`</span> , <span class="hljs-string">`img_path`</span>) <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span> , <span class="hljs-string">'人月神话'</span> , <span class="hljs-string">'刚哥'</span> , <span class="hljs-number">88.15</span> , <span class="hljs-number">20</span> , <span class="hljs-number">80</span> , <span class="hljs-string">'static/img/default.jpg'</span>);<span class="hljs-comment">## 查看表内容</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,author,price,sales,stock,img_path <span class="hljs-keyword">from</span> t_book;</code></pre></div><h4 id="1-2、编写图书模块的-JavaBean"><a href="#1-2、编写图书模块的-JavaBean" class="headerlink" title="1.2、编写图书模块的 JavaBean"></a>1.2、编写图书模块的 JavaBean</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;     <span class="hljs-keyword">private</span> Integer id;     <span class="hljs-keyword">private</span> String name;     <span class="hljs-keyword">private</span> String author;<span class="hljs-keyword">private</span> BigDecimal price;     <span class="hljs-keyword">private</span> Integer sales;     <span class="hljs-keyword">private</span> Integer stock;<span class="hljs-keyword">private</span> String imgPath = <span class="hljs-string">"static/img/default.jpg"</span>;&#125;</code></pre></div><h4 id="1-3、编写图书模块的-Dao-和测试-Dao"><a href="#1-3、编写图书模块的-Dao-和测试-Dao" class="headerlink" title="1.3、编写图书模块的 Dao 和测试 Dao"></a>1.3、编写图书模块的 Dao 和测试 Dao</h4><p>Dao 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-06  11:28</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookDao</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Book book)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">queryBookById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">queryBooks</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>BookDaoImpl 实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-06  11:31</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDaoImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BookDao</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span> </span>&#123;        String sql = <span class="hljs-string">"insert into t_book(`name`,`author`,`price`,`sales`,`stock`,`img_path`)values(?,?,?,?,?,?)"</span>;        <span class="hljs-keyword">return</span> update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        String sql = <span class="hljs-string">"delete from t_book where id = ?"</span>;        <span class="hljs-keyword">return</span> update(sql,id);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Book book)</span> </span>&#123;        String sql = <span class="hljs-string">"update t_book set `name`=?,`author`=?,`price`=?,`sales`=?,`stock`=?,`img_path`=? where id = ?"</span>;        <span class="hljs-keyword">return</span> update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath(),book.getId());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">queryBookById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        String sql = <span class="hljs-string">"select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` from t_book where id = ?"</span>;        <span class="hljs-keyword">return</span> queryForOne(Book<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">sql</span>,<span class="hljs-title">id</span>)</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">queryBooks</span><span class="hljs-params">()</span> </span>&#123;        String sql = <span class="hljs-string">"select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` from t_book"</span>;        <span class="hljs-keyword">return</span> queryForList(Book<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">sql</span>)</span>;    &#125;&#125;</code></pre></div><p>BookDao 的测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-06  11:42</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDaoImplTest</span> </span>&#123;    <span class="hljs-keyword">private</span> BookDao bookDao = <span class="hljs-keyword">new</span> BookDaoImpl();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">()</span> </span>&#123;        bookDao.addBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-keyword">null</span>, <span class="hljs-string">"帅哥"</span>, <span class="hljs-string">"坤哥"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">999</span>), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">()</span> </span>&#123;        bookDao.deleteBookById(<span class="hljs-number">21</span>);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">()</span> </span>&#123;        bookDao.updateBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">21</span>, <span class="hljs-string">"帅哥秘籍"</span>, <span class="hljs-string">"坤哥"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">999</span>), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryBookById</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(bookDao.queryBookById(<span class="hljs-number">21</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryBooks</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (Book querybook : bookDao.queryBooks()) &#123;            System.out.println(querybook);        &#125;    &#125;&#125;</code></pre></div><h4 id="1-4、编写图书模块的-Service-和测试-Service"><a href="#1-4、编写图书模块的-Service-和测试-Service" class="headerlink" title="1.4、编写图书模块的 Service 和测试 Service"></a>1.4、编写图书模块的 Service 和测试 Service</h4><p>BookService 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-06  13:09</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BookService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Book book)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">queryBookById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">queryBooks</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>BookServiceImpl 实现类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-06  13:11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BookService</span> </span>&#123;    <span class="hljs-keyword">private</span> BookDao bookDao = <span class="hljs-keyword">new</span> BookDaoImpl();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span> </span>&#123;        bookDao.addBook(book);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        bookDao.deleteBookById(id);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">(Book book)</span> </span>&#123;        bookDao.updateBook(book);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">queryBookById</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">return</span> bookDao.queryBookById(id);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">queryBooks</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> bookDao.queryBooks();    &#125;&#125;</code></pre></div><p>BookService 的测试:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@outhor</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-04-06  13:37</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImplTest</span> </span>&#123;    <span class="hljs-keyword">private</span> BookService bookService = <span class="hljs-keyword">new</span> BookServiceImpl();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">()</span> </span>&#123;        bookService.addBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-keyword">null</span>, <span class="hljs-string">"帅哥"</span>, <span class="hljs-string">"坤哥"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">999</span>), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteBookById</span><span class="hljs-params">()</span> </span>&#123;        bookService.deleteBookById(<span class="hljs-number">27</span>);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateBook</span><span class="hljs-params">()</span> </span>&#123;        bookService.updateBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">21</span>, <span class="hljs-string">"帅哥秘籍"</span>, <span class="hljs-string">"坤哥"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">999</span>), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryBookById</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(bookService.queryBookById(<span class="hljs-number">27</span>));    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryBooks</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (Book querybook : bookService.queryBooks()) &#123;            System.out.println(querybook);        &#125;    &#125;&#125;</code></pre></div><h4 id="1-5、编写图书模块的-Web-层，和页面联调测试"><a href="#1-5、编写图书模块的-Web-层，和页面联调测试" class="headerlink" title="1.5、编写图书模块的 Web 层，和页面联调测试"></a>1.5、编写图书模块的 Web 层，和页面联调测试</h4><h5 id="1-5-1、图书列表功能的实现"><a href="#1-5-1、图书列表功能的实现" class="headerlink" title="1.5.1、图书列表功能的实现"></a>1.5.1、图书列表功能的实现</h5><h6 id="1、图解列表功能流程："><a href="#1、图解列表功能流程：" class="headerlink" title="1、图解列表功能流程："></a>1、图解列表功能流程：</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599317751273.png" srcset="/img/loading.gif" alt="59931775127"></p><h6 id="2、BookServlet-程序中添加-list-方法"><a href="#2、BookServlet-程序中添加-list-方法" class="headerlink" title="2、BookServlet 程序中添加 list 方法"></a>2、BookServlet 程序中添加 list 方法</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//1.通过BookServlet查询全部图书</span>        List&lt;Book&gt; books = bookService.queryBooks();        <span class="hljs-comment">//2.把全部图书保存到Request域中</span>        req.setAttribute(<span class="hljs-string">"books"</span>,books);        <span class="hljs-comment">//3.请求转发到/pages/manager/book_manager.jsp</span>        req.getRequestDispatcher(<span class="hljs-string">"/pages/manager/book_manager.jsp"</span>).forward(req,resp);    &#125;</code></pre></div><h6 id="3、修改【图书管理】请求地址"><a href="#3、修改【图书管理】请求地址" class="headerlink" title="3、修改【图书管理】请求地址"></a>3、修改【图书管理】请求地址</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599317852680.png" srcset="/img/loading.gif" alt="59931785268"></p><h6 id="4、修改-pages-manager-book-manager-jsp-页面的数据遍历输出"><a href="#4、修改-pages-manager-book-manager-jsp-页面的数据遍历输出" class="headerlink" title="4、修改 pages/manager/book_manager.jsp 页面的数据遍历输出"></a>4、修改 pages/manager/book_manager.jsp 页面的数据遍历输出</h6><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">taglib</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"c"</span> <span class="hljs-attr">uri</span>=<span class="hljs-string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>图书管理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"header"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo_img"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../../static/img/logo.gif"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wel_word"</span>&gt;</span>图书管理系统<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%--</span> 静态包含<span class="hljs-attr">manager</span>管理，模块的菜单<span class="hljs-attr">--</span>%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"/pages/common/manager_menu.jsp"</span>%&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"main"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>作者<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>销量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">items</span>=<span class="hljs-string">"$&#123;requestScope.page.items&#125;"</span> <span class="hljs-attr">var</span>=<span class="hljs-string">"book"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.author&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.sales&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.stock&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"manager/bookServlet?action=getBook&amp;id=$&#123;book.id&#125;&amp;pageNo=$&#123;requestScope.page.pageNo&#125;"</span>&gt;</span>修改<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"deleteClass"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"manager/bookServlet?action=delete&amp;id=$&#123;book.id&#125;&amp;pageNo=$&#123;requestScope.page.pageNo&#125;"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"pages/manager/book_edit.jsp?pageNo=$&#123;requestScope.page.pageTotal&#125;"</span>&gt;</span>添加图书<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%--静态包含分页条--%</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"/pages/common/page_nav.jsp"</span>%&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%--</span>静态包含页脚内容<span class="hljs-attr">--</span>%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"/pages/common/footer.jsp"</span>%&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h5 id="1-5-2、前后台的简单介绍"><a href="#1-5-2、前后台的简单介绍" class="headerlink" title="1.5.2、前后台的简单介绍"></a>1.5.2、前后台的简单介绍</h5><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318008451.png" srcset="/img/loading.gif" alt="59931800845"></p><h5 id="1-5-3、添加图书功能的实现"><a href="#1-5-3、添加图书功能的实现" class="headerlink" title="1.5.3、添加图书功能的实现"></a>1.5.3、添加图书功能的实现</h5><h6 id="1-5-3-1、添加图书流程细节："><a href="#1-5-3-1、添加图书流程细节：" class="headerlink" title="1.5.3.1、添加图书流程细节："></a>1.5.3.1、添加图书流程细节：</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318056145.png" srcset="/img/loading.gif" alt="59931805614"></p><h6 id="1-5-3-2、问题说明：表单重复提交："><a href="#1-5-3-2、问题说明：表单重复提交：" class="headerlink" title="1.5.3.2、问题说明：表单重复提交："></a>1.5.3.2、问题说明：表单重复提交：</h6><p>当用户提交完请求，浏览器会记录下最后一次请求的全部信息。当用户按下功能键 F5，就会发起浏览器记录的最后一次请求。</p><h6 id="1-5-3-3、BookServlet-程序中添加-add-方法"><a href="#1-5-3-3、BookServlet-程序中添加-add-方法" class="headerlink" title="1.5.3.3、BookServlet 程序中添加 add 方法"></a>1.5.3.3、BookServlet 程序中添加 add 方法</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">int</span> pageNo = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"pageNo"</span>),<span class="hljs-number">0</span>);        pageNo+=<span class="hljs-number">1</span>;        <span class="hljs-comment">//1.获取请求的参数==封装成为Book对象</span>        Book book = WebUtils.copyParmToBean(req.getParameterMap(), <span class="hljs-keyword">new</span> Book());        <span class="hljs-comment">//2.调用BookService.addBook()保存图书</span>        bookService.addBook(book);        <span class="hljs-comment">//3.跳出图书列表页面</span>        <span class="hljs-comment">//  /manager/bookServlet?action=list</span>        <span class="hljs-comment">//这里跳转要用重定向，不能用请求转发，会有bug，F5刷新，会一直添加</span>        resp.sendRedirect(req.getContextPath() + <span class="hljs-string">"/manager/bookServlet?action=page&amp;pageNo="</span> + pageNo);    &#125;</code></pre></div><h6 id="1-5-3-4、修改-book-edit-jsp-页面"><a href="#1-5-3-4、修改-book-edit-jsp-页面" class="headerlink" title="1.5.3.4、修改 book_edit.jsp 页面"></a>1.5.3.4、修改 book_edit.jsp 页面</h6><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr">page</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">"text/html;charset=UTF-8"</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"java"</span> %&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"cmn-hans"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>编辑图书<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%--</span>  静态包含<span class="hljs-attr">base</span>标签,<span class="hljs-attr">css</span>样式,<span class="hljs-attr">jQuery</span>文件 <span class="hljs-attr">--</span>%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"/pages/common/head.jsp"</span>%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span>h1 &#123;text-align: center;margin-top: 200px;&#125;h1 a &#123;<span class="css"><span class="hljs-selector-tag">color</span><span class="hljs-selector-pseudo">:red</span>;</span>&#125;input &#123;text-align: center;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"header"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo_img"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../../static/img/logo.gif"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wel_word"</span>&gt;</span>编辑图书<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%--</span> 静态包含<span class="hljs-attr">manager</span>管理，模块的菜单<span class="hljs-attr">--</span>%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"/pages/common/manager_menu.jsp"</span>%&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"main"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"manager/bookServlet"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pageNo"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;param.pageNo&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"action"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;empty param.id ? "</span><span class="hljs-attr">add</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">update</span>"&#125;" /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.id&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>作者<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>销量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.name&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.price&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.author&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sales"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.sales&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stock"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.stock&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%--</span>静态包含页脚内容<span class="hljs-attr">--</span>%&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%@include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">"/pages/common/footer.jsp"</span>%&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h5 id="1-5-4、删除图书功能的实现"><a href="#1-5-4、删除图书功能的实现" class="headerlink" title="1.5.4、删除图书功能的实现"></a>1.5.4、删除图书功能的实现</h5><h6 id="1-5-4-1、图解删除流程："><a href="#1-5-4-1、图解删除流程：" class="headerlink" title="1.5.4.1、图解删除流程："></a>1.5.4.1、图解删除流程：</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318222162.png" srcset="/img/loading.gif" alt="59931822216"></p><h6 id="1-5-4-2、BookServlet-程序中的-delete-方法："><a href="#1-5-4-2、BookServlet-程序中的-delete-方法：" class="headerlink" title="1.5.4.2、BookServlet 程序中的 delete 方法："></a>1.5.4.2、BookServlet 程序中的 delete 方法：</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//1.获取请求的参数id，图书编号</span>        <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);        <span class="hljs-comment">//2.调用bookServlet.deleteBookById();删除图书</span>        bookService.deleteBookById(id);        <span class="hljs-comment">//3.重定向回图书列表管理页面</span>        resp.sendRedirect(req.getContextPath() + <span class="hljs-string">"/manager/bookServlet?action=page&amp;pageNo="</span> + req.getParameter(<span class="hljs-string">"pageNo"</span>));    &#125;</code></pre></div><h6 id="1-5-4-3、给-WebUtils-工具类添加转换-int-类型的工具方法"><a href="#1-5-4-3、给-WebUtils-工具类添加转换-int-类型的工具方法" class="headerlink" title="1.5.4.3、给 WebUtils 工具类添加转换 int 类型的工具方法"></a>1.5.4.3、给 WebUtils 工具类添加转换 int 类型的工具方法</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 将字符串转换为int类型的</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> strInt</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> defaultValue</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(String strInt,<span class="hljs-keyword">int</span> defaultValue)</span></span>&#123;        <span class="hljs-keyword">if</span> (strInt == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//前台客户端传参一定会是null,null转integer会报错</span>            <span class="hljs-keyword">return</span> defaultValue;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> Integer.parseInt(strInt);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//e.printStackTrace();</span>        &#125;        <span class="hljs-keyword">return</span> defaultValue;    &#125;</code></pre></div><h6 id="1-5-4-4、修改删除的连接地址："><a href="#1-5-4-4、修改删除的连接地址：" class="headerlink" title="1.5.4.4、修改删除的连接地址："></a>1.5.4.4、修改删除的连接地址：</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318397681.png" srcset="/img/loading.gif" alt="59931839768"></p><h6 id="1-5-4-5、给删除添加确认提示操作："><a href="#1-5-4-5、给删除添加确认提示操作：" class="headerlink" title="1.5.4.5、给删除添加确认提示操作："></a>1.5.4.5、给删除添加确认提示操作：</h6><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">        <span class="hljs-comment">// 给删除的a 标签绑定单击事件，用于删除的确认提示操作</span></span><span class="javascript">        $(<span class="hljs-string">"a.deleteClass"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">        <span class="hljs-comment">// 在事件的function 函数中，有一个this 对象。这个this 对象，是当前正在响应事件的dom 对象。</span></span>        /**        * confirm 是确认提示框函数        * 参数是它的提示内容        * 它有两个按钮，一个确认，一个是取消。<span class="actionscript">        * 返回<span class="hljs-literal">true</span> 表示点击了，确认，返回<span class="hljs-literal">false</span> 表示点击取消。</span>        */<span class="javascript">        <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">"你确定要删除【"</span> + $(<span class="hljs-keyword">this</span>).parent().parent().find(<span class="hljs-string">"td:first"</span>).text() + <span class="hljs-string">"】?"</span>); </span><span class="actionscript">           <span class="hljs-comment">// return false// 阻止元素的默认行为===不提交请求</span></span>        &#125;);    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h5 id="1-5-5、修改图书功能的实现"><a href="#1-5-5、修改图书功能的实现" class="headerlink" title="1.5.5、修改图书功能的实现"></a>1.5.5、修改图书功能的实现</h5><h6 id="1-5-5-1：图解修改图书细节："><a href="#1-5-5-1：图解修改图书细节：" class="headerlink" title="1.5.5.1：图解修改图书细节："></a>1.5.5.1：图解修改图书细节：</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318493594.png" srcset="/img/loading.gif" alt="59931849359"></p><h6 id="1-5-5-2、更新【修改】的请求地址："><a href="#1-5-5-2、更新【修改】的请求地址：" class="headerlink" title="1.5.5.2、更新【修改】的请求地址："></a>1.5.5.2、更新【修改】的请求地址：</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318557768.png" srcset="/img/loading.gif" alt="59931855776"></p><h6 id="1-5-5-3、BookServlet-程序中添加-getBook-方法："><a href="#1-5-5-3、BookServlet-程序中添加-getBook-方法：" class="headerlink" title="1.5.5.3、BookServlet 程序中添加 getBook 方法："></a>1.5.5.3、BookServlet 程序中添加 getBook 方法：</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getBook</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//1.获取请求的参数图书编号</span>        <span class="hljs-keyword">int</span> id = WebUtils.parseInt(req.getParameter(<span class="hljs-string">"id"</span>),<span class="hljs-number">0</span>);        <span class="hljs-comment">//2.调用bookServlet.queryBookId查询图书编号</span>        Book book = bookService.queryBookById(id);        <span class="hljs-comment">//3.保存图书到Request域中</span>        req.setAttribute(<span class="hljs-string">"book"</span>,book);        <span class="hljs-comment">//4.请求转发到 pages/manager/book_edit.jsp页面</span>        req.getRequestDispatcher(<span class="hljs-string">"/pages/manager/book_edit.jsp"</span>).forward(req,resp);    &#125;</code></pre></div><h6 id="1-5-5-4、在-book-edit-jsp-页面中显示修改的数据"><a href="#1-5-5-4、在-book-edit-jsp-页面中显示修改的数据" class="headerlink" title="1.5.5.4、在 book_edit.jsp 页面中显示修改的数据"></a>1.5.5.4、在 book_edit.jsp 页面中显示修改的数据</h6><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"main"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"manager/bookServlet"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pageNo"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;param.pageNo&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"action"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;empty param.id ? "</span><span class="hljs-attr">add</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">update</span>"&#125;" /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.id&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>作者<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>销量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.name&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.price&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.author&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sales"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.sales&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stock"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;requestScope.book.stock&#125;"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h6 id="1-5-5-5、在-BookServlet-程序中添加-update-方法："><a href="#1-5-5-5、在-BookServlet-程序中添加-update-方法：" class="headerlink" title="1.5.5.5、在 BookServlet 程序中添加 update 方法："></a>1.5.5.5、在 BookServlet 程序中添加 update 方法：</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//1.获取请求的参数==封装称为Book对象</span>        Book book = WebUtils.copyParmToBean(req.getParameterMap(), <span class="hljs-keyword">new</span> Book());        <span class="hljs-comment">//2.调用BookServlet.update</span>        bookService.updateBook(book);        <span class="hljs-comment">//3.重定向回图书列表管理页面</span>        resp.sendRedirect(req.getContextPath() + <span class="hljs-string">"/manager/bookServlet?action=page&amp;pageNo="</span> + req.getParameter(<span class="hljs-string">"pageNo"</span>));    &#125;</code></pre></div><h6 id="1-5-5-6、解决-book-edit-jsp页面，即要实现添加，又要实现修改操作"><a href="#1-5-5-6、解决-book-edit-jsp页面，即要实现添加，又要实现修改操作" class="headerlink" title="1.5.5.6、解决 book_edit.jsp页面，即要实现添加，又要实现修改操作"></a>1.5.5.6、解决 book_edit.jsp页面，即要实现添加，又要实现修改操作</h6><p><img src="/2020/09/05/%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AF%87/1599318761101.png" srcset="/img/loading.gif" alt="59931876110"></p>]]></content>
    
    
    <categories>
      
      <category>项目笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学成在线：项目总结</title>
    <link href="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
    <url>/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><p>后端代码：<a href="https://github.com/JK1452470209/xcEduService" target="_blank" rel="noopener">https://github.com/JK1452470209/xcEduService</a></p><p>前端代码：<a href="https://github.com/JK1452470209?tab=repositories" target="_blank" rel="noopener">https://github.com/JK1452470209?tab=repositories</a></p><p>完整的数据库文件以及 <code>nginx</code> 配置已上传至后端代码工程内</p><h1 id="一、学成在线是一个什么样的项目？"><a href="#一、学成在线是一个什么样的项目？" class="headerlink" title="一、学成在线是一个什么样的项目？"></a>一、学成在线是一个什么样的项目？</h1><h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a>1. 项目背景</h2><p>受互联网+概念的催化，当今中国在线教育市场的发展可谓是百花齐放、如火如荼。 按照市场领域细分为：学前教<br>育、K12教育、高等 育、留学教育、职业教育、语言教育、兴趣教育以及综合平台，其中，职业教育和语言教育<br>的市场优势突出。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image1.png" srcset="/img/loading.gif" alt="image-20200612174927095"></p><p>学成在线借鉴了<code>MOOC</code>（大型开放式网络课程，即MOOC（massive open online courses））的设计思想，是一<br>个提供IT职业课程在线学习的平台，它为即将和已经加入IT领域的技术人才提供在线学习服务，用户通过在线学<br>习、在线练习、在线考试等学习内容，最终掌握所学的IT技能，并能在工作中熟练应用。</p><p>当前市场的在线教育模式多种多样，包括：<code>B2C</code>、<code>C2C</code>、<code>B2B2C</code> 等业务模式，学成在线采用 <code>B2B2C</code> 业务模式，即向企业或个人提供在线教育平台和学生完成教学活动，市场上类似的平台有：网易云课堂、腾讯课堂等，学成在线的特点是IT职业课程在线教学。</p><h2 id="2-功能模块"><a href="#2-功能模块" class="headerlink" title="2. 功能模块"></a>2. 功能模块</h2><p>学成在线是一个在线教育平台，提供IT职业课程在线学习，平台包括：门户、学习中心、教学管理中心、系统管理<br>中心、社交系统等子系统。</p><p>项目的功能架构如下图：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image2.png" srcset="/img/loading.gif" alt="image-20200612175042972"></p><p>门户是整个平台的入口，功能包括：</p><ul><li>门户首页</li><li>注册/登录</li><li>课程搜索</li><li>职业规划</li><li>客服等</li></ul><p>学习中心为用户提供在线学习服务，包括：</p><ul><li>我的课程</li><li>视频点播</li><li>视频直播</li><li>在线考试</li><li>在线答疑</li><li>学习统计等功能</li></ul><p>教学管理中心为教育机构或个人讲师提供教学管理功能，包括：</p><ul><li>课程管理</li><li>媒资管理</li><li>考试管理</li><li>问答管理等功能</li></ul><p>系统管理中心提供系统参数配置</p><ul><li>CMS</li><li>数据字典</li><li>分类管理等功能</li></ul><h2 id="3-技术架构"><a href="#3-技术架构" class="headerlink" title="3. 技术架构"></a>3. 技术架构</h2><p>项目采用前后端分离的技术架构，前端采用vue.js构建，服务端采用 <code>Spring Cloud Netflix</code> 微服务架构，系统分为用户层、<code>CDN</code>、负载均衡、前端UI、微服务层、数据层、接口层 及 <code>DevOps</code> 等部分组成，下图是完整的技术架构图：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image3.png" srcset="/img/loading.gif" alt="image-20200612175427241"></p><p>业务流程举例：</p><p>1、用户可以通过pc、手机等客户端访问系统进行在线学习。<br>2、 系统应用 <code>CDN</code> 技术，对一些 <code>图片</code>、<code>CSS样式文件</code>、<code>视频</code> 等资源从 <code>CDN</code> 调度访问。<br>3、所有的请求全部经过负载均衡器。<br>4、对于PC、H5等客户端请求，首先请求UI层，渲染用户界面。<br>5、客户端UI请求服务层获取进行具体的业务操作。<br>6、服务层将数据持久化到数据库</p><p>下图是技术架构简图：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image4.png" srcset="/img/loading.gif" alt="image-20200612175442386"></p><p>1、用户层，用户层描述了本系统所支持的客户端用户有哪些，本项目目前为各用户提供服务，包括H5、PC、Android和IOS等。</p><p>2、<code>CDN</code> 全称 <code>Content Delivery Network</code>，即内容分发网络，本系统所有静态资源全部通过 <code>CDN</code> 加速来提高访问速度。系统静态资源包括：html页面、js文件、css文件、image图片、pdf和ppt及doc教学文档、video视频等</p><p>3、负载均衡 系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，系统采用LVS+Nginx实现负载均衡均<br>衡。</p><p>4、<code>UI</code> 层 UI层描述了系统向pc用户、app用户、h5用户提供的产品界面。本项目在 <code>PC</code> 和 <code>H5</code> 端采用<code>vue.js+elementUI</code> 实现。</p><p>5、微服务层将系统服务分类三类：前端服务、后端服务及系统服务。 前端服务：主要为学习用户提供学习服务。<br>后端服务：主要为管理用户提供教学管理服务。 系统服务：公共服务，为系统的所有微服务提供公共服务功能</p><p>6、外部系统接口 包括如下接口：</p><ul><li>第三方登录接口，如QQ、微博、微信等。</li><li>支付宝、微信支付接口</li><li>短信接口 （阿里大于）</li><li>邮件接口，通过smpt邮件服务器对外发送电子邮件。</li><li>微信公众号</li><li>点播、直播。</li><li><code>OSS</code> 存储</li><li>CDN，使用最阿里云CDN服务加速视频访问速度。</li></ul><p>7、<code>DevOps</code> 提供了本系统开发、运营、维护支撑的系统，包括如下内容：</p><ul><li>Eureka 服务治理中心：提供服务治理服务，包括：服务注册、服务获取等。</li><li>Docker 容器化部署服务：将本系统所有服务采用容器化部署方式。</li><li>Maven 项目管理工具：提供管理项目所有的 <code>Java</code> 包依赖、项目工程打包服务。</li><li>Git/GitLab 代码管理服务:提供 <code>git</code> 代码管理服务。</li><li>Spring Boot Admin 服务健康监控：监控微服务的健康状态、会话数量、并发数等</li></ul><h1 id="二、项目采用什么技术架构？"><a href="#二、项目采用什么技术架构？" class="headerlink" title="二、项目采用什么技术架构？"></a>二、项目采用什么技术架构？</h1><h2 id="1-微服务技术栈"><a href="#1-微服务技术栈" class="headerlink" title="1. 微服务技术栈"></a>1. 微服务技术栈</h2><p>所有微服务基于 <code>Spring Boot</code>、<code>Spring Cloud Netflix</code>构建</p><ul><li><p><strong>控制层</strong></p><p><code>Spring MVC</code>、<code>Spring Security Oauth2</code> 、<code>Swagger</code></p></li><li><p><strong>业务层</strong></p><p>事务控制：<code>Spring</code></p><p>任务处理：<code>Spring Task</code></p><p>数据缓存：<code>Spring Data Redis</code></p><p>消息队列：<code>Spring Rabbit Template</code></p><p>搜索： <code>Elasticsearch</code></p></li><li><p><strong>持久层</strong></p><p>操作 MySQL：<code>MyBatis</code>、<code>Druid</code> 连接池、<code>Spring Data JPA</code></p><p>操作MongoDB：<code>Spring Data Mongodb</code></p></li><li><p><strong>数据层</strong></p><p>采用 <code>MySQL</code> 和 <code>MongoDb</code> 存储数据，<code>MySQL</code> 存储用户、课程等系统核心信息，<code>MongoDB</code> 存储 <code>cms</code>、配置信息。等认证模块使用 <code>redis</code> 储存用户的令牌信息</p></li></ul><h2 id="2-接口定义规范"><a href="#2-接口定义规范" class="headerlink" title="2. 接口定义规范"></a>2. 接口定义规范</h2><p>项目架构设立接口层，接口层使用 <code>swagger</code> 注解描述接口的内容，接口定义规范如下：</p><p><strong>请求</strong></p><ul><li><code>GET</code> 请求时，前端请求 key/value 串，SpringMVC采用基本数据类型（String、Integer等）或自定义类型接收。</li><li><code>POST</code> 请求时，前端请 <code>Form</code> 表单数据（application/x-www-form-urlencoded）和 <code>Json</code> 数据(ContentType=application/json)、多部件类型数据（multipart/form-data），对于Json数据SpringMVC使用<br><code>@RequestBody</code> 注解解析请求的 <code>json</code> 数据。</li></ul><p><strong>响应</strong></p><ul><li>响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。</li><li>响应结果统一格式为 <code>json</code>。</li></ul><h2 id="3-微服务注册中心"><a href="#3-微服务注册中心" class="headerlink" title="3. 微服务注册中心"></a>3. 微服务注册中心</h2><p>两台 <code>Eureka Server</code> 互相注册，组成高可用。</p><p>微服务向 <code>Eureka Server</code> 注册自己，并在远程调用时从微服务发现目标服务地址。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image5.png" srcset="/img/loading.gif" alt="image-20200612181301600"></p><p>微服务远程调用采用客户端负载均衡技术，使用 <code>Feign Client</code>。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image6.png" srcset="/img/loading.gif" alt="image-20200612181320182"></p><h2 id="4-微服务网关"><a href="#4-微服务网关" class="headerlink" title="4. 微服务网关"></a>4. 微服务网关</h2><p>网关的作用是负载均衡、路由转发、请求过虑等。</p><p>项目中网关与 <code>Nginx</code> 配合使用。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image7.png" srcset="/img/loading.gif" alt="image-20200612181723892"></p><h2 id="5-项目使用Spring了吗？用了它的哪些东西？"><a href="#5-项目使用Spring了吗？用了它的哪些东西？" class="headerlink" title="5. 项目使用Spring了吗？用了它的哪些东西？"></a>5. 项目使用Spring了吗？用了它的哪些东西？</h2><p>该项目是基于 <code>Spring</code> 进行构建的</p><p>1、所有的微服务开发采用 <code>Spring Boot</code> 开发</p><p>3、数据层使用Spring Data JPA、Spring Data MongoDB、Spring Data redis。</p><p>4、业务层使用Spring来控制本地事务，还使用了 <code>Spring Task</code> 任务调度框架、<code>Spring AMQP</code> 组件等。</p><p>5、控制层使用 SpringMVC、<code>Sprnig Security Oauth2</code>。</p><p>6、微服务管理使用Spring Cloud的Eureka注册中心，微服务之间调用使用 <code>Ribbon</code> 和 <code>Feign Client</code> 完成。</p><p>7、使用 <code>Zuul</code>网关完成微服务安全验证</p><h2 id="6-项目中Spring-Cloud是怎么使用的？"><a href="#6-项目中Spring-Cloud是怎么使用的？" class="headerlink" title="6. 项目中Spring Cloud是怎么使用的？"></a>6. 项目中Spring Cloud是怎么使用的？</h2><blockquote><p>此问题通常是在回答了项目的技术架构后被问及，根据具体的使用Spring Cloud完成微服务开发的步骤来回答即可。</p></blockquote><p>1、每个微服务使用 <code>Spring Boot</code> 开发，每个微服务工程包括了web、service、dao三层，这和开发一般的项目没有区别：</p><ul><li>web 层使用Spring MVC实现，对外暴露API接口给前端调用。</li><li>service 层就是根据业务逻辑编写 JavaBean，并使用Spring的声明式事务控制方式来控制事务。</li><li>dao 层就是数据访问接口，来访问MySQL和Mongodb，访问MySQL使用 <code>Spring Data JPA</code> 和 <code>Mybatis</code>，访问 <code>mongodb</code>使用 <code>Spring data mongodb</code>。</li></ul><p>2、微服务开发完成要向 <code>Eureka</code> 注册中心注册，以便被其它微服务查找和访问。</p><p>3、微服务与微服务之间使用 <code>feign</code> 来调用，<code>feign Client</code>具有负载均衡的作用。只需要在接口上声明<code>@FeignClient</code> 注，Spring 底层会产生动态代理对象，使用 <code>ribbon</code> 客户端完成调用。</p><p>4、前端访问微服务需要通过网关，网关使用<code>Nginx</code> 和 <code>Zuul</code> 来实现，Nginx 是最前边的负载均衡，通过 Nginx 之后便到达了 Zuul，项目中 Zuul 的功能是过虑用户请求，判断用户身份，对于一些对外公开的微服务则需要经过 Zuul，直接通过 <code>Nginx</code> 负载均衡即可访问</p><h2 id="7-Spring-Data-JPA-和-MyBatis-为什么两个都用？具体怎么用的？"><a href="#7-Spring-Data-JPA-和-MyBatis-为什么两个都用？具体怎么用的？" class="headerlink" title="7. Spring Data JPA 和 MyBatis 为什么两个都用？具体怎么用的？"></a>7. Spring Data JPA 和 MyBatis 为什么两个都用？具体怎么用的？</h2><blockquote><p>此问题是考察对数据访问接口的使用程度。</p></blockquote><p>项目中使用 <code>Spring Data JPA</code> 和 <code>MyBatis</code> 都是用来访问 <code>MySQL</code>，但是它们的分工不同：</p><p>Spring Data JPA 是 <code>Spring</code> 提供的一套JPA接口，使用 Spring Data JPA 主要完成一些简单的增、删、改、查功能。</p><p>对于复杂的查询功能会使用 <code>MyBatis</code> 编写SQL语言来实现，因为使用 <code>Spring Data JPA</code> 来做一些复杂的查询是没有 <code>MyBatis</code> 方便的，Spring Data JPA 是面向的对象，而 <code>MyBatis</code> 直接面向 <code>SQL</code> 语句，并且复杂的 <code>sql</code> 操作使用原生的 sql 实现的话也便于后续的优化。</p><h2 id="8-什么雪崩？如何解决？"><a href="#8-什么雪崩？如何解决？" class="headerlink" title="8. 什么雪崩？如何解决？"></a>8. 什么雪崩？如何解决？</h2><p>容错保护是指微服务在执行过程中出现错误并从错误中恢复的能力。微服务容错性不好很容易导致雪崩效应，什么<br>是雪崩效应</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image8.png" srcset="/img/loading.gif" alt="image-20200612184246324"></p><p>微服务的雪崩效应表现在服务与服务之间调用，当其中一个服务无法提供服务可能导致其它服务也死掉，比如：单<br>点登录服务调用用户信息服务查询用户信息，由于用户信息服务无法提供服务导致单点登录服务一直等待，从而导<br>致用户登录、用户退出功能无法使用，像这样由一个服务所引起的一连串的多个服务无法提供服务即是微服务的雪<br>崩效应。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image9.png" srcset="/img/loading.gif" alt="image-20200701171102167"></p><p>Spring Cloud Hystrix 是基于 <code>Netflix</code> 的开源框架 <code>Hystrix</code> 的整合，它实现了断路保护、线程隔离、信号隔离等容错功能。</p><p>什么是断路保护？</p><p>断路保护就类似家庭电路中的保险丝，当电路过载时保险丝会自动切断，保护整个电路的安全。微服务的断路保护<br>的工作原理是当请求微服务失败的数量达到一定比例时会切换为开路状态，当请求微服务时就直接返回结果不再请<br>求微服务，当保持开路状态一段时间后判断微服务是否可以正常请求，如果正常则切换到半开路状态，最后切换到<br>哪闭路状态。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image10.png" srcset="/img/loading.gif" alt="image-20200701171226812"></p><p>具体的操作方法可以采用 Fallback，会每个FeignClient方法调用Fallback，当出现开路则调用Fallback方法返回错<br>误结果。</p><p>什么是线程隔离？</p><p>调用微服务使用不同的线程池，线程池之间互不影响，即使某个服务不可用也不影响其它服务的调用，比如：对商<br>品服务的调用使用一个线程池，对用户服务的调用使用另一个线程池，即使用户服务不可用也不影响商品服务的调<br>用。</p><h2 id="9-视图层用什么技术实现？"><a href="#9-视图层用什么技术实现？" class="headerlink" title="9. 视图层用什么技术实现？"></a>9. 视图层用什么技术实现？</h2><p>此问题问的较模糊，没有问是客户端的视图还是服务端的视图，所以此问题不光是视图技术还是考察我们对前后端分离的理解。</p><p>1、视图层在前端和服务端都存在。</p><p>2、前端视图采用 <code>vue.js</code> + <code>elementUI</code> 产品界面。</p><p>3、服务端都是暴露的 <code>rest</code> 接口，统一用 <code>json</code> 展示数据。</p><h2 id="10-接口是怎么定义的？采用什么数据格式？"><a href="#10-接口是怎么定义的？采用什么数据格式？" class="headerlink" title="10. 接口是怎么定义的？采用什么数据格式？"></a>10. 接口是怎么定义的？采用什么数据格式？</h2><p>本问题考察前后端分离开发中接口定义技能。</p><p><strong>1、接口定义</strong></p><p>使用 <code>SpringMVC</code> 编写<code>Controller</code> 方法，对外暴露 <code>Http</code> 接口，在 <code>Controller</code> 方法上使用<code>RequestMapping</code>、<code>PostMapping</code>、<code>GetMapping</code> 等注解定义 <code>Http</code> 接口。</p><p><strong>2、采用什么数据格式？</strong></p><ul><li><p>请求：</p><p><code>GET</code> 请求时：前端请求 <code>key/value</code> 串，<code>SpringMVC</code> 采用基本数据类型（String、Integer等）或自定义类型接收。</p><p><code>POST</code> 请求时：前端请 <code>Form</code> 表单数据（application/x-www-form-urlencoded）和Json数据(ContentType=application/json)、多部件类型数据（multipart/form-data），对于 <code>Json</code> 数据SpringMVC使用 <code>@RequestBody</code> 注解解析请求的json数据。</p></li><li><p>响应：</p><p>统一响应 <code>json</code> 格式，<code>json</code> 格式数据 <code>SpringMVC</code> 采用 <code>FastJson</code> 解析为对象。</p><p>非 <code>json</code> 格式数据 <code>SpringMVC</code> 提供参数绑定的方法，将 <code>key/value</code> 或 <code>Form-Data</code> 数据转换为对象或基本数据类型的变量。</p></li></ul><h1 id="三、前端开发时具体流程是什么？"><a href="#三、前端开发时具体流程是什么？" class="headerlink" title="三、前端开发时具体流程是什么？"></a>三、前端开发时具体流程是什么？</h1><p>前后端分离开发模式在互联网公司最常见，特别是一些大型的互联网公司，但是一些传统的软件开发企业仍然是采用传统开发模式，此问题被问及是考察你有没有真正体会前端开发的好处。</p><p>1、前端与后端开发人员讨论确定接口。</p><p>接口讨论通过，形成接口文档 。</p><p>本项目专门设立一个 <code>api</code> 工程，在此工程定义接口，<code>Spring Boot</code> 集成 <code>Swagger</code>，生成 <code>Swagger</code> 接口，前后端开发人员通过 <code>html</code> 查看接口文档的内容。</p><p>2、前端与后端开发人员按照接口文档进行开发。</p><p>开发过程中各自进行单元测试。</p><p><strong>前端人员怎么进行单元测试？</strong></p><p>前端人员可以通过一些工具生成一些模拟数据，比如：<code>EasyMock</code>。</p><p>3、双方功能开发完成进行前后端联调。</p><p>阅读：<a href="https://github.com/phodal/fe/blob/master/chapters/chapter-13.md" target="_blank" rel="noopener">https://github.com/phodal/fe/blob/master/chapters/chapter-13.md</a></p><h2 id="前端采用什么技术栈？"><a href="#前端采用什么技术栈？" class="headerlink" title="前端采用什么技术栈？"></a>前端采用什么技术栈？</h2><p>前端工程大多为单页面应用（SPA），采用 <code>vue.js</code> 框架开发，搜索功能前端采用 <code>nuxt.js</code> 服务端渲染（SSR）框架开发。</p><p>技术栈包括：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>node.js</td><td>Node.js是一个事件驱动I/O服务端 <code>JavaScript</code> 环境，基于Google的 <code>V8</code> 引擎，V8引擎执行 Javascript 的速度非常快，性能非常好。</td></tr><tr><td>vue.js</td><td>一套构建用户界面的渐进式框架。<code>Vue</code> 的目标是通过尽可能简单的 <code>API</code> 实现响应的数据绑定和组合的视图组件。</td></tr><tr><td>npm/cnpm</td><td>NPM是随同 <code>NodeJS</code> 一起安装的包管理工具，能解决NodeJS代码部署上的很多问题</td></tr><tr><td>webpack</td><td><code>Webpack</code> 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</td></tr><tr><td>axios</td><td>Axios 是一个基于 <code>Promise</code> 的 HTTP 库，可以用在浏览器和 <code>node.js</code> 中。</td></tr><tr><td>nuxt.js</td><td><code>Nuxt.js</code> 是一个通过 Vue 用于服务端渲染的简单框架，灵感来自 <code>Next.js</code></td></tr><tr><td>element-ui</td><td>一套为开发者、设计师和产品经理准备的基于 <code>Vue 2.0</code> 的桌面端组件库</td></tr></tbody></table><h1 id="四、该项目当前完成了哪些功能"><a href="#四、该项目当前完成了哪些功能" class="headerlink" title="四、该项目当前完成了哪些功能"></a>四、该项目当前完成了哪些功能</h1><h2 id="1-CMS页面管理"><a href="#1-CMS页面管理" class="headerlink" title="1. CMS页面管理"></a>1. CMS页面管理</h2><p><code>CMS</code>（Content Management System）即内容管理系统，本项目对 <code>CMS</code> 系统的定位是对各各网站（子站点）页面的管理，本项目的CMS系统不去管理每个子网站的全部资源，比如：图片、<code>CSS</code>、<code>html</code> 页面等，主要管理由于运营需要而经常变动的页面，从而满足根据运营需要快速开发、上线的需求。</p><p>功能包括：</p><ul><li>站点管理，站点就是本项目各各子网站，站点信息包括：站点名称、站点域名、端口、服务器物理路径等</li><li>模板管理，由于要对页面进行静态化，使用 <code>freemarker</code> 引擎技术，所以需要定义模板。</li><li>页面管理，包括：页面添加、页面修改、页面删除等操作。</li><li>页面预览，对页面静态化，在浏览器预览页面静态化内容。</li><li>页面发布，将页面静态化后发布到所属站点服务器。</li></ul><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image11.png" srcset="/img/loading.gif" alt="image-20200630163534389"></p><h3 id="GirdFS是什么？工作原理是什么？如何使用？"><a href="#GirdFS是什么？工作原理是什么？如何使用？" class="headerlink" title="GirdFS是什么？工作原理是什么？如何使用？"></a>GirdFS是什么？工作原理是什么？如何使用？</h3><blockquote><p>是什么？为什么？怎么用？</p></blockquote><p><code>GridFS</code> 是 <code>MongoDB</code> 提供的用于持久化存储文件的模块，它可以作为分布式文件系统使用，<code>CMS</code> 子系统将页面文件、模板文件存储到 <code>GridFS</code> 中，由于本项目使用 <code>MongoDB</code>，选用 <code>GridFS</code> 可以快速集成开发。</p><p>它的工作原理是：</p><p>在 <code>GridFS</code> 存储文件是将文件分块存储，文件会按照 <code>256KB</code> 的大小分割成多个块进行存储，<code>GridFS</code> 使用两个集合（collection）存储文件，一个集合是 <code>chunks</code>, 用于存储文件的二进制数据；一个集合是 <code>files</code>，用于存储文件的元数据信息（文件名称、块大小、上传时间等信息）。</p><p>从 <code>GridFS</code> 中读取文件要对文件的各个块进行组装、合并。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image12.png" srcset="/img/loading.gif" alt="image-20200630164402558"></p><p>使用方法是：</p><p>使用 <code>Spring data mongodb</code> 包下提供的 <code>GridFsTemplate</code> 访问 <code>GirdFS</code>。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">gridFsTemplate</span><span class="hljs-selector-class">.findone</span>() 查询文件<span class="hljs-selector-tag">gridFsTemplate</span><span class="hljs-selector-class">.delete</span>() 删除文件<span class="hljs-selector-tag">gridFsTemplate</span><span class="hljs-selector-class">.store</span>()存储文件</code></pre></div><h3 id="MQ在本项目中是如何使用的？"><a href="#MQ在本项目中是如何使用的？" class="headerlink" title="MQ在本项目中是如何使用的？"></a>MQ在本项目中是如何使用的？</h3><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image13.png" srcset="/img/loading.gif" alt="image-20200630164458936"></p><p>1、平台包括多个站点，页面归属不同的站点，需求是发布一个页面应将该页面发布到所属站点的服务器上。</p><p>2、每个站点服务部署 <code>CMS Client</code> 程序，并与交换机绑定，绑定时指定站点 <code>Id</code> 为 <code>routingKey</code>。指定站点<code>id</code> 为<code>routingKey</code> 就可以实现 <code>cms client</code> 只能接收到所属站点的页面发布消息。</p><p>3、页面发布程序向 <code>MQ</code> 发布消息时指定页面所属站点 <code>Id</code> 为 <code>routingKey</code>，根据 <code>routingKey</code> 将消息发给指定的 <code>CMS Client</code>。</p><h3 id="页面发布的结果如何收集？"><a href="#页面发布的结果如何收集？" class="headerlink" title="页面发布的结果如何收集？"></a>页面发布的结果如何收集？</h3><p>每次发布会在数据库记录发布日志，每个 <code>CMS Client</code> 完成页面发布会上报发布结果。</p><p>1、在站点管理中配置了每个站点的服务器信息</p><p>2、在每次发布页面时会记录发布日志（服务器ID、页面ID、页面名称、发布结果）</p><p>3、<code>CMS Client</code> 完成页面发布后会向数据库记录发布结果。</p><p>4、用户通过查询发布日志表的信息就可以知道每一次的发布结果（哪些服务器页面发布成功，哪些发布失败）</p><h2 id="2-课程管理"><a href="#2-课程管理" class="headerlink" title="2. 课程管理"></a>2. 课程管理</h2><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image14.png" srcset="/img/loading.gif" alt="image-20200630165416148"></p><h3 id="为什么用多张表存储课程信息？"><a href="#为什么用多张表存储课程信息？" class="headerlink" title="为什么用多张表存储课程信息？"></a>为什么用多张表存储课程信息？</h3><p>1、课程信息比较复杂，为了方便教学机构按步骤管理课程信息，并且也可以划分权限管理课程信息，将课程信息<br>管理功能分为多个表，如下</p><ul><li>课程基本信息表</li><li>课程图片表</li><li>课程营销信息表</li><li>课程计划表等</li></ul><p>2、将课程信息分开也是为了系统扩展需要，如果将课程所有信息存储在一张表中将不利于系统扩展。</p><h2 id="3-媒资管理"><a href="#3-媒资管理" class="headerlink" title="3. 媒资管理"></a>3. 媒资管理</h2><p>每个教学机构都可以在媒资系统管理自己的教学资源，包括：视频、教案等文件。</p><p>媒资管理的主要管理对象是课程录播视频，包括：媒资文件的查询、视频上传、视频删除、视频处理等。</p><ul><li>媒资查询：教学机构查询自己所拥有的媒体文件。</li><li>视频上传：将用户线下录制的教学视频上传到媒资系统。</li><li>视频处理：视频上传成功，系统自动对视频进行编码处理。</li><li>视频删除：如果该视频已不再使用，可以从媒资系统删除。</li></ul><h3 id="如何上传大文件？"><a href="#如何上传大文件？" class="headerlink" title="如何上传大文件？"></a>如何上传大文件？</h3><p>前端使用 <code>WebUploader</code> 将文件分块，调用服务端分块上传接口来上传分块文件，分块上传完毕前端请求服务端进行合并，当上传过程中断再次进行上传时服务端判断分块是否已经上传，已经上传的分块不再重新上传。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image15.png" srcset="/img/loading.gif" alt="image-20200630165928118"></p><h3 id="如何进行视频处理？"><a href="#如何进行视频处理？" class="headerlink" title="如何进行视频处理？"></a>如何进行视频处理？</h3><p>如上图所示，<code>Java</code> 程序调用 <code>ffmpeg</code> 及流媒体程序员提供的视频处理类库（C程序）完成 <code>avi</code>、<code>mp4</code> 视频转成 <code>m3u8</code> 格式的视频。</p><p><code>Java</code> 程序使用Jdk提供的 <code>Process Builder</code> 调用 <code>ffmpeg</code> 及 <code>C</code> 程序进行视频处理。</p><p><code>Process Builder</code> 可以调用第三方程序，在 <code>java</code> 程序运行时启动第三方程序进程。</p><p>视频处理完成，<code>Java</code> 程序捕获第三方程序的输出日志，解析出视频处理完成标记，更新视频处理状态为已完成。</p><h3 id="CDN-内容分发是什么？"><a href="#CDN-内容分发是什么？" class="headerlink" title="CDN 内容分发是什么？"></a>CDN 内容分发是什么？</h3><p>视频处理完成会在中心媒体服务器保存一份，另外通过 <code>CDN</code> 程序将视频发布到边缘媒体服务器，用户点播视频通<br>过 <code>CDN</code> 请求边缘媒体服务器中的视频，提高了视频播放速度。</p><p>具体使用的是第三方公司的 <code>CDN</code> 服务。</p><blockquote><p>本项目中未实现CDN内容分发</p></blockquote><h2 id="4-搜索"><a href="#4-搜索" class="headerlink" title="4. 搜索"></a>4. 搜索</h2><p>项目中课程搜索采用 <code>ElasticSearch</code> 来完成。</p><p>实现方法是：</p><p>１、使用 <code>Logstash</code>（logstash是ES下的一款开源软件，它能够同时 从多个来源采集数据、转换数据）将MySQL中的课程信息读取到 <code>ES</code> 中创建索引，使用IK分词器进行分词。</p><p>2、使用 <code>Java High Level REST Client</code> 完成搜索。</p><p>3、生产环境使用 <code>ES</code> 部署为集群。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image16.png" srcset="/img/loading.gif" alt="image-20200630170658544"></p><h2 id="5-图片服务器"><a href="#5-图片服务器" class="headerlink" title="5. 图片服务器"></a>5. 图片服务器</h2><p>本项目采用 <code>FastDFS</code> 分布式系统作为图片服务器。</p><p><code>FastDFS</code> 是用 <code>c</code> 语言编写的一款开源的分布式文件系统，适合小文件的存储。</p><p>FastDFS 包括 <code>Tracker server</code> 和 <code>Storage server</code> 。客户端请求 <code>Tracker server</code> 进行文件上传、下载，通过 <code>Tracker server</code> 调度向 <code>Storage server</code> 完成文件上传和下载。</p><p>使用 <code>FastDFS</code> 官方提供的 <code>Java API</code> 实现。</p><p>图片服务使用 <code>Nginx</code> 作为代理服务器，对 <code>Storage</code>上部署的 <code>Nginx</code> 完成负载均衡请求。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image17.png" srcset="/img/loading.gif" alt="image-20200630170937123"></p><h3 id="使用FastDFS的好处是什么？"><a href="#使用FastDFS的好处是什么？" class="headerlink" title="使用FastDFS的好处是什么？"></a>使用FastDFS的好处是什么？</h3><p><code>FastDFS</code> 相比其它的分布式文件系统它适用小文件存储，它不对文件进行分块存储，也不用对文件进行合并处理，所以性能比 <code>GFS</code>、<code>HDFS</code> 等通用文件系统的性能要高。</p><h3 id="图片上传流程是怎么样的？"><a href="#图片上传流程是怎么样的？" class="headerlink" title="图片上传流程是怎么样的？"></a>图片上传流程是怎么样的？</h3><p>时序图如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image18.png" srcset="/img/loading.gif" alt="image-20200630171105177"></p><p>执行流程如下：</p><p>1、管理员进入教学管理前端，点击上传图片</p><p>2、图片上传至文件系统服务，文件系统请求 <code>fastDFS</code> 上传文件</p><p>3、文件系统将文件信息入库，将文件信息存储到文件系统服务数据库中。</p><p>4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的 <code>Url</code> 路径。</p><p>5、课程管理前端请求课程管理，进行保存课程图片信息到课程数据库。</p><p>6、课程管理服务将课程图片信息保存在课程数据库。</p><h3 id="FastDFS支持断点续传吗？"><a href="#FastDFS支持断点续传吗？" class="headerlink" title="FastDFS支持断点续传吗？"></a>FastDFS支持断点续传吗？</h3><p><code>FastDFS</code> 支付断点续传，在 <code>Api</code> 中有 <code>append_file1</code> 方法就是用来实现断点续传的，本项目没有使用 <code>FastDFS</code> 的断点续传功能。</p><h2 id="6-在线视频点播"><a href="#6-在线视频点播" class="headerlink" title="6. 在线视频点播"></a>6. 在线视频点播</h2><p>本项目采用 <code>HLS</code> 技术实现视频点播。</p><p>1、使用 <code>FFmpeg</code> 对视频进行编码处理，生成 <code>m3u8</code> 文件及 <code>ts</code> 文件。</p><p>2、使用 <code>Nginx</code> 作为媒体服务器。</p><p>3、客户端使用 <code>video.js</code> 播放视频。</p><h1 id="五、项目一些常见的问题"><a href="#五、项目一些常见的问题" class="headerlink" title="五、项目一些常见的问题"></a>五、项目一些常见的问题</h1><h2 id="1-认证授权如何实现？"><a href="#1-认证授权如何实现？" class="headerlink" title="1. 认证授权如何实现？"></a>1. 认证授权如何实现？</h2><p>本项目采用 <code>Spring security</code> + <code>Oauth2</code> 完成用户认证及用户授权。认证授权流程如下：</p><p>1、用户请求认证服务完成身份认证。</p><p>2、认证服务下发用户 <code>JTI</code> （身份令牌）和 <code>JWT</code> 令牌，拥有身份令牌表示身份合法，<code>Jwt</code> 令牌用于完成授权。</p><p>3、用户携带 <code>jwt</code> 令牌请求资源服务。</p><p>4、网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问。</p><p>5、资源服务获取 <code>jwt</code> 令牌，根据 <code>jwt</code> 令牌完成授权，并放行用户访问指定的资源。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image19.png" srcset="/img/loading.gif" alt="image-20200630181135872"></p><h2 id="2-事务是怎么控制的？分布式项目如何进行事务控制？"><a href="#2-事务是怎么控制的？分布式项目如何进行事务控制？" class="headerlink" title="2. 事务是怎么控制的？分布式项目如何进行事务控制？"></a>2. 事务是怎么控制的？分布式项目如何进行事务控制？</h2><p>此问题考察对事务的理解和应用程度。</p><p>1、在微服务中使用 <code>Spring</code> 声明式事务控制方式进行控制，在 <code>Service</code> 方法上添加 <code>@Transctional</code> 注解即可实现事务控制，它控制的是 <code>MySQL</code> 的本地事务。</p><p>2、项目中大量存在分布式事务控制，比如下单支付、课程发布等地址都用到了分布式事务。本项目实现分布式事务控制实现最终数据一致性，做法是：</p><p>a、将分布式事务拆分为多个本地事务。</p><p>b、提交事务前每个参与者要通过数据校验，和资源预留。</p><p>c、由消息队列去通知多个事务参与者完成本地事务的提交。</p><p>d、提交失败的本地事务会重试。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image20.png" srcset="/img/loading.gif" alt="image-20200630181442011"></p><h2 id="3-一个接口出现bug你是怎么进行调试的？"><a href="#3-一个接口出现bug你是怎么进行调试的？" class="headerlink" title="3. 一个接口出现bug你是怎么进行调试的？"></a>3. 一个接口出现bug你是怎么进行调试的？</h2><p>1、接口的开发需要前端和服务端共同调试，要仔细阅读测试人员反映的 <code>bug</code> 信息，判断这个 <code>bug</code> 是服务端的<code>bug</code> 还是前端的 <code>bug</code>。通常服务接口开发完成会使用 <code>postman</code> 工具进行测试，测试没有问题再提交到 <code>Git</code>或<code>SVN</code> 。</p><p>2、找到 <code>bug</code> 的出错点就可以根据 <code>bug</code> 信息进行修改。</p><p>3、修改完成需要前后端再次连调测试，按照测试人员提交的测试流程重新进行测试，测试通过将此 <code>bug</code> 置为已解决。</p><h2 id="4-本项目中在线支付是如何实现的？遇到哪些问题"><a href="#4-本项目中在线支付是如何实现的？遇到哪些问题" class="headerlink" title="4. 本项目中在线支付是如何实现的？遇到哪些问题"></a>4. 本项目中在线支付是如何实现的？遇到哪些问题</h2><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p>1、系统中收费的课程需要用户在线支付，支付接口采用微信的扫码支付。</p><p>2、拿到需求后，确定使用微信支付，首先去阅读微信的接口文档，这里重点阅读统一下单、支付结果通知、支付<br>结果查询三个接口。</p><p>3、下载官方提供的 <code>sdk</code> 编写单元测试用例测试每个接口。测试时没有使用微信的沙箱测试，直接使用正式接口，我们将金额改的小一些进行测试。</p><p>4、单元测试通过后开发整个支付功能，最终集成测试通过。</p><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>接口参数的签名问题，当时是因为自己没有仔细看接口文档导致少写一个必填参数一直报签名失败，随后将所有必填参数填写完成，最终解决问题。</p><blockquote><p>本项目中还未实现在线支付功能，这里仅是提供一些实现的思路，需要后续自己完善</p></blockquote><h2 id="5-系统的异常是怎么处理的？"><a href="#5-系统的异常是怎么处理的？" class="headerlink" title="5. 系统的异常是怎么处理的？"></a>5. 系统的异常是怎么处理的？</h2><p>系统对异常的处理使用统一的异常处理流程。</p><p>1、自定义异常类型。</p><p>2、自定义错误代码及错误信息。</p><p>3、对于可预知的异常由程序员在代码中主动抛出自定义异常类型的异常，抛出异常时需要指定错误代码。</p><p>4、对于不可预知的异常（运行时异常）由 <code>SpringMVC</code> 统一捕获 <code>Exception</code> 类型的异常，由统一的异常捕获类来解析处理，并转换为与自定义异常类型一致的信息格式（错误代码+错误信息）。</p><p>5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随请求响应给客户端。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image21.png" srcset="/img/loading.gif" alt="image-20200630182055803"></p><h2 id="6-使用消息队列了吗？如何使用的？有哪些应用场景"><a href="#6-使用消息队列了吗？如何使用的？有哪些应用场景" class="headerlink" title="6. 使用消息队列了吗？如何使用的？有哪些应用场景"></a>6. 使用消息队列了吗？如何使用的？有哪些应用场景</h2><p>项目使用 <code>RabbitMQ</code> 消息队列。</p><p><code>RabbitMQ</code> 提供很多的工作模式，如下：</p><ul><li>Work queues</li><li>Publish/Subscribe</li><li>Routing</li><li>Topics</li><li>Header</li><li>RPC</li></ul><p>项目主要使用了 <code>Routing</code> 模式。</p><p><code>Routing</code> 模式即路由模式，使用方法是：</p><p>1、每个消费者监听自己的队列，并且设置 <code>routingkey</code>。</p><p>2、生产者将消息发给交换机，由交换机根据 <code>routingkey</code> 来转发消息到指定的队列。</p><p><strong>有哪些应用场景？</strong></p><p>1、任务异步处理。</p><p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p><p>2、应用程序解耦合</p><p><code>MQ</code> 相当于一个中介，生产方通过 <code>MQ</code> 与消费方交互，它将应用程序进行解耦合。</p><h2 id="7-你在开发中遇到什么问题？是怎么解决的"><a href="#7-你在开发中遇到什么问题？是怎么解决的" class="headerlink" title="7. 你在开发中遇到什么问题？是怎么解决的"></a>7. 你在开发中遇到什么问题？是怎么解决的</h2><blockquote><p>此问题考察开发人员的问题描述及问题解决能力，可列举开发中实际的技术问题。</p></blockquote><p>回答此问题要从两个方面来回答：</p><p>1、问题的描述</p><p>2、问题的解决方案</p><p><strong>例子：</strong></p><p>在处理订单时要用到定时任务，当时采用的是 <code>Spring Task</code> 来完成，由于一个订单服务会部署多个，多个订单服务同时去处理任务会造成任务被重复处理的情况，如何解决任务的重复处理。</p><p><strong>解决：</strong></p><p>采用乐观锁解决，在任务表中设置一个 <code>version</code> 字段记录版本号，取出任务记录同时拿到任务的版本号，执行前对任务进行锁定，具体的做法是执行 <code>update</code> 根据当前版本号将版本号加 <code>1</code>，<code>update</code> 成功表示锁定任务成功，即可开始执行任务。</p><h1 id="六、项目功能的整体的测试"><a href="#六、项目功能的整体的测试" class="headerlink" title="六、项目功能的整体的测试"></a>六、项目功能的整体的测试</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1）启动基础设施"><a href="#1）启动基础设施" class="headerlink" title="1）启动基础设施"></a>1）启动基础设施</h3><ul><li>Mysql（本项目中用于储存课程管理相关数据）</li><li>Redis（本项目中用于储存JWT令牌信息）</li><li>MongoDB（本项目中用于储存页面信息、数据等）</li><li>RabbitMQ（消息队列）</li><li>ElasticSearch （提供数据索引的API）</li><li>Logstash （将数据并且进行分词处理后发布到ES）</li><li>Nginx（学成在线静态门户、各个服务的反向代理）</li><li>FastDFS Tracker、FastDFS Storage （提供小文件储存服务，本项目中用于储存图片）</li></ul><p><code>ElasticSearch</code> 和 <code>Logstash</code> 使用<code>windows</code> 批处理启动（开发环境）其他服务均使用 <code>windows</code> 服务启动，启动效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020011722-w.png" srcset="/img/loading.gif" alt="ElasticSearch集群和Logstash"></p><p>ES启动脚本</p><div class="hljs"><pre><code class="hljs shell">@echo offsetlocal enabledelayedexpansionsetlocal enableextensionsSET params='%*':loopFOR /F "usebackq tokens=1* delims= " %%A IN (!params!) DO (    SET current=%%A    SET params='%%B'SET silent=NIF "!current!" == "-s" (SET silent=Y)IF "!current!" == "--silent" (SET silent=Y)IF "!silent!" == "Y" (SET nopauseonerror=Y) ELSE (    IF "x!newparams!" NEQ "x" (        SET newparams=!newparams! !current!        ) ELSE (            SET newparams=!current!        ))    IF "x!params!" NEQ "x" (GOTO loop))CALL "%~dp0elasticsearch-env.bat" || exit /b 1IF ERRORLEVEL 1 (IF NOT DEFINED nopauseonerror (PAUSE)EXIT /B %ERRORLEVEL%)set ES_JVM_OPTIONS=%ES_PATH_CONF%\jvm.options@setlocalfor /F "usebackq delims=" %%a in (`CALL %JAVA% -cp "!ES_CLASSPATH!" "org.elasticsearch.tools.launchers.JvmOptionsParser" "!ES_JVM_OPTIONS!" ^|^| echo jvm_options_parser_failed`) do set JVM_OPTIONS=%%a@endlocal &amp; set "MAYBE_JVM_OPTIONS_PARSER_FAILED=%JVM_OPTIONS%" &amp; set ES_JAVA_OPTS=%JVM_OPTIONS:$&#123;ES_TMPDIR&#125;=!ES_TMPDIR!% %ES_JAVA_OPTS%if "%MAYBE_JVM_OPTIONS_PARSER_FAILED%" == "jvm_options_parser_failed" (  exit /b 1)cd /d "%ES_HOME%"<span class="hljs-meta">%</span><span class="bash">JAVA% %ES_JAVA_OPTS% -Delasticsearch -Des.path.home=<span class="hljs-string">"%ES_HOME%"</span> -Des.path.conf=<span class="hljs-string">"%ES_PATH_CONF%"</span> -Des.distribution.flavor=<span class="hljs-string">"%ES_DISTRIBUTION_FLAVOR%"</span> -Des.distribution.type=<span class="hljs-string">"%ES_DISTRIBUTION_TYPE%"</span> -cp <span class="hljs-string">"%ES_CLASSPATH%"</span> <span class="hljs-string">"org.elasticsearch.bootstrap.Elasticsearch"</span> !newparams!</span>endlocalendlocalexit /b %ERRORLEVEL%</code></pre></div><p>Logstash 启动脚本</p><div class="hljs"><pre><code class="hljs sh">@title logstash i n teachplan_media_publogstash.bat -f ../config/mysql_course_media.conf --path.data=../data/teachplan_media/</code></pre></div><h3 id="2）启动所有服务，并且检查是否注册到的eureka中"><a href="#2）启动所有服务，并且检查是否注册到的eureka中" class="headerlink" title="2）启动所有服务，并且检查是否注册到的eureka中"></a>2）启动所有服务，并且检查是否注册到的eureka中</h3><table><thead><tr><th>Application</th><th>服务描述</th></tr></thead><tbody><tr><td>XC-GOVERN-CENTER</td><td>Eureka服务注册中心，本项目中启动两个实例作为一主一从</td></tr><tr><td>XC-GOVERN-GATEWAY</td><td>Zuul网关</td></tr><tr><td>XC-SERVICE-BASE-FILESYSTEM</td><td>文件系统服务，本项目中主要提供图片服务上传下载功能</td></tr><tr><td>XC-SERVICE-LEARNING</td><td>学习中心服务，提供中心相关的API接口</td></tr><tr><td>XC-SERVICE-MANAGE-CMS</td><td>站点CMS，提供网站页面静态化、制作、发布等相关API接口</td></tr><tr><td>XC-SERVICE-MANAGE-CMS-CLIENT</td><td>站点CMS客户端，通过MQ接收页面发布的通知，</td></tr><tr><td>XC-SERVICE-MANAGE-COURSE</td><td>课程管理服务，提供课程管理相关的API</td></tr><tr><td>XC-SERVICE-MANAGE-MEDIA</td><td>课程媒资管理服务，提供课程媒体文件相关的API</td></tr><tr><td>XC-SERVICE-MANAGE-MEDIA-PROCESSOR</td><td>媒资处理服务，通过MQ接收视频处理通知，再调用第三方API来对媒资文件进行转码、分块等。</td></tr><tr><td>XC-SERVICE-MANAGE-ORDER</td><td>订单管理服务，提供订单处理相关的API</td></tr><tr><td>XC-SERVICE-SEARCH</td><td>搜索服务，提供搜索相关的API</td></tr><tr><td>XC-SERVICE-UCENTER</td><td>用户中心服务，提供用户相关的API</td></tr><tr><td>XC-SERVICE-UCENTER-AUTH</td><td>统一认证中心服务，提供认证、授权相关操作的API</td></tr></tbody></table><p>在IDEA中启动服务，启动效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020011635-G.png" srcset="/img/loading.gif" alt="img"></p><p>所有服务成功的注册到 <code>eureka</code> 中</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020011635-u.png" srcset="/img/loading.gif" alt="img"></p><h3 id="3）启动前端工程"><a href="#3）启动前端工程" class="headerlink" title="3）启动前端工程"></a>3）启动前端工程</h3><ul><li>xc-ui-pc-portal （搜索门户前端）</li><li>xc-ui-pc-sysmanage（站点CMS前端）</li><li>xc-ui-pc-teach（课程管理前端）</li><li>xc-ui-pc-leanring（用户学习中心前端）</li></ul><p>启动效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020011742-w.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-功能测试"><a href="#2-功能测试" class="headerlink" title="2. 功能测试"></a>2. 功能测试</h2><h3 id="1）页面静态化测试"><a href="#1）页面静态化测试" class="headerlink" title="1）页面静态化测试"></a>1）页面静态化测试</h3><p>访问cms前端 <a href="http://cms.xuecheng.com/#/cms/page/list" target="_blank" rel="noopener">http://cms.xuecheng.com/#/cms/page/list</a></p><blockquote><p>cms.xuecheng.com在hosts文件中指向本地，并且配置nginx虚拟主机</p></blockquote><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022012-D.png" srcset="/img/loading.gif" alt="img"></p><p>找到一个以往的页面，点击预览，效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022014-J.png" srcset="/img/loading.gif" alt="img"></p><p>新增页面，填写页面数据，填写数据模型url，用于结合模板渲染页面</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022020-j.png" srcset="/img/loading.gif" alt="img"></p><p>添加成功</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022019-O.png" srcset="/img/loading.gif" alt="img"></p><p>预览效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022019-v.png" srcset="/img/loading.gif" alt="img"></p><p>编辑页面信息测试</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022021-s.png" srcset="/img/loading.gif" alt="img"></p><p>删除测试</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image22.png" srcset="/img/loading.gif" alt="image-20200702202300060"></p><p>删除成功</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022023-k.png" srcset="/img/loading.gif" alt="img"></p><h4 id="测试过程中出现的一些问题"><a href="#测试过程中出现的一些问题" class="headerlink" title="测试过程中出现的一些问题"></a>测试过程中出现的一些问题</h4><ol><li><p>CMS接口无权限问题</p><p>问题描述：由于在之前的章节中没有对CMS前端做登录授权的相关配置，导致访问CMS页面时无法正常获取数据</p><p>解决方案：参考day18的 “四、前端集成认证授权” 章节进行配置。</p></li><li><p>课程预览无权限</p><p>问题描述：由于CMS在预览课程时候使用的是 <code>window.open()</code> 来访问预览页面，无法向 <code>header</code> 传递认证信息</p><p>解决方案：在 <code>cms</code> 服务和 <code>course</code> 服务的 <code>ResourceServerConfig</code> 分别放心 <code>/cms/preview/*</code>，<code>/cms/config/getmodel/*</code> 和 <code>/course/preview/model/*</code> 的鉴权</p></li></ol><h3 id="2）课程管理"><a href="#2）课程管理" class="headerlink" title="2）课程管理"></a>2）课程管理</h3><p>访问学成主站 <a href="http://www.xuecheng.com/" target="_blank" rel="noopener">http://www.xuecheng.com/</a></p><p>点击右上角登录，进入到登录页面</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022026-1.png" srcset="/img/loading.gif" alt="img"></p><p>登录成功，主站右上角显示用户信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022029-N.png" srcset="/img/loading.gif" alt="img"></p><p>登录成功后，用户的认证令牌信息储存到 <code>redis</code> 中</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022033-N.png" srcset="/img/loading.gif" alt="img"></p><p>点击右上方的 “教学提供方” 进入到课程管理前端，点击我的课程，页面初始化前会访问 <code>/course/list</code> 接口获取该用户所属的所有课程信息，并且渲染到页面当中，效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022034-k.png" srcset="/img/loading.gif" alt="img"></p><p>点击管理课程，测试更新课程信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022035-8.png" srcset="/img/loading.gif" alt="img"></p><p>测试更换课程图片，删除原有图片并且上传</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022044-O.gif" srcset="/img/loading.gif" alt="img"></p><p>营销信息修改</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022045-u.png" srcset="/img/loading.gif" alt="img"></p><p>添加课程计划测试</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022046-q.png" srcset="/img/loading.gif" alt="img"></p><p>预览课程</p><p>点击课程预览，生成预览链接</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022047-Z.png" srcset="/img/loading.gif" alt="img"></p><p>访问预览链接，效果如下</p><p>从效果图中可以看到，成功将我们的课程数据与课程模板相结合进行静态化渲染，得到最终的课程详情页面效果</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022048-p.png" srcset="/img/loading.gif" alt="img"></p><p>课程发布</p><p>点击课程发布按钮</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022110-d.png" srcset="/img/loading.gif" alt="img"></p><p>点击查看课程详情页面，会自动跳转到该课程的正式发布页面，跳转到的链接如下</p><p><a href="http://www.xuecheng.com/course/detail/4028e58161bcf7f40161bcf8b77c0000.html" target="_blank" rel="noopener">http://www.xuecheng.com/course/detail/4028e58161bcf7f40161bcf8b77c0000.html</a></p><p>页面效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022111-P.png" srcset="/img/loading.gif" alt="img"></p><p>课程重新发布后，课程发布信息的时间戳会被更新，logstash也会重新采集我们发布的课程数据并且添加到 <code>ElasticSearch</code> 的索引库当中</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022111-v.png" srcset="/img/loading.gif" alt="img"></p><p>更新的 <code>ES</code> 索引库数据如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020022113-8.png" srcset="/img/loading.gif" alt="img"></p><h3 id="3）媒资管理"><a href="#3）媒资管理" class="headerlink" title="3）媒资管理"></a>3）媒资管理</h3><p>上传视频文件测试，效果如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/image23.png" srcset="/img/loading.gif" alt="image-20200703214815949"></p><p>访问我的媒资，可以看到我们刚才上传的视频文件的相关信息，如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032148-W.png" srcset="/img/loading.gif" alt="img"></p><h3 id="4）课程信息搜索"><a href="#4）课程信息搜索" class="headerlink" title="4）课程信息搜索"></a>4）课程信息搜索</h3><p>访问搜索门户页面 <a href="http://www.xuecheng.com/course/search" target="_blank" rel="noopener">http://www.xuecheng.com/course/search</a> 为了显示分页的效果，我们设置为每页显示两个结果</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032217-M.png" srcset="/img/loading.gif" alt="img"></p><p>输入 <code>cloud</code> 关键字进行搜索，并且实现关键字高亮，效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032218-J.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>课程图片随意上传的，别较真哈哈</p></blockquote><p>点击搜索结果进入该课程的课程详情页面</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032221-0.png" srcset="/img/loading.gif" alt="img"></p><h3 id="5）在线点播"><a href="#5）在线点播" class="headerlink" title="5）在线点播"></a>5）在线点播</h3><p>在课程的课程计划管理中，为某个课程计划关联我们刚才上传的视频，操作示例如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032233-p.gif" srcset="/img/loading.gif" alt="img"></p><p>关联成功后，重新发布该课程信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032239-4.png" srcset="/img/loading.gif" alt="img"></p><p>课程信息重新发布后，会更新该课程的时间戳，<code>logstash</code> 检索到时间戳的变化后会自动将更新后的课程信息到 <code>ElasticSearch</code> 的索引库中，如下图所示</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032240-L.png" srcset="/img/loading.gif" alt="img"></p><p>自动更新课程计划信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032241-F.png" srcset="/img/loading.gif" alt="img"></p><p>来到该课程的课程详情页面，点击 <code>马上学习</code></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020041308-t.png" srcset="/img/loading.gif" alt="img"></p><p>进入到在线学习页面，点击目录中的课程计划，将会自动切换到课程计划节点对应的媒资内容</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/202020032242-f.png" srcset="/img/loading.gif" alt="img"></p><p>播放测试，推动进度条</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E6%80%BB%E7%BB%93/2020200322-F.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day20：项目部署与持续集成（DevOps）</title>
    <link href="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/"/>
    <url>/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day20</code> 的内容。</p><ul><li>原讲义中对该章节的 <code>gitlab</code> 与 <code>jenkins</code> 安装步骤以及部署容器的内容和步骤描述得不够详细，在本文中做出了补充，详细的描述每个步骤。</li><li>本章节建议还是尝试看笔记来完成一次操作，然后再去看视频资料，这样能理解得更深刻。</li></ul><h1 id="一、DevOps介绍"><a href="#一、DevOps介绍" class="headerlink" title="一、DevOps介绍"></a>一、DevOps介绍</h1><p>DevOps 是 <code>Development</code> 和 <code>Operations</code> 两个词的缩写，引用百度百科的定义：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image1.png" srcset="/img/loading.gif" alt="image-20200607210842378"></p><p><code>DevOps</code> 是一种方法或理念，它涵盖开发、测试、运维的整个过程。<code>DevOps</code> 是提高软件开发、测试、运维、运营等各部门的沟通与协作质量的方法和过程，<code>DevOps</code> 强调软件开发人员与软件测试、软件运维、质量保障（QA）部门之间有效的沟通与协作，强调通过自动化的方法去管理软件变更、软件集成，使软件从构建到测试、发布更加快捷、可靠，最终按时交付软件。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image2.png" srcset="/img/loading.gif" alt="image-20200607210903849"></p><p><code>DevOps</code> 兴起于2009年，近年来由于云计算、互联网的发展，促进了DevOps的基础设施及工具链的发展，涌现了一大批优秀的工具，这些工具包括开发、测试、运维的各各领域，例如：GitHub、Git/SVN、Docker、Jenkins、Hudson、Ant/Maven/Gradle、Selenium、QUnit、JMeter 等。下图是DevOps相关的工具集：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image3.png" srcset="/img/loading.gif" alt="image-20200607210927381"></p><h1 id="二、使用GitLab管理项目"><a href="#二、使用GitLab管理项目" class="headerlink" title="二、使用GitLab管理项目"></a>二、使用GitLab管理项目</h1><h2 id="1-安装Gitlab"><a href="#1-安装Gitlab" class="headerlink" title="1. 安装Gitlab"></a>1. 安装Gitlab</h2><p>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。</p><p>GitLab 与 GitHub的功能相似，通常企业使用GitLab在局域网搭建自己的Git代码管理仓库</p><p>拉取gitlab、redis、postgresql，<code>gitlab</code> 依赖 <code>redis</code> 和 <code>postgresql</code>。</p><div class="hljs"><pre><code class="hljs shell">sudo docker pull sameersbn/redissudo docker pull sameersbn/postgresqlsudo docker pull gitlab/gitlab-ce:latest</code></pre></div><p>新建容器的目录</p><div class="hljs"><pre><code class="hljs shell">sudo mkdir /var/docker/postgresql/data -psudo mkdir /var/docker/redis/data -psudo mkdir /var/docker/gitlab/data -p</code></pre></div><p>创建 postgresql、redis 容器：</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建postgresql容器</span>sudo docker run --name postgresql -d --privileged=true -e 'DB_NAME=gitlabhq_production' -e 'DB_USER=gitlab' -e 'DB_PASS=123123' -e 'DB_EXTENSION=pg_trgm' -v /var/docker/postgresql/data:/var/lib/postgresql sameersbn/postgresql<span class="hljs-meta">#</span><span class="bash"> 创建redis容器</span>sudo docker run --name redis -d --privileged=true -v  /var/docker/redis/data:/var/lib/redissameersbn/redis</code></pre></div><p>创建gitlab容器：</p><div class="hljs"><pre><code class="hljs shell">sudo docker run --name gitlab -d --link postgresql:postgresql --link redis:redisio \--hostname 10.1.1.161 -p 10022:22 -p 8910:80 -p 8911:443 -e 'GITLAB_PORT=8899' \-e 'GITLAB_SSH_PORT=10022' \-e 'GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string' \-e 'GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string' \-e 'GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string' \-e  'GITLAB_HOST=10.1.1.161' \-e 'SMTP_AUTHENTICATION=login' \-v /var/docker/gitlab/data:/home/git/data docker.io/gitlab/gitlab-ce</code></pre></div><blockquote><ul><li>使用 \ 来标识shell命令的换行，在shell命令过长的情况下使用 \ 换行可以使内容更加清晰</li><li>–link：可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量</li></ul></blockquote><p>浏览器访问：<a href="http://10.1.1.161:8910/" target="_blank" rel="noopener">http://10.1.1.161:8910</a></p><p>初次访问需要等待一段时间。</p><p>查看 gitlab的启动日志</p><div class="hljs"><pre><code class="hljs shell">sudo docker logs -f gitlab</code></pre></div><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image4.png" srcset="/img/loading.gif" alt="image-20200607182758861"></p><p>启动完成后，配置初始密码，默认用户名为 <code>root</code></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image5.png" srcset="/img/loading.gif" alt="image-20200607183035804"></p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>登录 gitlab 后访问 <a href="http://10.1.1.161:8910/projects/new" target="_blank" rel="noopener">http://10.1.1.161:8910/projects/new</a></p><p>填写项目的基本信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image6.png" srcset="/img/loading.gif" alt="image-20200608183302202"></p><p>项目构建成功后，得到一个项目的链接 <a href="http://10.1.1.161:8910/root/xc-services-project" target="_blank" rel="noopener">http://10.1.1.161:8910/root/xc-services-project</a></p><p><img src="https://qnoss.codeyee.com/20200704_5b6u5pyN5YqhW+WtpuaIkOWcqOe6v10gZGF5MjAtMe+8mkRldk9wcyDpobnnm67pg6jnvbLkuI7mjIHnu63pm4bmiJA=/image7.png" srcset="/img/loading.gif" alt="image-20200608175145298"></p><h2 id="3-将项目推送至gitlab"><a href="#3-将项目推送至gitlab" class="headerlink" title="3. 将项目推送至gitlab"></a>3. 将项目推送至gitlab</h2><p>打开 cmd，进入到项目的目录下</p><p>1、运行 <code>git init</code> 初始化项目的git配置</p><p>2、在项目根目录下创建 <code>.gitignore</code> 文件，将一些编译后生成的文件排除在外 不上传至git仓库，内容如下</p><div class="hljs"><pre><code class="hljs shell">.idea*/target/*.**/target/**/*.**.class*.iml<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#ignore this file##</span></span>.classpath.project.settings     <span class="hljs-meta"> #</span><span class="bash"><span class="hljs-comment">#filter databfile、sln file##</span></span>*.mdb  *.ldb  *.sln   <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#class file##</span></span>*.com  *.class  *.dll  *.exe  *.o  *.so <span class="hljs-meta">#</span><span class="bash"> compression file</span>*.7z  *.dmg  *.gz  *.iso  *.jar  *.rar  *.tar  *.zip  *.via*.tmp*.err<span class="hljs-meta">#</span><span class="bash"> OS generated files <span class="hljs-comment">#  </span></span>.DS_Store  .DS_Store?  ._*  .Spotlight-V100  .Trashes  Icon?  ehthumbs.db  Thumbs.db</code></pre></div><p>3、执行 <code>git add .</code> 命令，暂存当前目录下的所有子目录以及文件到git记录</p><p>4、执行 <code>git commit -m &quot;第一次提交&quot;</code> 将暂存的记录正式提交到 <code>git</code> 记录内，-m 参数的内容为描述信息</p><p>5、执行以下命令，设置远程仓库的地址</p><div class="hljs"><pre><code class="hljs shell">git remote add origin "http://10.1.1.161:8910/root/xc-services-project.git"</code></pre></div><p>6、执行 <code>git push origin master</code> 推送代码到远程仓库</p><p><img src="https://qnoss.codeyee.com/20200704_5b6u5pyN5YqhW+WtpuaIkOWcqOe6v10gZGF5MjAtMe+8mkRldk9wcyDpobnnm67pg6jnvbLkuI7mjIHnu63pm4bmiJA=/image8.png" srcset="/img/loading.gif" alt="image-20200608184308041"></p><p>推送成功，查看远程仓库</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image9.png" srcset="/img/loading.gif" alt="image-20200608194951105"></p><h1 id="三、部署微服务到Docker"><a href="#三、部署微服务到Docker" class="headerlink" title="三、部署微服务到Docker"></a>三、部署微服务到Docker</h1><h2 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1. Docker简介"></a>1. Docker简介</h2><p>服务器虚拟化主要有两种技术：</p><p><strong>1、Hypervisor也叫VMM（virtual machine monitor）即虚拟机监视器</strong></p><p><code>Hypervisor</code> 是一种将操作系统与硬件抽象分离的方法，实现在宿主机（host machine）上能同时运行多个客户机（guest machine），每个客户机就是一个虚拟机，这些虚拟机高效地分享宿主机的硬件资源。</p><p>如下图：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image10.png" srcset="/img/loading.gif" alt="image-20200608135503026"></p><p>在服务器（宿主机）上安装操作系统，并安装hypervisor虚拟机管理软件，如VMware、VirtualBox等，由<br>hypervisor管理多个虚拟机，每个虚拟机上需要安装客户操作系统、依赖库、应用软件。</p><p><strong>2、Containers容器化技术</strong></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image11.png" srcset="/img/loading.gif" alt="image-20200608135556836"></p><p>容器技术中 <code>docker</code> 引擎取代了 <code>hypervisor</code>，docker引擎是运行在住宿操作系统上的一个进程，该进程管理了多个docker容器，每个docker容器集成了应用软件、依赖库，容器之间相互隔离。</p><p><strong>3、技术对比</strong></p><p>资源占用：</p><p>虚拟机由于是独立的操作系统，占用资源比docker多。</p><p>启动速度:</p><p>虚拟机包括操作系统，启动虚拟机相当于启动一个操作系统，容器则不一样，容器中只包括操作系统的内核，启动<br>一个容器实例相当于启动一个进程，容器的启动速度比虚拟机快。</p><p>体积：</p><p>容器包括操作系统内核、软件及依赖库，虚拟机不仅包括软件和依赖库还将完整的操作系统打包进去，虚拟机的体<br>积比容器大的多。</p><p><strong>4、Docker 容器架构</strong></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image12.png" srcset="/img/loading.gif" alt="image-20200608135730960"></p><ul><li><p><strong>Docker daemon</strong>（Docker守护进程）</p><p>Docker守护进程是部署在操作系统上，负责支撑 <code>Docker Container</code> 的运行以及本地 <code>Image</code> 的管理。</p></li><li><p><strong>Docker client</strong></p><p>用户不直接操作Docker daemon，用户通过 <code>Docker client</code> 访问 <code>Docker</code>，<code>Docker client</code> 提供<br>pull、run 等操作命令实现对docker的操作。</p></li><li><p><strong>Docker Image</strong></p><p>Docker 镜像就是一个只读的模板。 例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Tomcat或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p></li><li><p><strong>Docker Container</strong></p><p>Docker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停<br>止、删除。每个容器都是相互隔离的、保证安全的平台。打个比方，镜像相当于类，容器相当于对象。</p></li><li><p><strong>Docker Registry</strong></p><p>Docker 仓库分为公开仓库（Public）和私有仓库（Private）两种形式 最大的公开仓库是<br>Docker Hub，存放了数量庞大的镜像供用户下载。 用户也可以在本地网络内创建一个私有仓库。 当用户创建自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p></li></ul><h2 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2. 安装docker"></a>2. 安装docker</h2><p>Docker 可以运行在 MAC、Windows、Centos、DEBIAN、UBUNTU 等操作系统上，提供社区版和企业版，本教程基于Centos安装Docker。<code>Centos6</code> 对 docker 支持的不好，使用 <code>docker</code> 时建议升级到 <code>centos7</code>。</p><p>1、在 Centos7 上安装Docker</p><p>直接通过yum安装即可：</p><div class="hljs"><pre><code class="hljs powershell">yum install <span class="hljs-literal">-y</span> docker</code></pre></div><p>启动docker：<code>service docker start</code></p><p>查询docker版本: <code>docker version</code></p><p>关于的 <code>docker</code> 的一些常用的命令和操作，参考 <a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-tutorial.html</a></p><h2 id="3-部署流程"><a href="#3-部署流程" class="headerlink" title="3. 部署流程"></a>3. 部署流程</h2><p>本项目微服务采用 <code>SpringBoot</code> 开发，将每个微服务工程打成<code>Jar</code> 包，最终在 <code>Docker</code> 容器中运行 <code>jar</code>，部署流程如下：</p><p>1、SpringBoot 工程最终打成 <code>Jar</code> 包</p><p>2、创建Docker镜像</p><p>3、创建容器</p><p>4、启动容器</p><h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4. 打包"></a>4. 打包</h2><p>1、使用 maven 的打包插件：</p><p>将下边的插件依赖拷贝到微服务工程中，本例子将学成在线的 <code>Eureka</code> 工程打包：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>完整的 <code>Eureka</code> 工程 <code>pom.xml</code> 文件如下：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">                             http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-govern-center<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 导入Eureka服务的依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>2、maven打包</p><p>在工程目录运行：<code>mvn clear package</code></p><p>或通过IDEA执行 <code>clear package</code> 打包命令。</p><p>打包成功，如下图：</p><p><img src="https://qnoss.codeyee.com/20200704_5b6u5pyN5YqhW+WtpuaIkOWcqOe6v10gZGF5MjAtMe+8mkRldk9wcyDpobnnm67pg6jnvbLkuI7mjIHnu63pm4bmiJA=/image13.png" srcset="/img/loading.gif" alt="image-20200608151714281"></p><p>打包成功后在 <code>target</code> 目录下生成一个 jar包</p><h2 id="5-创建镜像"><a href="#5-创建镜像" class="headerlink" title="5. 创建镜像"></a>5. 创建镜像</h2><p>将上一步打包好的 <code>jar</code> 包拷贝到我们要部署微服务的Linux服务器，准备创建镜像。</p><p>安装jdk环境</p><div class="hljs"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install openjdk-8-jdk</code></pre></div><p>测试 jar 包是否可以运行，执行：<code>java -jar xc-govern-center-1.0-SNAPSHOT.jar</code></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image14.png" srcset="/img/loading.gif" alt="image-20200608153244826"></p><p>访问服务器地址 <a href="http://10.1.1.162:50101/" target="_blank" rel="noopener">http://10.1.1.162:50101/</a></p><blockquote><p>注意我这里的虚拟机IP地址为 10.1.1.162 ，测试的时候要更换你虚拟机的地址</p></blockquote><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image15.png" srcset="/img/loading.gif" alt="image-20200608160630154"></p><p>在 <code>jar</code> 包的目录下编写 <code>Dockerfile</code> 文件，执行 <code>vim Dockerfile</code></p><div class="hljs"><pre><code class="hljs shell">FROM java:8ENV ARTIFACTID xc-govern-centerENV ARTIFACTVERSION 1.0-SNAPSHOTENV HOME_PATH /homeWORKDIR $HOME_PATHADD $ARTIFACTID-$ARTIFACTVERSION.jar $HOME_PATH/$ARTIFACTID.jarENTRYPOINT ["java", "-jar", "xc-govern-center.jar"]</code></pre></div><blockquote><p>dockerfile说明文档： <a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-dockerfile.html</a></p></blockquote><p>在 Dockerfile 文件所在目录执行以下命令</p><div class="hljs"><pre><code class="hljs shell">docker build -t xc-govern-center:1.0-SNAPSHOT .</code></pre></div><p>镜像创建成功，查询镜像</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image16.png" srcset="/img/loading.gif" alt="img"></p><h2 id="6-创建容器"><a href="#6-创建容器" class="headerlink" title="6. 创建容器"></a>6. 创建容器</h2><p>基于前面我们生成的<code>xc-govern-center:1.0-SNAPSHOT</code> 镜像创建容器，容器名称为 xc-govern-center-test</p><div class="hljs"><pre><code class="hljs sql">docker <span class="hljs-keyword">create</span> <span class="hljs-comment">--name xc-govern-center-test -t -p 50101:50101 -e PORT=50101 \</span>-e EUREKA_SERVER=<span class="hljs-keyword">http</span>://<span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.162</span>:<span class="hljs-number">50101</span>/eureka/,<span class="hljs-keyword">http</span>://<span class="hljs-number">10.1</span><span class="hljs-number">.1</span><span class="hljs-number">.162</span>:<span class="hljs-number">50102</span>/eureka/ xc-govern-center:<span class="hljs-number">1.0</span>-<span class="hljs-keyword">SNAPSHOT</span></code></pre></div><blockquote><p>docker create 语法 与 run 相同，create表示只创建不运行，而run是创建容器后并马上运行。</p><p>run命令说明文档 <a href="https://www.runoob.com/docker/docker-run-command.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-run-command.html</a></p></blockquote><p>EUREKA_SERVER 为一个变量，用于服务启动时指定的 <code>eureka</code> 负载均衡到哪些 <code>eureka</code> 服务上，跟我们在 <code>idea</code> 的配置是一个道理，如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image17.png" srcset="/img/loading.gif" alt="image-20200608165054580"></p><p>容器创建成功后会回显一个容器的id，可通过 <code>docker ps -a</code> 命令看到该容器的信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image18.png" srcset="/img/loading.gif" alt="image-20200608165256155"></p><h2 id="7-启动容器"><a href="#7-启动容器" class="headerlink" title="7. 启动容器"></a>7. 启动容器</h2><p>运行以下命令，启动容器</p><div class="hljs"><pre><code class="hljs sql">docker <span class="hljs-keyword">start</span> xc-govern-center-<span class="hljs-keyword">test</span></code></pre></div><p>容器启动完成可以通过 <code>docker ps</code> 查询正在运行中的容器。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image19.png" srcset="/img/loading.gif" alt="image-20200608173443990"></p><p>测试访问</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image20.png" srcset="/img/loading.gif" alt="image-20200608174322226"></p><p>使用 <code>docker logs -f xc-govern-center-test</code> 可以查看容器的运行日志</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image21.png" srcset="/img/loading.gif" alt="image-20200608174430566"></p><blockquote><p>这里报错是因为我们做了负载均衡，两个 eureka 需要相互注册，但这里我们只启动了一个 eureka 服务，但不影响正常使用。</p></blockquote><h2 id="8-停止与删除"><a href="#8-停止与删除" class="headerlink" title="8. 停止与删除"></a>8. 停止与删除</h2><p>要删除的一个镜像重新创建，需要通过如下步骤：</p><p>1、停止正在运行的容器</p><p>docker stop 容器名</p><p>例如：<code>docker stop xc-govern-center-test</code></p><p>2、删除容器</p><p>docker rm 容器名</p><p>例如：<code>docker rm xc-govern-center-test</code></p><p>3、删除镜像</p><p>docker rmi 镜像名或镜像Id</p><p>例如：<code>docker rmi xc-govern-center:1.0-SNAPSHOT</code></p><h2 id="9-maven构建镜像"><a href="#9-maven构建镜像" class="headerlink" title="9. maven构建镜像"></a>9. maven构建镜像</h2><p>上边构建的过程是通过手工一步一步完成，<code>maven</code> 提供 <code>docker-maven-plugin</code> 插件可完成从打包到构建镜像、构建容器等过程。</p><p>1、将服务工程的 <code>pom.xml</code> 复制一份，命名为 <code>pom_docker.xml</code> 并将 <code>build</code> 标签的内容替换下面的内容</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-comment">&lt;!--docker镜像相关的配置信息--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-comment">&lt;!--镜像名，这里用工程名--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>                <span class="hljs-comment">&lt;!--Dockerfile文件所在目录--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span>                <span class="hljs-comment">&lt;!--TAG,这里用工程版本号--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>                <span class="hljs-comment">&lt;!--构建镜像的配置信息--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>2、将 Dockerfile 文件拷贝到 <code>src/main/resources</code> 下</p><p>3、将更新的内容提交到gitlab，并在服务器内拉取项目代码到本地</p><p>提交并推送新增的配置到远程仓库</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image22.png" srcset="/img/loading.gif" alt="image-20200608200850974"></p><p>在服务器内拉取项目代码到本地</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image23.png" srcset="/img/loading.gif" alt="image-20200608201008309"></p><p>4、删除之前创建的 <code>xc-govern-center</code> 镜像</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 停止容器</span>sudo docker stop xc-govern-center-test<span class="hljs-meta">#</span><span class="bash"> 删除容器</span>sudo docker rm xc-govern-center-test<span class="hljs-meta">#</span><span class="bash"> 删除镜像</span>sudo docker rmi xc-govern-center:1.0-SNAPSHOT</code></pre></div><p>5、进入工程根目录（ <code>pom_docker.xml</code> 所在目录）执行</p><p>安装 maven 环境</p><div class="hljs"><pre><code class="hljs shell">sudo apt install maven</code></pre></div><p>添加 maven 仓库国内源以及配置 <code>pluginGroup</code>，编辑 <code>/usr/share/maven/conf/settings.xml</code> 文件</p><p>在 <code>mirrors</code> 标签下添加如下内容</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyun-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun public<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></div><p>在 <code>pluginGroups</code> 标签下加入以下内容</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span></code></pre></div><p>如下图所示</p><p><img src="https://qnoss.codeyee.com/20200704_5b6u5pyN5YqhW+WtpuaIkOWcqOe6v10gZGF5MjAtMe+8mkRldk9wcyDpobnnm67pg6jnvbLkuI7mjIHnu63pm4bmiJA=/image24.png" srcset="/img/loading.gif" alt="image-20200608202134759"></p><p>给项目的目录设置权限，否则打包的时候会报错</p><div class="hljs"><pre><code class="hljs powershell">sudo chown <span class="hljs-literal">-R</span> <span class="hljs-number">1000</span>:<span class="hljs-number">1000</span> ~/xc<span class="hljs-literal">-services</span>/</code></pre></div><p>进入到 eureka 工程下，执行打包命令</p><div class="hljs"><pre><code class="hljs shell">mvn -f pom_docker.xml clean package -DskipTests docker:build</code></pre></div><p>等待依赖下载完成后开始构建镜像，创建镜像成功，结果如下：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image25.png" srcset="/img/loading.gif" alt="image-20200608205339883"></p><p>使用该镜像创建容器</p><div class="hljs"><pre><code class="hljs shell">docker create --name xc-govern-center-test -t -p 50101:50101 -e PORT=50101 \-e EUREKA_SERVER=http://10.1.1.162:50101/eureka/,http://10.1.1.162:50102/eureka/ xc-govern-center:1.0-SNAPSHOT</code></pre></div><p>容器创建成功</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image26.png" srcset="/img/loading.gif" alt="image-20200608205458488"></p><h1 id="四、持续集成"><a href="#四、持续集成" class="headerlink" title="四、持续集成"></a>四、持续集成</h1><h2 id="1-持续集成介绍"><a href="#1-持续集成介绍" class="headerlink" title="1. 持续集成介绍"></a>1. 持续集成介绍</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>传统的软件开发流程如下：</p><p>1、项目经理分配模块给开发人员</p><p>2、每个模块的开发人员并行开发，并进行单元测试</p><p>3、开发完毕，将代码集成部署到测试服务器，测试人员进行测试。</p><p>4、测试人员发现bug，提交bug、开发人员修改bug</p><p>5、bug修改完毕再次集成、测试。</p><p><strong>有哪些问题？</strong></p><p>1、模块之间依赖关系复杂，在集成时发现大量bug</p><p>2、测试人员等待测试时间过长</p><p>3、软件交付无法保障</p><p><strong>解决上述问题的思考：</strong></p><p>1、能否把集成测试时间提前？</p><p>2、能否使用自动化工具代替人工集成部署的过程？</p><h3 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h3><p>持续集成（Continuous integration）简称 <code>CI</code>，持续集成的思想是每天要多次将代码合并到主干，并进行集成、测试，这样就可以提早发现错误，进行修正。持久集成也属于 <code>DevOps</code></p><p>持续集成的好处：</p><p>1、自动化集成部署，提高了集成效率。</p><p>2、更快的修复问题。</p><p>3、更快的进行交付。</p><p>4、提高了产品质量。</p><h3 id="本项目持续集成流程"><a href="#本项目持续集成流程" class="headerlink" title="本项目持续集成流程"></a>本项目持续集成流程</h3><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image27.png" srcset="/img/loading.gif" alt="image-20200608210048479"></p><h2 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2. 搭建环境"></a>2. 搭建环境</h2><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>Jenkins是一个领先的开源自动化服务器，可用于自动化构建，测试，部署软件等相关任务。</p><p>官网地址：<a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io</a></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image28.png" srcset="/img/loading.gif" alt="image-20200608210213712"></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image29.png" srcset="/img/loading.gif" alt="image-20200608210914373"></p><h4 id="1、使用Docker安装Jenkins"><a href="#1、使用Docker安装Jenkins" class="headerlink" title="1、使用Docker安装Jenkins"></a>1、使用Docker安装Jenkins</h4><p>本教程在 <code>docker</code> 下安装 <code>Jenkins</code>：</p><p>拉取镜像</p><div class="hljs"><pre><code class="hljs shell">docker pull jenkinsci/blueocean</code></pre></div><p>创建容器挂载目录，并且赋予权限</p><div class="hljs"><pre><code class="hljs shell">mkdir /var/docker/jenkins -psudo chown -R 1000:1000 /var/docker/jenkins  # 这里需要为jenkins的目录赋予1000权限</code></pre></div><blockquote><p>注意：在安装jenkins时候，挂在文件夹<code>/var/docker/jenkins</code> 的归属用户id必须是1000，否则会抛出无操作权限异常。</p></blockquote><p>创建容器：</p><div class="hljs"><pre><code class="hljs shell">docker run -itd --name jenkins -u root -p 8900:8080 --privileged=true \-v /var/docker/jenkins:/var/jenkins_home \-v /var/run/docker.sock:/var/run/docker.sock \-v /home/jenkins:/home docker.io/jenkinsci/blueocean</code></pre></div><blockquote><ul><li>docker run 创建容器并且运行</li><li>docker create 只创建而不运行</li></ul></blockquote><p>访问你虚拟机的 <code>8900</code> 端口，我这里的地址为 <a href="http://10.1.1.161:8900/" target="_blank" rel="noopener">http://10.1.1.161:8900</a></p><p>初次运行 <code>Jenkins</code> 会经过一个安装过程，一般情况使用默认配置，下一步安装即可，其中一步需要输入密码，如下图</p><p><img src="https://qnoss.codeyee.com/20200704_5b6u5pyN5YqhW+WtpuaIkOWcqOe6v10gZGF5MjAtMe+8mkRldk9wcyDpobnnm67pg6jnvbLkuI7mjIHnu63pm4bmiJA=/image30.png" srcset="/img/loading.gif" alt="image-20200606140413863"></p><p>出现上边的画面需要输入 jenkins 的初始密码，查看容器的运行日志，从日志中找到初始里面</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo docker logs -f jenkins</span></code></pre></div><p>日志如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image31.png" srcset="/img/loading.gif" alt="image-20200607111618576"></p><p>日志中没有找到初始密码？我们可以直接在该容器挂载到本地目录的文件下查看。</p><p>这里我们在创建容器时指定了 <code>-v /var/docker/jenkins:/var/jenkins_home</code> ，表示将 <code>/var/docker/jenkins</code> 目录映射到 <code>jenkins</code> 容器上的 <code>/var/jenkins_home</code> 目录上，所以我们可以直接在本地执行如下命令，查看 <code>jenkins</code> 的初始密码</p><div class="hljs"><pre><code class="hljs shell">cat /var/docker/jenkins/secrets/initialAdminPassword</code></pre></div><p>初始密码如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image32.png" srcset="/img/loading.gif" alt="image-20200607101707269"></p><p>输入初始密码到 jenkins 页面后，继续完成后续的初始化步骤。</p><p>如果出现一直停留在在 <code>ready</code> 页面，如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image33.png" srcset="/img/loading.gif" alt="image-20200607111259258"></p><p>修改 jenkins 的配置文件 <code>hudson.model.UpdateCenter.xml</code> 将 url 修改为国内的 <code>jenkins</code> 源</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p><p>运行以下命令，并替换url标签内值为上述地址</p><div class="hljs"><pre><code class="hljs awk">vim <span class="hljs-regexp">/var/</span>docker<span class="hljs-regexp">/jenkins/</span>hudson.model.UpdateCenter.xml</code></pre></div><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image34.png" srcset="/img/loading.gif" alt="image-20200607111740728"></p><p>输入密码后进入到插件安装页面</p><p><img src="https://qnoss.codeyee.com/20200704_5b6u5pyN5YqhW+WtpuaIkOWcqOe6v10gZGF5MjAtMe+8mkRldk9wcyDpobnnm67pg6jnvbLkuI7mjIHnu63pm4bmiJA=/image35.png" srcset="/img/loading.gif" alt="image-20200607112006171"></p><p>如果愿意等的话，可以选择第一个安装所有默认推荐的插件，但是大概需要1小时左右才能安装完成。</p><p>为了节省时间我们可以选择第二个，取消默认选择的插件，然后继续下一步操作。</p><p>如果选择了安装推荐，则需要等待插件安装完成，如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image36.png" srcset="/img/loading.gif" alt="image-20200607112232774"></p><p>插件安装完成后，设置管理员信息</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image37.png" srcset="/img/loading.gif" alt="image-20200607161327005"></p><p>本项目使用 <code>Jenkins</code> 需要配置Jdk1.8、Git、maven。</p><p><strong>1）Maven 安装：</strong></p><p>到官网下载最新版的maven <a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p>解压 <code>maven</code> 压缩包到容器的挂载目录下</p><div class="hljs"><pre><code class="hljs crystal">tar zxvf apache-maven-<span class="hljs-number">3.6</span>.<span class="hljs-number">3</span>-bin.tar.gz -C /var/docker/jenkins/<span class="hljs-class"><span class="hljs-keyword">lib</span>/</span></code></pre></div><p>在控制台 <code>Global Tool Configuration</code> 配置maven路径为容器内的目录 <code>/var/jenkins_home/lib/apache-maven-3.6.3/</code></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image38.png" srcset="/img/loading.gif" alt="image-20200607171140658"></p><p><strong>2）Jdk安装配置</strong></p><blockquote><p>如果jenkins镜像里面有该环境则不需要再安装</p></blockquote><p>宿主机安装java</p><div class="hljs"><pre><code class="hljs shell">sudo apt-get install openjdk-8-jdk</code></pre></div><p>拷贝本地 <code>JDK</code> 环境到 <code>jenkins</code> 容器的挂载目录的 lib 目录下</p><div class="hljs"><pre><code class="hljs shell">mkdir -p /var/docker/jenkins/lib/java-1.8.0-openjdk-amd64 &amp;&amp; cp -r /usr/lib/jvm/java-1.8.0-openjdk-amd64/* /var/docker/jenkins/lib/java-1.8.0-openjdk-amd64</code></pre></div><p>在 jenkins 设置 jdk的路径为 <code>/var/jenkins_home/lib/java-1.8.0-openjdk-amd64</code>，该路径为容器里面的路径</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image39.png" srcset="/img/loading.gif" alt="image-20200606140553273"></p><p><strong>3）Git安装方法同上</strong></p><blockquote><p>如果jenkins镜像里面有该环境则不需要再安装</p></blockquote><p>宿主机安装git</p><div class="hljs"><pre><code class="hljs powershell">apt<span class="hljs-literal">-get</span> install git</code></pre></div><p>复制git到容器挂载的目录下</p><div class="hljs"><pre><code class="hljs shell">mkdir /var/docker/jenkins/lib/git &amp;&amp; cp -r /usr/lib/git-core/* /var/docker/jenkins/lib/git</code></pre></div><p>在 <code>jenkins</code>控制台上配置容器中的 git 文件的路径 <code>/var/jenkins_home/lib/git/git</code></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image40.png" srcset="/img/loading.gif" alt="image-20200607175332443"></p><h4 id="2、配置-SSH-Remote-Hosts"><a href="#2、配置-SSH-Remote-Hosts" class="headerlink" title="2、配置 SSH Remote Hosts"></a>2、配置 SSH Remote Hosts</h4><p>SSH remote hosts 是 <code>Jenkins</code> 提供的一种远程访问 <code>ssh</code> 服务器的方法，通过如下步骤测试此功能：</p><p><strong>1）安装插件SSH plugin</strong></p><p>访问虚拟机的地址 <a href="http://10.1.1.161:8900/pluginManager/" target="_blank" rel="noopener">http://10.1.1.161:8900/pluginManager/</a></p><p>从可选插件中选择SSH Plugin进行安装</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image41.png" srcset="/img/loading.gif" alt="image-20200607171628455"></p><p>安装成功可在已安装插件中查询：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image42.png" srcset="/img/loading.gif" alt="image-20200607171720075"></p><p><strong>2）配置凭证</strong></p><p>访问虚拟机 <a href="http://10.1.1.161:8900/credentials/store/system/domain/_/newCredentials" target="_blank" rel="noopener">http://10.1.1.161:8900/credentials/store/system/domain/_/newCredentials</a></p><p>配置部署服务的虚拟机的 <code>SSH</code> 登录账号和密码：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image43.png" srcset="/img/loading.gif" alt="image-20200606140717614"></p><p><strong>3）配置SSH sites</strong></p><p>访问 <a href="http://10.1.1.161:8900/configure" target="_blank" rel="noopener">http://10.1.1.161:8900/configure</a></p><p>找到 ssh sites 的配置，输入你要远程配置的服务器 <code>IP</code> 和 <code>端口</code> 等信息，并选择你刚才添加的凭证信息。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image44.png" srcset="/img/loading.gif" alt="image-20200607172721808"></p><p><strong>4）在任务构建中编写脚本</strong></p><p>下拉到 “构建” 的选项，选择 <code>Execute shell</code> 的选项</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image45.png" srcset="/img/loading.gif" alt="image-20200607174116753"></p><p>选择刚才添加的 ssh sites， 填写你要执行的shell命令，然后保存</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image46.png" srcset="/img/loading.gif" alt="image-20200607174305189"></p><p>点击保存后，点击左边的立即构建，测试是否能够执行 shell 命令到指定的服务器上。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image47.png" srcset="/img/loading.gif" alt="image-20200607174350348"></p><p>远程命令执行成功，执行了 <code>echo</code> 命令写入内容到文件上，如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image48.png" srcset="/img/loading.gif" alt="image-20200607174407110"></p><h3 id="搭建Docker私有仓库"><a href="#搭建Docker私有仓库" class="headerlink" title="搭建Docker私有仓库"></a>搭建Docker私有仓库</h3><p>微服务的镜像会上传到 <code>Docker</code> 仓库保存，常用的公网 <code>Docker</code> 仓库有阿里云，网易云等，在企业局域网也可以搭建自己的 <code>Docker</code> 私有仓库，本教程使用 Docker 提供的私有仓库 <code>registry</code>。</p><p>进入 Docker 私有仓库所在服务器执行：</p><p>1、安装 Docker</p><p>2、创建私有仓库容器</p><div class="hljs"><pre><code class="hljs shell">sudo docker run --name docker-registry -d -p 5000:5000 registry</code></pre></div><p>执行结果如下：</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image49.png" srcset="/img/loading.gif" alt="image-20200607180928284"></p><p>上边显示 <code>registry</code> 镜像已经创建，并且 <code>docker-registry</code> 容器已经启动成功。</p><p>访问：<a href="http://10.1.1.161:5000/v2/_catalog" target="_blank" rel="noopener">http://10.1.1.161:5000/v2/_catalog</a></p><p>响应结果如下：</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"repositories"</span>:[]&#125;</code></pre></div><p>上边的响应结果说明在 <code>docker</code> 私有仓库中还没有镜像。</p><p>默认 docker-registry 只允许 https 提交镜像，如下配置使 <code>docker-registry</code> 支持 <code>http</code></p><p>在宿主机 <code>/etc/docker</code> 下，创建 <code>daemon.json</code> 文件，写入：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"insecure-registries"</span>:[<span class="hljs-string">"10.1.1.161:5000"</span>]&#125;</code></pre></div><p>重启 docker：</p><div class="hljs"><pre><code class="hljs shell">systemctl restart docker.service</code></pre></div><p>启动 docker-registry</p><div class="hljs"><pre><code class="hljs shell">sudo docker start docker-registry</code></pre></div><h3 id="安装Gitlab"><a href="#安装Gitlab" class="headerlink" title="安装Gitlab"></a>安装Gitlab</h3><p>由于前面的内容就已经需要用到 <code>gitlab</code>，所以在本文开始的内容中已经介绍了整个 <code>gitlab</code> 安装部署流程</p><h3 id="编写pom"><a href="#编写pom" class="headerlink" title="编写pom"></a>编写pom</h3><p>本例子将 <code>xc-govern-center</code> 工程使用 <code>Jenkins</code> 进行构建。</p><p>在 xc-govern-center 工程根目录编写 <code>pom_docker_registry.xml</code></p><p>此文件相比工程原有 <code>pom_docker.xml</code> 增加了<code>docker-maven-plugin</code> 插件，其作用是构建docker镜像并将镜像推送到 <code>Docker</code> 私有仓库，我的docker仓库地址是 10.1.1.161:5000</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">                             http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-govern-center<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-comment">&lt;!--docker镜像相关的配置信息--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-comment">&lt;!--镜像名，这里用工程名--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>                    <span class="hljs-comment">&lt;!--Dockerfile文件所在目录--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span>                    <span class="hljs-comment">&lt;!--TAG,这里用工程版本号--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span>                    <span class="hljs-comment">&lt;!--私有docker仓库地址--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">registryUrl</span>&gt;</span>10.1.1.161:5000<span class="hljs-tag">&lt;/<span class="hljs-name">registryUrl</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">pushImage</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">pushImage</span>&gt;</span>                    <span class="hljs-comment">&lt;!--构建后的镜像名称--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>10.1.1.161:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;                    <span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>                    <span class="hljs-comment">&lt;!--构建镜像的配置信息--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>稍后我们结合 <code>jenkins</code> 来进行自动构建。</p><h2 id="3-创建持续集成任务"><a href="#3-创建持续集成任务" class="headerlink" title="3. 创建持续集成任务"></a>3. 创建持续集成任务</h2><h3 id="创建jenkins的构建任务"><a href="#创建jenkins的构建任务" class="headerlink" title="创建jenkins的构建任务"></a>创建jenkins的构建任务</h3><p>新建一个任务 xc-edu，选择 “构建一个自由风格的软件项目” ，点击确定</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image50.png" srcset="/img/loading.gif" alt="image-20200609173403898"></p><h3 id="配置git仓库"><a href="#配置git仓库" class="headerlink" title="配置git仓库"></a>配置git仓库</h3><p>1、配置git凭证</p><p>此凭证用于远程从 <code>git</code> 仓库克隆工程源代码</p><p>输入 <code>git</code> 仓库的账号和密码，这里如果使用码云，下边需要配置码云的账号和密码。</p><p>访问 <a href="http://10.1.1.161:8900/credentials/store/system/domain/_/newCredentials" target="_blank" rel="noopener">http://10.1.1.161:8900/credentials/store/system/domain/_/newCredentials</a></p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image51.png" srcset="/img/loading.gif" alt="image-20200610155838201"></p><p>2、在刚才我们新建的 <code>xc-edu</code> 任务下配置 <code>git</code> 仓库地址，此地址即 <code>xc-edu</code> 项目的地址</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image52.png" srcset="/img/loading.gif" alt="image-20200609170051196"></p><h3 id="配置自动构建流程"><a href="#配置自动构建流程" class="headerlink" title="配置自动构建流程"></a>配置自动构建流程</h3><p>实现目标：</p><p>使用 <code>jenkins</code> 重复构建不要产生重复镜像</p><p>使用 <code>jenkins</code> 停止容器、删除容器、删除镜像之间进行判断</p><p><strong>构建过程分为三步：</strong></p><p>本例子以构建 <code>xc-govern-center</code> 工程为例，其它工程构建方式类似。</p><h4 id="1、停止容器、删除容器、删除镜像"><a href="#1、停止容器、删除容器、删除镜像" class="headerlink" title="1、停止容器、删除容器、删除镜像"></a><strong>1、停止容器、删除容器、删除镜像</strong></h4><p>shell脚本如下：</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>result=$(docker ps | grep "192.168.101.64:5000/xc-govern-center")if [[ "$result" != "" ]]thenecho "stop xc-govern-center"sudo docker stop xc-govern-centerfiresult1=$(docker ps -a | grep "192.168.101.64:5000/xc-govern-center")if [[ "$result1" != "" ]]thenecho "rm xc-govern-center"sudo docker rm xc-govern-centerfiresult2=$(docker images | grep "192.168.101.64:5000/xc-govern-center")if [[ "$result2" != "" ]]thenecho "192.168.101.64:5000/xc-govern-center:1.0-SNAPSHOT"sudo docker rmi 192.168.101.64:5000/xc-govern-center:1.0-SNAPSHOTfi</code></pre></div><blockquote><ol><li>检查指定镜像是否有容器在运行，有则停止容器</li><li>检查指定镜像是否创建了容器，有则删除容器</li><li>检查是否存在指定镜像，存在则删除该镜像</li></ol></blockquote><p>添加一个构建步骤</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image53.png" srcset="/img/loading.gif" alt="image-20200609175013408"></p><p>选择我们的服务器地址，将脚本内容复制 <code>command</code> 中，作为第一步需要执行的内容</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image54.png" srcset="/img/loading.gif" alt="img"></p><p>注意，如果在jenkins远程执行的 <code>SSH凭证</code> 非 <code>root</code> 用户，需要在远程服务器上执行以下命令，将当前用户加入到 <code>docker</code> 组内</p><div class="hljs"><pre><code class="hljs shell">sudo usermod -aG docker $USER</code></pre></div><h4 id="2、配置maven步骤"><a href="#2、配置maven步骤" class="headerlink" title="2、配置maven步骤"></a>2、配置maven步骤</h4><p>添加一个构建步骤，选择 调用顶层maven目标，如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image55.png" srcset="/img/loading.gif" alt="image-20200609175128767"></p><p>配置第二步，执行如下maven指令</p><div class="hljs"><pre><code class="hljs shell">clean package -f xc-govern-center/pom_docker_registry.xml -DskipTests docker:build</code></pre></div><p>如下图所示</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image56.png" srcset="/img/loading.gif" alt="image-20200609175242308"></p><h4 id="3、配置docker步骤"><a href="#3、配置docker步骤" class="headerlink" title="3、配置docker步骤"></a>3、配置docker步骤</h4><p>继续添加一个执行 <code>shell</code> 的构建步骤</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image57.png" srcset="/img/loading.gif" alt="image-20200609175314254"></p><p>配置第三步，从 <code>docker</code> 私有仓库拉取镜像并创建容器，启动容器</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 如果指定容器容器不存在则拉取后再进行创建，并且创建后自动执行</span>docker run --name xc-govern-center -p 50101:50101 -idt 10.1.1.161:5000/xc-govern-center:1.0-SNAPSHOTdocker logs xc-govern-center</code></pre></div><blockquote><p>注意使用log输出容器启动状态时不要加-f参数，否则会一直输出容器日志，导致任务一直处于构建中。c</p></blockquote><p>如下图</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image58.png" srcset="/img/loading.gif" alt="image-20200611152804801"></p><p>添加完第三步后，点击保存</p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>1、进入任务页面，点击 “立即构建”</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image59.png" srcset="/img/loading.gif" alt="image-20200609171946626"></p><p>2、开始构建，查看日志</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image60.png" srcset="/img/loading.gif" alt="image-20200610165006790"></p><p>构建成功，如上图所示。</p><h3 id="使用Gitlab通知Jenkins进行自动部署"><a href="#使用Gitlab通知Jenkins进行自动部署" class="headerlink" title="使用Gitlab通知Jenkins进行自动部署"></a>使用Gitlab通知Jenkins进行自动部署</h3><h4 id="1、安装gitlab-hook插件"><a href="#1、安装gitlab-hook插件" class="headerlink" title="1、安装gitlab hook插件"></a>1、安装gitlab hook插件</h4><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image61.png" srcset="/img/loading.gif" alt="image-20200610173808935"></p><h4 id="2、配置webhook"><a href="#2、配置webhook" class="headerlink" title="2、配置webhook"></a>2、配置webhook</h4><p>GitLab 中使用 <code>webhook</code> 向 <code>jenkins</code> 通知，当有代码 push 后将通知 <code>jenkins</code> 进行构建。</p><p>1、新建一个任务 “xc-edu”，在 Jenkins 中找到通知地址</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image62.png" srcset="/img/loading.gif" alt="image-20200607103230924"></p><p>2、进入Jenkins设置允许匿名访问jenkins，这样 <code>GitLab</code> 才能访问通知地址去通知 <code>Jenkins</code> 进行工作</p><p>进入到配置页面 <a href="http://10.1.1.161:8900/configure" target="_blank" rel="noopener">http://10.1.1.161:8900/configure</a> ，取消认证的勾选，认证默认是开启的。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image63.png" srcset="/img/loading.gif" alt="image-20200610174958486"></p><p>3、使用管理员帐号 root 登录 <code>Gitlab</code>，密码就是你 <code>gitlab</code> 搭建好之后第一次输入的密码,设置允许请求本地网络服务</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image64.png" srcset="/img/loading.gif" alt="image-20200607103253653"></p><p>4、设置钩子地址，即 <code>jenkins</code> 中的项目地址</p><p>访问项目的配置地址 <a href="http://10.1.1.161:8910/root/xc-services-project/-/settings/integrations" target="_blank" rel="noopener">http://10.1.1.161:8910/root/xc-services-project/-/settings/integrations</a></p><p>点击开启webhooks</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image65.png" srcset="/img/loading.gif" alt="image-20200610175240440"></p><p>将 <code>jenkins</code> 的触发地址设置到 <code>gitlab</code> 的 <code>webhooks</code> 地址中 ，点击最下面的添加即可。</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image66.png" srcset="/img/loading.gif" alt="image-20200610175458275"></p><p>如果出现添加失败，并且显示如下错误</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image67.png" srcset="/img/loading.gif" alt="image-20200610175721074"></p><p>参考 <a href="https://blog.csdn.net/anqixiang/article/details/104968469" target="_blank" rel="noopener">https://blog.csdn.net/anqixiang/article/details/104968469</a> 即可解决，并添加webhooks的白名单</p><blockquote><p>由于webhooks的钩子是允许匿名访问的，建议还是设置白名单来提高安全性</p></blockquote><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image68.png" srcset="/img/loading.gif" alt="image-20200610175956666"></p><p>配置完成后再回到之前的操作，添加webhooks的钩子地址即可，添加成功的效果如下</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image69.png" srcset="/img/loading.gif" alt="image-20200610180136855"></p><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p>尝试提交一个代码更新，观察jenkins是否能够收到通知并且执行构建任务</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image70.png" srcset="/img/loading.gif" alt="image-20200611151650255"></p><p>jenkins开始自动构建</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image71.png" srcset="/img/loading.gif" alt="image-20200611151643554"></p><p>构建成功，并自动启动容器</p><p><img src="/2020/08/31/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday20/image72.png" srcset="/img/loading.gif" alt="image-20200611152118926"></p><h2 id="4-思考一些问题"><a href="#4-思考一些问题" class="headerlink" title="4. 思考一些问题"></a>4. 思考一些问题</h2><h3 id="1、如何实现自动构建指定的服务工程？"><a href="#1、如何实现自动构建指定的服务工程？" class="headerlink" title="1、如何实现自动构建指定的服务工程？"></a>1、如何实现自动构建指定的服务工程？</h3><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>例如我们在整个微服务项目当中有A、B、C三个服务，在代码更新时只更新了 <code>服务A</code> 相关的代码，而 <code>jenkins</code> 进行自动部署的时候，只需要部署 <code>服务A</code> 的代码即可。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><code>Comment (regex) for triggering a build</code> 不可用，该选项只匹配 <code>merge request</code> 的 commit</li><li>Gitlab 在同一个项目里面是否能够添加多个jenkins任务钩子？如何在gitlab上实现按需通知</li></ul>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day19：分布式事务</title>
    <link href="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/"/>
    <url>/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day19</code> 的内容</p><ul><li>分析了分布式事务的使用场景、以及 <code>2PC</code>、<code>TCC</code>、<code>MQ</code> 等解决方案</li><li>通过用户下单选课的案例来讲解了基于 <code>Spring Task</code> 以及 <code>RabbitMQ</code> 来实现 <code>MQ</code> 在分布式事务的整个流程。</li><li>对 <code>Mysql</code> 本地事务有了更深刻的了解，例如在同一个事务当中，<code>操作A</code> 与 <code>操作B</code> 需要同时都操作成功，数据才能真正的写入到数据库内，这样也就保证了数据的幂等性。</li></ul><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day19</code> 的内容</p><ul><li>分析了分布式事务的使用场景、以及 <code>2PC</code>、<code>TCC</code>、<code>MQ</code> 等解决方案</li><li>通过用户下单选课的案例来讲解了基于 <code>Spring Task</code> 以及 <code>RabbitMQ</code> 来实现 <code>MQ</code> 在分布式事务的整个流程。</li><li>对 <code>Mysql</code> 本地事务有了更深刻的了解，例如在同一个事务当中，<code>操作A</code> 与 <code>操作B</code> 需要同时都操作成功，数据才能真正的写入到数据库内，这样也就保证了数据的幂等性。</li></ul><h1 id="一、订单与选课的需求分析"><a href="#一、订单与选课的需求分析" class="headerlink" title="一、订单与选课的需求分析"></a>一、订单与选课的需求分析</h1><h2 id="1-订单支付流程"><a href="#1-订单支付流程" class="headerlink" title="1. 订单支付流程"></a>1. 订单支付流程</h2><p>学成在线的课程分为免费和收费两种。对于收费课程，用户需提交订单并完成支付方可在线学习。</p><p>提交订单及支付流程如下：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image1.png" srcset="/img/loading.gif" alt="image-20200604112504575"></p><p><strong>系统处理流程：</strong></p><p>1、用户提交订单需要先登录系统</p><p>2、提交订单，订单信息保存到订单数据库</p><p>3、订单支付，调用微信支付接口完成支付</p><p>4、完成支付，微信支付系统通知学成在线支付结果</p><p>5、学成在线接收到支付结果通知，更新支付结果</p><p><strong>用户操作流程</strong>：</p><p>1、用户进入课程详情页面</p><p>2、点击“立即购买”，打开订单确认信息</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image2.png" srcset="/img/loading.gif" alt="image-20200604112633430"></p><p>3、点击“确认无误，提交订单”</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image3.png" srcset="/img/loading.gif" alt="image-20200604112640698"></p><p>订单提交成功，向订单数据库的 <code>xc_orders</code> 订单表保存一条记录，向 <code>xc_orders_detail</code>订单明细表保存一条或多条记录，向订单支付表插入一条记录。</p><p>4、订单提交成功自动进入订单支付页面</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image4.png" srcset="/img/loading.gif" alt="image-20200604112708567"></p><p>5、点击“微信支付”打开二维码</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image5.png" srcset="/img/loading.gif" alt="image-20200604112719253"></p><p>6、用手机扫码支付，支付完成，点击 “完成支付”</p><p>支付完成，收到微信支付系统的支付完成通知或请求微信查询支付已完成，更新学成在线订单支付表中的支付状态字段。</p><h2 id="2-自动选课需求"><a href="#2-自动选课需求" class="headerlink" title="2. 自动选课需求"></a>2. 自动选课需求</h2><p>支付成功即完成订单，订单完成之后系统需自动添加选课。</p><p>下图是微信支付、学成在线订单服务、学成在线学习服务交互图：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image6.png" srcset="/img/loading.gif" alt="image-20200604112937855"></p><p>1、用户支付完成，微信支付系统会主动通知学成在线支付结果，学成在线也可主动请求微信支付查询订单的支付结果。最终得到支付结果后将订单支付结果保存到订单数据库中。</p><p>2、订单支付完成系统自动向选课表添加学生选课记录。</p><p>3、选课记录添加完成学习即可在线开始学习。</p><h1 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>根据上边的自动选课的需求，分析如下：</p><p>用户支付完成后，会将支付状态及订单状态保存在订单数据库中，由订单服务去维护订单数据库。而学生选课信息在学习中心数据库，由学习服务去维护学习中心数据库的信息。下图是系统结图：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image7.png" srcset="/img/loading.gif" alt="image-20200604113050991"></p><p>如何实现两个分布式服务（订单服务、学习服务）共同完成一件事即订单支付成功自动添加学生选课的需求，这里的关键是如何保证两个分布式服务的事务的一致性。</p><p>尝试解决上边的需求，在订单服务中远程调用选课接口，伪代码如下：</p><div class="hljs"><pre><code class="hljs plain">订单支付结果通知方法｛    更新支付表中支付状态为“成功”。    远程调用选课接口添加选课记录。｝</code></pre></div><p>上边的逻辑说明：</p><p>1、更新支付表状态为本地数据库操作。</p><p>2、远程调用选课接口为网络远程调用请求。</p><p>3、为保存事务上边两步操作由spring控制事务，当遇到 <code>Exception</code> 异常则 <code>回滚</code> 本地数据库操作。</p><p><strong>问题如下：</strong></p><p>1、如果更新支付表失败则抛出异常，不再执行远程调用，此设想没有问题。</p><p>2、如果更新支付表成功，网络远程调用超时，会拉长本地数据库事务时间，影响数据库性能。</p><p>3、如果更新支付表成功，远程调用添加选课成功（选课数据库commit成功），最后更新支付表时因为数据库意外宕机或其他原因导致无法访问数据库，导致commit时失败，此时出现操作不一致。</p><p>上边的几个问题涉及到分布式事务控制，下面我们带着这些问题，来继续了解一下什么是分布式事务。</p><h2 id="2-什么是分布式事务"><a href="#2-什么是分布式事务" class="headerlink" title="2. 什么是分布式事务"></a>2. 什么是分布式事务</h2><p>在了解分布式事务之前，我们来回顾一下什么是分布式系统。</p><p><strong>1、什么是分布式系统？</strong></p><p>部署在不同节点上的系统，通过网络交互来完成协同工作的系统。</p><p>比如：充值加积分的业务，用户在充值系统向自己的账户充钱，在积分系统中自己积分相应的增加。充值系统和积分系统是两个不同的系统，一次充值加积分的业务就需要这两个系统协同工作来完成。</p><p><strong>2、什么是事务？</strong></p><p>事务是指由一组操作组成的一个工作单元，这个工作单元具有以下几个特点</p><ul><li>原子性（atomicity）</li><li>一致性（consistency）</li><li>隔离性（isolation）</li><li>持久性（durability）</li></ul><p><strong>原子性：</strong></p><p>执行单元中的操作要么全部执行成功，要么全部失败。如果有一部分成功一部分失败那么成功的操作要全部回滚到执行前的状态。</p><p><strong>一致性：</strong></p><p>执行一次事务会使用数据从一个正确的状态转换到另一个正确的状态，执行前后<br>数据都是完整的。</p><p><strong>隔离性</strong>：</p><p>在该事务执行的过程中，任何数据的改变只存在于该事务之中，对外界没有影响，事务与事务之间是完全的隔离的。<strong>只有事务提交后数据才会真正的储存到数据库内</strong>，其它事务才可以查询到最新的数据。</p><p><strong>持久性：</strong></p><p>事务完成后对数据的改变会永久性的存储起来，即使发生断电宕机数据依然在。</p><h2 id="3-CAP理论"><a href="#3-CAP理论" class="headerlink" title="3. CAP理论"></a>3. CAP理论</h2><p>如何进行分布式事务控制？<code>CAP</code> 理论是分布式事务处理的理论基础，了解了 <code>CAP</code> 理论有助于我们研究分布式事务的处理方案。</p><p>CAP 理论是：分布式系统在设计时只能在 <strong>一致性 (Consistency)</strong>、<strong>可用性(Availability)</strong>、<strong>分区容忍性(PartitionTolerance)</strong> 中满足两种，无法兼顾三种。</p><p>我们通过下面的内容来进一步的了解 CAP 理论：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image8.png" srcset="/img/loading.gif" alt="image-20200604132506494"></p><ul><li><p>一致性(Consistency)：</p><p>服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。</p></li><li><p>可用性(Availability)：</p><p>服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结点，当服务A宕机整个系统将无法提供服务，增加服务B、C是为了保证系统的可用性。</p></li><li><p>分区容忍性(Partition Tolerance)：</p><p>分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。</p><p>分布式系统不可避免的出现了多个系统通过网络协同工作的场景，节点之间难免会出现 <strong>网络中断</strong>、<strong>网延延迟</strong> 等现象，这种现象一旦出现就导致数据被分散在不同的节点上，这就是网络分区。</p></li></ul><p><strong>分布式系统能否兼顾C、A、P？</strong></p><p>在保证 <strong>分区容忍性</strong> 的前提下 <strong>一致性</strong> 和 <strong>可用性</strong> 无法兼顾，如果要提高系统的可用性就要增加多个结点，如果要保证数据的一致性就要实现每个结点的数据一致，结点越多可用性越好，但是数据一致性越差。所以，在进行分布式系统设计时，同时满足 “一致性”、“可用性” 和 “分区容性” 三者是几乎不能的。</p><p><strong>CAP有哪些组合方式？</strong></p><ul><li><p>CA：放弃分区容忍性，加 <strong>强一致性</strong> 和可用性，关系数据库按照 <code>CA</code> 进行设计。</p></li><li><p>AP：放弃一致性，加强可用性和分区容忍性，追求 <strong>最终一致性</strong>，很多 <code>NoSQL</code> 数据库按照AP进行设计。</p><blockquote><p>这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允许暂时的数据不一致，只要最终在用户接受的时间内数据一致可。</p></blockquote></li><li><p>CP：放弃可用性，加强一致性和分区容忍性，一些 <strong>强一致性</strong> 要求的系统按 <code>CP</code> 进行设计，比如 <strong>跨行转账</strong>，<strong>一次转账</strong> 请求要等待双方银行系统都完成整个事务才算完成。</p><blockquote><p>由于网络问题的存在CP系统可能会出现待等待超时，如果没有处理超时问题则整理系统会出现阻塞</p></blockquote></li></ul><p><strong>总结：</strong></p><p>在分布式系统设计中 <code>AP</code> 的应用较多，即 “保证分区容忍性” 和 “可用性 ”，牺牲数据的强一致性（写入操作后其他节点立即同步数据），而使用AP的方式来保证数据最终一致性。</p><p>比如：订单退款，今日退款成功，明日账户到账，只要在预定的用户可以接受的时间内退款事务走完即可。</p><h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><h3 id="两阶段提交协议（2PC）"><a href="#两阶段提交协议（2PC）" class="headerlink" title="两阶段提交协议（2PC）"></a>两阶段提交协议（2PC）</h3><p>为解决分布式系统的数据一致性问题，出现了两阶段提交协议（2 Phase Commitment Protocol），两阶段提交由 <code>协调者</code> 和 <code>参与者</code> 组成，共经过 “两个阶段” 和 “三个操作”，部分关系数据库如 <code>Oracle</code>、<code>MySQL</code> 支持两阶段提交协议，本节讲解关系数据库两阶段提交协议。</p><p>2PC协议流程图：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image9.png" srcset="/img/loading.gif" alt="image-20200604133432528"></p><p><strong>1）第一阶段：准备阶段（prepare）</strong></p><p>协调者通知参与者准备提交订单，参与者开始投票。</p><p>协调者完成准备工作向协调者回应Yes。</p><p><strong>2）第二阶段：提交(commit)/回滚(rollback)阶段</strong></p><p>协调者根据参与者的投票结果发起最终的提交指令。</p><p>如果有参与者没有准备好则发起回滚指令。</p><p><strong>一个下单减库存的例子：</strong></p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image10.png" srcset="/img/loading.gif" alt="image-20200604133512692"></p><p>1、应用程序连接两个数据源。</p><p>2、应用程序通过事务协调器向两个库发起 <code>prepare</code>，两个数据库收到消息分别执行本地事务（记录日志），但不提交，如果执行成功则回复 <code>yes</code>，否则回复 <code>no</code>。</p><p>3、事务协调器收到回复，只要有一方回复 <code>no</code> 则分别向参与者发起回滚事务，参与者开始回滚事务。</p><p>4、事务协调器收到回复，全部回复 <code>yes</code>，此时向参与者发起提交事务。如果参与者有一方提交事务失败则由事务协调器发起回滚事务。</p><p><strong>优点：</strong></p><p>实现强一致性，部分关系数据库支持（Oracle、MySQL等）。</p><p><strong>缺点：</strong></p><p>整个事务的执行需要由协调者在多个节点之间去协调，增加了事务的执行时间，性能低下。</p><p>解决方案有：<code>springboot</code> + <code>Atomikos</code> or <code>Bitronix</code></p><p>更详细的资料可以参考：<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a></p><h3 id="事务补偿（TCC）"><a href="#事务补偿（TCC）" class="headerlink" title="事务补偿（TCC）"></a>事务补偿（TCC）</h3><p>TCC 事务补偿是基于 <code>2PC</code> 实现的业务层事务控制方案，它是 <code>Try</code>、<code>Confirm</code> 和 <code>Cancel</code> 三个单词的首字母，含义如下：</p><p>1、Try 检查及预留业务资源，完成提交事务前的检查，并预留好资源。</p><p>2、Confirm 确定执行业务操作，对 try 阶段预留的资源正式执行。</p><p>3、Cancel 取消执行业务操作，对 try 阶段预留的资源释放。</p><p>下边用一个下单减库存的业务为例来说明：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image11.png" srcset="/img/loading.gif" alt="image-20200604133914143"></p><p>1、Try</p><ul><li>下单业务由 <code>订单服务</code> 和 <code>库存服务</code> 协同完成，在 try 阶段 订单服务 和 库存服务 完成检查和预留资源。</li><li>订单服务检查当前是否满足提交订单的条件（比如：当前存在未完成订单的不允许提交新订单）。</li><li>库存服务检查当前是否有充足的库存，并锁定资源。</li></ul><p>2、Confirm</p><ul><li>订单服务 和 库存服务 成功完成Try后开始正式执行资源操作。</li><li>订单服务向订单写一条订单信息。</li><li>库存服务减去库存。</li></ul><p>3、Cancel</p><ul><li>如果订单服务和库存服务有一方出现失败则全部取消操作。</li><li>订单服务需要删除新增的订单信息。</li><li>库存服务将减去的库存再还原。</li></ul><p>优点：最终保证数据的一致性，在业务层实现事务控制，灵活性好。</p><p>缺点：开发成本高，每个事务操作每个参与者都需要实现 <code>try/confirm/cancel</code> 三个接口。</p><p>注意：TCC 的 <code>try/confirm/cancel</code> 接口都要实现幂等性，在try、confirm、cancel失败后要不断重试 。</p><p>什么是幂等性？幂等性是指 <strong>同一个操作无论请求多少次</strong>，其结果都相同。</p><p>幂等操作实现方式有：</p><p>1、操作之前在业务方法进行判断如果执行过了就不再执行。</p><p>2、缓存所有请求和处理的结果，已经处理的请求则直接返回结果。</p><h3 id="消息队列实现最终一致性"><a href="#消息队列实现最终一致性" class="headerlink" title="消息队列实现最终一致性"></a>消息队列实现最终一致性</h3><p>本方案是将分布式事务拆分成多个本地事务来完成，并且由消息队列异步协调完成，如下图：<br>下边以下单减少库存为例来说明：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image12.png" srcset="/img/loading.gif" alt="image-20200604135609607"></p><p>1、订单服务和库存服务完成检查和预留资源。</p><p>2、订单服务在本地事务中完成 “添加订单表记录” 和添加 “减少库存任务消息”。</p><p>3、由定时任务根据消息表的记录发送给 <code>MQ</code> 通知库存服务执行减库存操作。</p><p>4、库存服务执行减少库存，并且记录执行消息状态（为避免重复执行消息，在执行减库存之前查询是否执行过此<br>消息。</p><blockquote><p>这里注意，每个消息通知都会带有一个消息id，用于通过本地事务校验该消息的状态</p></blockquote><p>5、库存服务向 <code>MQ</code> 发送完成减少库存的消息。</p><p>6、订单服务接收到完成库存减少的消息后，删除原来添加的 “减少库存任务消息”。</p><p><strong>实现最终事务一致要求：</strong></p><p>预留资源成功理论上要求正式执行成功，如果执行失败会进行重试，要求业务执行方法实现幂等。</p><p>也就是说，如果订单服务在指定时间内如果没有收到库存服务的 “库存减少成功” 的消息，那么订单服务会再次尝试发送这个 “减少库存” 的消息到 <code>MQ</code> 并且由 <code>MQ</code> 继续尝试去通知库存服务去减少库存，直到订单服务收到 “库存减少成功” 的消息。</p><p>优点 ：</p><p>由 <code>MQ</code> 按异步的方式协调完成事务，性能较高。</p><p>不用实现 <code>try/confirm/cancel</code> 接口，开发成本比 <code>TCC</code> 低。</p><p>缺点：</p><p>此方式基于关系数据库本地事务来实现，会出现频繁读写数据库记录，浪费数据库资源，另外对于高并发操作不是<br>最佳方案。</p><h2 id="5-自动添加选课方案"><a href="#5-自动添加选课方案" class="headerlink" title="5. 自动添加选课方案"></a>5. 自动添加选课方案</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>根据自动选课需求，为了更好的分析解决方案，这里搭建订单工程及数据库。</p><h4 id="1、创建订单工程"><a href="#1、创建订单工程" class="headerlink" title="1、创建订单工程"></a>1、创建订单工程</h4><p>导入资料下的 <code>xc-service-manage-order</code> 工程。</p><h4 id="2、创建订单数据库"><a href="#2、创建订单数据库" class="headerlink" title="2、创建订单数据库"></a>2、创建订单数据库</h4><p>创建订单数据库 xc_order（MySQL）导入 xc_order.sql</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image13.png" srcset="/img/loading.gif" alt="image-20200604144256737"></p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image14.png" srcset="/img/loading.gif" alt="image-20200604144250661"></p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image15.png" srcset="/img/loading.gif" alt="image-20200604144307880"></p><p><code>xc_orders</code>：订单主表</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image16.png" srcset="/img/loading.gif" alt="image-20200604144326034"></p><p><code>xc_orders_details</code>：订单明细表，记录订单的明细信息</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image17.png" srcset="/img/loading.gif" alt="image-20200604144339203"></p><p><code>xc_orders_pay</code>：订单支付表记录订单的支付状态</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image18.png" srcset="/img/loading.gif" alt="image-20200604144357001"></p><p>向 <code>xc_order</code> 数据库导入 <code>xc_order_task.sql</code></p><p>待处理任务表：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image19.png" srcset="/img/loading.gif" alt="image-20200604144421695"></p><p>在任务表中包括了交换机的名称、路由 <code>key</code> 等信息为了是将任务的处理做成一个通用的功能。</p><p>考虑分布式系统并发读取任务处理任务的情况发生项目使用乐观锁的方式解决并发问题。</p><p>已完成任务表 ：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image20.png" srcset="/img/loading.gif" alt="image-20200604144514253"></p><h4 id="3、创建选课数据库"><a href="#3、创建选课数据库" class="headerlink" title="3、创建选课数据库"></a>3、创建选课数据库</h4><p>创建 <code>xc_learning</code> 数据库，导入<code>xc_learning.sql</code>，<code>xc_learning_course</code> 为学生选课表。</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image21.png" srcset="/img/loading.gif" alt="image-20200604144604843"></p><p>导入 <code>xc_task_his.sql</code>，<code>xc_task_his</code> 为历史任务表 。</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image22.png" srcset="/img/loading.gif" alt="image-20200604144621397"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>本项目综合考虑选择基于消息的分布式事务解决方案，解决方案如下图：</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image23.png" srcset="/img/loading.gif" alt="image-20200604143344123"></p><p>1、支付成功后，订单服务向本地数据库更新订单状态，并向消息表写入“添加选课消息”，通过本地数据库保证订单状态和添加选课消息的事务。如果 <strong>更新订单状态</strong> 或者 <strong>消息写入</strong> 这两个操作其中一个失败了，那么这个事务都不会被执行，这样就保证了事务的一致性。</p><p>2、使用 <code>Spring Task</code> 定时任务扫描消息表，取出 “添加选课任务“ 的消息并发向<code>MQ</code>，由 <code>MQ</code> 通知学习服务添加选课。</p><p>3、学习服务接收到添加选课的消息，先查询本地数据库的历史消息表是否存在消息，存在则说明已经添加选课，则向 <code>MQ</code> 发送一个选课成功的消息，让订单服务知道该订单已经选课成功，否则向本地数据库添加选课，并向历史消息表添加选课消息，并发送选课成功的消息到 <code>MQ</code>。这里选课表和历史消息表在同一个数据库，通过本地事务保证一致性。</p><p>4、订单服务接收到完成选课的消息后，删除订单数据库中消息表的 “添加选课消息”，为保证后期对账将消息表的消息先添加到历史消息表再删除消息，表示此消息已经完成。</p><h1 id="三、Spring-Task定时任务"><a href="#三、Spring-Task定时任务" class="headerlink" title="三、Spring Task定时任务"></a>三、Spring Task定时任务</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>根据分布式事务的研究结果，订单服务需要定时扫描任务表向 <code>MQ</code> 发送任务。本节研究定时任务处理的方案，并实现定时任务对任务表进行扫描，并向 <code>MQ</code> 发送消息。</p><p>实现定时任务的方案有以下几种：</p><p>1、使用jdk的 <code>Timer</code> 和 <code>TimerTask</code> 实现</p><p>可以实现简单的间隔执行任务，无法实现按日历去调度执行任务。</p><p>2、使用 Quartz 实现</p><p><code>Quartz</code> 是一个异步任务调度框架，功能丰富，可以实现按日历调度。</p><p>3、使用 Spring Task 实现</p><p><code>Spring 3.0</code> 后提供 <code>Spring Task</code> 实现任务调度，支持按日历调度，相比 <code>Quartz</code> 功能稍简单，但是在开发基本够用，支持注解编程方式。</p><p>本项目使用 <code>Spring Task</code> 实现任务调度。</p><h2 id="2-Spring-Task-串行任务"><a href="#2-Spring-Task-串行任务" class="headerlink" title="2. Spring Task 串行任务"></a>2. Spring Task 串行任务</h2><h3 id="1、编写任务类"><a href="#1、编写任务类" class="headerlink" title="1、编写任务类"></a>1、编写任务类</h3><p>在 Spring boot 启动类上添加注解：<code>@EnableScheduling</code></p><p>新建任务测试类 <code>TestTask</code>，编写测试方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChooseCourseTask</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">// @Scheduled(fixedRate = 5000) //上次执行开始时间后5秒执行</span>    <span class="hljs-comment">// @Scheduled(fixedDelay = 5000) //上次执行完毕后的5秒执行</span>    <span class="hljs-comment">// @Scheduled(initialDelay=3000, fixedRate=5000) //第一次延迟3秒，以后每隔5秒执行一次</span>    <span class="hljs-meta">@Scheduled</span>(cron=<span class="hljs-string">"0/3 * * * * *"</span>)<span class="hljs-comment">//每隔3秒执行一次</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span></span>&#123;        LOGGER.info(<span class="hljs-string">"===============测试定时任务1开始==============="</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">5000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;         LOGGER.info(<span class="hljs-string">"===============测试定时任务1结束==============="</span>);    &#125;&#125;</code></pre></div><p>测试：</p><p>1、测试 <code>fixedRate</code> 和 <code>fixedDelay</code> 的区别</p><p>2、测试并观察串行执行的特点</p><h3 id="2、cron表达式"><a href="#2、cron表达式" class="headerlink" title="2、cron表达式"></a>2、cron表达式</h3><p>cron表达式包括6部分：</p><p>秒（0<del>59） 分钟（0</del>59） 小时（0<del>23） 月中的天（1</del>31） 月（1<del>12） 周中的天（填写MON，TUE，WED，THU，FRI，SAT,SUN，或数字1</del>7 1表示MON，依次类推）</p><p><strong>特殊字符介绍：</strong></p><ul><li>“/” 字符表示指定数值的增量</li><li>“*” 字符表示所有可能的值</li><li>“-” 字符表示区间范围</li><li>“,” 字符表示列举</li><li>“？” 字符仅被用于月中的天和周中的天两个子表达式，表示不指定值</li></ul><p><strong>例子：</strong></p><ul><li>0/3 * * * * * 每隔 3 秒执行</li><li>0 0/5 * * * * 每隔 5 分钟执行</li><li>0 0 0 * * * 表示每天 0 点执行</li><li>0 0 12 ? * WEN 每周三 12 点执行</li><li>0 15 10 ? * MON-FRI 每月的周一到周五10点15分执行</li><li>0 15 10 ? * MON,FRI 每月的周一和周五10点 15分执行</li></ul><h3 id="3、串行任务测试"><a href="#3、串行任务测试" class="headerlink" title="3、串行任务测试"></a>3、串行任务测试</h3><p>参考 <code>task1</code> 方法的的定义方法，再定义 <code>task2</code> 方法，此时共用两个任务方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">3000</span>) <span class="hljs-comment">//上次执行开始时间后3秒执行</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task2</span><span class="hljs-params">()</span></span>&#123;    LOGGER.info(<span class="hljs-string">"===============测试定时任务2开始==============="</span>);    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">3000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;     LOGGER.info(<span class="hljs-string">"===============测试定时任务2结束==============="</span>);&#125;</code></pre></div><p>通过测试发现，两个任务方法由一个线程串行执行，<code>task1</code> 方法执行完成 <code>task2</code> 再执行。</p><h2 id="3-Spring-Task-并行任务"><a href="#3-Spring-Task-并行任务" class="headerlink" title="3. Spring Task 并行任务"></a>3. Spring Task 并行任务</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>在项目通常是需要多个不同的任务并行去执行。</p><p>本节实现 <code>Spring Task</code> 并行执行任务的方法。</p><h3 id="2、配置异步任务"><a href="#2、配置异步任务" class="headerlink" title="2、配置异步任务"></a>2、配置异步任务</h3><p>创建异步任务配置类，需要配置线程池实现多线程调度任务。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.config; <span class="hljs-keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;<span class="hljs-keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;<span class="hljs-keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar; <span class="hljs-keyword">import</span> java.util.concurrent.Executor; <span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTaskConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SchedulingConfigurer</span>, <span class="hljs-title">AsyncConfigurer</span> </span>&#123;    <span class="hljs-comment">//线程池线程数量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> corePoolSize = <span class="hljs-number">5</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskScheduler <span class="hljs-title">taskScheduler</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        ThreadPoolTaskScheduler scheduler = <span class="hljs-keyword">new</span> ThreadPoolTaskScheduler();        scheduler.initialize();<span class="hljs-comment">//初始化线程池</span>        scheduler.setPoolSize(corePoolSize);<span class="hljs-comment">//线程池容量</span>        <span class="hljs-keyword">return</span> scheduler;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getAsyncExecutor</span><span class="hljs-params">()</span> </span>&#123;        Executor executor = taskScheduler();        <span class="hljs-keyword">return</span> executor;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> </span>&#123;        scheduledTaskRegistrar.setTaskScheduler(taskScheduler());    &#125;&#125;</code></pre></div><p>将 <code>@EnableScheduling</code> 添加到此配置类上，<code>SpringBoot</code> 启动类上不用再添加 <code>@EnableScheduling</code></p><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>通过测试发现两个任务由不同的线程在并行执行，互不影响。</p><h1 id="四、订单服务定时发送消息"><a href="#四、订单服务定时发送消息" class="headerlink" title="四、订单服务定时发送消息"></a>四、订单服务定时发送消息</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>定时任务发送消息流程如下：</p><p>1、每隔1分钟扫描一次任务表。</p><p>1、定时任务扫描 <code>task</code> 表，一次取出多个任务，取出 <strong>超过1分钟</strong> 未处理的任务</p><p>2、考虑订单服务可能集群部署，为避免重复发送任务使用 <strong>乐观锁</strong> 的方式每次从任务列表取出要处理的任务</p><p>3、任务发送完毕更新任务发送时间</p><p><strong>关于任务表的添加：</strong></p><p>正常的流程是订单支付成功后，更新订单支付状态并向任务表写入 “添加选课任务”。</p><p>目前订单支付功能没有开发，所以我们暂时采用手动向任务表添加任务。</p><h2 id="2-RabbitMQ配置"><a href="#2-RabbitMQ配置" class="headerlink" title="2. RabbitMQ配置"></a>2. RabbitMQ配置</h2><p>向 <code>RabbitMQ</code> 声明两个队列：添加选课、完成选课，交换机使用路由模式，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.config; <span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration; <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;     <span class="hljs-comment">//添加选课任务交换机</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_LEARNING_ADDCHOOSECOURSE = <span class="hljs-string">"ex_learning_addchoosecourse"</span>;      <span class="hljs-comment">//添加选课消息队列,用于发送添加选课消息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_ADDCHOOSECOURSE = <span class="hljs-string">"xc_learning_addchoosecourse"</span>;     <span class="hljs-comment">//完成添加选课消息队列,用于接收完成选课的消息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_FINISHADDCHOOSECOURSE = <span class="hljs-string">"xc_learning_finishaddchoosecourse"</span>;     <span class="hljs-comment">//添加选课路由key,用于发送添加选课的消息</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_ADDCHOOSECOURSE_KEY = <span class="hljs-string">"addchoosecourse"</span>;     <span class="hljs-comment">//完成添加选课路由key</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_FINISHADDCHOOSECOURSE_KEY = <span class="hljs-string">"finishaddchoosecourse"</span>;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换机配置,用于发送添加选课消息以及接收完成添加选课的消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the exchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EX_LEARNING_ADDCHOOSECOURSE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_DECLARE</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_LEARNING_ADDCHOOSECOURSE).durable(<span class="hljs-keyword">true</span>).build();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明用于接收 "完成添加选课" 消息的队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Queue</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(XC_LEARNING_FINISHADDCHOOSECOURSE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_XC_LEARNING_FINISHADDCHOOSECOURSE</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(XC_LEARNING_FINISHADDCHOOSECOURSE);        <span class="hljs-keyword">return</span> queue;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明用于发送 "添加选课" 消息的队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Queue</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(XC_LEARNING_ADDCHOOSECOURSE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_XC_LEARNING_ADDCHOOSECOURSE</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(XC_LEARNING_ADDCHOOSECOURSE);        <span class="hljs-keyword">return</span> queue;    &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将 "完成添加选课消息" 的队列绑定到交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 完成添加选课消息队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> BindingBuilder</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_FINISHADDCHOOSECOURSE</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        @Qualifier(XC_LEARNING_FINISHADDCHOOSECOURSE)</span> Queue queue,</span><span class="hljs-function">        @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_LEARNING_ADDCHOOSECOURSE)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(XC_LEARNING_FINISHADDCHOOSECOURSE_KEY).noargs();    &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将 "添加选课" 消息的队列绑定到交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 添加选课消息队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> BindingBuilder</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_ADDCHOOSECOURSE</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        @Qualifier(XC_LEARNING_ADDCHOOSECOURSE)</span> Queue queue,</span><span class="hljs-function">        @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_LEARNING_ADDCHOOSECOURSE)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(XC_LEARNING_ADDCHOOSECOURSE_KEY).noargs();    &#125; &#125;</code></pre></div><h2 id="3-查询前N条任务"><a href="#3-查询前N条任务" class="headerlink" title="3. 查询前N条任务"></a>3. 查询前N条任务</h2><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>在 <code>dao</code>下创建一个 XcTaskRepository 自定义方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.dao; <span class="hljs-keyword">import</span> com.xuecheng.framework.domain.task.XcTask;<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository; <span class="hljs-keyword">import</span> java.util.Date; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTask</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//取出指定时间之前的记录</span>    <span class="hljs-function">Page&lt;XcTask&gt; <span class="hljs-title">findByUpdateTimeBefore</span><span class="hljs-params">(Pageable pageable, Date updateTime)</span></span>;&#125;</code></pre></div><p><code>findByUpdateTimeBefore</code> 方法为 <code>JPA</code> 自带的一个组合方法，可以根据传入的分页参数以及时间查询，查询到该时间之前的数据。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    XcTaskRepository xcTaskRepository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询任务列表的实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 查询数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> updateTime 上次更新时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;XcTask&gt; <span class="hljs-title">findTaskList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Date updateTime)</span> </span>&#123;        Pageable pageable = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">0</span>, n);        Page&lt;XcTask&gt; byUpdateTimeBefore = xcTaskRepository.findByUpdateTimeBefore(pageable, updateTime);        List&lt;XcTask&gt; content = byUpdateTimeBefore.getContent();        <span class="hljs-keyword">return</span> content;    &#125;&#125;</code></pre></div><p>在 Service 中我们调用刚才定义的 <code>findByUpdateTimeBefore</code> 来查询指定时间之前的数据</p><h3 id="编写定时任务"><a href="#编写定时任务" class="headerlink" title="编写定时任务"></a>编写定时任务</h3><p>编写任务类，每分钟执行任务，启动订单工程，观察定时发送消息日志，观察 <code>rabbitMQ</code> 队列中是否有消息，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>TaskService taskService; <span class="hljs-comment">//每隔1分钟扫描消息表，向mq发送消息</span><span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0/60 * * * * *"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendChoosecourseTask</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//取出当前时间1分钟之前的时间</span>    Calendar calendar =<span class="hljs-keyword">new</span> GregorianCalendar();    calendar.setTime(<span class="hljs-keyword">new</span> Date());    calendar.add(GregorianCalendar.MINUTE,-<span class="hljs-number">1</span>);    Date time = calendar.getTime();    List&lt;XcTask&gt; taskList = taskService.findTaskList(<span class="hljs-number">10</span>, time);    System.out.println(taskList);&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>成功从 task 表中拿到了任务数据</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image24.png" srcset="/img/loading.gif" alt="image-20200605110002127"></p><h2 id="4-定时发送任务"><a href="#4-定时发送任务" class="headerlink" title="4. 定时发送任务"></a>4. 定时发送任务</h2><h3 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h3><p>在 <code>XcTaskRepository</code> 中添加更新任务方法 <code>updateTaskTime</code>，使用 JPA 提供的 <code>@Query</code> 注解来实现自定义SQL语句来实现更新操作</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTask</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//取出指定时间之前的记录</span>    <span class="hljs-function">Page&lt;XcTask&gt; <span class="hljs-title">findByUpdateTimeBefore</span><span class="hljs-params">(Pageable pageable, Date updateTime)</span></span>;     <span class="hljs-comment">//更细任务处理的时间</span>    <span class="hljs-meta">@Modifying</span>  <span class="hljs-comment">//更新操作需要使用该注解</span>    <span class="hljs-meta">@Query</span>(<span class="hljs-string">"update XcTask t set t.updateTime = :updateTimeParam where t.id = :idParam"</span>)  <span class="hljs-comment">//自定义更新语句</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateTaskTime</span><span class="hljs-params">(@Param(<span class="hljs-string">"idParam"</span>)</span> String id, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"updateTimeParam"</span>)</span>Date updateTime)</span>;&#125;</code></pre></div><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><p>添加发送消息方法， 使用 <code>RabbitTemplate</code> 提供的 <code>convertAndSend</code> 来实现发送消息到指定 <code>MQ</code> 交换机上，并且交换机根据提供的 <code>routekey</code> 转发到自定的消息队列，具体代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskService</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送添加选课消息的实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xcTask 消息内容</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ex 交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> routingKey 路由key</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishChooseMsg</span><span class="hljs-params">(XcTask xcTask, String ex, String routingKey)</span> </span>&#123;        <span class="hljs-comment">//查询任务是否存在</span>        Optional&lt;XcTask&gt; byId = xcTaskRepository.findById(xcTask.getId());        <span class="hljs-keyword">if</span>(byId.isPresent())&#123;            xcTask = byId.get();            <span class="hljs-comment">//发送消息到MQ</span>            rabbitTemplate.convertAndSend(ex, routingKey, xcTask);            <span class="hljs-comment">//更细当前任务的时间</span>            xcTaskRepository.updateTaskTime(xcTask.getId(), <span class="hljs-keyword">new</span> Date());        &#125;    &#125;&#125;</code></pre></div><h3 id="编写任务类"><a href="#编写任务类" class="headerlink" title="编写任务类"></a>编写任务类</h3><p>编写任务类，每分钟执行任务，启动订单工程，观察定时发送消息日志，观察 <code>rabbitMQ</code> 队列中是否有消息，代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.mq;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChooseCourseTask</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    TaskService taskService;    <span class="hljs-comment">//每隔1分钟扫描消息表，向mq发送消息</span>    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0/3 * * * * *"</span>)  <span class="hljs-comment">//这里我们为了方便测试，时间改为了3秒一次</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendChoosecourseTask</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//取出当前时间1分钟之前的时间</span>        Calendar calendar =<span class="hljs-keyword">new</span> GregorianCalendar();        calendar.setTime(<span class="hljs-keyword">new</span> Date());        calendar.add(GregorianCalendar.MINUTE,-<span class="hljs-number">1</span>);        Date time = calendar.getTime();        List&lt;XcTask&gt; taskList = taskService.findTaskList(<span class="hljs-number">10</span>, time);        <span class="hljs-keyword">for</span>(XcTask xcTask: taskList)&#123;            String taskId = xcTask.getId();            <span class="hljs-comment">//发送消息到MQ</span>            taskService.publishChooseMsg(xcTask, xcTask.getMqExchange(), xcTask.getMqRoutingkey());            LOGGER.info(<span class="hljs-string">"send choose course task id:&#123;&#125;"</span>,taskId);        &#125;    &#125;&#125;</code></pre></div><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><blockquote><p>在测试之前注意检查以下 task 表的消息中的 交换机名称、路由key是否配置正确。</p></blockquote><p>我们在发布的方法中打个断点</p><p>这时已经将消息发送到了 <code>RabbitMQ</code> 中，我们到 <code>RabbitMQ</code> 的控制台中查看消息是否提交成功</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image26.png" srcset="/img/loading.gif" alt="image-20200605114804617"></p><p>消息成功发送到了 <code>MQ</code></p><h2 id="5-乐观锁取任务"><a href="#5-乐观锁取任务" class="headerlink" title="5. 乐观锁取任务"></a>5. 乐观锁取任务</h2><p>服务将来会集群部署，为了避免任务在 <code>1分钟</code> 内重复执行，这里使用 <strong>乐观锁</strong>，实现思路如下：</p><p>例如 <code>服务A</code> 和 <code>服务B</code> 都需要扫描 task 表里面的任务信息，他们各自手里都携带着一个 <code>version</code> 标识，默认值都为1，并且 task 表里面的 <code>任务X</code> 也会带有一个 <code>version</code> 字段，默认值也为1，如果A先达到数据库，A 在查询<code>任务X</code> 的时候会携带他手里的 version 标识进行匹配查询，如果能匹配到任务，证明A是第一个取出该任务的，取出该任务信息后，A会将该任务在数据库里面的version标识修改为2，在之后到达 task表进行查询的服务B也会以同样的方式匹配 version 为1的任务，这个时候 服务B 就不会再匹配到 <code>version</code> 值为 2 的 <code>任务X</code> 。</p><p>1、在 <code>Dao</code> 中增加校验当前版本及 <code>任务id</code> 的匹配方法</p><div class="hljs"><pre><code class="hljs jade">public interface XcTaskRepository extends JpaRepository&lt;XcTask, String&gt; &#123;    &#x2F;&#x2F;使用乐观锁方式校验任务id和版本号是否匹配，匹配则版本号加1    @Modifying    @Query(&quot;update XcTask t set t.version &#x3D; :version+1 where t.id &#x3D; :id and t.version &#x3D;           :version&quot;)           public int updateTaskVersion(@Param(value &#x3D; &quot;id&quot;) String id,@Param(value &#x3D; &quot;version&quot;) int version);           ...</code></pre></div><p>2、在 <code>service</code> 中增加方法，使用乐观锁方法校验任务</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTask</span><span class="hljs-params">(String taskId,<span class="hljs-keyword">int</span> version)</span></span>&#123;    <span class="hljs-keyword">int</span> i = xcTaskRepository.updateTaskVersion(taskId, version);    <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><p>3、执行任务类中修改</p><div class="hljs"><pre><code class="hljs java">...    <span class="hljs-comment">//任务id</span>    String taskId = xcTask.getId();    <span class="hljs-comment">//版本号</span>    Integer version = xcTask.getVersion();    <span class="hljs-comment">//调用乐观锁方法校验任务是否可以执行</span>    <span class="hljs-keyword">if</span>(taskService.getTask(taskId, version)&gt;<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//发送选课消息</span>        taskService.publish(xcTask, xcTask.getMqExchange(),xcTask.getMqRoutingkey());        LOGGER.info(<span class="hljs-string">"send choose course task id:&#123;&#125;"</span>,taskId);&#125;...</code></pre></div><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>测试的预期结果：使用乐观锁保证同一分钟内同一个任务只能被获取一次</p><p>启动两个实例进行测试，测试流程如下</p><p><strong>1、配置两个端口不同的实例</strong></p><p>实例A</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image27.png" srcset="/img/loading.gif" alt="image-20200605140818128"></p><p>实例B</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image28.png" srcset="/img/loading.gif" alt="image-20200605140754305"></p><p>修改配置文件中的端口，有限从启动配置中获取</p><div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span><span class="hljs-symbol">  port:</span> $&#123;PORT:<span class="hljs-number">31500</span>&#125;</code></pre></div><p><strong>2、先启动实例A，在定时任务发送消息到MQ设置一个断点</strong></p><p>在遍历查询结果之前，设置断点后同时启动两个实例</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image29.png" srcset="/img/loading.gif" alt="image-20200605142540979"></p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image30.png" srcset="/img/loading.gif" alt="image-20200605142611363"></p><p>观察这两个实例都是否查询到了数据，并且达到断点的位置</p><p><strong>3、测试乐观锁</strong></p><p>实例A通过单步调试，运行到执行 getTask 之后，再将实例B也运行到 执行了 getTask之后。</p><p>在实例A执行完后，获取到了任务并且将当前任务的 version 值进行+1</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image31.png" srcset="/img/loading.gif" alt="image-20200605142819208"></p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image32.png" srcset="/img/loading.gif" alt="image-20200605142839878"></p><p>而实例B则没有匹配到该任务</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image33.png" srcset="/img/loading.gif" alt="image-20200605142912374"></p><h1 id="五、自动添加选课功能开发"><a href="#五、自动添加选课功能开发" class="headerlink" title="五、自动添加选课功能开发"></a>五、自动添加选课功能开发</h1><h2 id="1-学习服务添加选课"><a href="#1-学习服务添加选课" class="headerlink" title="1. 学习服务添加选课"></a>1. 学习服务添加选课</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>学习服务接收 <code>MQ</code> 发送添加选课消息，执行添加 选 课操作。</p><p>添加选课成功向学生选课表插入记录、向历史任务表插入记录、并向 <code>MQ</code> 发送“完成选课”消息。</p><h3 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h3><p>学习服务监听 <code>MQ</code> 的添加选课队列，并且声明完成选课队列，配置代码与 <code>订单服务</code> 中 <code>RabbitMQ</code> 配置相同。</p><h3 id="Dao-2"><a href="#Dao-2" class="headerlink" title="Dao"></a>Dao</h3><p>学生选课Dao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcLearningCourseRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcLearningCourse</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//根据用户和课程查询选课记录，用于判断是否添加选课</span>    <span class="hljs-function">XcLearningCourse <span class="hljs-title">findXcLearningCourseByUserIdAndCourseId</span><span class="hljs-params">(String userId, String courseId)</span></span>;&#125;</code></pre></div><p>历史任务Dao：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskHisRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTaskHis</span>,<span class="hljs-title">String</span>&gt; </span>&#123;    &#125;</code></pre></div><h3 id="Service-2"><a href="#Service-2" class="headerlink" title="Service"></a>Service</h3><p>1、添加选课方法</p><p>向 <code>xc_learning_course</code> 添加记录，为保证不重复添加选课，先查询历史任务表，如果从历史任务表查询不到任务说明此任务还没有处理，此时则添加选课并添加历史任务。</p><p>在学习服务中编码如下代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//完成选课</span><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">addChooseCourse</span><span class="hljs-params">(String userId, String courseId,String valid,Date startTime,Date endTime,XcTask xcTask)</span></span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(courseId)) &#123;            ExceptionCast.cast(LearningCode.CHOOSECOURSE_COURSEID_ISNULL);        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(userId)) &#123;            ExceptionCast.cast(LearningCode.CHOOSECOURSE_USERID_ISNULL);        &#125;        <span class="hljs-keyword">if</span>(xcTask == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(xcTask.getId()))&#123;            ExceptionCast.cast(LearningCode.CHOOSECOURSE_TASKID_ISNULL);        &#125;    <span class="hljs-comment">//查询历史任务</span>    Optional&lt;XcTaskHis&gt; optional = xcTaskHisRepository.findById(xcTask.getId());    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;     XcLearningCourse xcLearningCourse = xcLearningCourseRepository.findXcLearningCourseByUserIdAndCourseId(userId, courseId);    <span class="hljs-keyword">if</span> (xcLearningCourse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//没有选课记录则添加</span>        xcLearningCourse = <span class="hljs-keyword">new</span> XcLearningCourse();        xcLearningCourse.setUserId(userId);        xcLearningCourse.setCourseId(courseId);        xcLearningCourse.setValid(valid);        xcLearningCourse.setStartTime(startTime);        xcLearningCourse.setEndTime(endTime);        xcLearningCourse.setStatus(<span class="hljs-string">"501001"</span>);        xcLearningCourseRepository.save(xcLearningCourse);    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//有选课记录则更新日期</span>        xcLearningCourse.setValid(valid);        xcLearningCourse.setStartTime(startTime);        xcLearningCourse.setEndTime(endTime);        xcLearningCourse.setStatus(<span class="hljs-string">"501001"</span>);        xcLearningCourseRepository.save(xcLearningCourse);    &#125;    <span class="hljs-comment">//向历史任务表播入记录</span>    Optional&lt;XcTaskHis&gt; optional = xcTaskHisRepository.findById(xcTask.getId());    <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;        <span class="hljs-comment">//添加历史任务</span>        XcTaskHis xcTaskHis = <span class="hljs-keyword">new</span> XcTaskHis();        BeanUtils.copyProperties(xcTask,xcTaskHis);        xcTaskHisRepository.save(xcTaskHis);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);&#125;</code></pre></div><h3 id="接收添加选课消息"><a href="#接收添加选课消息" class="headerlink" title="接收添加选课消息"></a>接收添加选课消息</h3><p>接收到添加选课的消息调用添加选课方法完成添加选课，并发送完成选课消息。</p><p>在 <code>com.xuecheng.learning.mq</code> 包下添加 <code>ChooseCourseTask</code> 类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChooseCourseTask</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    LearningService learningService;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 接收选课任务</span><span class="hljs-comment">    */</span>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitMQConfig.XC_LEARNING_ADDCHOOSECOURSE&#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveChoosecourseTask</span><span class="hljs-params">(XcTask xcTask,Message message,Channel channel)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">        IOException </span>&#123;        LOGGER.info(<span class="hljs-string">"receive choose course task,taskId:&#123;&#125;"</span>,xcTask.getId());        <span class="hljs-comment">//接收到 的消息id</span>        String id = xcTask.getId();        <span class="hljs-comment">//添加选课</span>        <span class="hljs-keyword">try</span> &#123;            String requestBody = xcTask.getRequestBody();            Map map = JSON.parseObject(requestBody, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            String userId = (String) map.get(<span class="hljs-string">"userId"</span>);            String courseId = (String) map.get(<span class="hljs-string">"courseId"</span>);            String valid = (String) map.get(<span class="hljs-string">"valid"</span>);            Date startTime = <span class="hljs-keyword">null</span>;            Date endTime = <span class="hljs-keyword">null</span>;            SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"YYYY‐MM‐dd HH:mm:ss"</span>);            <span class="hljs-keyword">if</span>(map.get(<span class="hljs-string">"startTime"</span>)!=<span class="hljs-keyword">null</span>)&#123;                startTime =dateFormat.parse((String) map.get(<span class="hljs-string">"startTime"</span>));            &#125;             <span class="hljs-keyword">if</span>(map.get(<span class="hljs-string">"endTime"</span>)!=<span class="hljs-keyword">null</span>)&#123;                endTime =dateFormat.parse((String) map.get(<span class="hljs-string">"endTime"</span>));            &#125;             <span class="hljs-comment">//添加选课</span>            ResponseResult addcourse = learningService.addcourse(                userId, courseId,valid,startTime, endTime,xcTask);            <span class="hljs-comment">//选课成功发送响应消息</span>            <span class="hljs-keyword">if</span>(addcourse.isSuccess())&#123;                <span class="hljs-comment">//发送响应消息</span>                rabbitTemplate.convertAndSend(                    RabbitMQConfig.EX_LEARNING_ADDCHOOSECOURSE,                     RabbitMQConfig.XC_LEARNING_FINISHADDCHOOSECOURSE_KEY,                     xcTask );                LOGGER.info(<span class="hljs-string">"send finish choose course taskId:&#123;&#125;"</span>,id);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"send finish choose course taskId:&#123;&#125;"</span>, id);        &#125;    &#125;&#125;</code></pre></div><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><p>测试接收选课消息，并且返回选课成功的消息到 <code>MQ</code></p><p>订单服务发送 “添加选课” 的消息到MQ</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image34.png" srcset="/img/loading.gif" alt="image-20200605165303909"></p><p>学习服务接从MQ中收到 “添加选课” 的消息，进行添加或者更新选课记录，再发送一个完成选课的消息到MQ</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image35.png" srcset="/img/loading.gif" alt="image-20200605165736109"></p><p>再到 <code>RabbitMQ</code> 的控制台查看消息是否发送成功</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image36.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-订单服务结束任务"><a href="#2-订单服务结束任务" class="headerlink" title="2. 订单服务结束任务"></a>2. 订单服务结束任务</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>订单服务接收 <code>MQ</code> 完成选课的消息，将任务从当前任务表删除，将完成的任务添加到完成任务表。</p><h3 id="Dao-3"><a href="#Dao-3" class="headerlink" title="Dao"></a>Dao</h3><p>配置 XcTaskHisRepository</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.dao; <span class="hljs-keyword">import</span> com.xuecheng.framework.domain.task.XcTaskHis;<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskHisRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTaskHis</span>, <span class="hljs-title">String</span>&gt; </span>&#123; &#125;</code></pre></div><h3 id="Service-3"><a href="#Service-3" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除任务</span><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishTask</span><span class="hljs-params">(String taskId)</span></span>&#123;    Optional&lt;XcTask&gt; taskOptional = xcTaskRepository.findById(taskId);    <span class="hljs-keyword">if</span>(taskOptional.isPresent())&#123;        XcTask xcTask = taskOptional.get();        xcTask.setDeleteTime(<span class="hljs-keyword">new</span> Date());        XcTaskHis xcTaskHis = <span class="hljs-keyword">new</span> XcTaskHis();        BeanUtils.copyProperties(xcTask, xcTaskHis);        <span class="hljs-comment">//保存任务到 task_hit 表内</span>        xcTaskHisRepository.save(xcTaskHis);        <span class="hljs-comment">//删除当前任务</span>        xcTaskRepository.delete(xcTask);    &#125;&#125;</code></pre></div><h3 id="接收完成选课消息"><a href="#接收完成选课消息" class="headerlink" title="接收完成选课消息"></a>接收完成选课消息</h3><p>在 com.xuecheng.manage_order.mq 包下 <code>ChooseCourseTask</code> 类中添加 <code>receiveChoosecourseTask</code>，接收完成课任务消息并进行处理。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 接收选课响应结果</span><span class="hljs-comment">*/</span><span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitMQConfig.xc_learning_finishaddchoosecourse&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveFinishChoosecourseTask</span><span class="hljs-params">(XcTask task,Message message, Channel channel)</span> <span class="hljs-keyword">throws</span></span><span class="hljs-function">    IOException </span>&#123;    LOGGER.info(<span class="hljs-string">"receiveChoosecourseTask...&#123;&#125;"</span>,task.getId());    <span class="hljs-comment">//接收到 的消息id</span>    String id = task.getId();    <span class="hljs-comment">//删除任务，添加历史任务</span>    taskService.finishTask(id);&#125;</code></pre></div><h2 id="3-集成测试"><a href="#3-集成测试" class="headerlink" title="3. 集成测试"></a>3. 集成测试</h2><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><h4 id="1、添加任务数据"><a href="#1、添加任务数据" class="headerlink" title="1、添加任务数据"></a>1、添加任务数据</h4><p>向 xc_task 表添加一行数据，模拟用户支付成功后向 xc_task 表写入添加选课的任务</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image37.png" srcset="/img/loading.gif" alt="image-20200605180154027"></p><p>SQL 语句如下</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`xc_task`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'4028858162959ce5016295b604ba0000'</span>, <span class="hljs-string">'2018-04-05 20:09:17'</span>, <span class="hljs-string">'2020-06-05 17:15:51'</span>, <span class="hljs-string">'2020-06-05 17:40:04'</span>, <span class="hljs-string">'add_choosecourse'</span>, <span class="hljs-string">'ex_learning_addchoosecourse'</span>, <span class="hljs-string">'addchoosecourse'</span>, <span class="hljs-string">'&#123;\"courseId\":\"4028e58161bcf7f40161bcf8b77c0000,\",\"userId\":\"49\"&#125;'</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'10201'</span>, <span class="hljs-literal">NULL</span>);</code></pre></div><h4 id="2、配置断点"><a href="#2、配置断点" class="headerlink" title="2、配置断点"></a>2、配置断点</h4><p>为了能够清楚的看到整个处理流程，我们在各个处理模块下设置断点。</p><p>在订单服务的 ChooseCourseTask 下配置断点，分别是发送 “添加选课” 消息到MQ的模块 和 接收 “选课完成” 消息的模块</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image38.png" srcset="/img/loading.gif" alt="image-20200605180510707"></p><p>在学习服务的接收选课任务方法下设置断点</p><h4 id="3、启动服务进行测试"><a href="#3、启动服务进行测试" class="headerlink" title="3、启动服务进行测试"></a>3、启动服务进行测试</h4><p>同时启动 <code>订单服务</code> 和 <code>学习服务</code></p><p>订单服务扫描 <code>xc_task</code> 表中的任务，并且发送 “添加选课” 的消息到 <code>MQ</code></p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image40.png" srcset="/img/loading.gif" alt="image-20200605182354315"></p><p>学习服务通过监听 MQ的消息，接收到了订单服务送过来的 “添加选课” 消息</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image41.png" srcset="/img/loading.gif" alt="image-20200605182533669"></p><p>完成选课添加后，发送响应的消息到MQ</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image42.png" srcset="/img/loading.gif" alt="image-20200605182603485"></p><p>订单服务接收到 “选课完成” 的消息，删除 <code>xc_task</code> 表中的任务，并且添加任务记录到 <code>xc_task_his</code> 表中</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image43.png" srcset="/img/loading.gif" alt="image-20200605182738167"></p><p>学习服务收到重复的完成消息，但由于 xc_task 中该任务的已经被删除，所以步任何的操作，如下图</p><p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image44.png" srcset="/img/loading.gif" alt="image-20200605182948477"></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>Spring Task</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day18：基于oauth2实现RBAC认证授权、微服务间认证实现</title>
    <link href="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/"/>
    <url>/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day18</code> 的内容</p><ul><li>基于方法的权限校验</li><li>基于 <code>RBAC</code> 进行用户权限配置以及动态查询。</li><li>根据教师所属的公司来实现课程信息查询的细粒度授权。也就是 <code>A</code> 公司的老师只能查询到 <code>A</code> 公司下的课程。</li><li>使用 <code>Feign</code> 拦截器实现获取前端请求中的 header 信息，并将 <code>header</code> 中带有的 jwt 令牌向下传递，实现微服务间的远程调用的认证授权。</li></ul><h1 id="一、用户授权业务流程"><a href="#一、用户授权业务流程" class="headerlink" title="一、用户授权业务流程"></a>一、用户授权业务流程</h1><p>用户授权的业务流程如下：</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image1.png" srcset="/img/loading.gif" alt="image-20200601102646580"></p><p>业务流程说明如下：</p><p>1、用户认证通过，认证服务向浏览器 <code>cookie</code> 写入 <code>token</code>（ 身份令牌）</p><p>2、前端携带 <code>token</code> 请求用户中心服务获取jwt令牌，前端获取到jwt令牌解析，并存储在<code>sessionStorage</code></p><p>3、前端携带 <code>cookie</code> 中的身份令牌及jwt令牌访问资源服务</p><p>前端请求资源服务需要携带两个 <code>token</code>，一个是 <code>cookie</code> 中的身份令牌，一个是 <code>http header</code>中的 <code>jwt</code>，前端请求资源服务前在 <code>http header</code>上添加 <code>jwt</code> 请求资源</p><p>4、网关校验 <code>token</code> 的合法性</p><p>用户请求必须携带身份令牌和jwt令牌。</p><p>网关校验 <code>redis</code> 中 <code>user_token</code> 的有效期，已过期则要求用户重新登录。</p><p>5、资源服务校验 <code>jwt</code> 的合法性并进行授权</p><p>资源服务校验 <code>jwt</code> 令牌，完成授权，拥有权限的方法正常执行，没有权限的方法将拒绝访问。</p><h1 id="二、基于方法授权"><a href="#二、基于方法授权" class="headerlink" title="二、基于方法授权"></a>二、基于方法授权</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>方法授权要完成的是 <code>资源服务</code> 根据 jwt 令牌完成对方法的授权，具体流程如下：</p><p>1、生成 <code>Jwt</code> 令牌时在令牌中写入用户所拥有的权限</p><p>我们给每个权限起个名字，例如某个用户拥有如下权限：</p><p>course_find_list：课程查询</p><p>course_pic_list：课程图片查询</p><p>2、在资源服务方法上添加注解 <code>@PreAuthorize</code>，并指定此方法所需要的权限</p><blockquote><p>@PreAuthorize 注解是由Spring Security 提供的一个权限校验注解</p></blockquote><p>例如下边是课程管理接口方法的授权配置，它就表示要执行这个方法需要拥有 <code>course_find_list</code> 权限。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('course_find_list')"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResult&lt;CourseInfo&gt; <span class="hljs-title">findCourseList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page,</span><span class="hljs-function">                                              @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size,</span><span class="hljs-function">                                              CourseListRequest courseListRequest)</span></code></pre></div><p>3、当请求有权限的方法时正常访问</p><p>4、当请求没有权限的方法时则拒绝访问</p><h2 id="2-jwt令牌包含权限"><a href="#2-jwt令牌包含权限" class="headerlink" title="2. jwt令牌包含权限"></a>2. jwt令牌包含权限</h2><p>修改认证服务的 <code>UserDetailServiceImpl</code> 类，下边的代码中 <code>permissionList</code> 列表中存放了用户的权限，并且将权限标识按照中间使用逗号分隔的语法组成一个字符串，最终提供给 <code>Spring security</code></p><p>核心的代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//指定用户的权限，这里暂时硬编码</span>List&lt;String&gt; permissionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();permissionList.add(<span class="hljs-string">"course_base_list"</span>);permissionList.add(<span class="hljs-string">"course_pic_list"</span>); <span class="hljs-comment">//将权限串中间以逗号分隔</span>String user_permission_string = StringUtils.join(permissionList.toArray(), <span class="hljs-string">","</span>);<span class="hljs-comment">//设置用户信息到userDetails对象</span>UserJwt userDetails = <span class="hljs-keyword">new</span> UserJwt(    username,    password,    AuthorityUtils.commaSeparatedStringToAuthorityList(user_permission_string));</code></pre></div><p>在上述的代码当中，通过向 <code>permissionList</code> 添加标识来对用户的进行授权，这里我们暂时对用户的权限的内容进行硬编码，后面的章节中用户的权限信息会从数据库中获取。</p><p>全部代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;    <span class="hljs-comment">//取出身份，如果身份为空说明没有认证</span>    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();    <span class="hljs-comment">//没有认证统一采用httpbasic认证，httpbasic中存储了client_id和client_secret</span>    <span class="hljs-comment">//开始认证client_id和client_secret</span>    <span class="hljs-keyword">if</span>(authentication==<span class="hljs-keyword">null</span>)&#123;        ClientDetails clientDetails = clientDetailsService.loadClientByClientId(username);        <span class="hljs-keyword">if</span>(clientDetails!=<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//密码</span>            String clientSecret = clientDetails.getClientSecret();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username,clientSecret,AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">""</span>));        &#125;    &#125;    <span class="hljs-keyword">if</span> (StringUtils.isEmpty(username)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;     <span class="hljs-comment">//请求ucenter查询用户</span>    XcUserExt userext = userClient.getUserext(username);    <span class="hljs-keyword">if</span>(userext == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">//如果获取到的用信息为空,则返回null,spring security则会抛出异常</span>     <span class="hljs-comment">//设置用户的认证和权限信息</span>    userext.setUsername(<span class="hljs-string">"itcast"</span>);    userext.setPassword(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>));    userext.setPermissions(<span class="hljs-keyword">new</span> ArrayList&lt;XcMenu&gt;());  <span class="hljs-comment">//这里授权部分还没完成,所以先填写静态的</span>     <span class="hljs-keyword">if</span>(userext == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;     <span class="hljs-comment">//从数据库查询用户正确的密码，Spring Security会去比对输入密码的正确性</span>    String password = userext.getPassword();     <span class="hljs-comment">//指定用户的权限，这里暂时硬编码</span>    List&lt;String&gt; permissionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    permissionList.add(<span class="hljs-string">"course_base_list"</span>);    permissionList.add(<span class="hljs-string">"course_pic_list"</span>);     <span class="hljs-comment">//将权限串中间以逗号分隔</span>    String user_permission_string = StringUtils.join(permissionList.toArray(), <span class="hljs-string">","</span>);    <span class="hljs-comment">//设置用户信息到userDetails对象</span>    UserJwt userDetails = <span class="hljs-keyword">new</span> UserJwt(        username,        password,        AuthorityUtils.commaSeparatedStringToAuthorityList(user_permission_string));    <span class="hljs-comment">//用户id</span>    userDetails.setId(userext.getId());    <span class="hljs-comment">//用户名称</span>    userDetails.setName(userext.getName());    <span class="hljs-comment">//用户头像</span>    userDetails.setUserpic(userext.getUserpic());    <span class="hljs-comment">//用户所属企业id</span>    userDetails.setCompanyId(userext.getCompanyId());     <span class="hljs-comment">//返回用信息给到Spring Security进行处理</span>    <span class="hljs-keyword">return</span> userDetails;&#125;</code></pre></div><p>重启认证服务工程，使用 <code>postman</code> 完成登录，获取到用户令牌</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image2.png" srcset="/img/loading.gif" alt="image-20200601114112301"></p><p>从 <code>redis</code> 中找到该用户令牌对应的 <code>jwt</code> 令牌。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image3.png" srcset="/img/loading.gif" alt="image-20200601114257044"></p><p>使用 <code>jwt</code> 的测试程序查看 此令牌的内容。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image4.png" srcset="/img/loading.gif" alt="image-20200601114334352"></p><p>可以看到 <code>authorities</code> 属性中为用户的权限。</p><h2 id="3-方法授权实现"><a href="#3-方法授权实现" class="headerlink" title="3. 方法授权实现"></a>3. 方法授权实现</h2><p><strong>1、资源服务添加权限控制</strong></p><p>要想在资源服务使用方法授权，首先在 <code>资源服务</code> 配置授权控制，流程如下</p><p>1）添加 <code>spring-cloud-starter-oauth2</code> 依赖。</p><p>2）拷贝授权配置类 <code>ResourceServerConfig</code>。</p><p>3）拷贝公钥。</p><p><strong>2、方法上添加注解</strong></p><p>通常情况下，程序员编写在资源服务的 <code>controller</code> 方法时会使用注解指定此方法的权限标识。</p><p>为什么不在 <code>Service</code> 或者 <code>Dao</code>上定义？因为 Service 和 Dao的方法有可能是公用的，而 <code>Controller</code> 通常都是最外层的，所以不会涉及到被其他服务依赖的情况。</p><p>下面我们在 <code>获取课程的图片</code> 和 <code>删除课程图</code> 的接口中使用 <code>@PreAuthorize</code> 注解进行权限的设置，试下以下功能</p><ul><li>访问 getCoursePic 需要授权 course_pic_list 权限</li><li>访问 deleteCoursePic 需要授权 course_pic_delete 权限</li></ul><p>而我们要注意的是，我们在前面的认证当中，只为用分配了 course_pic_list 的权限，配置完后我们来进行测试。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据课程id获取该课程的课程图片信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 由于这里每个课程只有一个图片，所以只返回一个 CoursePic 对象</span><span class="hljs-comment">     */</span><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('course_pic_list')"</span>)<span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/coursepic/get/&#123;courseId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CoursePic <span class="hljs-title">getCoursePic</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"courseId"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.getCoursePic(courseId);&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除课程图片信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span> <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('course_pic_delete')"</span>)<span class="hljs-meta">@Override</span><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/coursepic/delete"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">deleteCoursePic</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"courseId"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.deleteCoursePic(courseId);&#125;</code></pre></div><p>3、在资源服务（这里是课程管理）的 <code>ResourceServerConfig</code> 类上添加注解，激活方法上添加授权注解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//激活方法上的PreAuthorize注解</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>, securedEnabled = <span class="hljs-keyword">true</span>)</code></pre></div><h2 id="4-方法授权测试"><a href="#4-方法授权测试" class="headerlink" title="4. 方法授权测试"></a>4. 方法授权测试</h2><p>重启课程管理服务，测试上边两个方法。</p><p>使用 <code>postman</code> 测试，测试前执行登录，并且将 <code>jwt</code> 令牌（access_token）添加到 <code>header</code>。</p><p>发送GET请求到以下链接</p><p><a href="http://www.xuecheng.com/api/course/coursepic/get/4028e58161bd22e60161bd23672a0001" target="_blank" rel="noopener">http://www.xuecheng.com/api/course/coursepic/get/4028e58161bd22e60161bd23672a0001</a></p><p>1、用户拥有 <code>course_pic_list</code> 权限，可以正常访问获取课程图片的接口 。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image5.png" srcset="/img/loading.gif" alt="image-20200601115936697"></p><p>2、下面我们来测试删除课程图片的接口</p><p>发送给 <code>DELETE</code> 请求到 <a href="http://www.xuecheng.com/api/course/coursepic/delete?courseId=4028e58161bd22e60161bd23672a0001" target="_blank" rel="noopener">http://www.xuecheng.com/api/course/coursepic/delete?courseId=4028e58161bd22e60161bd23672a0001</a></p><p>由于用户没有查询课程列表方法的权限，所以无法正常访问，其它方法可以正常访问。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image6.png" srcset="/img/loading.gif" alt="image-20200601133025369"></p><p>控制台报错：</p><p><code>org.springframework.security.access.AccessDeniedException: 不允许访问</code></p><p>说明：如果方法上没有添加授权注解 <code>spring security</code> 将不进行授权控制，只要 <code>jwt</code> 令牌合法则可以正常访问</p><p>3、异常处理</p><p>上边当没有权限访问时资源服务，应该返回下边的错误代码：</p><div class="hljs"><pre><code class="hljs java">UNAUTHORISE(<span class="hljs-keyword">false</span>,<span class="hljs-number">10002</span>,<span class="hljs-string">"权限不足，无权操作！"</span>)</code></pre></div><p>进入资源服务（我们测试的是课程管理），新建一个 <code>exception</code> 包，在包下创建一个 CustomExceptionCatch ，并继承 <code>common</code> 工程中的 ExceptionCatch 。</p><p>添加异常类 <code>AccessDeniedException.class</code> 与错误代码 10002 的 对应关系，使用 <code>@ControllerAdvice</code> 注解添加一个全局的异常处理，并继承我们在 <code>common</code> 工程中定义的 <code>ExceptionCatch</code> ，使用 static {} 向 <code>builder</code> 里面添加自定义的异常处理代码。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.exception; <span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCatch;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> org.springframework.security.access.AccessDeniedException;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice; <span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExceptionCatch</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExceptionCatch</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">//除了CustomException以外的异常类型及对应的错误代码在这里定义,，如果不定义则统一返回固定的错误信息</span>        builder.put(AccessDeniedException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">CommonCode</span>.<span class="hljs-title">UNAUTHORISE</span>)</span>;    &#125;&#125;</code></pre></div><p>再次测试，结果如下：</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image7.png" srcset="/img/loading.gif" alt="image-20200601134010887"></p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>基于方法授权步骤：</p><p>1、<code>ResourceServerConfig</code> 类上添加注解，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//激活方法上的PreAuthorize注解</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>, securedEnabled = <span class="hljs-keyword">true</span>)</code></pre></div><p>2、在 <code>Controller</code> 为需要校验权限的方法上添加授权注解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('权限名称')"</span>)</code></pre></div><p>3、如果方法上不添加授权注解则表示此方法不需要权限即可访问。</p><h1 id="三、动态查询用户权限"><a href="#三、动态查询用户权限" class="headerlink" title="三、动态查询用户权限"></a>三、动态查询用户权限</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>截至目前在测试授权时使用的权限数据是静态数据，正常情况的流程是：</p><p>1、管理员给用户分配权限，权限数据写到数据库中。</p><p>2、认证服务在进行用户认证时从数据库读取用户的权限数据（动态数据）<br>本节实现动态权限数据。</p><h2 id="2-权限数据模型"><a href="#2-权限数据模型" class="headerlink" title="2. 权限数据模型"></a>2. 权限数据模型</h2><h3 id="数据模型结构"><a href="#数据模型结构" class="headerlink" title="数据模型结构"></a>数据模型结构</h3><p>打开 <code>xc_user</code> 数据库，找到下边的表：</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image8.png" srcset="/img/loading.gif" alt="image-20200601141058705"></p><p>xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等</p><p>xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。</p><p>xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有</p><p>xc_menu: 模块表，记录了菜单及菜单下的权限</p><p>xc_permission: 角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有</p><blockquote><p>xc_permission 表可以更名为 xc_permission_role 或者 xc_menu_role 会容易理解</p></blockquote><h3 id="数据模型的使用"><a href="#数据模型的使用" class="headerlink" title="数据模型的使用"></a>数据模型的使用</h3><p>本项目教学阶段不再实现权限定义及用户权限分配的功能，但是基于权限数据模型（5张数据表）及现有数据，要求学生在数据库中操作完成给用户分配权限、查询用户权限等需求。</p><p>1、查询用户所拥有的权限</p><p>步骤：</p><ul><li>确定用户的id</li><li>查询用户所拥有的角色</li><li>查询用户所属的 <strong>角色</strong> 所拥有的权限</li></ul><p>例子：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment"># 根据查到的权限ID(menu_id)查询所对应的权限的详细信息</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> xc_menu <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">IN</span>(<span class="hljs-comment"># 根据用户角色ID取出该角色所拥有的权限</span><span class="hljs-keyword">SELECT</span> menu_id <span class="hljs-keyword">FROM</span> xc_permission <span class="hljs-keyword">WHERE</span> role_id <span class="hljs-keyword">IN</span>(        <span class="hljs-comment"># 获取指定用户所拥有角色的id</span><span class="hljs-keyword">SELECT</span> role_id <span class="hljs-keyword">FROM</span> xc_user_role <span class="hljs-keyword">where</span> user_id = <span class="hljs-number">49</span>))</code></pre></div><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image9.png" srcset="/img/loading.gif" alt="image-20200601144244164"></p><p>2、向已拥有角色分配权限</p><p>1）新增一个 权限 <code>A</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">INSERT INTO <span class="hljs-title">xc_menu</span> <span class="hljs-params">(id,code,p_id,menu_name)</span> <span class="hljs-title">VALUES</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"903459378655395851"</span>, # 权限A的ID</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"course_pic_list"</span>,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"903459378655395841"</span>,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"课程图片查询"</span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre></div><p>2）将该用户所属的某个角色与权限 <code>A</code> 关联起来</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> xc_permission (<span class="hljs-keyword">id</span>,role_id,menu_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">"8947692177635409931"</span>,<span class="hljs-number">20</span>,<span class="hljs-string">"903459378655395851"</span> <span class="hljs-comment"># 权限A的ID</span>)</code></pre></div><p>3）再次查询该用户对有的权限</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image10.png" srcset="/img/loading.gif" alt="image-20200601144328736"></p><p>从上图中可以看到，我们为用户所属的角色下添加了一个课程图片查询的权限，那么用户也会同时拥有了该权限。</p><h2 id="3-用户中心查询用户权限"><a href="#3-用户中心查询用户权限" class="headerlink" title="3. 用户中心查询用户权限"></a>3. 用户中心查询用户权限</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>认证服务请求用户中心查询用户信息，用户需要将用户基本信息和用户权限一同返回给认证服务。</p><p>本小节实现查询用户所拥有的权限，并将用户权限信息添加到的指定对象中返回给认证服务。</p><p>以上需求需要修改如下接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getuserext"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserext</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"username"</span>)</span> String username)</span>;</code></pre></div><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>在用户中心服务中编写 <code>dao</code>，实现根据用户id查询权限。</p><p>1、定义 XcMenuMapper.java</p><p>在 <code>com.xuecheng.ucenter.dao</code> 包下定义：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcMenuMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;XcMenu&gt; <span class="hljs-title">selectPermissionByUserId</span><span class="hljs-params">(String userid)</span></span>;&#125;</code></pre></div><p>2、XcMenuMapper.xml</p><p>在 <code>resources</code> 下创建 <code>com.xuecheng.ucenter.dao</code> 然后定义 <code>XcMenuMapper.xml</code></p><p>这里要注意的一个点就是，在r esources 创建 com.xuecheng.ucenter.dao 时需要逐个包来创建，如果直接复制整串来创建，idea会将他识别为同一个目录，导致mapperxml文件无法被扫描到，例如下图</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image11.png" srcset="/img/loading.gif" alt="image-20200602103546011"></p><blockquote><p>这里mapper.xml文件也可以存放的位置也可以是自定义的包名，但是要在启动类配置mapperscan</p></blockquote><div class="hljs"><pre><code class="hljs sql">&lt;?xml version="1.0" encoding="UTF‐8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "‐//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis‐3‐mapper.dtd" &gt;&lt;mapper namespace="com.xuecheng.ucenter.dao.XcMenuMapper" &gt;    &lt;select id="selectPermissionByUserId"            resultType="com.xuecheng.framework.domain.ucenter.XcMenu" parameterType="java.lang.String" &gt;        <span class="hljs-keyword">SELECT</span>        <span class="hljs-keyword">id</span>,        CODE,        p_id pId,        menu_name menuName,        <span class="hljs-keyword">url</span>,        is_menu isMenu,        <span class="hljs-keyword">LEVEL</span>,        <span class="hljs-keyword">sort</span>,        <span class="hljs-keyword">STATUS</span>,        icon,        create_time createTime,        update_time updateTiem        <span class="hljs-keyword">FROM</span>        xc_menu        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">IN</span>(        <span class="hljs-keyword">SELECT</span> menu_id <span class="hljs-keyword">FROM</span> xc_permission <span class="hljs-keyword">WHERE</span> role_id <span class="hljs-keyword">IN</span>(        <span class="hljs-keyword">SELECT</span> role_id <span class="hljs-keyword">FROM</span> xc_user_role <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-comment">#&#123;id&#125;</span>        )        )    &lt;/<span class="hljs-keyword">select</span>&gt;&lt;/mapper&gt;</code></pre></div><p>其它 Dao 采用 <code>spring data jpa</code> 编写如下：</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image12.png" srcset="/img/loading.gif" alt="image-20200601144613066"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>修改 <code>UserService</code> 的 <code>getUserExt</code> 方法，查询用户权限。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//根据账号查询用户的信息，返回用户扩展信息</span><span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserExt</span><span class="hljs-params">(String username)</span></span>&#123;    XcUser xcUser = <span class="hljs-keyword">this</span>.findXcUserByUsername(username);    <span class="hljs-keyword">if</span>(xcUser == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;     <span class="hljs-comment">//根据用户id查询用户权限</span>    String userId = xcUser.getId();    List&lt;XcMenu&gt; xcMenus = xcMenuMapper.selectPermissionByUserId(userId);    XcUserExt xcUserExt = <span class="hljs-keyword">new</span> XcUserExt();    BeanUtils.copyProperties(xcUser,xcUserExt);    <span class="hljs-comment">//用户的权限</span>    xcUserExt.setPermissions(xcMenus);    <span class="hljs-keyword">return</span> xcUserExt;&#125;</code></pre></div><h2 id="4-认证服务查询用户权限"><a href="#4-认证服务查询用户权限" class="headerlink" title="4. 认证服务查询用户权限"></a>4. 认证服务查询用户权限</h2><p>修改认证服务的 <code>UserDetailServiceImpl</code> ，查询用户的权限，并拼接权限串，将原来硬编码权限代码删除，代码如<br>下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;        <span class="hljs-meta">@Autowired</span>    ClientDetailsService clientDetailsService;     <span class="hljs-comment">//用户中心服务客户端</span>    <span class="hljs-meta">@Autowired</span>    UserClient userClient;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        <span class="hljs-comment">//取出身份，如果身份为空说明没有认证</span>        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-comment">//没有认证统一采用httpbasic认证，httpbasic中存储了client_id和client_secret</span>        <span class="hljs-comment">//开始认证client_id和client_secret</span>        <span class="hljs-keyword">if</span>(authentication==<span class="hljs-keyword">null</span>)&#123;            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(username);            <span class="hljs-keyword">if</span>(clientDetails!=<span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//密码</span>                String clientSecret = clientDetails.getClientSecret();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username,clientSecret,AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">""</span>));            &#125;        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(username)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-comment">//请求ucenter查询用户</span>        XcUserExt userext = userClient.getUserext(username);        <span class="hljs-keyword">if</span>(userext == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">//如果获取到的用信息为空,则返回null,spring security则会抛出异常</span>         <span class="hljs-comment">//从数据库查询用户正确的密码，Spring Security会去比对输入密码的正确性</span>        String password = userext.getPassword();        <span class="hljs-comment">//指定用户的权限,从数据库中获取</span>        List&lt;XcMenu&gt; permissions = userext.getPermissions();        <span class="hljs-keyword">if</span>(permissions == <span class="hljs-keyword">null</span>) &#123;            permissions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;         List&lt;String&gt; permissionsCode = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//遍历权限对象中的code字段</span>        permissions.forEach(item -&gt; permissionsCode.add(item.getCode()));        <span class="hljs-comment">//将权限串中间以逗号分隔</span>        String user_permission_string = StringUtils.join(permissionsCode.toArray(), <span class="hljs-string">","</span>);         <span class="hljs-comment">//设置用户信息到userDetails对象</span>        UserJwt userDetails = <span class="hljs-keyword">new</span> UserJwt(            username,            password,            AuthorityUtils.commaSeparatedStringToAuthorityList(user_permission_string));         <span class="hljs-comment">//用户id</span>        userDetails.setId(userext.getId());        <span class="hljs-comment">//用户名称</span>        userDetails.setName(userext.getName());        <span class="hljs-comment">//用户头像</span>        userDetails.setUserpic(userext.getUserpic());        <span class="hljs-comment">//用户所属企业id</span>        userDetails.setCompanyId(userext.getCompanyId());         <span class="hljs-comment">//返回用信息给到Spring Security进行处理</span>        <span class="hljs-keyword">return</span> userDetails;    &#125;&#125;</code></pre></div><p>这里要注意的是，设置到 <code>userDetails</code> 对象的权限信息为权限的代码标识，也就是 <code>UserJwt</code> 对象的 <code>code</code>字段，需要将所有的权限代码遍历出来然后拼接成字符串，如下代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//指定用户的权限,从数据库中获取</span>List&lt;XcMenu&gt; permissions = userext.getPermissions();List&lt;String&gt; permissionsCode = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">for</span> (XcMenu xcMenu : permissions )&#123;    String code = xcMenu.getCode();    permissionsCode.add(code);&#125;<span class="hljs-comment">//将权限串中间以逗号分隔</span>String user_permission_string = StringUtils.join(permissionsCode.toArray(), <span class="hljs-string">","</span>);</code></pre></div><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><p>1、执行登录，在 <code>redis</code> 中查看 <code>jwt</code> 令牌，使用 <code>jwt</code> 测试程序解析 <code>jwt</code> 令牌中是否包括用户的权限 。</p><p>测试登录，拿到令牌</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image13.png" srcset="/img/loading.gif" alt="image-20200602114307895"></p><p>根据令牌，我们到redis里找到该令牌对应的 <code>access_token</code></p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image14.png" srcset="/img/loading.gif" alt="image-20200602114407430"></p><p>2、使用新的jwt令牌测试方法授权</p><p>成功的访问课程图片的接口</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image15.png" srcset="/img/loading.gif" alt="image-20200602121703349"></p><h1 id="四、前端集成认证授权"><a href="#四、前端集成认证授权" class="headerlink" title="四、前端集成认证授权"></a>四、前端集成认证授权</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>截至目前认证授权服务端的功能已基本完成，本章实现前端集成认证授权功能。</p><p>前端集成认证授权功能需要作如下工作：</p><p>1、前端页面校验用户的身份，如果用户没有登录则跳转到登录页面</p><p>2、前端请求资源服务需要在 <code>http header</code> 中添加 <code>jwt</code> 令牌，资源服务根据 <code>jwt</code> 令牌完成授权。</p><p>哪些功能需要前端请求时携带 <code>JWT</code> ？</p><p>用户登录成功请求资源服务都需要携带 <code>jwt</code> 令牌，因为资源服务已经实现了 <code>jwt</code> 认证，如果校验头部没有 <code>jwt</code> 则会认为身份不合法。</p><h2 id="2-教学管理中心"><a href="#2-教学管理中心" class="headerlink" title="2. 教学管理中心"></a>2. 教学管理中心</h2><p>本节实现教学管理中心（xc-ui-pc-teach）实现身份校验，其它前端参考教学管理中心实现</p><h3 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h3><p>教学管理前端访问微服务统一在访问地址前添加 <code>/api</code> 前缀并经过网关转发到微服务。</p><p>配置 teacher.xuecheng.com 虚拟主机。</p><div class="hljs"><pre><code class="hljs java">#前端教学管理upstream teacher_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">12000</span> weight=<span class="hljs-number">10</span>;&#125; #文件服务upstream filesystem_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">22100</span> weight=<span class="hljs-number">10</span>;&#125; #媒资服务upstream media_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">31400</span> weight=<span class="hljs-number">10</span>;&#125;# 学成网教学管理中心server &#123;    listen <span class="hljs-number">80</span>;    server_name teacher.xuecheng.com;    #个人中心    location / &#123;        proxy_pass http:<span class="hljs-comment">//teacher_server_pool;</span>    &#125;     location /api &#123;        proxy_pass http:<span class="hljs-comment">//api_server_pool;</span>    &#125;     location /filesystem &#123;        proxy_pass http:<span class="hljs-comment">//filesystem_server_pool;</span>    &#125;    #媒资管理    location ^~ /api/media/ &#123;        proxy_pass http:<span class="hljs-comment">//media_server_pool/media/;</span>    &#125;     #认证    location ^~ /openapi/auth/ &#123;        proxy_pass http:<span class="hljs-comment">//auth_server_pool/auth/;</span>    &#125;&#125;</code></pre></div><p>修改 <code>hosts</code> 文件 C:\Windows\System32\drivers\etc\hosts</p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> teacher.xuecheng.com</code></pre></div><h3 id="身份校验"><a href="#身份校验" class="headerlink" title="身份校验"></a>身份校验</h3><p>教学管理中心（xc-ui-pc-teach）是单页面应用，我们在路由变化时校验用户的身份，校验失败将跳转到登录页面。</p><p>校验方法如下：</p><ul><li>如果成功从 sessionStorage 和 <code>cookie</code> 获取当前用户则继续访问</li><li>如果 sessionStorage 中无当前用户，cookie 中有当前用户则请求服务端获取 <code>jwt</code>，如果成功则继续访问。</li><li>以上两种情况都不满足则跳转到登录页面。</li></ul><p>1、在 <code>main.js</code> 中添加路由监控代码，如下</p><div class="hljs"><pre><code class="hljs java">router.beforeEach((to, from, next) =&gt; &#123;    <span class="hljs-keyword">if</span>(openAuthenticate)&#123;        <span class="hljs-comment">// console.log(to)</span>        <span class="hljs-comment">// console.log(from)</span>        <span class="hljs-comment">//***********身份校验***************</span>        let activeUser        let uid        <span class="hljs-keyword">try</span>&#123;            activeUser = utilApi.getActiveUser()            uid = utilApi.getCookie(<span class="hljs-string">"uid"</span>)        &#125;<span class="hljs-keyword">catch</span>(e)&#123;            <span class="hljs-comment">//alert(e)</span>        &#125;         <span class="hljs-keyword">if</span>(activeUser &amp;&amp; uid &amp;&amp; uid == activeUser.uid) &#123;            next();        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(to.path ==<span class="hljs-string">'/login'</span> || to.path ==<span class="hljs-string">'/logout'</span>)&#123;            next();        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(uid)&#123;            <span class="hljs-comment">//请求获取jwt</span>            systemApi.getjwt().then((res)=&gt;&#123;                <span class="hljs-keyword">if</span>(res.success)&#123;                    let jwt = res.jwt;                    let activeUser = utilApi.getUserInfoFromJwt(jwt)                    <span class="hljs-keyword">if</span>(activeUser)&#123;                        utilApi.setUserSession(<span class="hljs-string">"activeUser"</span>,JSON.stringify(activeUser))                    &#125;                     next();                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-comment">//跳转到统一登陆</span>                    window.location = <span class="hljs-string">"http://ucenter.xuecheng.com/#/login?returnUrl="</span>+Base64.encode(window.location)                &#125;            &#125;)        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//跳转到统一登陆</span>            window.location = <span class="hljs-string">"http://ucenter.xuecheng.com/#/login?returnUrl="</span>+Base64.encode(window.location)        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        next();    &#125;&#125;);</code></pre></div><p>配置 xc-ui-pc-teach/config/sysConfig.js 开启认证授权的配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sysConfig = &#123;    openAuthenticate: <span class="hljs-literal">true</span>,    openAuthorize: <span class="hljs-literal">true</span>&#125; <span class="hljs-built_in">module</span>.exports = sysConfig</code></pre></div><p>2、在 base/api/system.js 中添加 <code>getjwt</code> 方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*获取jwt令牌*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getjwt= <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> http.requestQuickGet(<span class="hljs-string">'/openapi/auth/userjwt'</span>)&#125;</code></pre></div><p>3、在utils.js中添加 如下方法</p><div class="hljs"><pre><code class="hljs js">getActiveUser: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> uid = <span class="hljs-keyword">this</span>.getCookie(<span class="hljs-string">"uid"</span>)    <span class="hljs-keyword">if</span>(uid)&#123;        <span class="hljs-keyword">let</span> activeUserStr = <span class="hljs-keyword">this</span>.getUserSession(<span class="hljs-string">"activeUser"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(activeUserStr);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">this</span>.delUserSession(<span class="hljs-string">"activeUser"</span>)    &#125;&#125;,    <span class="hljs-comment">//获取jwt令牌</span>    getJwt : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">let</span> activeUser = <span class="hljs-keyword">this</span>.getActiveUser()        <span class="hljs-keyword">if</span>(activeUser)&#123;            <span class="hljs-keyword">return</span> activeUser.jwt        &#125;    &#125;,        <span class="hljs-comment">//解析jwt令牌，获取用户信息</span>        getUserInfoFromJwt : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jwt</span>) </span>&#123;            <span class="hljs-keyword">if</span>(!jwt)&#123;                <span class="hljs-keyword">return</span> ;            &#125;             <span class="hljs-keyword">var</span> jwtDecodeVal = jwtDecode(jwt);            <span class="hljs-keyword">if</span> (!jwtDecodeVal) &#123;                <span class="hljs-keyword">return</span> ;            &#125;             <span class="hljs-keyword">let</span> activeUser=&#123;&#125;            <span class="hljs-comment">//console.log(jwtDecodeVal)</span>            activeUser.utype = jwtDecodeVal.utype || <span class="hljs-string">''</span>;            activeUser.username = jwtDecodeVal.name || <span class="hljs-string">''</span>;            activeUser.userpic = jwtDecodeVal.userpic || <span class="hljs-string">''</span>;            activeUser.userid = jwtDecodeVal.userid || <span class="hljs-string">''</span>;            activeUser.authorities = jwtDecodeVal.authorities || <span class="hljs-string">''</span>;            activeUser.uid = jwtDecodeVal.jti || <span class="hljs-string">''</span>;            activeUser.jwt = jwt;            <span class="hljs-keyword">return</span> activeUser;        &#125;,</code></pre></div><p>4、测试</p><p>1）启动学习中心前端、教学管理前端、认证服务、用户中心服务、网关、<code>Eureka</code></p><ul><li>进入首页</li><li>点击“教学提供方”，此时由于没有登录自动跳转到登录页面</li></ul><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image16.png" srcset="/img/loading.gif" alt="image-20200603075015366"></p><p>2）输入账号和密码登录</p><p>登录成功，跳转到教学管理页面</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image17.png" srcset="/img/loading.gif" alt="image-20200603075038706"></p><h3 id="携带JWT授权"><a href="#携带JWT授权" class="headerlink" title="携带JWT授权"></a>携带JWT授权</h3><p>1、前端携带JWT请求</p><p>根据需求，在使用 <code>axios</code> 进行 http 请求前向 <code>header</code> 中加入 <code>jwt</code> 令牌</p><p>在 <code>main.js</code> 中添加</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-comment">// 添加请求拦截器</span>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;    <span class="hljs-comment">// 在发送请求向header添加jwt</span>    <span class="hljs-keyword">let</span> jwt = utilApi.getJwt()    <span class="hljs-keyword">if</span>(jwt)&#123;        config.headers[<span class="hljs-string">'Authorization'</span>] = <span class="hljs-string">'Bearer '</span>+jwt    &#125;     <span class="hljs-keyword">return</span> config;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);&#125;);</code></pre></div><p>2、测试 <code>http</code> 请求是否携带jwt</p><p>进入教学管理中心，点击我的课程，观察 <code>request header</code> 中是否有 <code>Authorization</code> 信息</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image18.png" srcset="/img/loading.gif" alt="image-20200603075158919"></p><p>3、测试授权效果</p><p>当访问一个没有权限的方法时是否报错？</p><p>测试方法：</p><p>在课程计划查询方法上添加授权注解，表示当前用户需要拥有course_teachplan_list权限方可正常访问。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('course_teachplan_list')"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">findTeachplanList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"courseId"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.findTeachplanList(courseId);&#125;</code></pre></div><p>进入我的课程，点击课程计划，观察响应结果为 10002错误。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image19.png" srcset="/img/loading.gif" alt="image-20200603075236015"></p><p>4、提示权限不足</p><p>当权限不足首页要给出提示，实现思路是使用axios的拦截，在执行后校验响应结果，如果是<code>10002</code> 代码的错误则提示用户 ```“权限不足”<code>，如果是</code>10001` 代码则强制登录。</p><p>在 <code>main.js</code> 中添加</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 响应拦截</span>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"data="</span>,data)  <span class="hljs-keyword">if</span>(data &amp;&amp; data.data)&#123;    <span class="hljs-keyword">if</span>(data.data.code &amp;&amp; data.data.code ==<span class="hljs-string">'10001'</span>)&#123;      <span class="hljs-comment">//需要登录</span>      <span class="hljs-comment">// router.push(&#123;</span>      <span class="hljs-comment">//   path: '/login',</span>      <span class="hljs-comment">//   query: &#123;returnUrl: Base64.encode(window.location)&#125;</span>      <span class="hljs-comment">// &#125;)</span>      <span class="hljs-built_in">window</span>.location = <span class="hljs-string">"http://ucenter.xuecheng.com/#/login?returnUrl="</span>+ Base64.encode(<span class="hljs-built_in">window</span>.location)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.data.code &amp;&amp; data.data.code ==<span class="hljs-string">'10002'</span>)&#123;      Message.error(<span class="hljs-string">'您没有权限操作该选项'</span>);      <span class="hljs-keyword">return</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.data.code &amp;&amp; data.data.code ==<span class="hljs-string">'10003'</span>)&#123;      Message.error(<span class="hljs-string">'认证被拒绝，请重新登录重试！'</span>);      <span class="hljs-keyword">return</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> data&#125;)</code></pre></div><p>测试：</p><p>执行一个没有权限的操作，提示如下</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image20.png" srcset="/img/loading.gif" alt="image-20200603101409637"></p><h2 id="3-一些问题"><a href="#3-一些问题" class="headerlink" title="3. 一些问题"></a>3. 一些问题</h2><p>用户前端是如何解密JWT令牌的？ 公钥是否会暴露在前端？</p><h1 id="五、细粒度授权"><a href="#五、细粒度授权" class="headerlink" title="五、细粒度授权"></a>五、细粒度授权</h1><h2 id="1-需求分析-3"><a href="#1-需求分析-3" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p><strong>什么是细粒度授权？</strong></p><p>细粒度授权也叫数据范围授权，即不同的用户所拥有的操作权限相同，但是能够操作的数据范围是不一样的。</p><p>一个例子：</p><p>用户 <code>A</code> 和 用户 <code>B</code> 都是教学机构，他们都拥有 “我的课程” 权限，但是两个用户所查询到的数据是不一样的。<br>本项目有哪些细粒度授权？</p><p>比如：</p><p>我的课程，教学机构只允许查询本教学机构下的课程信息。</p><p>我的选课，学生只允许查询自己所选课。</p><p><strong>如何实现细粒度授权？</strong></p><p>细粒度授权涉及到不同的业务逻辑，通常在service层实现，根据不同的用户进行校验，根据不同的参数查询不同的数据或操作不同的数据。</p><h2 id="2-我的课程细粒度授权"><a href="#2-我的课程细粒度授权" class="headerlink" title="2. 我的课程细粒度授权"></a>2. 我的课程细粒度授权</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>1、我的课程查询，细粒度授权过程如下：</p><ul><li>获取当前登录的用户Id</li><li>得到用户所属教育机构的Id</li><li>查询该教学机构下的课程信息</li></ul><p>最终实现了用户只允许查询自己机构的课程信息。</p><p>2、修改课程管理服务 “<code>我的课程</code>” 的功能，根据 公司 <code>Id</code> 查询课程，思路如下：</p><ul><li>修改Dao，支持根据公司Id 查询课程。</li><li>修改Service，将公司Id传入Dao。</li><li>修改Controller，获取当前用户的公司Id，传给Service。</li></ul><p>3、数据模型分析如下：</p><p>1）课程表</p><p>在 <code>xc_course</code> 数据库的 <code>course_base</code> 表中添加 <code>company_id</code> 字段，来表示此课程的归属</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image21.png" srcset="/img/loading.gif" alt="image-20200603102939596"></p><p>2）用户企业表</p><p>在 <code>xc_user</code> 数据库的 <code>xc_company_user</code> 表中记录了用户的归属公司信息</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image22.png" srcset="/img/loading.gif" alt="image-20200603102958164"></p><p>通过 xc_company_user 表可得到 用户 的所属公司 Id。</p><p>如何查询某个用户的课程？</p><p>1、确定用户的 Id</p><p>2、根据用户的 <code>Id</code> 查询用户归属的公司。</p><p>3、根据 <code>公司Id</code> 查询该公司下的课程信息</p><p>一个例子：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">/*确定用户的id：49*/</span><span class="hljs-comment">/*根据用户Id查找所属公司*/</span><span class="hljs-comment">/*根据公司查询所拥有的课程*/</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> xc_course.course_base <span class="hljs-keyword">WHERE</span> company_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> company_id <span class="hljs-keyword">FROM</span> xc_user.xc_company_user <span class="hljs-keyword">WHERE</span> user_id = <span class="hljs-string">'49'</span>)</code></pre></div><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>定义我的课程查询接口如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"查询指定公司下的所有课程"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;CourseInfo&gt; <span class="hljs-title">findCourseListByCompany</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> page,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> size,</span></span><span class="hljs-function"><span class="hljs-params">    CourseListRequest courseListRequest</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre></div><h3 id="DAO-1"><a href="#DAO-1" class="headerlink" title="DAO"></a>DAO</h3><p>在 CourseMapper 下新增一个 <code>findCourseListByCompany</code> 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseMapper</span> </span>&#123;   <span class="hljs-comment">//根据课程id查询课程信息</span>   <span class="hljs-function">CourseBase <span class="hljs-title">findCourseBaseById</span><span class="hljs-params">(String id)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 分页查询课程数据</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> courseListRequest 查询条件</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function">Page&lt;CourseBase&gt; <span class="hljs-title">findCourseList</span><span class="hljs-params">(CourseListRequest courseListRequest)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 分页查询指定公司下的课程数据</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> courseListRequest 查询条件</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function">Page&lt;CourseInfo&gt; <span class="hljs-title">findCourseListByCompany</span><span class="hljs-params">(CourseListRequest courseListRequest)</span></span>; &#125;</code></pre></div><p>修改 <code>CourseMapper.xml</code> 的查询课程列表，添加 <code>companyId</code> 条件。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findCourseListByCompany"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.CourseInfo"</span></span><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.request.CourseListRequest"</span>&gt;</span>    SELECT    course_base.*,    (SELECT pic FROM course_pic WHERE courseid = course_base.id) pic    FROM    course_base    where 1=1    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"companyId!=null and companyId!=''"</span>&gt;</span>        and course_base.company_id = #&#123;companyId&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><p>修改 CourseService 的 <code>findCourseList</code> 方法，添加 <code>companyId</code> 参数，并且传给 dao.</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询指定公司下的课程信息</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findCourseListByCompany</span><span class="hljs-params">(String companyId ,<span class="hljs-keyword">int</span> pageNum, <span class="hljs-keyword">int</span> size, CourseListRequest courseListRequest)</span></span>&#123;    <span class="hljs-keyword">if</span>(pageNum&lt;=<span class="hljs-number">0</span>)&#123;        pageNum = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">0</span>)&#123;        size = <span class="hljs-number">20</span>;    &#125;    PageHelper.startPage(pageNum,size);  <span class="hljs-comment">//设置分页参数</span>     <span class="hljs-comment">//设置公司信息到查询条件内</span>    courseListRequest.setCompanyId(companyId);    Page&lt;CourseInfo&gt; courseList = courseMapper.findCourseListByCompany(courseListRequest);    QueryResult queryResult = <span class="hljs-keyword">new</span> QueryResult();    queryResult.setList(courseList.getResult());    queryResult.setTotal(courseList.getTotal());    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);&#125;</code></pre></div><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>修改 CourseController 的 <code>findCourseList</code>，向 service 传入 <code>companyId</code></p><p>这里先使用静态数据测试使用。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询指定公司下的所有课程</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseListRequest 查询参数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> QueryResponseResult</span><span class="hljs-comment">     */</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/coursebase/company/list/&#123;page&#125;/&#123;size&#125;"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findCourseListByCompany</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    @PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page,</span><span class="hljs-function">    @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size,</span><span class="hljs-function">    CourseListRequest courseListRequest</span><span class="hljs-function">)</span>&#123;    String companyId = <span class="hljs-string">"1"</span>;    <span class="hljs-keyword">return</span> courseService.findCourseListByCompany(companyId, page, size, courseListRequest);&#125;</code></pre></div><h3 id="课程查询前端修改"><a href="#课程查询前端修改" class="headerlink" title="课程查询前端修改"></a>课程查询前端修改</h3><p>修改 <code>xc-ui-pc-teach/src/module/course/api/course.js</code> 中查询课程的API 与我们前面构建的 controller 对应</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//我的课程列表</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> findCourseList = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;<span class="hljs-comment">//使用工具类将json对象转成key/value</span>  <span class="hljs-keyword">let</span> queries = querystring.stringify(params)  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">"/course/coursebase/company/list/"</span>+page+<span class="hljs-string">"/"</span>+size+<span class="hljs-string">"?"</span>+queries)&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>进入我的课程，查看数据是否正确。</p><p>由于我们在 <code>controller</code> 中暂时将 <code>company</code> 的固定的写为了1，所以预期的结果应该是查询到 company 为1的所有课程，测试结果如下。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image23.png" srcset="/img/loading.gif" alt="image-20200603141305638"></p><p>测试结果如下，得到了预期的结果</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image24.png" srcset="/img/loading.gif" alt="image-20200603141347386"></p><h2 id="3-获取当前信息"><a href="#3-获取当前信息" class="headerlink" title="3. 获取当前信息"></a>3. 获取当前信息</h2><p>要想实现只查询自己的课程信息，则需要获取当前用户所属的企业id。</p><p>1、认证服务在用户认证通过将用户所属公司id等信息存储到jwt令牌中。</p><p>2、用户请求到达资源服务后，资源服务需要取出header中的jwt令牌，并解析出用户信息。</p><h3 id="JWT令牌包括企业Id"><a href="#JWT令牌包括企业Id" class="headerlink" title="JWT令牌包括企业Id"></a>JWT令牌包括企业Id</h3><p>资源服务在授权时需要用到用户所属企业 <code>ID</code>，需要实现认证服务生成的JWT令牌中包括用户所属公司 <code>id</code> 信息。</p><p>查看认证服务 <code>UserDetailServiceImpl</code> 代码如下：</p><div class="hljs"><pre><code class="hljs java">......<span class="hljs-comment">//用户id</span>userDetails.setId(userext.getId());<span class="hljs-comment">//用户名称</span>userDetails.setName(userext.getName());<span class="hljs-comment">//用户头像</span>userDetails.setUserpic(userext.getUserpic());<span class="hljs-comment">//用户类型</span>userDetails.setUtype(userext.getUtype());<span class="hljs-comment">//用户所属企业id</span>userDetails.setCompanyId(userext.getCompanyId());<span class="hljs-keyword">return</span> userDetails;......</code></pre></div><p>通过上边代码的分析得知，认证服务调用远程调用 ucenter 服务的 <code>getUserext</code> 接口获取用户信息，并将 <code>userext</code> 中的信息存储到jwt令牌中，所以在在 getUserext 接口中返回的 <code>userext</code> 对象中需要包括了 <code>companyId</code> 公司ID等信息 。</p><p>getUserExt 的代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据用户名获取用户权限的实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserExt</span><span class="hljs-params">(String username)</span> </span>&#123;    <span class="hljs-comment">//查询用户信息</span>    XcUser xcUser = <span class="hljs-keyword">this</span>.findXcUserByUsername(username);    <span class="hljs-keyword">if</span>(xcUser ==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;     XcUserExt xcUserExt = <span class="hljs-keyword">new</span> XcUserExt();    BeanUtils.copyProperties(xcUser,xcUserExt);     <span class="hljs-comment">//根据用户id查询用所属公司</span>    String xcUserId = xcUser.getId();    XcCompanyUser xcCompanyUser = xcCompanyUserRepository.findByUserId(xcUserId);    <span class="hljs-keyword">if</span>(xcCompanyUser!=<span class="hljs-keyword">null</span>)&#123;        String companyId = xcCompanyUser.getCompanyId();        xcUserExt.setCompanyId(companyId);    &#125;     <span class="hljs-comment">//获取用户的所有权限</span>    List&lt;XcMenu&gt; xcMenus = xcMenuMapper.selectPermissionByUserId(xcUserId);    xcUserExt.setPermissions(xcMenus);     <span class="hljs-comment">//返回XcUserExt对象</span>    <span class="hljs-keyword">return</span> xcUserExt;&#125;</code></pre></div><p><code>getUserExt</code> 是在用户进行认证时被调用的，由 <code>ucenter-auth</code> 服务向 <code>ucenter</code> 服务调用该接口，获取用户的信息，然后将得到的这些信息 打包为 <code>UserJwt</code> 对象交由 Spring Security 进行校验，校验通过后会将该JWT令牌到认证服务中，校验 Spring Security 返回的 <code>JWT</code>令牌完整性后写入到 redis。</p><h3 id="解析令牌中的信息"><a href="#解析令牌中的信息" class="headerlink" title="解析令牌中的信息"></a>解析令牌中的信息</h3><h4 id="1、JWT解析工具类"><a href="#1、JWT解析工具类" class="headerlink" title="1、JWT解析工具类"></a>1、JWT解析工具类</h4><p>1、在 <code>Oauth2Util</code> 工具类中，从 header 中取出JWT令牌，并解析 <code>JWT</code> 令牌的内容。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Oauth2Util</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String,String&gt; <span class="hljs-title">getJwtClaimsFromHeader</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;                <span class="hljs-comment">//取出头信息</span>        String authorization = request.getHeader(<span class="hljs-string">"Authorization"</span>);        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(authorization) || authorization.indexOf(<span class="hljs-string">"Bearer"</span>) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;                <span class="hljs-comment">//从Bearer后边开始取出token</span>        String token = authorization.substring(<span class="hljs-number">7</span>);        Map&lt;String,String&gt; map = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//解析jwt</span>            Jwt decode = JwtHelper.decode(token);            <span class="hljs-comment">//得到 jwt中的用户信息</span>            String claims = decode.getClaims();            <span class="hljs-comment">//将jwt转为Map</span>            map = JSON.parseObject(claims, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;         <span class="hljs-keyword">return</span> map;    &#125;&#125;</code></pre></div><p>2、在 <code>XcOauth2Util</code> 工具类中，将解析的 <code>JWT</code> 内容封装成 <code>UserJwt</code> 对象返回。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XcOauth2Util</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> UserJwt <span class="hljs-title">getUserJwtFromHeader</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        Map&lt;String, String&gt; jwtClaims = Oauth2Util.getJwtClaimsFromHeader(request);        <span class="hljs-keyword">if</span>(jwtClaims == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(jwtClaims.get(<span class="hljs-string">"id"</span>)))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         UserJwt userJwt = <span class="hljs-keyword">new</span> UserJwt();        userJwt.setId(jwtClaims.get(<span class="hljs-string">"id"</span>));        userJwt.setName(jwtClaims.get(<span class="hljs-string">"name"</span>));        userJwt.setCompanyId(jwtClaims.get(<span class="hljs-string">"companyId"</span>));        userJwt.setUtype(jwtClaims.get(<span class="hljs-string">"utype"</span>));        userJwt.setUserpic(jwtClaims.get(<span class="hljs-string">"userpic"</span>));        <span class="hljs-keyword">return</span> userJwt;    &#125;     <span class="hljs-meta">@Data</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserJwt</span></span>&#123;        <span class="hljs-keyword">private</span> String id;        <span class="hljs-keyword">private</span> String name;        <span class="hljs-keyword">private</span> String userpic;        <span class="hljs-keyword">private</span> String utype;        <span class="hljs-keyword">private</span> String companyId;    &#125;&#125;</code></pre></div><h4 id="2、获取当前用户"><a href="#2、获取当前用户" class="headerlink" title="2、获取当前用户"></a>2、获取当前用户</h4><p>修改课程管理的 CourseController 类，将 <code>companyId</code> 的静态数据改为动态获取：</p><p>配置 <code>CourseController</code> 继承 <code>BaseController</code> ，这样我们就可以拿到一个用户请求时的 request 对象</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseContorller</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;...&#125;</code></pre></div><p>在 <code>findCourseListByCompany</code> 中调用前面我们定义的工具类，从用户的 <code>header</code> 信息中取出 JWT 令牌并且解析出用户的信息，拿到用户所属的公司 <code>ID</code>，实现细粒度的课程信息获取。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询指定公司下的所有课程</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseListRequest 查询参数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> QueryResponseResult</span><span class="hljs-comment">     */</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/coursebase/company/list/&#123;page&#125;/&#123;size&#125;"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findCourseListByCompany</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    @PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page,</span><span class="hljs-function">    @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size,</span><span class="hljs-function">    CourseListRequest courseListRequest</span><span class="hljs-function">)</span>&#123;    <span class="hljs-comment">//调用工具类取出用户信息</span>    XcOauth2Util xcOauth2Util = <span class="hljs-keyword">new</span> XcOauth2Util();    <span class="hljs-comment">//从用户header中附带的jwt令牌取出用户信息</span>    XcOauth2Util.UserJwt userJwt = xcOauth2Util.getUserJwtFromHeader(request);    <span class="hljs-comment">//从用户信息获取该用户所属的公司id，根据该公司id查询该公司下的所有课程</span>    String companyId = userJwt.getCompanyId();    <span class="hljs-keyword">return</span> courseService.findCourseListByCompany(companyId, page, size, courseListRequest);&#125;</code></pre></div><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>使用不同的用户登录系统，测试细粒度权限控制效果。</p><p>预期结果：每个用户只查询自己所拥有的课程。</p><p>公司1的用户</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image25.png" srcset="/img/loading.gif" alt="image-20200603150544501"></p><p>公司2的用户</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image26.png" srcset="/img/loading.gif" alt="image-20200603150423751"></p><h1 id="六、微服务间认证"><a href="#六、微服务间认证" class="headerlink" title="六、微服务间认证"></a>六、微服务间认证</h1><h2 id="1-需求分析-4"><a href="#1-需求分析-4" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>前边章节已经实现了用户携带身份令牌（JTI） 和 <code>JWT</code>（access_token） 令牌访问微服务，微服务获取 <code>jwt</code> 并完成授权。当微服务访问微服务，此时如果没有携带 <code>JWT</code> 则微服务会在授权时报错。</p><p>测试课程预览：</p><p>1、将课程管理服务和CMS全部添加授权配置</p><p>2、用户登录教学管理前端，进入课程发布界面，点击课程发布，观察课程管理服务端报错如下：</p><div class="hljs"><pre><code class="hljs json">feign.FeignException: status 401 reading CmsPageClient#save(CmsPage); content:&#123;<span class="hljs-attr">"error"</span>:<span class="hljs-string">"unauthorized"</span>,<span class="hljs-attr">"error_description"</span>:<span class="hljs-string">"Full authentication is required to access thisresource"</span>&#125;</code></pre></div><p>分析原因：</p><p>由于课程管理访问 <code>CMS</code> 时没有携带 <code>JWT</code> 令牌导致。</p><p>解决方案：</p><p>微服务之间进行调用时需携带 <code>JWT</code>。</p><h2 id="2-Feign-拦截器"><a href="#2-Feign-拦截器" class="headerlink" title="2. Feign 拦截器"></a>2. Feign 拦截器</h2><p>微服务之间使用 <code>feign</code> 进行远程调用，采用 <code>feign</code> 拦截器实现远程调用携带 JWT。</p><p>在 common 工程添加依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring‐cloud‐starter‐openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="定于Feign拦截器"><a href="#定于Feign拦截器" class="headerlink" title="定于Feign拦截器"></a>定于Feign拦截器</h3><p>在 <code>Common</code> 工程定义拦截器如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.interceptor;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignClientInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//使用RequestContextHolder工具获取request相关变量</span>            ServletRequestAttributes attributes = (ServletRequestAttributes)                RequestContextHolder.getRequestAttributes();            <span class="hljs-keyword">if</span>(attributes!=<span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//取出request</span>                HttpServletRequest request = attributes.getRequest();                Enumeration&lt;String&gt; headerNames = request.getHeaderNames();                <span class="hljs-keyword">if</span> (headerNames != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">while</span> (headerNames.hasMoreElements()) &#123;                        String name = headerNames.nextElement();                        String values = request.getHeader(name);                        <span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">"authorization"</span>))&#123;                            <span class="hljs-comment">//System.out.println("name="+name+"values="+values);</span>                            requestTemplate.header(name, values);                        &#125;                    &#125;                &#125;            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTace();        &#125;    &#125;&#125;</code></pre></div><h3 id="使用Feign拦截器"><a href="#使用Feign拦截器" class="headerlink" title="使用Feign拦截器"></a>使用Feign拦截器</h3><p>本例子中课程管理调用 <code>cms</code> 需要携带 <code>jwt</code>，所以需要在课程管理中定义 <code>Feign</code> 拦截器 <code>bean</code>，在启动类中定义 <code>bean</code> 如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> FeignClientInterceptor <span class="hljs-title">feignClientInterceptor</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignClientInterceptor();&#125;</code></pre></div><h3 id="使用restTemplate访问其他服务接口被拦截的解决方案"><a href="#使用restTemplate访问其他服务接口被拦截的解决方案" class="headerlink" title="使用restTemplate访问其他服务接口被拦截的解决方案"></a>使用restTemplate访问其他服务接口被拦截的解决方案</h3><p>在发布课程时，cms服务使用 restTeamlate 向数据模型URL发送请求获取数据，该操作涉及到调用课程管理服务的接口，由于课程管理服务开启了接口认证，所有没附带 JWT 令牌的请求都会被拒绝，如下图所示</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image27.png" srcset="/img/loading.gif" alt="image-20200603171728929"></p><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p>在课程管理服务中放行该URL的认证拦截，通常该接口是可以不需要认证的。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image28.png" srcset="/img/loading.gif" alt="image-20200603172432245"></p><p>在课程管理服务的 <code>ResourceServerConfig</code> 中配置 <code>configure</code> 方法，放行 <code>/course/preview/model</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;oauth2.urlMatchers&#125;"</span>)String urlMatchers; <span class="hljs-comment">//Http安全配置，对每个到达系统的http请求链接进行校验</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span>(urlMatchers.equals(<span class="hljs-string">""</span>))&#123;        <span class="hljs-comment">//如果urlMatchers未指定,则所有url都需要授权后才能被访问</span>        http.authorizeRequests().anyRequest().authenticated();    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//放行 urlMatchers 中指定的url条目, 未指定的url仍需授权后才能访问</span>        <span class="hljs-keyword">if</span>(urlMatchers != <span class="hljs-keyword">null</span>)&#123;            String[] split = urlMatchers.split(<span class="hljs-string">","</span>);            http.authorizeRequests()                <span class="hljs-comment">//下边的路径放行</span>                .antMatchers(split).permitAll()                .anyRequest().authenticated();        &#125;    &#125;&#125;</code></pre></div><p>我这里需要放行的URL是从 appliaction.yml 中将 <code>oauth2.urlMatchers</code> 注入到变量 <code>urlMatchers</code> 内，内容如下</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">oauth2:</span>  <span class="hljs-attr">urlMatchers:</span> <span class="hljs-string">/v2/api-docs,/swagger-resources/configuration/ui,/swagger-resources,/swagger-resources/configuration/security,/swagger-ui.html,/webjars/**,/course/coursepic/get/*</span></code></pre></div><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p>获取当前请求的 <code>request</code> 对象，从该对象中取出当前请求中 <code>header</code> 信息里面包含的 <code>authorization</code> 字段，该字段内带有了我们认证需要的 <code>JWT</code> 令牌信息。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//从dataUrl中获取页面模型数据</span><span class="hljs-function"><span class="hljs-keyword">private</span> Map <span class="hljs-title">getModelByPageId</span><span class="hljs-params">(String pageId)</span></span>&#123;    <span class="hljs-comment">//查询页面信息</span>    CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);    CmsPage cmsPage = cmsPageResult.getCmsPage();    <span class="hljs-comment">//页面不存在</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);    &#125;    <span class="hljs-comment">//取出dataUrl</span>    String dataUrl = cmsPage.getDataUrl();    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(dataUrl))&#123;        ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_DATAURL_IS_NULL);    &#125;        <span class="hljs-comment">//通过获取当前请求的request对象来取出jwt认证信息,并且传递到下一个请求中</span>    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request = attributes.getRequest();    String jwt = request.getHeader(<span class="hljs-string">"authorization"</span>);    <span class="hljs-comment">//使用LinkedMultiValueMap储存多个header信息</span>    LinkedMultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();    headers.add(<span class="hljs-string">"authorization"</span>,jwt);    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);        <span class="hljs-comment">//发送请求获取模型数据</span>    ResponseEntity&lt;Map&gt; forEntity = restTemplate.exchange(dataUrl, HttpMethod.GET,httpEntity,Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    Map body = forEntity.getBody();    <span class="hljs-keyword">return</span> body;&#125;</code></pre></div><h4 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h4><p>将 <code>CMS</code> 服务中调用 <code>课程管理服务</code> 的数据模型接口更改为使用 <code>Feign</code> 来进行远程调用，再结合前面配置的 <code>Feign</code> 拦截器实现 Header 信息的向下传递。</p><p>由于数据模型接口需要的参数是课程ID，但CmsPage对象中没有明确的给出该页面对应的课程ID，但是我们可以看到，页面的名称其实就是以课程ID所命名的，如下图</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image29.png" srcset="/img/loading.gif" alt="image-20200603182403327"></p><p>所以我们可以从 <code>pageName</code> 中取出课程ID进行远程调用，代码如下</p><div class="hljs"><pre><code class="hljs java">String[] pageNameSplit = cmsPageName.split(<span class="hljs-string">"\\."</span>);String courseId = pageNameSplit[<span class="hljs-number">0</span>];</code></pre></div><blockquote><p>这里要注意如果以 <code>.</code> 对字符串进行分割，需要在点号前面加两个斜杠，如 <code>\\.</code></p></blockquote><p>在之前的代码中，使用 <code>RestTemplate</code> 访问的数据模型接口返回的是一个 <code>map</code> 类型的数据，而如果采用远程调用的方式，拿到的是一个 <code>CourseView</code> 对象，这里我们可以使用 <code>JSONObject.toJSONString</code> 将对象转为字符串，再使用 <code>parseObject</code> 将JSON形式的字符串转换为 <code>Map</code> 对象，代码如下</p><div class="hljs"><pre><code class="hljs java">JSONObject.parseObject(JSONObject.toJSONString(courseView), Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre></div><p>修改后的全部代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//从dataUrl中获取页面模型数据</span><span class="hljs-function"><span class="hljs-keyword">private</span> Map <span class="hljs-title">getModelByPageId</span><span class="hljs-params">(String pageId)</span></span>&#123;    <span class="hljs-comment">//查询页面信息</span>    CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);    CmsPage cmsPage = cmsPageResult.getCmsPage();     <span class="hljs-comment">//页面不存在</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);    &#125;    String cmsPageName = cmsPage.getPageName();    <span class="hljs-keyword">if</span>(cmsPageName == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(CmsCode.CMS_PAGE_NAME_NOT_EXISTS);    &#125;    String[] pageNameSplit = cmsPageName.split(<span class="hljs-string">"\\."</span>);    String courseId = pageNameSplit[<span class="hljs-number">0</span>];    CourseView courseView = courseManageClient.courseView(courseId);    Map body = JSONObject.parseObject(JSONObject.toJSONString(courseView), Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//        ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(dataUrl,Map.class);</span>    <span class="hljs-comment">//        Map body = forEntity.getBody();</span>    <span class="hljs-comment">//        courseManageClient.courseView(cmsPage.)</span>    <span class="hljs-keyword">return</span> body;&#125;</code></pre></div><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>执行课程发布，提示发布成功。</p><p><img src="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/image30.png" srcset="/img/loading.gif" alt="image-20200603191048332"></p><h1 id="七、提出一些问题"><a href="#七、提出一些问题" class="headerlink" title="七、提出一些问题"></a>七、提出一些问题</h1><p>1、JWT时间目前是由 <code>redis</code> 来进行控制，那么 <code>jwt</code>令牌的实际过期时间是多久？ 如何获取或者设置？</p><p>2、生成JWT的公钥和私钥都有哪些作用？</p><p>公钥：用于校验JWT令牌是否完整，以及解密JWT令牌中的用户信息</p><p>私钥：生成加密后的JWT令牌</p><h1 id="八、待完善的一些功能"><a href="#八、待完善的一些功能" class="headerlink" title="八、待完善的一些功能"></a>八、待完善的一些功能</h1><ul><li>为 swagger-ui 配置认证授权，使接口文档暴露在外部时需要进行登录认证，提高安全性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Feign</tag>
      
      <tag>Spring Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day17：基于Zuul网关实现路由转发、过滤器</title>
    <link href="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/"/>
    <url>/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day17</code> 的内容</p><ul><li>构建用户中心服务，并基于 <code>Spring Security Oauth2</code> 以及 <code>jwt</code> 令牌实现用户认证的完整流程。</li><li>完成门户网站的用户登入、登出接口、前端页面的开发以及调试。</li><li>基于 Zuul 构建网关服务，以及使用 Zuul 网关实现基本的路由转发、过滤器、身份校验等功能</li></ul><h1 id="一、用户认证"><a href="#一、用户认证" class="headerlink" title="一、用户认证"></a>一、用户认证</h1><h2 id="1-用户认证流程分析"><a href="#1-用户认证流程分析" class="headerlink" title="1. 用户认证流程分析"></a>1. 用户认证流程分析</h2><p>用户认证流程如下：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image1.png" srcset="/img/loading.gif" alt="image-20200527083511311"></p><p>业务流程说明如下：</p><p><strong>1、客户端请求认证服务进行认证。</strong></p><p><strong>2、认证服务认证通过向浏览器 cookie 写入 token (身份令牌)</strong></p><p>认证服务请求用户中心查询用户信息。</p><p>认证服务请求 <code>Spring Security</code> 申请令牌。</p><p>认证服务将 <code>token</code> (身份令牌)和 <code>jwt</code> 令牌存储至 <code>redis</code> 中。</p><p>认证服务向cookie写入 <code>token</code> (身份令牌)。</p><p>3<strong>、前端携带</strong>token<strong>请求认证服务获取</strong>jwt令牌</p><p>前端获取到 <code>jwt</code> 令牌并存储在 <code>sessionStorage</code>。</p><p>前端从jwt令牌中解析中用户信息并显示在页面。</p><blockquote><p>前端如何解析？还是认证服务返回明文数据</p></blockquote><p>4<strong>、前端携带</strong>cookie<strong>中的</strong>token<strong>身份令牌及</strong>jwt<strong>令牌访问资源服务</strong></p><p>前端请求资源服务需要携带两个token，一个是cookie中的身份令牌，一个是http header中的jwt令牌</p><p>前端请求资源服务前在http header上添加jwt请求资源</p><p><strong>5、网关校验 token的合法性</strong></p><p>用户请求必须携带 <code>token</code> 身份令牌和jwt令牌</p><p>网关校验redis中 <code>token</code> 是否合法，已过期则要求用户重新登录</p><p><strong>6、资源服务校验jwt的合法性并完成授权</strong></p><p>资源服务校验jwt令牌，完成授权，拥有权限的方法正常执行，没有权限的方法将拒绝访问。</p><h2 id="2-认证服务查询数据库"><a href="#2-认证服务查询数据库" class="headerlink" title="2. 认证服务查询数据库"></a>2. 认证服务查询数据库</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>认证服务根据数据库中的用户信息去校验用户的身份，即校验账号和密码是否匹配。</li><li>认证服务不直接连接数据库，而是通过用户中心服务去查询用户中心数据库。</li></ul><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image2.png" srcset="/img/loading.gif" alt="image-20200527083511311"></p><p>完整的流程图如下：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image3.png" srcset="/img/loading.gif" alt="image-20200527084051627"></p><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>1、创建用户中心数据库</p><p>用户中心负责用户管理，包括：用户信息管理、角色管理、权限管理等。</p><p>创建 <code>xc_user</code> 数据库（MySQL）</p><p>导入 <code>xc_user.sql</code> (已导入不用重复导入)</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image4.png" srcset="/img/loading.gif" alt="image-20200527084200019"></p><p>2、创建用户中心工程</p><p>导入“资料”-》xc-service-ucenter.zip</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image5.png" srcset="/img/loading.gif" alt="image-20200527084302385"></p><p>完成用户中心根据账号查询用户信息接口功能。</p><h3 id="查询用户接口开发"><a href="#查询用户接口开发" class="headerlink" title="查询用户接口开发"></a>查询用户接口开发</h3><h4 id="1、Api接口"><a href="#1、Api接口" class="headerlink" title="1、Api接口"></a>1、Api接口</h4><p>用户中心对外提供如下接口</p><p>1）响应数据类型</p><p>此接口将来被用来查询用户信息及用户权限信息，所以这里定义扩展类型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.ucenter.response.ext;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.ucenter.XcMenu;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.ucenter.XcUser;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString; <span class="hljs-keyword">import</span> java.util.List; <span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XcUserExt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XcUser</span> </span>&#123;    <span class="hljs-comment">//权限信息</span>    <span class="hljs-keyword">private</span> List&lt;XcMenu&gt; permissions;    <span class="hljs-comment">//企业信息</span>    <span class="hljs-keyword">private</span> String companyId;&#125;</code></pre></div><p>2）根据账号查询用户信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.ucenter; <span class="hljs-keyword">import</span> com.xuecheng.framework.domain.ucenter.response.ext.XcUserExt;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation; <span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"用户中心"</span>,description = <span class="hljs-string">"用户中心管理"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UcenterControllerApi</span> </span>&#123;        <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"获取用户信息"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserext</span><span class="hljs-params">(String username)</span></span>;&#125;</code></pre></div><h4 id="2、DAO"><a href="#2、DAO" class="headerlink" title="2、DAO"></a>2、DAO</h4><p>添加 <code>XcUser</code>、<code>XcCompantUser</code> 两个表的Dao ，对于一些简单的sql操作，我们使用 Spring Data JPA 实现</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcUserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcUser</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-function">XcUser <span class="hljs-title">findXcUserByUsername</span><span class="hljs-params">(String username)</span></span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcCompanyUserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcCompanyUser</span>,<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//根据用户id查询所属企业id</span>    <span class="hljs-function">XcCompanyUser <span class="hljs-title">findByUserId</span><span class="hljs-params">(String userId)</span></span>;&#125;</code></pre></div><h4 id="3、Service"><a href="#3、Service" class="headerlink" title="3、Service"></a>3、Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;     <span class="hljs-comment">//对xc_user表的相关操作</span>    <span class="hljs-meta">@Autowired</span>    XcUserRepository xcUserRepository;     <span class="hljs-comment">//对xc_company_user表的相关操作</span>    <span class="hljs-meta">@Autowired</span>    XcCompanyUserRepository xcCompanyUserRepository;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据用户名查询用户信息的实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> XcUser <span class="hljs-title">findXcUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">return</span> xcUserRepository.findXcUserByUsername(username);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据用户名获取用户权限的实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserExt</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-comment">//查询用户信息</span>        XcUser xcUser = <span class="hljs-keyword">this</span>.findXcUserByUsername(username);        <span class="hljs-keyword">if</span>(xcUser ==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         XcUserExt xcUserExt = <span class="hljs-keyword">new</span> XcUserExt();        BeanUtils.copyProperties(xcUser,xcUserExt);         <span class="hljs-comment">//根据用户id查询用所属公司</span>        String xcUserId = xcUser.getId();        XcCompanyUser xcCompanyUser = xcCompanyUserRepository.findByUserId(xcUserId);        <span class="hljs-keyword">if</span>(xcCompanyUser!=<span class="hljs-keyword">null</span>)&#123;            String companyId = xcCompanyUser.getCompanyId();            xcUserExt.setCompanyId(companyId);        &#125;         <span class="hljs-comment">//返回XcUserExt对象</span>        <span class="hljs-keyword">return</span> xcUserExt;    &#125;&#125;</code></pre></div><h4 id="4、Controller"><a href="#4、Controller" class="headerlink" title="4、Controller"></a>4、Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/ucenter"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UcenterController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UcenterControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getuserext"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserext</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"username"</span>)</span> String username) </span>&#123;        XcUserExt xcUser = userService.getUserExt(username);        <span class="hljs-keyword">return</span> xcUser;    &#125;&#125;</code></pre></div><h4 id="5、可能出现的一些问题"><a href="#5、可能出现的一些问题" class="headerlink" title="5、可能出现的一些问题"></a>5、可能出现的一些问题</h4><p>如果 <code>ucenter</code> 服务出现接口需要认证才能访问的情况，考虑可能是继承了 <code>model</code> 工程的 <code>oauth2</code> 依赖导致开启了认证拦截。</p><p>解决方案：在 model 工程下的 <code>oauth2</code> 依赖加上 <code>&lt;optional&gt;true&lt;/optional&gt;</code> 标签，该标签可以防止本工程下的依赖包传递到其他工程。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><p>使用 <code>Swagger-ui</code> 或 <code>postman</code> 测试用户信息查询接口</p><p>GET <a href="http://localhost:40300/ucenter/getuserext" target="_blank" rel="noopener">http://localhost:40300/ucenter/getuserext</a></p><p>参数为 username</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image6.png" srcset="/img/loading.gif" alt="img"></p><h4 id="7、思考一些问题"><a href="#7、思考一些问题" class="headerlink" title="7、思考一些问题"></a>7、思考一些问题</h4><p>在上述测试过程中，通过 GET 请求调用 <a href="http://localhost:40300/ucenter/getuserext" target="_blank" rel="noopener">http://localhost:40300/ucenter/getuserext</a> 接口可以获取到一个用户的详细信息，但是考虑到用户数据的安全问题，这个接口不应该直接暴露给普通的用户，只适合服务间的调用，并需要经过授权的服务才可以调用。</p><p>答：后期配置微服务间认证后可以解决上述的问题。</p><h3 id="调用查询用户的接口"><a href="#调用查询用户的接口" class="headerlink" title="调用查询用户的接口"></a>调用查询用户的接口</h3><h4 id="1、创建-client"><a href="#1、创建-client" class="headerlink" title="1、创建 client"></a>1、创建 client</h4><p>认证服务需要远程调用用户中心服务查询用户，在 <code>认证服务</code> 中创建Feign客户端</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = XcServiceList.XC_SERVICE_UCENTER)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/ucenter/getuserext"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> XcUserExt <span class="hljs-title">getUserext</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"username"</span>)</span> String username)</span><span class="hljs-function">&#125;</span></code></pre></div><h4 id="2、UserDetailsService"><a href="#2、UserDetailsService" class="headerlink" title="2、UserDetailsService"></a>2、UserDetailsService</h4><p>认证服务调用 <code>spring security</code> 接口申请令牌，<code>spring security</code> 接口会调用 <code>UserDetailsServiceImpl</code> 从数据库查询用户，如果查询不到则返回 <code>NULL</code>，表示不存在；在<code>UserDetailsServiceImpl</code> 中将正确的密码返回， <code>spring security</code> 会自动去比对输入密码的正确性。</p><p>修改 UserDetailsServiceImpl 的 <code>loadUserByUsername</code> 方法，调用 Ucenter服务的查询用户接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;     <span class="hljs-meta">@Autowired</span>    ClientDetailsService clientDetailsService;     <span class="hljs-comment">//用户中心服务客户端</span>    <span class="hljs-meta">@Autowired</span>    UserClient userClient;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        <span class="hljs-comment">//取出身份，如果身份为空说明没有认证</span>        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();        <span class="hljs-comment">//没有认证统一采用httpbasic认证，httpbasic中存储了client_id和client_secret</span>        <span class="hljs-comment">//开始认证client_id和client_secret</span>        <span class="hljs-keyword">if</span>(authentication==<span class="hljs-keyword">null</span>)&#123;            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(username);            <span class="hljs-keyword">if</span>(clientDetails!=<span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//密码</span>                String clientSecret = clientDetails.getClientSecret();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username,clientSecret,AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">""</span>));            &#125;        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(username)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-comment">//请求ucenter查询用户</span>        XcUserExt userext = userClient.getUserext(username);        <span class="hljs-keyword">if</span>(userext == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">//如果获取到的用信息为空,则返回null,spring security则会抛出异常</span>         <span class="hljs-comment">//设置用户的认证和权限信息</span>        userext.setUsername(<span class="hljs-string">"itcast"</span>);        userext.setPassword(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>));        userext.setPermissions(<span class="hljs-keyword">new</span> ArrayList&lt;XcMenu&gt;());  <span class="hljs-comment">//这里授权部分还没完成,所以先填写静态的</span>        <span class="hljs-keyword">if</span>(userext == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-comment">//从数据库查询用户正确的密码，Spring Security会去比对输入密码的正确性</span>        String password = userext.getPassword();        String user_permission_string = <span class="hljs-string">""</span>;         <span class="hljs-comment">//设置用户信息到userDetails对象</span>        UserJwt userDetails = <span class="hljs-keyword">new</span> UserJwt(                username,                password,                AuthorityUtils.commaSeparatedStringToAuthorityList(user_permission_string));        <span class="hljs-comment">//用户id</span>        userDetails.setId(userext.getId());        <span class="hljs-comment">//用户名称</span>        userDetails.setName(userext.getName());        <span class="hljs-comment">//用户头像</span>        userDetails.setUserpic(userext.getUserpic());        <span class="hljs-comment">//用户所属企业id</span>        userDetails.setCompanyId(userext.getCompanyId());         <span class="hljs-comment">//返回用信息给到Spring Security进行处理</span>        <span class="hljs-keyword">return</span> userDetails;    &#125;&#125;</code></pre></div><h4 id="3、BCryptPaswordEncoder"><a href="#3、BCryptPaswordEncoder" class="headerlink" title="3、BCryptPaswordEncoder"></a>3、BCryptPaswordEncoder</h4><p>早期使用md5对密码进行编码，每次算出的md5值都一样，这样非常不安全，Spring Security推荐使用<br>BCryptPasswordEncoder对密码加随机盐，每次的Hash值都不一样，安全性高 。</p><p>1）BCryptPasswordEncoder测试程序如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPasswrodEncoder</span><span class="hljs-params">()</span></span>&#123;    String password = <span class="hljs-string">"111111"</span>;    PasswordEncoder passwordEncoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;        <span class="hljs-comment">//每个计算出的Hash值都不一样</span>        String hashPass = passwordEncoder.encode(password);        System.out.println(hashPass);        <span class="hljs-comment">//虽然每次计算的密码Hash值不一样但是校验是通过的</span>        <span class="hljs-keyword">boolean</span> f = passwordEncoder.matches(password, hashPass);        System.out.println(f);    &#125;&#125;</code></pre></div><p>2）在 <code>AuthorizationServerConfig</code> 配置类中配置 BCryptPasswordEncoder</p><blockquote><p>原教程中已经在 WebSecurityConfig 中进行了配置，这个在哪里配置都无所谓，本质上都是向spring注入一个bean</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//采用bcrypt对密码进行Hash</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();&#125;</code></pre></div><p>3）测试</p><p>请求 <a href="http://localhost:40400/auth/userlogin%EF%BC%8C%E8%BE%93%E5%85%A5%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">http://localhost:40400/auth/userlogin，输入正常的账号和密码进行测试</a></p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image7.png" srcset="/img/loading.gif" alt="image-20200529102941282"></p><h4 id="4、解析申请令牌错误信息"><a href="#4、解析申请令牌错误信息" class="headerlink" title="4、解析申请令牌错误信息"></a>4、解析申请令牌错误信息</h4><p>当账号输入错误应该返回用户不存在的信息，当密码错误要返回用户名或密码错误信息，业务流程图如下：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image8.png" srcset="/img/loading.gif" alt="image-20200527103015749"></p><p>修改申请令牌的程序解析返回的错误:</p><p>由于 <code>restTemplate</code> 收到400或401的错误会抛出异常，而 <code>spring security</code> 针对账号不存在及密码错误会返回 <code>400</code> 及 <code>401</code>，所以在代码中控制针对 <code>400</code> 或 <code>401</code> 的响应不要抛出异常。</p><p>修改 <code>AuthServiceImpl</code> 的 appleToken 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//向Oauth2服务申请令牌</span><span class="hljs-function"><span class="hljs-keyword">private</span> AuthToken <span class="hljs-title">appleToken</span><span class="hljs-params">(String username, String password, String clientId, String clientSecret)</span></span>&#123;    <span class="hljs-comment">//采用客户端负载均衡的方式从eureka获取认证服务的ip和端口</span>    ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">"XC-SERVICE-UCENTER-AUTH"</span>);    URI uri = serviceInstance.getUri();    String authUrl = uri + <span class="hljs-string">"/auth/oauth/token"</span>;     <span class="hljs-comment">//使用LinkedMultiValueMap储存多个header信息</span>    LinkedMultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();    <span class="hljs-comment">//设置basic认证信息</span>    String basicAuth = <span class="hljs-keyword">this</span>.getHttpBasic(clientId, clientSecret);    headers.add(<span class="hljs-string">"Authorization"</span>,basicAuth);     <span class="hljs-comment">//设置请求中的body信息</span>    LinkedMultiValueMap&lt;String, String&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();    body.add(<span class="hljs-string">"grant_type"</span>,<span class="hljs-string">"password"</span>);    body.add(<span class="hljs-string">"username"</span>,username);    body.add(<span class="hljs-string">"password"</span>,password);    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body, headers);     <span class="hljs-comment">//凭证信息错误时候, 指定restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值</span>    restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> DefaultResponseErrorHandler()&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(ClientHttpResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-comment">//当响应的值为400或者401时也要正常响应,不要抛出异常</span>            <span class="hljs-keyword">if</span>(response.getRawStatusCode()!=<span class="hljs-number">400</span> &amp;&amp; response.getRawStatusCode()!=<span class="hljs-number">401</span>)&#123;                <span class="hljs-keyword">super</span>.handleError(response);            &#125;        &#125;    &#125;);     Map map = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        ((RestTemplate) restTemplate).setErrorHandler(<span class="hljs-keyword">new</span> DefaultResponseErrorHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(ClientHttpResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">// 设置 当响应400和401时照常响应数据，不要报错</span>                <span class="hljs-keyword">if</span> (response.getRawStatusCode() != <span class="hljs-number">400</span> &amp;&amp; response.getRawStatusCode() != <span class="hljs-number">401</span> ) &#123;                    <span class="hljs-keyword">super</span>.handleError(response);                &#125;            &#125;        &#125;);         <span class="hljs-comment">//http请求spring security的申请令牌接口</span>        ResponseEntity&lt;Map&gt; mapResponseEntity = restTemplate.exchange(authUrl, HttpMethod.POST, <span class="hljs-keyword">new</span>                                                                      HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(body, headers), Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        map = mapResponseEntity.getBody();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        LOGGER.error(<span class="hljs-string">"request oauth_token_password error: &#123;&#125;"</span>,e.getMessage());        e.printStackTrace();        ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);    &#125;    <span class="hljs-keyword">if</span>(map == <span class="hljs-keyword">null</span> ||map.get(<span class="hljs-string">"access_token"</span>) == <span class="hljs-keyword">null</span> ||       map.get(<span class="hljs-string">"refresh_token"</span>) == <span class="hljs-keyword">null</span> ||       map.get(<span class="hljs-string">"jti"</span>) == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//jti是jwt令牌的唯一标识作为用户身份令牌</span>        <span class="hljs-comment">//获取spring security返回的错误信息</span>        String error_description = (String) map.get(<span class="hljs-string">"error_description"</span>);        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(error_description))&#123;            <span class="hljs-keyword">if</span>(error_description.equals(<span class="hljs-string">"坏的凭证"</span>))&#123;                ExceptionCast.cast(AuthCode.AUTH_CREDENTIAL_ERROR);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(error_description.indexOf(<span class="hljs-string">"UserDetailsService returned null"</span>)&gt;=<span class="hljs-number">0</span>)&#123;                ExceptionCast.cast(AuthCode.AUTH_ACCOUNT_NOTEXISTS);            &#125;        &#125; ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);    &#125;     <span class="hljs-comment">//拼装authToken并返回</span>    AuthToken authToken = <span class="hljs-keyword">new</span> AuthToken();    <span class="hljs-comment">//访问令牌(jwt)</span>    String access_token = (String) map.get(<span class="hljs-string">"access_token"</span>);    <span class="hljs-comment">//刷新令牌(jwt)</span>    String refresh_token = (String) map.get(<span class="hljs-string">"refresh_token"</span>);    <span class="hljs-comment">//jti，作为用户的身份标识,也就是后面我们用于返回给到用户前端的凭证</span>    String jwt_token = (String) map.get(<span class="hljs-string">"jti"</span>);     authToken.setAccess_token(access_token);    authToken.setRefresh_token(refresh_token);    authToken.setJwt_token(jwt_token);    <span class="hljs-keyword">return</span> authToken;&#125;</code></pre></div><p>用户不存在：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image9.png" srcset="/img/loading.gif" alt="image-20200527103916066"></p><p>密码错误：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image10.png" srcset="/img/loading.gif" alt="image-20200527103926094"></p><h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a><strong>5、测试</strong></h4><p>使用postman请求<a href="http://localhost:40400/auth/userlogin" target="_blank" rel="noopener">http://localhost:40400/auth/userlogin</a></p><p>1、输入正确的账号和密码进行测试</p><p>从数据库找到测试账号，本课程所提供的用户信息初始密码统一为123</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image11.png" srcset="/img/loading.gif" alt="image-20200529104816836"></p><p>2、输入错误的账号和密码进行测试</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image12.png" srcset="/img/loading.gif" alt="image-20200529104802458"></p><h2 id="3-用户登录前端"><a href="#3-用户登录前端" class="headerlink" title="3. 用户登录前端"></a>3. 用户登录前端</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>点击用户登录固定跳转到用户中心前端的登录页面，如下：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image13.png" srcset="/img/loading.gif" alt="image-20200527085248145"></p><p>输入账号和密码，登录成功，跳转到首页。</p><p>用户中心前端（<code>xc-ui-pc-learning</code>工程）提供登录页面，所有子系统连接到此页面。</p><p>说明：</p><ul><li>页面有 “登录|注册” 链接的前端系统有：门户系统、搜索系统、用户中心。</li><li>本小节修改门户系统的页头，其它三处可参考门户修改。</li></ul><h3 id="Api方法"><a href="#Api方法" class="headerlink" title="Api方法"></a>Api方法</h3><p>在 <code>xc-ui-pc-leanring/src/base/api/login.js</code> 下配置该api方法，用于请求后端登录接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*登陆*/</span>export <span class="hljs-keyword">const</span> login = params =&gt; &#123;    <span class="hljs-comment">//let loginRequest = querystring.stringify(params)</span>    let loginRequest = qs.stringify(params);    <span class="hljs-keyword">return</span> http.requestPostForm(<span class="hljs-string">'/openapi/auth/userlogin'</span>,loginRequest);&#125;</code></pre></div><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p><strong>1、登录页面</strong></p><p>进入用户中心前端 <code>xc-ui-pc-leanring/src/module/home/page/</code>，找到登录页面 <code>loginpage.vue</code>：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image14.png" srcset="/img/loading.gif" alt="image-20200527085434263"></p><p>loginpage.vue 导入了 <code>loginForm.vue</code> 组件，<code>loginForm.vue</code> 页面包括了登录表单</p><div class="hljs"><pre><code class="hljs js">&lt;template&gt;  &lt;div&gt;    &lt;p-head&gt;&lt;<span class="hljs-regexp">/p-head&gt;</span><span class="hljs-regexp"> </span><span class="hljs-regexp">    &lt;login-form&gt;&lt;/</span>login-form&gt;     &lt;p-foot&gt;&lt;<span class="hljs-regexp">/p-foot&gt;</span><span class="hljs-regexp">  &lt;/</span>div&gt;&lt;<span class="hljs-regexp">/template&gt;</span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">import PHead from '@/</span>base/components/head.vue<span class="hljs-string">';</span><span class="hljs-string">import PFoot from '</span>@/base/components/foot.vue<span class="hljs-string">';</span><span class="hljs-string">import loginForm from '</span>@/base/components/loginForm.vue<span class="hljs-string">';</span><span class="hljs-string">...</span></code></pre></div><p>在 <code>xc-ui-pc-leanring/src/base/components</code> 下我们可以看到一个 <code>loginForm.vue</code> 的页面文件，主要为登录表单的页面实现，部分页面代码如下</p><div class="hljs"><pre><code class="hljs js">&lt;template&gt;  &lt;div&gt;        &lt;el-row <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"container"</span> style=<span class="hljs-string">"width: 470px"</span>&gt;          &lt;div id=<span class="hljs-string">"body"</span>&gt;            &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"g-center login-page"</span> @keyup.enter=<span class="hljs-string">"login"</span>&gt;              &lt;el-tabs v-model=<span class="hljs-string">"activeName"</span> &gt;                &lt;el-tab-pane label=<span class="hljs-string">"用户登陆"</span> name=<span class="hljs-string">"login"</span>&gt;              &lt;el-form :model=<span class="hljs-string">"loginForm"</span> label-width=<span class="hljs-string">"80px"</span> :rules=<span class="hljs-string">"loginRules"</span> ref=<span class="hljs-string">"loginForm"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"login-form"</span>&gt;                &lt;el-form-item label=<span class="hljs-string">"账号"</span> prop=<span class="hljs-string">"username"</span>&gt;                  &lt;el-input v-model=<span class="hljs-string">"loginForm.username"</span> auto-complete=<span class="hljs-string">"off"</span> &gt;&lt;<span class="hljs-regexp">/el-input&gt;</span><span class="hljs-regexp">                &lt;/</span>el-form-item&gt;                &lt;el-form-item label=<span class="hljs-string">"密码"</span> prop=<span class="hljs-string">"password"</span>&gt;                  &lt;el-input v-model=<span class="hljs-string">"loginForm.password"</span> auto-complete=<span class="hljs-string">"off"</span> &gt;&lt;<span class="hljs-regexp">/el-input&gt;</span><span class="hljs-regexp">                &lt;/</span>el-form-item&gt;                &lt;el-form-item &gt;                  &lt;el-button type=<span class="hljs-string">"primary"</span>  @click.native=<span class="hljs-string">"login"</span> :loading=<span class="hljs-string">"editLoading"</span>&gt;登陆&lt;<span class="hljs-regexp">/el-button&gt;</span><span class="hljs-regexp">                  &lt;el-button type="primary"  @click="resetForm('loginForm')"&gt;重置&lt;/</span>el-button&gt;                &lt;<span class="hljs-regexp">/el-form-item&gt;</span><span class="hljs-regexp">              &lt;/</span>el-form&gt;                &lt;<span class="hljs-regexp">/el-tab-pane&gt;</span><span class="hljs-regexp">                &lt;el-tab-pane label="用户注册" name="register"&gt;</span><span class="hljs-regexp">                  建设中..</span><span class="hljs-regexp">                &lt;/</span>el-tab-pane&gt;              &lt;<span class="hljs-regexp">/el-tabs&gt;</span><span class="hljs-regexp">            &lt;/</span>div&gt;        &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">        &lt;/</span>el-row&gt;  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;</code></pre></div><p><strong>2、路由配置</strong></p><p>来到 <code>xc-ui-pc-leanring/src/module/home/router</code> 下配置home模块的路由：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/home.vue'</span>;<span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/loginpage.vue'</span>;<span class="hljs-keyword">import</span> Denied <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/denied.vue'</span>;<span class="hljs-keyword">import</span> Logout <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/logout.vue'</span>;<span class="hljs-keyword">import</span> order_pay <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/order/page/order_pay.vue'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [&#123;    path: <span class="hljs-string">'/'</span>,    component: Home,    name: <span class="hljs-string">'个人中心'</span>,    hidden: <span class="hljs-literal">true</span>&#125;,&#123;path: <span class="hljs-string">'/login'</span>,component: Login,name: <span class="hljs-string">'Login'</span>, hidden: <span class="hljs-literal">true</span>&#125;,   .....</code></pre></div><p><strong>3、登录后跳转</strong></p><p>请求登录页面需携带 <code>returnUrl</code> 参数，要求此参数使用 <code>Base64</code> 编码。</p><p>登录成功后将跳转到 <code>returnUrl</code>，<code>loginForm.vue</code> 组件的登录方法如下：</p><div class="hljs"><pre><code class="hljs js">login: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.$refs.loginForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (valid) &#123;            <span class="hljs-keyword">this</span>.editLoading = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">let</span> para = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, <span class="hljs-keyword">this</span>.loginForm);            loginApi.login(para).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;                <span class="hljs-keyword">this</span>.editLoading = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">if</span>(res.success)&#123;                    <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'登陆成功'</span>);                    <span class="hljs-comment">//刷新 当前页面</span>                    <span class="hljs-comment">// alert(this.returnUrl)</span>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.returnUrl)                    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.returnUrl!=<span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">this</span>.returnUrl!=<span class="hljs-string">''</span>                       &amp;&amp; !<span class="hljs-keyword">this</span>.returnUrl.includes(<span class="hljs-string">"/userlogout"</span>)                       &amp;&amp; !<span class="hljs-keyword">this</span>.returnUrl.includes(<span class="hljs-string">"/userlogin"</span>))&#123;                        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-keyword">this</span>.returnUrl;                    &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-comment">//跳转到首页</span>                        <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'http://www.xuecheng.com/'</span>                    &#125;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(res.message)&#123;                        <span class="hljs-keyword">this</span>.$message.error(res.message);                    &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'登陆失败'</span>);                    &#125;                &#125;            &#125;,                                      (res) =&gt; &#123;                <span class="hljs-keyword">this</span>.editLoading = <span class="hljs-literal">false</span>;            &#125;);        &#125;    &#125;);&#125;,</code></pre></div><h3 id="点击登录页面"><a href="#点击登录页面" class="headerlink" title="点击登录页面"></a>点击登录页面</h3><p>在门户的页头点击“登录|注册”连接到用户中心的登录页面，并且携带 <code>returnUrl</code>。<br>修改门户的 <code>header.html</code>，代码如下：</p><div class="hljs"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">"javascript:;"</span> @click=<span class="hljs-string">"showlogin"</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"logined == false"</span>&gt;登陆&amp;nbsp;|&amp;nbsp;注册&lt;<span class="hljs-regexp">/a&gt;</span></code></pre></div><p>配置 showlogin 方法</p><div class="hljs"><pre><code class="hljs js">showlogin: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//this.loginFormVisible = true;</span>    <span class="hljs-built_in">window</span>.location = <span class="hljs-string">"http://ucenter.xuecheng.com/#/login?returnUrl="</span>+        Base64.encode(<span class="hljs-built_in">window</span>.location)&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试之前修改认证服务的配置：</p><p>修改 <code>application.yml</code> 中 cookie 域名</p><div class="hljs"><pre><code class="hljs c">cookieDomain: xuecheng.com</code></pre></div><p>测试流程如下：</p><p>1、输入<a href="http://www.xuecheng.xn--com%28hosts%29-9m4pn7u58t0o1c6r8djlgzpcd80fthza2bger7a/" target="_blank" rel="noopener">www.xuecheng.com进入系统（需要在hosts文件配置）</a></p><p>2、输入正确的账号和密码，提交</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image15.png" srcset="/img/loading.gif" alt="image-20200529111655698"></p><p>3、输入错误的账号和密码，提交</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image16.png" srcset="/img/loading.gif" alt="image-20200529111704463"></p><p>登录成功，观察 <code>cookie</code> 是否存储成功：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image17.png" srcset="/img/loading.gif" alt="image-20200527085814933"></p><h1 id="二、前端显示当前用户"><a href="#二、前端显示当前用户" class="headerlink" title="二、前端显示当前用户"></a>二、前端显示当前用户</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>用户登录成功在页头显示当前登录的用户名称。</p><p>数据流程如下图：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image18.png" srcset="/img/loading.gif" alt="image-20200529113051020"></p><p>1、用户请求认证服务，登录成功。</p><p>2、用户登录成功，认证服务向 <code>cookie</code> 写入身份令牌，向 <code>redis</code> 写入 <code>user_token</code>（身份令牌及授权jwt授权令牌）</p><p>3、客户端携带 <code>cookie</code> 中的身份令牌请求认证服务获取 <code>jwt</code> 令牌。</p><p>4、客户端解析 <code>jwt</code> 令牌，并将解析的用户信息存储到 <code>sessionStorage</code> 中。jwt令牌中包括了用户的基本信息，客户端解析jwt令牌即可获取用户信息。</p><p>5、客户端从<code>sessionStorage</code>中读取用户信息，并在页头显示。</p><blockquote><p>sessionStorage 是H5的一个会话存储对象，在 SessionStorage中保存的数据只在同一窗口或同一标签页中有效，在关闭窗口之后将会删除SessionStorage中的数据。seesionStorage 的存储方式采用key/value的方式，可保存5M左右的数据（不同的浏览器会有区别）</p></blockquote><p>sessionStorage 是H5的一个会话存储对象，在 SessionStorage中保存的数据只在同一窗口或同一标签页中有效，<br>在关闭窗口之后将会删除SessionStorage中的数据。</p><p>seesionStorage的存储方式采用key/value的方式，可保存5M左右的数据（不同的浏览器会有区别）</p><h2 id="2-jwt查询接口"><a href="#2-jwt查询接口" class="headerlink" title="2. jwt查询接口"></a>2. jwt查询接口</h2><p>该接口我们在 <code>ucenter-auth</code> 服务下进行开发</p><h3 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h3><p>认证服务对外提供jwt查询接口，流程如下：</p><p>1、客户端携带 <code>cookie</code> 中的身份令牌请求认证服务获取 <code>jwt</code></p><p>2、认证服务根据身份令牌从 <code>redis</code> 中查询 <code>jwt</code> 令牌并返回给客户端。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>在认证模块定义 <code>jwt</code> 查询接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"jwt查询接口"</span>,description = <span class="hljs-string">"客户端查询jwt令牌内容"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"查询userjwt令牌"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> JwtResult <span class="hljs-title">userjwt</span><span class="hljs-params">()</span></span>;    ....</code></pre></div><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>无</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>在AuthService中定义方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//从redis查询令牌</span><span class="hljs-function"><span class="hljs-keyword">public</span> AuthToken <span class="hljs-title">getUserToken</span><span class="hljs-params">(String token)</span></span>&#123;    String userToken = <span class="hljs-string">"user_token:"</span>+token;    String userTokenString = stringRedisTemplate.opsForValue().get(userToken);    <span class="hljs-keyword">if</span>(userToken!=<span class="hljs-keyword">null</span>)&#123;        AuthToken authToken = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            authToken = JSON.parseObject(userTokenString, AuthToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            LOGGER.error(<span class="hljs-string">"getUserToken from redis and execute JSON.parseObject error&#123;&#125;"</span>,e.getMessage());            e.printStackTrace();        &#125;         <span class="hljs-keyword">return</span> authToken;    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/userjwt"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> JwtResult <span class="hljs-title">userjwt</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//获取cookie中的令牌</span>    String access_token = getTokenFormCookie();    <span class="hljs-comment">//根据令牌从redis查询jwt</span>    AuthToken authToken = authService.getUserToken(access_token);    <span class="hljs-keyword">if</span>(authToken == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtResult(CommonCode.SUCCESS,authToken.getJwt_token());&#125; <span class="hljs-comment">//从cookie中读取访问令牌</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getTokenFormCookie</span><span class="hljs-params">()</span></span>&#123;    Map&lt;String, String&gt; cookieMap = CookieUtil.readCookie(request, <span class="hljs-string">"uid"</span>);    String access_token = cookieMap.get(<span class="hljs-string">"uid"</span>);    <span class="hljs-keyword">return</span> access_token;&#125;</code></pre></div><p>WebSecurityConfig 配置放行 <code>userjwt</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        web.ignoring().antMatchers(<span class="hljs-string">"/userlogin"</span>,<span class="hljs-string">"/userlogout"</span>,<span class="hljs-string">"/getjwt"</span>,<span class="hljs-string">"/swagger-ui.html"</span>);    &#125;</code></pre></div><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>使用 <code>postman</code> 测试</p><p>1、请求 /auth/userlogin</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image19.png" srcset="/img/loading.gif" alt="image-20200530091705402"></p><p>观察 <code>cookie</code> 是否已存入用户身份令牌</p><p>2、get请求jwt</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image20.png" srcset="/img/loading.gif" alt="image-20200529114126146"></p><h2 id="3-前端请求jwt"><a href="#3-前端请求jwt" class="headerlink" title="3. 前端请求jwt"></a>3. 前端请求jwt</h2><h3 id="需求分析-3"><a href="#需求分析-3" class="headerlink" title="需求分析"></a>需求分析</h3><p>前端需求如下：</p><p>用户登录成功，前端请求认证服务获取jwt令牌。</p><p>前端解析jwt令牌的内容，得到用户信息，并将用户信息存储到 sessionStorage。</p><p>从 sessionStorage 取出用户信息在页头显示用户名称。</p><p>以下操作我们在门户工程进行</p><h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><p>在login.js中定义getjwt方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*获取jwt令牌*/</span><span class="hljs-keyword">const</span> getjwt = () =&gt; &#123;<span class="hljs-keyword">return</span> requestGet(<span class="hljs-string">'/openapi/auth/userjwt'</span>);&#125;</code></pre></div><h3 id="页面-1"><a href="#页面-1" class="headerlink" title="页面"></a>页面</h3><p>修改 <code>include/header.html</code></p><p>1、页面视图</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"logined == true"</span>&gt;</span>欢迎&#123;&#123;this.user.username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"logout"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"logined == true"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://ucenter.xuecheng.com/"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"personal"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>我的学习<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showlogin"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"logined == false"</span>&gt;</span>登陆<span class="hljs-symbol">&amp;nbsp;</span>|<span class="hljs-symbol">&amp;nbsp;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://teacher.xuecheng.com/"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"personal"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>教学提供方<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://system.xuecheng.com/"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"personal"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>系统后台<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>用户登录成功设置数据对象 <code>logined</code> 为 <code>true</code>，设置数据对象 <code>user</code> 为当前用户信息。</p><p>数据对象定义如下</p><div class="hljs"><pre><code class="hljs js">user:&#123;    userid:<span class="hljs-string">''</span>,    username: <span class="hljs-string">''</span>,    userpic: <span class="hljs-string">''</span>&#125;,logined:<span class="hljs-literal">false</span></code></pre></div><p>2、解析jwt令牌</p><p>在 <code>util.js</code> 中定义解析jwt令牌方法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//解析jwt令牌，获取用户信息</span><span class="hljs-keyword">var</span> getUserInfoFromJwt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jwt</span>) </span>&#123;    <span class="hljs-keyword">if</span>(!jwt)&#123;        <span class="hljs-keyword">return</span> ;    &#125;     <span class="hljs-keyword">var</span> jwtDecodeVal = jwt_decode(jwt);    <span class="hljs-keyword">if</span> (!jwtDecodeVal) &#123;        <span class="hljs-keyword">return</span> ;    &#125;     <span class="hljs-keyword">let</span> activeUser=&#123;&#125;    <span class="hljs-comment">//console.log(jwtDecodeVal)</span>    activeUser.utype = jwtDecodeVal.utype || <span class="hljs-string">''</span>;    activeUser.username = jwtDecodeVal.name || <span class="hljs-string">''</span>;    activeUser.userpic = jwtDecodeVal.userpic || <span class="hljs-string">''</span>;    activeUser.userid = jwtDecodeVal.userid || <span class="hljs-string">''</span>;    activeUser.authorities = jwtDecodeVal.authorities || <span class="hljs-string">''</span>;    activeUser.uid = jwtDecodeVal.jti || <span class="hljs-string">''</span>;    activeUser.jwt = jwt;    <span class="hljs-keyword">return</span> activeUser;&#125;</code></pre></div><p>3、refresh_user()</p><p>在 <code>mounted</code> 钩子方法中调用 <code>refresh_user</code> 获取当前用户信息，并将用户信息存储到 <code>sessionStorage</code></p><div class="hljs"><pre><code class="hljs js">mounted()&#123;<span class="hljs-comment">//刷新当前用户</span><span class="hljs-keyword">this</span>.refresh_user()&#125;</code></pre></div><p>refresh_user() 方法如下：</p><div class="hljs"><pre><code class="hljs js">refresh_user:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//从sessionStorage中取出当前用户</span>    <span class="hljs-keyword">let</span> activeUser= getActiveUser();    <span class="hljs-comment">//取出cookie中的令牌</span>    <span class="hljs-keyword">let</span> uid = getCookie(<span class="hljs-string">"uid"</span>)        <span class="hljs-comment">//console.log(activeUser)</span>        <span class="hljs-keyword">if</span>(activeUser &amp;&amp; uid &amp;&amp; uid == activeUser.uid)&#123;            <span class="hljs-keyword">this</span>.logined = <span class="hljs-literal">true</span>                <span class="hljs-keyword">this</span>.user = activeUser;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(!uid)&#123;                <span class="hljs-keyword">return</span> ;            &#125;             <span class="hljs-comment">//请求查询jwt</span>            getjwt().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;                <span class="hljs-keyword">if</span>(res.success)&#123;                    <span class="hljs-keyword">let</span> jwt = res.jwt;                    <span class="hljs-keyword">let</span> activeUser = getUserInfoFromJwt(jwt)                        <span class="hljs-keyword">if</span>(activeUser)&#123;                            <span class="hljs-keyword">this</span>.logined = <span class="hljs-literal">true</span>                                <span class="hljs-keyword">this</span>.user = activeUser;                            setUserSession(<span class="hljs-string">"activeUser"</span>,<span class="hljs-built_in">JSON</span>.stringify(activeUser))                        &#125;                &#125;            &#125;)        &#125;&#125;</code></pre></div><h3 id="配置代理转发"><a href="#配置代理转发" class="headerlink" title="配置代理转发"></a>配置代理转发</h3><p>上边实现在首页显示当前用户信息，首页需要通过 <code>Nginx</code> 代理请求认证服务，所以需要在 <code>www</code> 域下的虚拟主机上配置代理路径：</p><div class="hljs"><pre><code class="hljs c">#认证location ^~ /openapi/auth/ &#123;proxy_pass http:<span class="hljs-comment">//auth_server_pool/auth/;</span>&#125;</code></pre></div><p>注意：其它前端系统要接入认证要请求认证服务也需要配置上边的代理路径。</p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>登录成功后自动跳转回到门户主站，并显示用户的信息</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image21.png" srcset="/img/loading.gif" alt="img"></p><h1 id="三、用户退出"><a href="#三、用户退出" class="headerlink" title="三、用户退出"></a>三、用户退出</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>操作流程如下：</p><p>1、用户点击退出，弹出退出确认窗口，点击确定</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image22.png" srcset="/img/loading.gif" alt="image-20200530095137916"></p><p>2、退出成功</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image23.png" srcset="/img/loading.gif" alt="image-20200530095144891"></p><p>用户退出要完成以下动作：</p><p>1、删除 <code>redis</code> 中的 <code>token</code></p><p>2、删除 <code>cookie</code> 中的 <code>token</code></p><h2 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h2><p>认证服务对外提供退出接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"退出"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">logout</span><span class="hljs-params">()</span></span>;</code></pre></div><h2 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3. 服务端"></a>3. 服务端</h2><p>认证服务提供退出接口。</p><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>无</p><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除指定usertoken在redis中的jwt信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> uid usertoken</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">delToken</span><span class="hljs-params">(String uid)</span> </span>&#123;    String key = <span class="hljs-string">"user_token:"</span> + uid;    Boolean delete = stringRedisTemplate.delete(key);    <span class="hljs-keyword">return</span> delete;&#125;</code></pre></div><h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/userlogout"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">logout</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 取出用户身份令牌</span>    String uid = getTokenFormCookie();    <span class="hljs-comment">//删除用户在redis中的身份信息</span>    Boolean delToken = authService.delToken(uid);    <span class="hljs-comment">//通过修改返回的response来实现用户前端收到响应后删除浏览器的cookie信息</span>    clearCookie(uid);    <span class="hljs-keyword">if</span>(delToken)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);&#125; <span class="hljs-comment">//清除cookie</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearCookie</span><span class="hljs-params">(String token)</span></span>&#123;    HttpServletResponse response = ((ServletRequestAttributes)                                    RequestContextHolder.getRequestAttributes()).getResponse();    <span class="hljs-comment">// 设置maxAge为实现删除cookie</span>    CookieUtil.addCookie(response, cookieDomain, <span class="hljs-string">"/"</span>, <span class="hljs-string">"uid"</span>, token, <span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);&#125;</code></pre></div><h3 id="退出URL放行"><a href="#退出URL放行" class="headerlink" title="退出URL放行"></a>退出URL放行</h3><p>认证服务默认都要校验用户的身份信息，这里需要将退出url放行。</p><p>在 <code>WebSecurityConfig</code> 类中重写 <code>configure</code> (WebSecurity web)方法，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    web.ignoring().antMatchers(<span class="hljs-string">"/userlogin"</span>,<span class="hljs-string">"/userlogout"</span>,<span class="hljs-string">"/userjwt"</span>,<span class="hljs-string">"/swagger-ui.html"</span>);&#125;</code></pre></div><h2 id="4-前端"><a href="#4-前端" class="headerlink" title="4. 前端"></a>4. 前端</h2><h3 id="需求分析-4"><a href="#需求分析-4" class="headerlink" title="需求分析"></a>需求分析</h3><p>在用户中心前端工程（xc-ui-pc-learning）开发退出页面。</p><h3 id="Api方法定义"><a href="#Api方法定义" class="headerlink" title="Api方法定义"></a>Api方法定义</h3><p>在用户中心工程增加退出的 <code>api</code> 方法</p><p>在 <code>base</code> 模块的 <code>login.js</code> 增加方法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*退出*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> logout = <span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> http.requestPost(<span class="hljs-string">'/openapi/auth/userlogout'</span>);&#125;</code></pre></div><h3 id="退出页面"><a href="#退出页面" class="headerlink" title="退出页面"></a>退出页面</h3><p>1、在用户中心工程创建退出页面</p><p>参考： <code>xc-ui-pc-leanring/src/module/home/page/logout.vue</code></p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image24.png" srcset="/img/loading.gif" alt="image-20200530095510125"></p><p>2、路由配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Logout <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/logout.vue'</span>;<span class="hljs-keyword">import</span> order_pay <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/order/page/order_pay.vue'</span>;<span class="hljs-comment">// import LoginMini from '@/module/home/page/login_mini.vue';</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [&#123;    path: <span class="hljs-string">'/'</span>,    component: Home,    name: <span class="hljs-string">'个人中心'</span>,    hidden: <span class="hljs-literal">true</span>&#125;,&#123;    path: <span class="hljs-string">'/login'</span>,    component: Login,    name: <span class="hljs-string">'Login'</span>,    hidden: <span class="hljs-literal">true</span>&#125;,&#123;    path: <span class="hljs-string">'/logout'</span>,    component: Logout,    name: <span class="hljs-string">'Logout'</span>,    hidden: <span class="hljs-literal">true</span>&#125;,....</code></pre></div><p>3、退出方法</p><p>退出成功清除页面的 <code>sessionStorage</code></p><p>参考 <code>logout.vue</code></p><p>在 <code>created</code> 钩子方法请求退出方法</p><div class="hljs"><pre><code class="hljs js">created()&#123;    loginApi.logout(&#123;&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            sessionStorage.removeItem(<span class="hljs-string">'activeUser'</span>);            <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'退出成功'</span>);            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.code == <span class="hljs-number">11111</span>)&#123;            <span class="hljs-comment">// 用户的登录信息已在redis过期</span>            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>            <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'用户凭证过期, 在这之前已经退出登陆'</span>);        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>        &#125;        <span class="hljs-comment">//清空用户的缓存信息</span>        sessionStorage.clear()    &#125;,                             (res) =&gt; &#123;        <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>    &#125;);&#125;,</code></pre></div><h3 id="链接到退出页面"><a href="#链接到退出页面" class="headerlink" title="链接到退出页面"></a>链接到退出页面</h3><p>修改门户主站 xc-ui-pc-static-portal 的 <code>include/header.html</code></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"logout"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"logined == true"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p>在 <code>include/header.html</code> 中添加 <code>element-ui</code> 库，将此js加到 <code>head</code> 的最下边</p><blockquote><p>否则可能会出现无法加载element-ui组件的问题</p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/css/el/index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p><code>logout</code> 方法如下：</p><div class="hljs"><pre><code class="hljs js">logout: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认退出吗?'</span>, <span class="hljs-string">'提示'</span>, &#123;    &#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-comment">//跳转到用户中心的登出页面</span>        <span class="hljs-built_in">window</span>.location = <span class="hljs-string">"http://ucenter.xuecheng.com/#/logout"</span>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            &#125;);&#125;,</code></pre></div><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image25.png" srcset="/img/loading.gif" alt="image-20200530111647702"></p><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><blockquote><p>下述的一些问题在我上面的代码中其实已经修复，但部分读者可能跳过了上述的步骤，仍然使用的是原教程中所给到的代码案例，所以这里的一些问题我单独列出来。</p></blockquote><p>1、用户的登录信息已在redis过期，返回操作的状态码，前端没有识别为已登出的状态</p><p>增加对 <code>11111</code> 状态码的判断</p><div class="hljs"><pre><code class="hljs js">created()&#123;    loginApi.logout(&#123;&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            sessionStorage.removeItem(<span class="hljs-string">'activeUser'</span>);            <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'退出成功'</span>);            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.code == <span class="hljs-number">11111</span>)&#123;            <span class="hljs-comment">// 用户的登录信息已在redis过期</span>            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>            <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'用户凭证过期, 在这之前已经退出登陆'</span>);        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>        &#125;    &#125;,                             (res) =&gt; &#123;        <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>    &#125;);&#125;,</code></pre></div><p>2、登出成功后，返回主页后仍然显示用户的信息</p><p>在发送登出请求后，使用 <code>sessionStorage.clear()</code> 清空用户的缓存信息</p><div class="hljs"><pre><code class="hljs js">created()&#123;    loginApi.logout(&#123;&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            sessionStorage.removeItem(<span class="hljs-string">'activeUser'</span>);            <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'退出成功'</span>);            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.code == <span class="hljs-number">11111</span>)&#123;            <span class="hljs-comment">// 用户的登录信息已在redis过期</span>            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>            <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'用户凭证过期, 在这之前已经退出登陆'</span>);        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>        &#125;        <span class="hljs-comment">//清空用户的缓存信息</span>        sessionStorage.clear()    &#125;,                             (res) =&gt; &#123;        <span class="hljs-keyword">this</span>.logoutsuccess = <span class="hljs-literal">false</span>    &#125;);&#125;,</code></pre></div><h1 id="四、Zuul-网关"><a href="#四、Zuul-网关" class="headerlink" title="四、Zuul 网关"></a>四、Zuul 网关</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>网关的作用相当于一个过虑器、拦截器，它可以拦截多个系统的请求。</p><p>本章节要使用网关校验用户的身份是否合法。</p><h2 id="2-Zuul-介绍"><a href="#2-Zuul-介绍" class="headerlink" title="2. Zuul 介绍"></a>2. Zuul 介绍</h2><p>什么是Zuul？</p><p>Spring Cloud Zuul 是整合 <code>Netflix</code> 公司的 <code>Zuul</code> 开源项目实现的微服务网关，它实现了 <code>请求路由</code>、<code>负载均衡</code>、<code>校验过虑</code> 等功能。</p><p>官方：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p><p>什么是网关？</p><p>服务网关是在微服务前边设置一道屏障，请求先到服务网关，网关会对请求进行 <code>过虑</code>、<code>校验</code>、<code>路由</code> 等处理。有了服务网关可以提高微服务的安全性，网关校验请求的合法性，请求不合法将被拦截，拒绝访问。</p><p>Zuul 与 <code>Nginx</code> 怎么配合使用？</p><p>Zuul与 <code>Nginx</code> 在实际项目中需要配合使用，如下图，<code>Nginx</code> 的作用是反向代理、负载均衡，<code>Zuul</code> 的作用是保障微服务的安全访问，拦截微服务请求，校验合法性及负载均衡。</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image26.png" srcset="/img/loading.gif" alt="image-20200531170255074"></p><h2 id="3-搭建网关工程"><a href="#3-搭建网关工程" class="headerlink" title="3.搭建网关工程"></a>3.搭建网关工程</h2><p>创建网关工程（xc-govern-gateway）：</p><p><strong>1、创建 xc-govern-gateway 工程</strong></p><p>导入 <code>资料/xc-govern-gateway.zip</code></p><p><strong>2、@EnableZulProxy</strong></p><p>注意在启动类上使用 <code>@EnableZuulProxy</code> 注解标识此工程为 <code>Zuul</code> 网关，启动类代码如下：</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@EnableZuulProxy</span>public class GatewayApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(GatewayApplication.class, args);    &#125;&#125;</code></pre></div><h2 id="4-路由配置"><a href="#4-路由配置" class="headerlink" title="4. 路由配置"></a>4. 路由配置</h2><h3 id="需求分析-5"><a href="#需求分析-5" class="headerlink" title="需求分析"></a>需求分析</h3><p>Zuul 网关具有代理的功能，根据请求的url转发到微服务，如下图：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image27.png" srcset="/img/loading.gif" alt="image-20200531170704355"></p><ul><li>客户端请求网关 <code>/api/learning</code>，通过路由转发到 <code>/learning</code></li><li>客户端请求网关 <code>/api/course</code>，通过路由转发到 <code>/course</code></li></ul><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><p>在 <code>appcation.yml</code> 中配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span><span class="hljs-attr">manage-course:</span> <span class="hljs-comment">#路由名称，名称任意，保持所有路由名称唯一</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/course/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-manage-course</span> <span class="hljs-comment">#指定服务id，从Eureka中找到服务的ip和端口</span>      <span class="hljs-comment">#url: http://localhost:31200 #也可指定url</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#true：代理转发时去掉前缀，false:代理转发时不去掉前缀</span>      <span class="hljs-attr">sensitiveHeaders:</span> <span class="hljs-comment">#默认zuul会屏蔽cookie，cookie不会传到下游服务，这里设置为空则取消默认的黑名单，如果设置了具体的头信息则不会传到下游服务</span>  <span class="hljs-comment"># ignoredHeaders: Authorization</span></code></pre></div><ul><li><p><strong>serviceId</strong>：推荐使用 <code>serviceId</code>，zuul会从 <code>Eureka</code> 中找到服务 <code>id</code> 对应的 <code>ip</code> 和端口。</p></li><li><p><strong>strip-prefix</strong>: false或者true，设置为 <code>true</code> 时代理转发时去掉前缀，<code>false</code> 则代理转发时不去掉前缀</p><p>例如，设置为 <code>true</code> 请求 <code>/course/coursebase/get/..</code> ，代理转发到 <code>/coursebase/get/</code>，如果为false则代理直接转发到原来的url</p></li><li><p><strong>sensitiveHeaders</strong>：敏感头设置，默认会过虑掉cookie，这里设置为空表示不过虑</p></li><li><p><strong>ignoredHeaders</strong>：可以设置过虑的头信息，默认为空表示不过虑任何头</p></li></ul><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><p><a href="http://localhost:50201/api" target="_blank" rel="noopener">http://localhost:50201/api</a> 是网关地址，通过路由转发到 <code>xc-service-manage-course</code> 服务。</p><p>打算使用课程图片信息获取的 API 进行测试我，这里的课程图片信息获取的URL为 <code>/course/coursepic/get</code> ，所以由于课程管理已经添加了授课拦截，这里为了测试网关功能暂时将 url <code>/course/coursepic/get</code>排除认证。在课程管理服务的 <code>ResourceServerConfig</code> 类中添加 <code>&quot;/course/coursepic/get/*&quot;</code> 代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//所有请求必须认证通过</span>    http.authorizeRequests()        <span class="hljs-comment">//下边的路径放行</span>        .antMatchers(<span class="hljs-string">"/v2/api-docs"</span>, <span class="hljs-string">"/swagger-resources/configuration/ui"</span>,                     <span class="hljs-string">"/swagger-resources"</span>,<span class="hljs-string">"/swagger-resources/configuration/security"</span>,                     <span class="hljs-string">"/swagger-ui.html"</span>,<span class="hljs-string">"/course/coursepic/list/*"</span>)        .permitAll()        .anyRequest().authenticated();&#125;</code></pre></div><p>而我之前的课程中将需要排除的 <code>url</code> 改写成了从配置文件中读取，如下代码，如果是按原教程的配置的，可以忽略下述的代码， 直接阅读测试的环节。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;oauth2.urlMatchers&#125;"</span>)String urlMatchers; <span class="hljs-comment">//Http安全配置，对每个到达系统的http请求链接进行校验</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span>(urlMatchers.equals(<span class="hljs-string">""</span>))&#123;        <span class="hljs-comment">//如果urlMatchers未指定,则所有url都需要授权后才能被访问</span>        http.authorizeRequests().anyRequest().authenticated();    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//放行 urlMatchers 中指定的url条目, 未指定的url仍需授权后才能访问</span>        String[] split = urlMatchers.split(<span class="hljs-string">","</span>);        http.authorizeRequests()            <span class="hljs-comment">//下边的路径放行</span>            .antMatchers(split).permitAll()            .anyRequest().authenticated();    &#125;&#125;</code></pre></div><p>在 <code>appliaction.yml</code> 中配置 oauth2.urlMatchers</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">oauth2:</span>  <span class="hljs-attr">urlMatchers:</span> <span class="hljs-string">/v2/api-docs,/swagger-resources/configuration/ui,/swagger-resources,/swagger-resources/configuration/security,/swagger-ui.html,/webjars/**,"/course/coursepic/get/*"</span></code></pre></div><p>请求请求到如下连接，进行 查询课程图片信息</p><p>GET：<a href="http://localhost:50201/api/course/coursepic/list/4028e58161bd22e60161bd23672a0001" target="_blank" rel="noopener">http://localhost:50201/api/course/coursepic/list/4028e58161bd22e60161bd23672a0001</a></p><p>测试结果如下</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image28.png" srcset="/img/loading.gif" alt="image-20200531175205607"></p><h3 id="完整的路由配置"><a href="#完整的路由配置" class="headerlink" title="完整的路由配置"></a>完整的路由配置</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">xc-service-learning:</span> <span class="hljs-comment">#路由名称，名称任意，保持所有路由名称唯一</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/learning/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-learning</span> <span class="hljs-comment">#指定服务id，从Eureka中找到服务的ip和端口</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span>      <span class="hljs-attr">sensitiveHeaders:</span>    <span class="hljs-attr">manage-course:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/course/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-manage-course</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span>      <span class="hljs-attr">sensitiveHeaders:</span>    <span class="hljs-attr">manage-cms:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/cms/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-manage-cms</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">sensitiveHeaders:</span>    <span class="hljs-attr">manage-sys:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/sys/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-manage-cms</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span>      <span class="hljs-attr">sensitiveHeaders:</span>    <span class="hljs-attr">service-ucenter:</span>    <span class="hljs-attr">path:</span> <span class="hljs-string">/ucenter/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-ucenter</span>      <span class="hljs-attr">sensitiveHeaders:</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">xc-service-manage-order:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/order/**</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">xc-service-manage-order</span>      <span class="hljs-attr">sensitiveHeaders:</span>      <span class="hljs-attr">strip-prefix:</span> <span class="hljs-literal">false</span></code></pre></div><h2 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5. 过滤器"></a>5. 过滤器</h2><p>Zuul的核心就是过虑器，通过过虑器实现请求过虑，身份校验等</p><h3 id="配置ZuulFilter"><a href="#配置ZuulFilter" class="headerlink" title="配置ZuulFilter"></a>配置ZuulFilter</h3><p>自定义过虑器需要继承 <code>ZuulFilter</code>，ZuulFilter 是一个抽象类，需要覆盖它的四个方法，如下：</p><ul><li>shouldFilter：返回一个 Boolean 值，判断该过滤器是否需要执行。返回true表示要执行此过虑器，否则不执<br>行。</li><li>run：过滤器的业务逻辑。</li><li>filterType：返回字符串代表过滤器的类型，如下<ul><li><code>pre</code>：请求在被路由之前执行</li><li><code>routing</code>：在路由请求时调用</li><li><code>post</code>：在 routing 和 errror 过滤器之后调用</li><li><code>error</code>：处理请求时发生错误调用</li></ul></li><li>filterOrder：此方法返回整型数值，通过此数值来定义过滤器的执行顺序，数字越小优先级越高。</li></ul><h3 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h3><p>过虑所有请求，判断头部信息是否有 <code>Authorization</code>，如果没有则拒绝访问，否则转发到微服务。</p><p>定义过虑器，使用 <code>@Component</code> 标识为 bean。</p><p>在网关工程下构建一个 <code>filter</code> 包，创建一个 LoginFilterTest 并继承于 <code>ZuulFilter</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilterTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG = LoggerFactory.getLogger(LoginFilterTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"pre"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//int值来定义过滤器的执行顺序，数值越小优先级越高</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 该过滤器需要执行</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletResponse response = requestContext.getResponse();         <span class="hljs-comment">//获取响应对象</span>        HttpServletRequest request = requestContext.getRequest();           <span class="hljs-comment">//获取请求对象</span>        <span class="hljs-comment">//取出头部信息Authorization</span>        String authorization = request.getHeader(<span class="hljs-string">"Authorization"</span>);        <span class="hljs-comment">//判断用户的请求中是否带有 Authorization 字段,如果没有则表示未认证用户</span>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(authorization))&#123;            requestContext.setSendZuulResponse(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 拒绝访问</span>            requestContext.setResponseStatusCode(<span class="hljs-number">200</span>);<span class="hljs-comment">// 设置响应状态码</span>            ResponseResult unauthenticated = <span class="hljs-keyword">new</span> ResponseResult(CommonCode.UNAUTHENTICATED);            String jsonString = JSON.toJSONString(unauthenticated);            requestContext.setResponseBody(jsonString);            requestContext.getResponse().setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><p>测试请求：</p><p><a href="http://localhost:50201/api/course/coursebase/get/4028e581617f945f01617f9dabc40000" target="_blank" rel="noopener">http://localhost:50201/api/course/coursebase/get/4028e581617f945f01617f9dabc40000</a> 查询课程信息</p><p>1、Header 中不设置 Authorization</p><p>响应结果：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image29.png" srcset="/img/loading.gif" alt="image-20200531184006794"></p><p>2、Header 中设置 <code>Authorization</code></p><p>成功响应课程信息。</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image30.png" srcset="/img/loading.gif" alt="image-20200531183942639"></p><h1 id="五、身份校验"><a href="#五、身份校验" class="headerlink" title="五、身份校验"></a>五、身份校验</h1><h2 id="1-需求分析-3"><a href="#1-需求分析-3" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>本小节实现网关连接 <code>Redis</code> 校验令牌：</p><p>1、从 <code>cookie</code> 查询用户身份令牌是否存在，不存在则拒绝访问</p><p>2、从 <code>http header</code> 查询jwt令牌是否存在，不存在则拒绝访问</p><p>3、从 <code>Redis</code> 查询 <code>user_token</code> 令牌是否过期，过期则拒绝访问</p><h2 id="2-业务实现"><a href="#2-业务实现" class="headerlink" title="2. 业务实现"></a>2. 业务实现</h2><p>1、配置 application.yml</p><p>配置 redis链接参数：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc‐govern‐gateway</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;REDIS_HOST:127.0.0.1&#125;</span>    <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;REDIS_PORT:6379&#125;</span>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span> <span class="hljs-comment">#连接超时 毫秒</span>    <span class="hljs-attr">jedis:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-attr">maxActive:</span> <span class="hljs-number">3</span>        <span class="hljs-attr">maxIdle:</span> <span class="hljs-number">3</span>        <span class="hljs-attr">minIdle:</span> <span class="hljs-number">1</span>        <span class="hljs-attr">maxWait:</span> <span class="hljs-string">‐1</span>  <span class="hljs-comment">#连接池最大等行时间 ‐1没有限制</span></code></pre></div><p>2、使用 StringRedisTemplate 查询 <code>key</code> 的有效期</p><p>在 <code>service</code> 包下定义 <code>AuthService</code> 类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    StringRedisTemplate stringRedisTemplate;    <span class="hljs-comment">//查询身份令牌</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTokenFromCookie</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        Map&lt;String, String&gt; cookieMap = CookieUtil.readCookie(request, <span class="hljs-string">"uid"</span>);        String access_token = cookieMap.get(<span class="hljs-string">"uid"</span>);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(access_token))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-keyword">return</span> access_token;    &#125;     <span class="hljs-comment">//从header中查询jwt令牌</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJwtFromHeader</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;        String authorization = request.getHeader(<span class="hljs-string">"Authorization"</span>);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(authorization))&#123;            <span class="hljs-comment">//拒绝访问</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span>(!authorization.startsWith(<span class="hljs-string">"Bearer "</span>))&#123;            <span class="hljs-comment">//拒绝访问</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-keyword">return</span> authorization;    &#125;     <span class="hljs-comment">//查询令牌的有效期</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">(String access_token)</span> </span>&#123;        <span class="hljs-comment">//token在redis中的key</span>        String key = <span class="hljs-string">"user_token:"</span>+access_token;        Long expire = stringRedisTemplate.getExpire(key);        <span class="hljs-keyword">return</span> expire;    &#125;&#125;</code></pre></div><p>3、定义LoginFilter</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 身份校验器</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-28  13:14</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    AuthService authService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"pre"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//int值来定义过滤器的执行顺序，数值越小优先级越高</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 该过滤器需要执行</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;        RequestContext requestContext = RequestContext.getCurrentContext();        HttpServletResponse response = requestContext.getResponse();         <span class="hljs-comment">//获取响应对象</span>        HttpServletRequest request = requestContext.getRequest();           <span class="hljs-comment">//获取请求对象</span>        <span class="hljs-comment">//取cookie中的身份令牌</span>        String tokenFromCookie = authService.getTokenFromCookie(request);        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(tokenFromCookie))&#123;            <span class="hljs-comment">//拒绝访问</span>            <span class="hljs-keyword">this</span>.access_denied();        &#125;        <span class="hljs-comment">//从header中取jwt</span>        String jwtFromHeader = authService.getJwtFromHeader(request);        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(jwtFromHeader))&#123;            <span class="hljs-comment">//拒绝访问</span>            <span class="hljs-keyword">this</span>.access_denied();        &#125;        <span class="hljs-comment">//从redis取出jwt的过期时间</span>        <span class="hljs-keyword">long</span> expire = authService.getExpire(tokenFromCookie);        <span class="hljs-keyword">if</span> (expire &lt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//拒绝访问</span>            <span class="hljs-keyword">this</span>.access_denied();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//拒绝访问</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">access_denied</span><span class="hljs-params">()</span></span>&#123;        RequestContext requestContext = RequestContext.getCurrentContext();        requestContext.setSendZuulResponse(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 拒绝访问</span>        requestContext.setResponseStatusCode(<span class="hljs-number">200</span>);<span class="hljs-comment">// 设置响应状态码</span>        ResponseResult unauthenticated = <span class="hljs-keyword">new</span> ResponseResult(CommonCode.UNAUTHENTICATED);        String jsonString = JSON.toJSONString(unauthenticated);        requestContext.setResponseBody(jsonString);        requestContext.getResponse().setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);    &#125;&#125;</code></pre></div><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>1、配置代理</p><p>通过 <code>nginx</code> 转发到 <code>gateway</code>，在 <a href="http://www.xuecheng.com/" target="_blank" rel="noopener">www.xuecheng.com</a> 虚拟主机来配置</p><div class="hljs"><pre><code class="hljs c">#微服务网关upstream api_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">50201</span> weight=<span class="hljs-number">10</span>;&#125; #微服务网关location /api &#123;proxy_pass http:<span class="hljs-comment">//api_server_pool;</span>&#125;</code></pre></div><p>使用 <code>postman</code> 测试：</p><p>GET 请求：<a href="http://www.xuecheng.com/api/course/coursepic/get/4028e581617f945f01617f9dabc40000" target="_blank" rel="noopener">http://www.xuecheng.com/api/course/coursepic/get/4028e581617f945f01617f9dabc40000</a></p><p>注意：这里通过网关请求了 <code>course/coursepic/get</code> 地址，课程管理 <code>url</code> 根据自己的开发情况去配置放行。</p><h3 id="正常流程测试"><a href="#正常流程测试" class="headerlink" title="正常流程测试"></a>正常流程测试</h3><p>1、执行登录使之向 <code>cookie</code> 写入身份令牌 <code>uid</code></p><p>Post请求：<a href="http://ucenter.xuecheng.com/openapi/auth/userlogin" target="_blank" rel="noopener">http://ucenter.xuecheng.com/openapi/auth/userlogin</a></p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image31.png" srcset="/img/loading.gif" alt="image-20200531190540813"></p><p>并从redis获取jwt令牌的内容</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image32.png" srcset="/img/loading.gif" alt="image-20200531182147472"></p><p>2、手动在postman添加header</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image33.png" srcset="/img/loading.gif" alt="image-20200531201049165"></p><p>成功查询：</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image34.png" srcset="/img/loading.gif" alt="image-20200531201107131"></p><blockquote><p>这里要注意的是，如果这里出现 token验证失败，那就是你的课程管理管理服务的 resources 下的公钥文件于认证服务的私钥不匹配</p></blockquote><h3 id="异常流程测试"><a href="#异常流程测试" class="headerlink" title="异常流程测试"></a>异常流程测试</h3><p>手动删除 <code>header</code> 或清除 <code>cookie</code> 观察测试结果。</p><p><img src="/2020/08/25/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday17/image35.png" srcset="/img/loading.gif" alt="image-20200531201145872"></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zuul</tag>
      
      <tag>Spring Security</tag>
      
      <tag>Oauth2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day16：基于Spring Security Oauth2开发认证服务</title>
    <link href="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/"/>
    <url>/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day16</code> 的内容</p><ul><li>学习 Spring Security + Oauth2 基本概念以及实现过程。</li><li>学习 <code>Oauth2</code> 的基本应用场景，这里主要是通过 <code>Oauth2</code> 的密码模式来实战。</li><li>初识 <code>JWT</code> 令牌。</li><li>本章节的最后通过 <code>Spring Security Oauth2</code> 完成了认证服务的基本实现，但授权还没做。</li></ul><h1 id="一、用户需求分析"><a href="#一、用户需求分析" class="headerlink" title="一、用户需求分析"></a>一、用户需求分析</h1><h2 id="1-用户认证与授权"><a href="#1-用户认证与授权" class="headerlink" title="1. 用户认证与授权"></a>1. 用户认证与授权</h2><p>截至目前，项目已经完成了在线学习功能，用户通过在线学习页面点播视频进行学习。</p><p>如何去记录学生的学习过程呢？</p><p>要想掌握学生的学习情况就需要知道用户的身份信息，记录哪个用户在什么时间学习什么课程；如果用户要购买课程也需要知道用户的身份信息。所以，去管理学生的学习过程最基本的要实现用户的身份认证。</p><p>什么是用户身份认证？</p><p>用户身份认证即用户去访问 <code>系统资源</code> 时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证表现形式有：用户名密码登录，指纹打卡等方式。</p><p>什么是用户授权？</p><p>用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的 <code>权限</code>，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。</p><h2 id="2-单点登录需求"><a href="#2-单点登录需求" class="headerlink" title="2. 单点登录需求"></a>2. 单点登录需求</h2><p>本项目包括多个子项目，如：学习系统，教学管理中心、系统管理中心等，为了提高用户体验性需要实现用户只认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录。</p><p>引用百度百科：单点登录（Single Sign On），简称为 <code>SSO</code>，是目前比较流行的企业业务整合的解决方案之一。</p><p><code>SSO</code> 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。<br>下图是 <code>SSO</code> 的示意图，用户登录学成网一次即可访问多个系统。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image1" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image1.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-第三方认证需求"><a href="#3-第三方认证需求" class="headerlink" title="3. 第三方认证需求"></a>3. 第三方认证需求</h2><p>作为互联网项目难免需要访问外部系统的资源，同样本 <code>服务</code> 也要访问 <code>其他服务</code> 的资源接口。</p><p>一个微信用户没有在学成在线注册，本系统可以通过请求微信系统来验证该用户的身份，验证通过后该用户便可在本系统学习，它的基本流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image2" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>从上图可以看出，微信不属于本系统，本系统并没有存储微信用户的账号、密码等信息，本系统如果要获取该用户的基本信息则需要首先通过微信的认证系统（微信认证）进行认证，微信认证通过后本系统便可获取该微信用户的基本信息，从而在本系统将该微信用户的头像、昵称等信息显示出来，该用户便不用在本系统注册却可以直接学习。</p><p>什么是第三方认证（跨平台认证）？</p><p>当需要访问第三方系统的资源时需要首先通过第三方系统的认证（例如：微信认证），由第三方系统对用户认证通过，并授权资源的访问权限。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image3" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image3.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="二、用户认证技术方案"><a href="#二、用户认证技术方案" class="headerlink" title="二、用户认证技术方案"></a>二、用户认证技术方案</h1><h2 id="1-单点登录技术方案"><a href="#1-单点登录技术方案" class="headerlink" title="1. 单点登录技术方案"></a>1. 单点登录技术方案</h2><p>分布式系统要实现单点登录，通常将认证系统独立抽取出来，并且将用户身份信息存储在单独的存储介质，比如：<code>MySQL</code>、<code>Redis</code>，考虑性能要求，通常存储在 <code>Redis</code> 中，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image4" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>单点登录的特点是：</p><p>1、认证系统为独立的系统。</p><p>2、各个 <code>子系统</code> 通过 <code>Http</code> 或其它协议与认证系统通信，完成用户认证。</p><p>3、用户身份信息存储在 <code>Redis</code> 集群。</p><p>Java 中有很多用户认证的框架都可以实现单点登录：</p><p>1、Apache Shiro.</p><p>2、CAS</p><p>3、Spring security CAS</p><h2 id="2-Oauth2认证"><a href="#2-Oauth2认证" class="headerlink" title="2. Oauth2认证"></a>2. Oauth2认证</h2><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><p>第三方认证技术方案最主要是解决认证协议的通用标准 问题，因为要实现 跨系统认证，各系统之间要遵循一定的接口协议。</p><p><code>OAUTH</code> 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用 <code>OAUTH</code> 认证服务，任何服务提供商都可以实现自身的 <code>OAUTH</code> 认证服务，因而 <code>OAUTH</code> 是开放的。业界提供了 <code>OAUTH</code> 的多种实现如 <code>PHP</code>、<code>JavaScript</code>，<code>Java</code>，<code>Ruby</code> 等各种语言开发包，大大节约了程序员的时间，因而 <code>OAUTH</code> 是简易的。互联网很多服务如 <code>Open API</code>，很多大公司如 <code>Google</code>，<code>Yahoo</code>，<code>Microsoft</code> 等都提供了 <code>OAUTH</code> 认证服务，这些都足以说明 <code>OAUTH</code> 标准逐渐成为开放资源授权的标准。</p><p><code>Oauth</code> 协议目前发展到 <code>2.0</code> 版本，<code>1.0</code> 版本过于复杂，<code>2.0</code> 版本已得到广泛应用。</p><p>参考：<a href="https://baike.baidu.com/item/oAuth/7153134?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</a></p><p>Oauth协议：<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6749</a></p><p>下边分析一个Oauth2认证的例子，黑马程序员网站使用微信认证的过程：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image5" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>从流程图可以看出，用户首先需要访问黑马程序员的登录页面，登录页面中会有一个第三方登录的选项，例如选择微信来进行登录。</p><p>点击微信登录后，黑马程序员网站会向微信获取到一个认证授权的页面，并返回给客户端，客户端自动跳转到该 <code>认证授权页面</code> 进行微信的认证，当用户通过微信授权认证成功后，微信的认证服务器会返回一个授权码到客户端，客户端使用授权码向微信认证服务器申请 认证<code>token</code>，当用户获取到 <code>token</code> 后，会携带该 <code>token</code> 值去请求黑马程序员网站，黑马程序员通过该token向微信服务器获取到用户的微信信息后，黑马程序员网站才能确定该用户是可信的。</p><p>具体流程演示如下：</p><p>1、客户端请求第三方授权</p><p>用户进入黑马程序的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image6" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击“微信”出现一个二维码，此时用户扫描二维码，开始给黑马程序员授权。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image7" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image7.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、资源拥有者同意给客户端授权</p><p>资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证， 验证通过后，微信会询问用户是否给授权黑马程序员访问自己的微信数据，用户点击 “确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到黑马程序员的网站。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image8" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>3、客户端获取到授权码，请求认证服务器申请令牌</p><p>此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。</p><p>4、认证服务器向客户端响应令牌</p><p>认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在黑马程序员看到已经登录成功。</p><p>5、客户端请求资源服务器的资源</p><p>客户端携带令牌访问资源服务器的资源。黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。</p><p>6、资源服务器返回受保护资源</p><p>资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。<br>注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。</p><p><code>Oauth2.0</code> 认证流程如下：</p><p>引自 <code>Oauth2.0</code> 协议 <code>rfc6749</code> <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6749</a></p><p><a href="https://qnoss.codeyee.com/20200704_16/image9" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>Oauth2包括以下角色：</p><p>1、客户端</p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：学成在线Android客户端、学成在线Web客户端（浏览器端）、微信客户端等。</p><p>2、资源拥有者</p><p>通常为用户，也可以是应用程序，即该资源的拥有者。</p><p>3、授权服务器（也称认证服务器）<br>用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。</p><p>4、资源服务器<br>存储资源的服务器，比如，学成网用户管理服务器存储了学成网的用户信息，学成网学习服务器存储了学生的学习信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。</p><h3 id="Oauth2在本项目的应用"><a href="#Oauth2在本项目的应用" class="headerlink" title="Oauth2在本项目的应用"></a>Oauth2在本项目的应用</h3><p>Oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用 <code>Oauth2</code>，本项目使用 <code>Oauth2</code> 实现如下目标：</p><p>1、学成在线访问第三方系统的资源</p><p>2、外部系统访问学成在线的资源</p><p>3、学成在线前端（客户端） 访问学成在线微服务的资源。</p><p>4、学成在线微服务之间访问资源，例如：<code>微服务A</code> 访问 <code>微服务B</code> 的资源，<code>B</code> 访问 <code>A</code> 的资源。</p><h2 id="3-Spring-Security-Oauth2-认证解决方案"><a href="#3-Spring-Security-Oauth2-认证解决方案" class="headerlink" title="3. Spring Security Oauth2 认证解决方案"></a>3. Spring Security Oauth2 认证解决方案</h2><p>本项目采用 <code>Spring security + Oauth2</code> 完成用户认证及用户授权，<code>Spring security</code> 是一个强大的和高度可定制的身份验证和访问控制框架，<code>Spring security</code> 框架集成了<code>Oauth2</code> 协议，下图是项目认证架构图：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image10" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、用户请求认证服务完成认证。</p><p>2、认证服务下发用户身份令牌，拥有身份令牌表示身份合法。</p><p>3、用户携带令牌请求资源服务，请求资源服务必先经过网关。</p><p>4、网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问。</p><p>5、资源服务获取令牌，根据令牌完成授权。</p><p>6、资源服务完成授权则响应资源信息。</p><h1 id="三、Spring-Security-Oauth2-研究"><a href="#三、Spring-Security-Oauth2-研究" class="headerlink" title="三、Spring Security Oauth2 研究"></a>三、Spring Security Oauth2 研究</h1><h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. 目标</h2><p>本项目认证服务基于 <code>Spring Security Oauth2</code> 进行构建，并在其基础上作了一些扩展，采用 <code>JWT</code> 令牌机制，并自定义了用户身份信息的内容。 本教程的主要目标是学习在项目中集成<code>Spring Security Oauth2</code> 的方法和流程，通过 <code>Spring Security Oauth2</code> 的研究需要达到以下目标：</p><p>1、理解 <code>Oauth2</code> 的授权码认证流程及密码认证的流程。</p><p>2、理解 <code>Spring Security Oauth2</code> 的工作流程。</p><p>3、掌握资源服务集成 <code>Spring Security</code> 框架完成 <code>Oauth2</code> 认证的流程。</p><h2 id="2-搭建认证服务器"><a href="#2-搭建认证服务器" class="headerlink" title="2. 搭建认证服务器"></a>2. 搭建认证服务器</h2><h3 id="导入基础工程"><a href="#导入基础工程" class="headerlink" title="导入基础工程"></a>导入基础工程</h3><p>导入 <code>资料</code> 目录下的 <code>xc-service-ucenter-auth</code> 工程，该工程是基于<code>Spring Security Oauth2</code> 的一个二次封装的工程，导入此工程研究 <code>Oauth2</code> 认证流程。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>导入资料目录下的 <code>xc_user.sql</code>，创建用户数据库</p><p><a href="https://qnoss.codeyee.com/20200704_16/image11" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p>以 <code>oauth_</code> 开头的表都是 <code>Spring Security</code> 自带的表。</p><p>本项目中 Spring Security 主要使用 <code>oauth_client_details</code> 表：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image12" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image12.png" srcset="/img/loading.gif" alt="img"></a></p><ul><li>client_id：客户端id</li><li>resource_ids：资源id（暂时不用）</li><li>client_secret：客户端密码</li><li>scope：范围</li><li>access_token_validity：访问token的有效期（秒）</li><li>refresh_token_validity：刷新token的有效期（秒）</li><li>authorized_grant_type：授权类型，<ul><li>authorization_code</li><li>password</li><li>refresh_token</li><li>client_credentials</li></ul></li></ul><h2 id="3-Oauth2授权码模式"><a href="#3-Oauth2授权码模式" class="headerlink" title="3. Oauth2授权码模式"></a>3. Oauth2授权码模式</h2><p>Oauth2 有以下授权模式：</p><ul><li>授权码模式（Authorization Code）</li><li>隐式授权模式（Implicit）</li><li>密码模式（Resource Owner PasswordCredentials）</li><li>客户端模式（Client Credentials）</li></ul><p>其中授权码模式和密码模式应用较多，本小节介绍授权码模式。</p><h3 id="授权码授权流程"><a href="#授权码授权流程" class="headerlink" title="授权码授权流程"></a>授权码授权流程</h3><p>上边例举的黑马程序员网站使用微信认证的过程就是授权码模式，流程如下：</p><p>1、客户端请求第三方授权</p><p>2、用户(资源拥有者)同意给客户端授权</p><p>3、客户端获取到授权码，请求认证服务器申请令牌</p><p>4、认证服务器向客户端响应令牌</p><p>5、客户端请求资源服务器的资源，资源服务校验令牌合法性，完成授权</p><p>6、资源服务器返回受保护资源</p><h3 id="申请授权码"><a href="#申请授权码" class="headerlink" title="申请授权码"></a>申请授权码</h3><p>请求认证服务获取授权码：</p><p>GET 请求：</p><div class="hljs"><pre><code class="hljs c">localhost:<span class="hljs-number">40400</span>/auth/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scop=app&amp;redirect_uri=http:<span class="hljs-comment">//localhost</span></code></pre></div><p>参数列表如下：</p><ul><li>client_id：客户端 <code>id</code>，和授权配置类中设置的客户端id一致。</li><li>response_type：授权码模式固定为 <code>code</code></li><li>scop：客户端范围，和授权配置类中设置的 <code>scop</code>一致。</li><li>redirect_uri：跳转 <code>uri</code>，当授权码申请成功后会跳转到此地址，并在后边带上code参（授权码）。</li></ul><p>首次访问会跳转到登录页面：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image13" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image13.png" srcset="/img/loading.gif" alt="img"></a></p><p>输入账号和密码，点击 Login。</p><p><code>Spring Security</code> 接收到请求会调用 <code>UserDetailsService</code> 接口的 <code>loadUserByUsername</code> 方法查询用户正确的密码。</p><p>在 <code>oauth_client_details</code> 表中配置认证的账号和密码，当然密码是加密后储存的，这里我们暂时先不关注，后面再讲解</p><p><a href="https://qnoss.codeyee.com/20200704_16/image14" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image14.png" srcset="/img/loading.gif" alt="img"></a></p><p>账号密码为 <code>XcWebApp</code> 和 <code>XcWebApp</code></p><p>接下来进入授权页面：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image15" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image15.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击 同意，接下来返回授权码：认证服务携带授权码跳转 <code>redirect_uri</code></p><p><a href="https://qnoss.codeyee.com/20200704_16/image16" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image16.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="申请令牌"><a href="#申请令牌" class="headerlink" title="申请令牌"></a>申请令牌</h3><p>拿到授权码后，申请令牌。</p><p>POST 请求：<a href="http://localhost:40400/auth/oauth/token" target="_blank" rel="noopener">http://localhost:40400/auth/oauth/token</a></p><p>参数如下：</p><ul><li>grant_type：授权类型，填写authorization_code，表示授权码模式</li><li>code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</li><li>redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</li></ul><p>此链接需要使用 http Basic认证。</p><p>什么是 <code>http Basic</code>认证？</p><p><code>http</code> 协议定义的一种认证方式，将客户端id和客户端密码按照 <code>客户端ID:客户端密码</code> 的格式拼接，并用 <code>base64</code> 编码，放在 <code>header</code> 中请求服务端，一个例子：</p><p>Authorization：Basic WGNXZWJBcHA6WGNXZWJBcHA=</p><p>WGNXZWJBcHA6WGNXZWJBcHA= 是 <code>用户名:密码</code> 的 base64 编码。</p><p>如果认证失败服务端会返回 <code>401 Unauthorized</code></p><p>以上测试使用 <code>postman</code> 完成。</p><p>http basic认证：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image17" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image17.png" srcset="/img/loading.gif" alt="img"></a></p><p>客户端 <code>Id</code> 和客户端密码会匹配数据库 <code>oauth_client_details</code> 表中的客户端 <code>id</code> 及客户端密码。</p><p>POST 请求参数：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image18" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击发送：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image19" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image19.png" srcset="/img/loading.gif" alt="img"></a></p><p>申请令牌成功。</p><ul><li>access_token：访问令牌，携带此令牌访问资源</li><li>token_type：有 <code>MAC Token</code>与 <code>Bearer Token</code>两种类型，两种的校验算法不同，RFC 6750建议Oauth2采用 Bearer</li><li>Token（<a href="http://www.rfcreader.com/#rfc6750%EF%BC%89%E3%80%82" target="_blank" rel="noopener">http://www.rfcreader.com/#rfc6750）。</a></li><li>refresh_token：刷新令牌，使用此令牌可以延长访问令牌的过期时间。</li><li>expires_in：过期时间，单位为秒。</li><li>scope：范围，与定义的客户端范围一致。</li></ul><h3 id="资源服务授权"><a href="#资源服务授权" class="headerlink" title="资源服务授权"></a>资源服务授权</h3><h4 id="1）授权流程"><a href="#1）授权流程" class="headerlink" title="1）授权流程"></a>1）授权流程</h4><p>资源服务拥有要访问的受保护资源，客户端携带令牌访问资源服务，如果令牌合法则可成功访问资源服务中的资源，流程如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image20" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image20.png" srcset="/img/loading.gif" alt="img"></a></p><p>上图的业务流程如下：</p><p>1、客户端请求认证服务申请令牌</p><p>2、认证服务生成令牌认证服务采用非对称加密算法，使用私钥生成令牌。</p><p>3、客户端携带令牌访问资源服务客户端在 <code>Http header</code> 中添加： <code>Authorization：Bearer 令牌</code>。</p><blockquote><p>注意这里的Authorization字段的值为 Bearer + 空格 + 令牌</p></blockquote><p>4、资源服务请求认证服务校验令牌的有效性资源服务接收到令牌，使用公钥校验令牌的合法性。</p><p>5、令牌有效，资源服务向客户端响应资源信息</p><h4 id="2）授权配置"><a href="#2）授权配置" class="headerlink" title="2）授权配置"></a>2）授权配置</h4><p>基本上所有微服务都是资源服务，这里我们在 <code>课程管理服务</code> 上配置授权控制，当配置了授权控制后如要访问课程信息则必须提供令牌。</p><p>在我们导入的 <code>auth</code> 工程的 <code>resources</code> 下可以看到一个 <code>xc.keystore</code> 文件，该文件是用于认证的一个私钥文件，用于生成我们的授权码，生成的授权码可以使用 <code>公钥</code> 文件来进行校验。下面我们来做一个简单的实验来了解整个校验的流程。</p><p>1、配置公钥</p><p>认证服务生成令牌采用非对称加密算法，认证服务采用私钥加密生成令牌，对外向资源服务提供公钥，资源服务使<br>用公钥 来校验令牌的合法性。</p><p>将 <code>day16</code> 的 <code>资料</code> 下的公钥拷贝到 <code>publickey.txt</code> 文件中，将此文件拷贝到资源服务工程的 <code>classpath</code> 下</p><p><a href="https://qnoss.codeyee.com/20200704_16/image21" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image21.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、添加依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--oatuh2--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>4、在 <code>config</code> 包下创建 ResourceServerConfig 类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.config;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>, securedEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-comment">//激活方法上的PreAuthorize注解</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;  <span class="hljs-comment">//公钥</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PUBLIC_KEY = <span class="hljs-string">"publickey.txt"</span>;  <span class="hljs-comment">//定义JwtTokenStore，使用jwt令牌</span>  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">(JwtAccessTokenConverter jwtAccessTokenConverter)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter);  &#125;  <span class="hljs-comment">//定义JJwtAccessTokenConverter，使用jwt令牌</span>  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;    JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();    converter.setVerifierKey(getPubKey());    <span class="hljs-keyword">return</span> converter;  &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">      * 获取非对称加密公钥 Key</span><span class="hljs-comment">      * <span class="hljs-doctag">@return</span> 公钥 Key</span><span class="hljs-comment">      */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getPubKey</span><span class="hljs-params">()</span> </span>&#123;    Resource resource = <span class="hljs-keyword">new</span> ClassPathResource(PUBLIC_KEY);    <span class="hljs-keyword">try</span> &#123;      InputStreamReader inputStreamReader = <span class="hljs-keyword">new</span>          InputStreamReader(resource.getInputStream());      BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(inputStreamReader);      <span class="hljs-keyword">return</span> br.lines().collect(Collectors.joining(<span class="hljs-string">"\n"</span>));    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;  &#125;  <span class="hljs-comment">//Http安全配置，对每个到达系统的http请求链接进行校验</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//所有请求必须认证通过</span>    http.authorizeRequests().anyRequest().authenticated();  &#125;&#125;</code></pre></div><h4 id="3）授权测试"><a href="#3）授权测试" class="headerlink" title="3）授权测试"></a>3）授权测试</h4><p>这里我们使用 <code>POSTMAN</code> 测试课程图片查询</p><p>GET <a href="http://localhost:31200/course/coursepic/list/4028e58161bd3b380161bd3bcd2f0000" target="_blank" rel="noopener">http://localhost:31200/course/coursepic/list/4028e58161bd3b380161bd3bcd2f0000</a></p><p>请求时没有携带令牌则报错：</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"error"</span>: <span class="hljs-string">"unauthorized"</span>,<span class="hljs-attr">"error_description"</span>: <span class="hljs-string">"Full authentication is required to access this resource"</span>&#125;</code></pre></div><p>请求时携带令牌：</p><p>在 <code>http header</code> 中添加 <code>Authorization： Bearer</code> 令牌</p><p><a href="https://qnoss.codeyee.com/20200704_16/image22" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>当输入错误的令牌也无法正常访问资源。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image23" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image23.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="4）解决swagger-ui无法访问"><a href="#4）解决swagger-ui无法访问" class="headerlink" title="4）解决swagger-ui无法访问"></a>4）解决swagger-ui无法访问</h4><blockquote><p>这个问题可以单独提取出来，发布到csdn上。</p></blockquote><p>当课程管理加了授权之后再访问 <code>swagger-ui</code> 则报错</p><p><a href="https://qnoss.codeyee.com/20200704_16/image24" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image24.png" srcset="/img/loading.gif" alt="img"></a></p><p>修改授权配置类 <code>ResourceServerConfig</code> 的 <code>configure</code> 方法：</p><p>针对 <code>swagger-ui</code> 的请求路径进行放行：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//Http安全配置，对每个到达系统的http请求链接进行校验</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//所有请求必须认证通过</span>    http.authorizeRequests()            <span class="hljs-comment">//下边的路径放行</span>            .antMatchers(<span class="hljs-string">"/v2/api-docs"</span>, <span class="hljs-string">"/swagger-resources/configuration/ui"</span>,                    <span class="hljs-string">"/swagger-resources"</span>,<span class="hljs-string">"/swagger-resources/configuration/security"</span>,                    <span class="hljs-string">"/swagger-ui.html"</span>,<span class="hljs-string">"/webjars/**"</span>).permitAll()            .anyRequest().authenticated();&#125;</code></pre></div><p>注意：</p><p>通过上边的配置虽然可以访问 <code>swagger-ui</code>，但是无法进行单元测试，除非去掉认证的配置或在上边配置中添加所有请求均放行（”/**”）。</p><p>但是需要注意的是，虽说在开发环境下我们可与通过使用 <code>/**</code> 的方式来便于我们进行单元测试，但是难免会有疏漏的时候，如果在生产上线时没有及时改回来，那么后果不堪设想。</p><p>所以我们可以考虑使用多环境配置的形式，将需要放行的 <code>url</code> 从配置文件 <code>application.yml</code> 中读取，而开发环境中，我们可以单独配置一个 <code>application-dev.yml</code> 作为我们的开发环境的配置，用于区别上线环境的配置。例如下面的例子</p><p><code>application-dev.yml</code> 加入 <code>oauth2.urlMatchers</code> ，在该字段下指定我们无需授权访问的一些url地址，使用 <code>,</code> 进行分割</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">oauth2:</span>  <span class="hljs-attr">urlMatchers:</span> <span class="hljs-string">/v2/api-docs,/swagger-resources/configuration/ui,/swagger-resources,/swagger-resources/configuration/security,/swagger-ui.html,/webjars/**</span></code></pre></div><p>而在生产环境中的配置 <code>application-dev.yml</code> 你可以不配置 urlMatchers 的值，这样所有的url都需要认证后才能访问，当然，你也可以添加一些例外。如下则是全部 <code>url</code> 都拦截的情况的配置，虽然没有值，但是我们也要在配置文件中写出这个 <code>urlMatchers</code> 字段，便于后面的拓展工作。</p><div class="hljs"><pre><code class="hljs c">oauth2:  urlMatchers:</code></pre></div><p>那么我们的配置类 <code>ResourceServerConfig</code> 就应该做出如下的修改：</p><p>使用 <code>@Value</code> 注解获取配置文件中 <code>urlMatchers</code> 的值，在 <code>configure</code> 方法下做出相关的操作。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;oauth2.urlMatchers&#125;"</span>)String urlMatchers;<span class="hljs-comment">//Http安全配置，对每个到达系统的http请求链接进行校验</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span>(urlMatchers.equals(<span class="hljs-string">""</span>))&#123;        <span class="hljs-comment">//如果urlMatchers未指定,则所有url都需要授权后才能被访问</span>        http.authorizeRequests().anyRequest().authenticated();    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//放行 urlMatchers 中指定的url条目, 未指定的url仍需授权后才能访问</span>        String[] split = urlMatchers.split(<span class="hljs-string">","</span>);        http.authorizeRequests()            <span class="hljs-comment">//下边的路径放行</span>            .antMatchers(split).permitAll()            .anyRequest().authenticated();    &#125;&#125;</code></pre></div><h2 id="4-Oauth2密码模式认证"><a href="#4-Oauth2密码模式认证" class="headerlink" title="4. Oauth2密码模式认证"></a>4. Oauth2密码模式认证</h2><p>密码模式（Resource Owner Password Credentials）与授权码模式的区别是申请令牌不再使用授权码，而是直接<br>通过用户名和密码即可申请令牌。</p><p>测试如下：</p><p>POST 请求：<a href="http://localhost:40400/auth/oauth/token" target="_blank" rel="noopener">http://localhost:40400/auth/oauth/token</a></p><p>参数：</p><ul><li>grant_type：密码模式授权填写password</li><li>username：账号</li><li>password：密码</li></ul><p>那么这个密码信息是从哪里获取到的？</p><p>在我们的 auth 服务工程中可以看到，我们写了一个 <code>UserDetailsService</code> 的实现类。</p><p>这个实现类中实现了 <code>loadUserByUsername</code> 方法，在该方法中，首先会验证提交请求中带有的 App 用户密码信息是否正确，也就是我们提交的 <code>http Basic</code> 认证信息，App的认证信息通过后，会出数据库获取用户的认证信息和权限信息进行设置，然后再根据我们提交的信息进行比对。但在当前的测试中，我们是直接在 <code>loadUserByUsername</code> 方法内自定义了一个账号和密码，便于我们测试，完整的认证授权流程会在后面的内容中讲到。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//设置用户的认证和权限信息</span>XcUserExt userext = <span class="hljs-keyword">new</span> XcUserExt();userext.setUsername(<span class="hljs-string">"mrt"</span>);userext.setPassword(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>));userext.setPermissions(<span class="hljs-keyword">new</span> ArrayList&lt;XcMenu&gt;());<span class="hljs-keyword">if</span>(userext == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>使用 <code>http Basic</code> 进行App的身份认证，这里我们的账号和密码都为 <code>XcWebApp</code>。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image25" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image25.png" srcset="/img/loading.gif" alt="img"></a></p><p>上边参数使用 <code>x-www-form-urlencoded</code> 方式传输，使用postman测试如下：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image26" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image26.png" srcset="/img/loading.gif" alt="img"></a></p><p>那么，授权码模式与密码模式，分别都适用于哪些场景？</p><ul><li>授权码模式一般适用于提供给第三方进行认证，例如在前面提到的在黑马程序员网站进行微信登录时，这里我们的角色就应该对应的是 <code>微信的认证服务器</code>，而黑马程序员网站属于第三方。</li><li>密码模式在我们后续的开发中会经常用到，一般用于我们微服务间的认证以及用户的前台、后台权限管理等场景。</li></ul><h2 id="5-校验令牌"><a href="#5-校验令牌" class="headerlink" title="5. 校验令牌"></a>5. 校验令牌</h2><p>Spring Security Oauth2 提供校验令牌的端点，如下：</p><p>GET: <a href="http://localhost:40400/auth/oauth/check_token?token=" target="_blank" rel="noopener">http://localhost:40400/auth/oauth/check_token?token=</a></p><p>参数：</p><ul><li>token：令牌</li></ul><p>使用 <code>postman</code> 测试如下：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image27" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image27.png" srcset="/img/loading.gif" alt="img"></a></p><p>结果如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"companyId"</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">"userpic"</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">"user_name"</span>: <span class="hljs-string">"itcast"</span>,    <span class="hljs-attr">"scope"</span>: [        <span class="hljs-string">"app"</span>    ],    <span class="hljs-attr">"name"</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">"utype"</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">"active"</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">"id"</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">"exp"</span>: <span class="hljs-number">1590351690</span>,    <span class="hljs-attr">"jti"</span>: <span class="hljs-string">"ed441eb3-cd16-4e74-b598-484656a03287"</span>,    <span class="hljs-attr">"client_id"</span>: <span class="hljs-string">"XcWebApp"</span>&#125;</code></pre></div><ul><li>exp：过期时间，long类型，距离1970年的秒数（new Date().getTime()可得到当前时间距离1970年的毫秒数）。</li><li>user_name： 用户名</li><li>client_id：客户端Id，在oauth_client_details中配置</li><li>scope：客户端范围，在oauth_client_details表中配置</li><li>jti：与令牌对应的唯一标识</li><li>companyId、userpic、name、utype、id：这些字段是本认证服务在Spring Security基础上扩展的用户身份信息</li></ul><p>我们可以根据这些数据进行一些相关的操作。</p><h2 id="6-刷新令牌"><a href="#6-刷新令牌" class="headerlink" title="6. 刷新令牌"></a>6. 刷新令牌</h2><p>刷新令牌是当令牌快过期时重新生成一个令牌，它于授权码授权和密码授权生成令牌不同，刷新令牌不需要授权码<br>也不需要账号和密码，只需要一个 <code>刷新令牌</code>、<code>客户端id</code> 和 <code>客户端密码</code>。</p><p>测试如下：</p><p>POST：<a href="http://localhost:40400/auth/oauth/token" target="_blank" rel="noopener">http://localhost:40400/auth/oauth/token</a></p><p>参数：</p><ul><li>grant_type： 固定为 refresh_token</li><li>refresh_token：刷新令牌（注意不是 <code>access_token</code>，而是 <code>refresh_token</code>）</li></ul><p>刷新令牌成功，会重生成新的访问令牌和刷新令牌，令牌的有效期也比旧令牌长。</p><p>刷新令牌通常是在令牌快过期时进行刷新。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image28" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image28.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="7-JWT研究"><a href="#7-JWT研究" class="headerlink" title="7. JWT研究"></a>7. JWT研究</h2><h3 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h3><p>在介绍JWT之前先看一下传统校验令牌的方法，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image29" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image29.png" srcset="/img/loading.gif" alt="img"></a></p><p>问题：</p><p>传统授权方法的问题是用户每次请求资源服务，资源服务都需要携带令牌访问认证服务去校验令牌的合法性，并根<br>据令牌获取用户的相关信息，性能低下。</p><p>解决：</p><p>使用 <code>JWT</code> 的思路是，用户认证通过会得到一个 <code>JWT</code> 令牌，<code>JWT</code> 令牌中已经包括了用户相关的信息，客户端只需要携带 <code>JWT</code> 访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。<code>JWT</code> 令牌授权过程如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image30" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image30.png" srcset="/img/loading.gif" alt="img"></a></p><p>什么是 <code>JWT</code> ？</p><p>JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于<br>在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。<code>JWT</code> 可以使用 <code>HMAC</code> 算法或使用 <code>RSA</code>的公钥/私钥对来签名，防止被篡改。</p><p>官网：<a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p><p>标准：<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7519</a></p><p><code>JWT</code> 令牌的优点：</p><p>1、jwt基于 <code>json</code>，非常方便解析。</p><p>2、可以在令牌中自定义丰富的内容，易扩展。</p><p>3、通过非对称加密算法及数字签名技术，<code>JWT</code> 防止篡改，安全性高。</p><p>4、资源服务使用JWT可不依赖认证服务即可完成授权。</p><p>缺点：JWT令牌较长，占存储空间比较大。</p><h4 id="令牌结构"><a href="#令牌结构" class="headerlink" title="令牌结构"></a>令牌结构</h4><p>通过学习JWT令牌结构为自定义 <code>jwt</code> 令牌打好基础。</p><p>JWT 令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p><p><strong>1、Header</strong></p><p>头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）<br>下边是Header部分的内容</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"alg"</span>: <span class="hljs-string">"HS256"</span>,    <span class="hljs-attr">"typ"</span>: <span class="hljs-string">"JWT"</span>&#125;</code></pre></div><p><strong>2、Payload</strong></p><p>第二部分是用于储存一些有效信息，内容也是一个 <code>json</code>对象，它可以存放 <code>jwt</code> 提供的现成字段，比如：<code>iss</code>（签发者）,<code>exp</code>（过期时间戳）, <code>sub</code>（面向的用户）等，也可自定义字段。</p><p>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</p><p>最后将第二部分负载使用 <code>Base64Url</code> 编码，得到一个字符串就是JWT令牌的第二部分。</p><p>一个例子 ：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"sub"</span>: <span class="hljs-string">"1234567890"</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"456"</span>,    <span class="hljs-attr">"admin"</span>: <span class="hljs-literal">true</span>&#125;</code></pre></div><p><strong>3、Signature</strong></p><p>第三部分是签名，此部分用于防止jwt内容被篡改。</p><p>这个部分使用 <code>base64url</code> 将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明<br>签名算法进行签名。</p><p>一个例子：</p><div class="hljs"><pre><code class="hljs lisp">HMACSHA256(<span class="hljs-name">base64UrlEncode</span>(<span class="hljs-name">header</span>) + <span class="hljs-string">"."</span> +base64UrlEncode(<span class="hljs-name">payload</span>),secret)</code></pre></div><ul><li>base64UrlEncode(header)：jwt令牌的第一部分。</li><li>base64UrlEncode(payload)：jwt令牌的第二部分。</li><li>secret：签名所使用的密钥。</li></ul><h3 id="JWT入门"><a href="#JWT入门" class="headerlink" title="JWT入门"></a>JWT入门</h3><p>Spring Security 提供对 <code>JWT</code> 的支持，本节我们使用 <code>Spring Security</code> 提供的 <code>JwtHelper</code> 来创建JWT令牌，校验JWT令牌等操作。</p><h4 id="生成私钥和公钥"><a href="#生成私钥和公钥" class="headerlink" title="生成私钥和公钥"></a>生成私钥和公钥</h4><p>JWT令牌生成采用非对称加密算法</p><p>1、生成密钥证书</p><p>下边命令生成密钥证书，采用RSA 算法每个证书包含公钥和私钥</p><div class="hljs"><pre><code class="hljs shell">keytool -genkeypair -alias xckey -keyalg RSA -keypass xuecheng -keystore xc.keystore -storepass xuechengkeystore</code></pre></div><p><code>Keytool</code> 是一个 <code>java</code> 提供的证书管理工具，以下是参数的说明</p><ul><li>-alias：密钥的别名</li><li>-keyalg：使用的hash算法</li><li>-keypass：密钥的访问密码</li><li>-keystore：密钥库文件名，xc.keystore保存了生成的证书</li><li>-storepass：密钥库的访问密码</li></ul><p>查询证书信息：</p><div class="hljs"><pre><code class="hljs applescript">keytool -<span class="hljs-built_in">list</span> -keystore xc.keystore</code></pre></div><p><a href="https://qnoss.codeyee.com/20200704_16/image31" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image31.png" srcset="/img/loading.gif" alt="img"></a></p><p>删除别名：</p><div class="hljs"><pre><code class="hljs d">keytool -<span class="hljs-keyword">delete</span> -<span class="hljs-keyword">alias</span> xckey -keystore xc.keystore</code></pre></div><p>2、导出公钥</p><p><code>openssl</code> 是一个加解密工具包，这里使用openssl来导出公钥信息。</p><p>安装 openssl：<a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p><p>安装完成后，配置 <code>openssl</code> 的 <code>path</code> 环境变量，本教程配置在 <code>D:\OpenSSL-Win64\bin</code></p><p>在命令行进入 <code>xc.keystore</code> 文件所在目录执行如下命令：</p><div class="hljs"><pre><code class="hljs applescript">keytool -<span class="hljs-built_in">list</span> -rfc <span class="hljs-comment">--keystore xc.keystore | openssl x509 -inform pem -pubkey</span></code></pre></div><p>输入密钥库密码，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image32" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image32.png" srcset="/img/loading.gif" alt="img"></a></p><p>复制生成出来的公钥数据</p><p><a href="https://qnoss.codeyee.com/20200704_16/image33" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image33.png" srcset="/img/loading.gif" alt="img"></a></p><p>将上边的公钥拷贝到文本文件中，<code>合并为一行</code>，换行会有换行符，所以尽可能的避免一些我的发生 ，可以用<code>notepad++</code> 直接替换换行符 <code>\n</code> 如下图，当然你也可以手动的合并成一行。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image34" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image34.png" srcset="/img/loading.gif" alt="img"></a></p><div class="hljs"><pre><code class="hljs jboss-cli"><span class="hljs-params">-----BEGIN</span> PUBLIC KEY<span class="hljs-params">-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAi1pGvYqLcTG2dcKhrtisQgkB90iWaCwE4OriDwCLMdiUV2NViEn</span>+r/jMbuIFCBtnB21yWZlIPnXjzcre/8HIUJy2dMWqP9NUhzoCzwdC1I9clZRVHTpe1H0eiaQY4BLxz5EScBZdr5u4Q0hT+t6D3t7qQg1MHxLBaFy2<span class="hljs-keyword">cd</span>HQbmz5Ly/1mmnWBHmFgjbbNG7gfaO3jRCl7RbNVUfSjb6gN+MfpyLk/iXr5S8Qhc2X07hvtm09QEk3cl14tQkZkXAUk7rAl9kgPSKoKr4MAdiYEsVNplKd4LMs4S2AC0dYrhdIX754eo6u4Ehpe6v5hSsF2d3ZpuV7nJ6JDCNxo7tU9wIDAQAB<span class="hljs-params">-----END</span> PUBLIC KEY<span class="hljs-params">-----</span></code></pre></div><h4 id="生成jwt令牌"><a href="#生成jwt令牌" class="headerlink" title="生成jwt令牌"></a>生成jwt令牌</h4><p>在认证工程创建测试类，测试jwt令牌的生成与验证。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.auth;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<span class="hljs-keyword">import</span> org.springframework.security.jwt.Jwt;<span class="hljs-keyword">import</span> org.springframework.security.jwt.JwtHelper;<span class="hljs-keyword">import</span> org.springframework.security.jwt.crypto.sign.RsaSigner;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.provider.token.store.KeyStoreKeyFactory;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="hljs-keyword">import</span> java.security.KeyPair;<span class="hljs-keyword">import</span> java.security.interfaces.RSAPrivateKey;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">JwtTest</span> </span>&#123;    <span class="hljs-comment">//生成一个jwt令牌</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateJwt</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//证书文件</span>        String key_location = <span class="hljs-string">"xc.keystore"</span>;        <span class="hljs-comment">//密钥库密码</span>        String keystore_password = <span class="hljs-string">"xuechengkeystore"</span>;        <span class="hljs-comment">//访问证书路径</span>        ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(key_location);        <span class="hljs-comment">//密钥工厂</span>        KeyStoreKeyFactory keyStoreKeyFactory = <span class="hljs-keyword">new</span> KeyStoreKeyFactory(resource, keystore_password.toCharArray());        <span class="hljs-comment">//密钥的密码，此密码和别名要匹配</span>        String keypassword = <span class="hljs-string">"xuecheng"</span>;        <span class="hljs-comment">//密钥别名</span>        String alias = <span class="hljs-string">"xckey"</span>;        <span class="hljs-comment">//密钥对（密钥和公钥）</span>        KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias,keypassword.toCharArray());        <span class="hljs-comment">//私钥</span>        RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate();        <span class="hljs-comment">//定义payload信息</span>        Map&lt;String, Object&gt; tokenMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        tokenMap.put(<span class="hljs-string">"id"</span>, <span class="hljs-string">"123"</span>);        tokenMap.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"mrt"</span>);        tokenMap.put(<span class="hljs-string">"roles"</span>, <span class="hljs-string">"r01,r02"</span>);        tokenMap.put(<span class="hljs-string">"ext"</span>, <span class="hljs-string">"1"</span>);        <span class="hljs-comment">//生成jwt令牌</span>        Jwt jwt = JwtHelper.encode(JSON.toJSONString(tokenMap), <span class="hljs-keyword">new</span> RsaSigner(aPrivate));        <span class="hljs-comment">//取出jwt令牌</span>        String token = jwt.getEncoded();        System.out.println(token);    &#125;&#125;</code></pre></div><h4 id="验证jwt令牌"><a href="#验证jwt令牌" class="headerlink" title="验证jwt令牌"></a>验证jwt令牌</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//资源服务使用公钥验证jwt的合法性，并对jwt解码</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testVerify</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//jwt令牌</span>    String token =<span class="hljs-string">""</span>;    <span class="hljs-comment">//公钥</span>    String publickey = <span class="hljs-string">""</span>;    <span class="hljs-comment">//校验jwt</span>    Jwt jwt = JwtHelper.decodeAndVerify(token, <span class="hljs-keyword">new</span> RsaVerifier(publickey));    <span class="hljs-comment">//获取jwt原始内容</span>    String claims = jwt.getClaims();    System.out.println(claims);    <span class="hljs-comment">//jwt令牌</span>    String encoded = jwt.getEncoded();    System.out.println(encoded);&#125;</code></pre></div><h1 id="四、认证服务开发"><a href="#四、认证服务开发" class="headerlink" title="四、认证服务开发"></a>四、认证服务开发</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>用户登录的流程图如下</p><p><a href="https://qnoss.codeyee.com/20200704_16/image35" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image35.png" srcset="/img/loading.gif" alt="img"></a></p><p>执行流程：</p><p>1、用户登录，请求认证服务</p><p>2、认证服务认证通过，生成 <code>jwt</code> 令牌，将 <code>jwt</code> 令牌及相关信息写入 <code>Redis</code>，并且将身份令牌写入 <code>cookie</code></p><p>3、用户访问资源页面，带着 <code>cookie</code> 到网关</p><p>4、网关从 <code>cookie</code> 获取 <code>token</code>，并查询 <code>Redis</code> 校验 <code>token</code>,如果 <code>token</code> 不存在则拒绝访问，否则放行</p><p>5、用户退出，请求认证服务，清除 <code>redis</code> 中的 <code>token</code>，并且删除 <code>cookie</code> 中的 <code>token</code></p><p>使用 <code>redis</code> 存储用户的身份令牌有以下作用：</p><p>1、实现用户退出注销功能，服务端清除令牌后，即使客户端请求携带 <code>token</code> 也是无效的。</p><p>2、由于 <code>jwt</code> 令牌过长，不宜存储在 cookie 中，所以将 jwt 的 <code>身份令牌</code> 存储在 <code>redis</code>，客户端请求服务端时附带这个 <code>身份令牌</code>，服务端根据身份令牌到 <code>redis</code> 中取出身份令牌对应的 jwt 令牌。</p><h2 id="2-Redis配置"><a href="#2-Redis配置" class="headerlink" title="2. Redis配置"></a>2. Redis配置</h2><h3 id="安装Redis服务"><a href="#安装Redis服务" class="headerlink" title="安装Redis服务"></a>安装Redis服务</h3><p>下载Windows版本的redis：<a href="https://github.com/MicrosoftArchive/redis/tags" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/tags</a></p><p>下载 <code>msi</code> 安装包进行安装</p><p>刷新服务，会看到多了一个 <code>redis</code> 服务。</p><p><a href="https://qnoss.codeyee.com/20200704_16/image36" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image36.png" srcset="/img/loading.gif" alt="img"></a></p><p>如果下载的是zip包</p><p>运行</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">redis</span>‐<span class="hljs-selector-tag">server</span> <span class="hljs-selector-tag">redis</span><span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span></code></pre></div><p>注册为服务：</p><div class="hljs"><pre><code class="hljs cmd">redis‐server ‐‐service‐install redis.windows‐service.conf ‐‐loglevel verbose</code></pre></div><p>常用的 redis 服务命令如下：</p><p>卸载服务：<code>sc delete Redis</code></p><p>开启服务：<code>net start Redis</code></p><p>停止服务：<code>net stop Redis</code></p><p>下载 windows 版本的redis客户端：<a href="https://redisdesktop.com/download" target="_blank" rel="noopener">https://redisdesktop.com/download</a></p><p>下载 redis-desktop-manager-0.9.2.806.exe</p><p>安装后启动 <code>redis</code> 客户端：</p><p>配置 <code>redis</code> 链接：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image37" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image37.png" srcset="/img/loading.gif" alt="img"></a></p><p>连接成功</p><p><a href="https://qnoss.codeyee.com/20200704_16/image38" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image38.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="redis连接配置"><a href="#redis连接配置" class="headerlink" title="redis连接配置"></a>redis连接配置</h3><p>在认证服务的 <code>application.yml</code> 文件中添加如下配置：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span><span class="hljs-attr">name:</span> <span class="hljs-string">xc‐service‐ucenter‐auth</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;REDIS_HOST:127.0.0.1&#125;</span>    <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;REDIS_PORT:6379&#125;</span>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span> <span class="hljs-comment">#连接超时 毫秒</span>    <span class="hljs-attr">jedis:</span>     <span class="hljs-attr">pool:</span>        <span class="hljs-attr">maxActive:</span> <span class="hljs-number">3</span>        <span class="hljs-attr">maxIdle:</span> <span class="hljs-number">3</span>        <span class="hljs-attr">minIdle:</span> <span class="hljs-number">1</span>        <span class="hljs-attr">maxWait:</span> <span class="hljs-string">‐1</span> <span class="hljs-comment">#连接池最大等行时间 ‐1没有限制</span></code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RedisTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRedis</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//定义key</span>        String key = <span class="hljs-string">"user_token:9734b68f‐cf5e‐456f‐9bd6‐df578c711390"</span>;        <span class="hljs-comment">//定义Map</span>        Map&lt;String,String&gt; mapValue = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        mapValue.put(<span class="hljs-string">"id"</span>,<span class="hljs-string">"101"</span>);        mapValue.put(<span class="hljs-string">"username"</span>,<span class="hljs-string">"itcast"</span>);        String value = JSON.toJSONString(mapValue);        <span class="hljs-comment">//向redis中存储字符串</span>        stringRedisTemplate.boundValueOps(key).set(value,<span class="hljs-number">60</span>, TimeUnit.SECONDS);        <span class="hljs-comment">//读取过期时间，已过期返回‐2</span>        Long expire = stringRedisTemplate.getExpire(key);        <span class="hljs-comment">//根据key获取value</span>        String s = stringRedisTemplate.opsForValue().get(key);        System.out.println(s);    &#125;&#125;</code></pre></div><h2 id="3-认证服务"><a href="#3-认证服务" class="headerlink" title="3. 认证服务"></a>3. 认证服务</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>认证服务需要实现的功能如下：</p><p>1、登录接口</p><p>前端post提交账号、密码等，用户身份校验通过，生成令牌，并将令牌存储到redis。<br>将令牌写入cookie。</p><p>2、退出接口</p><p>校验当前用户的身份为合法并且为已登录状态。</p><p>将令牌从redis删除。</p><p>删除cookie中的令牌。</p><p>业务流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_16/image39" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image39.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="Api接口"><a href="#Api接口" class="headerlink" title="Api接口"></a>Api接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"用户认证"</span>,description = <span class="hljs-string">"用户认证接口"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"登录"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> LoginResult <span class="hljs-title">login</span><span class="hljs-params">(LoginRequest loginRequest)</span></span>;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"退出"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">logout</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>在 <code>application.yml</code> 中配置参数</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">auth:</span>  <span class="hljs-attr">tokenValiditySeconds:</span> <span class="hljs-number">1200</span> <span class="hljs-comment">#token存储到redis的过期时间</span>  <span class="hljs-attr">clientId:</span> <span class="hljs-string">XcWebApp</span>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">XcWebApp</span>  <span class="hljs-attr">cookieDomain:</span> <span class="hljs-string">localhost</span>  <span class="hljs-attr">cookieMaxAge:</span> <span class="hljs-string">‐1</span></code></pre></div><h3 id="申请令牌测试"><a href="#申请令牌测试" class="headerlink" title="申请令牌测试"></a>申请令牌测试</h3><p>为了不破坏 <code>Spring Security</code> 的代码，我们在 <code>Service</code> 方法中通过 <code>RestTemplate</code> 请求 <code>Spring Security</code> 所暴露的申请令<br>牌接口来申请令牌，下边是测试代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestClient</span> </span>&#123;    <span class="hljs-comment">//Eureka负载均衡客户端</span>    <span class="hljs-meta">@Autowired</span>    LoadBalancerClient loadBalancerClient;    <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testClient</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//采用客户端负载均衡的方式从eureka获取认证服务的ip和端口</span>        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">"XC-SERVICE-UCENTER-AUTH"</span>);        URI uri = serviceInstance.getUri();        String authUrl = uri + <span class="hljs-string">"/auth/oauth/token"</span>;        <span class="hljs-comment">//使用LinkedMultiValueMap储存多个header信息</span>        LinkedMultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();        <span class="hljs-comment">//设置basic认证信息</span>        String basicAuth = <span class="hljs-keyword">this</span>.getHttpBasic(<span class="hljs-string">"XcWebApp"</span>, <span class="hljs-string">"XcWebApp"</span>);        headers.add(<span class="hljs-string">"Authorization"</span>,basicAuth);        <span class="hljs-comment">//设置请求中的body信息</span>        LinkedMultiValueMap&lt;String, String&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();        body.add(<span class="hljs-string">"grant_type"</span>,<span class="hljs-string">"password"</span>);        body.add(<span class="hljs-string">"username"</span>,<span class="hljs-string">"itcast"</span>);        body.add(<span class="hljs-string">"password"</span>,<span class="hljs-string">"12322"</span>);        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body, headers);        <span class="hljs-comment">//凭证信息错误时候, 指定restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值</span>        restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> DefaultResponseErrorHandler()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(ClientHttpResponse response)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;                <span class="hljs-comment">//当响应的值为400或者401时也要正常响应,不要抛出异常</span>                <span class="hljs-keyword">if</span>(response.getRawStatusCode()!=<span class="hljs-number">400</span> &amp;&amp; response.getRawStatusCode()!=<span class="hljs-number">401</span>)&#123;                    <span class="hljs-keyword">super</span>.handleError(response);                &#125;            &#125;        &#125;);        <span class="hljs-comment">//远程调用令牌</span>        ResponseEntity&lt;Map&gt; responseEntity = restTemplate.exchange(authUrl, HttpMethod.POST, httpEntity, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        Map responseBody = responseEntity.getBody();        System.out.println(responseBody);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getHttpBasic</span><span class="hljs-params">(String clientId,String clientSecret)</span></span>&#123;        <span class="hljs-comment">//将客户端id和客户端密码拼接，按“客户端id:客户端密码”</span>        String string = clientId+<span class="hljs-string">":"</span>+clientSecret;        <span class="hljs-comment">//进行base64编码</span>        <span class="hljs-keyword">byte</span>[] encode = Base64.encode(string.getBytes());        <span class="hljs-keyword">return</span> <span class="hljs-string">"Basic "</span>+<span class="hljs-keyword">new</span> String(encode);    &#125;&#125;</code></pre></div><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>暂时使用静态数据，待用户登录调通再连接数据库校验用户信息。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>调用认证服务申请令牌，并将令牌存储到 <code>redis</code>。</p><p>1、AuthToken</p><p>创建 <code>AuthToken</code> 模型类，存储申请的令牌，包括身份令牌、刷新令牌、jwt令牌</p><p>身份令牌：用于校验用户是否认证</p><p>刷新令牌：jwt令牌快过期时执行刷新令牌</p><p>jwt令牌：用于授权</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.ucenter.ext;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by mrt on 2018/5/21.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthToken</span> </span>&#123;    String access_token;<span class="hljs-comment">//访问token</span>    String refresh_token;<span class="hljs-comment">//刷新token</span>    String jwt_token;<span class="hljs-comment">//jwt令牌</span>&#125;</code></pre></div><p><strong>申请令牌的 service 方法如下</strong></p><p>这里要注意一点的就是，原视频和讲义中将用户凭证储存到 <code>redis</code> 的方法是直接储存 <code>access_token</code> 作为 <code>key</code>，如果 access_token 作为key储存的话，用户在发送认证请求的时候就需要提供 <code>access_token</code>，也意味着 access_token 需要暴露给用户。</p><ul><li>直接暴露 access_token 会有一定的安全风险</li><li>access_token 长度太大，不适合储存在cookie</li></ul><p>前面的时候该课程的老师也讲到了这个问题，但是后面还是犯了这个错误（至少我认为这是不应该的），所以 key 应该使用 <code>jti</code> 的值作为储存 ，value 为 <code>access_token</code> + <code>refresh_token</code> 储存到 <code>map</code> 转换成<code>json</code>后的字符串。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.auth.service.impl;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AuthService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;auth.tokenValiditySeconds&#125;"</span>)    <span class="hljs-keyword">int</span> tokenValiditySeconds;    <span class="hljs-comment">//Eureka负载均衡客户端</span>    <span class="hljs-meta">@Autowired</span>    LoadBalancerClient loadBalancerClient;    <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    StringRedisTemplate stringRedisTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户登陆认证实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clientId 客户端id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clientSecret 客户端凭证</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> AuthToken</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthToken <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, String clientId, String clientSecret)</span> </span>&#123;        <span class="hljs-comment">//申请令牌</span>        AuthToken authToken = <span class="hljs-keyword">this</span>.appleToken(username, password, clientId, clientSecret);        <span class="hljs-keyword">if</span>(authToken == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);        &#125;        <span class="hljs-comment">//保存令牌到redis</span>        <span class="hljs-keyword">boolean</span> saveToken = <span class="hljs-keyword">this</span>.saveToken(authToken, tokenValiditySeconds);        <span class="hljs-keyword">if</span>(!saveToken)&#123;            ExceptionCast.cast(AuthCode.AUTH_LOGIN_TOKEN_SAVEFAIL);        &#125;        <span class="hljs-keyword">return</span> authToken;    &#125;    <span class="hljs-comment">//储存令牌到redis</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">saveToken</span><span class="hljs-params">(AuthToken authToken, <span class="hljs-keyword">long</span> ttl)</span></span>&#123;        <span class="hljs-comment">//储存到redis的key</span>        String key = <span class="hljs-string">"user_token:"</span> + authToken.getJwt_token();        Map&lt;String,String&gt; valueMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">//拼装value</span>        valueMap.put(<span class="hljs-string">"access_token"</span>,authToken.getAccess_token());        valueMap.put(<span class="hljs-string">"refresh_token"</span>,authToken.getRefresh_token());        String valueJson = JSON.toJSONString(valueMap);        <span class="hljs-comment">//保存到令牌到redis</span>        stringRedisTemplate.boundValueOps(key).set(valueJson,ttl, TimeUnit.SECONDS);        <span class="hljs-comment">//获取过期时间</span>        Long expire = stringRedisTemplate.getExpire(key);        <span class="hljs-comment">//大于0则返回true</span>        <span class="hljs-keyword">return</span> expire&gt;<span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//向Oauth2服务申请令牌</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> AuthToken <span class="hljs-title">appleToken</span><span class="hljs-params">(String username, String password, String clientId, String clientSecret)</span></span>&#123;        <span class="hljs-comment">//采用客户端负载均衡的方式从eureka获取认证服务的ip和端口</span>        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">"XC-SERVICE-UCENTER-AUTH"</span>);        URI uri = serviceInstance.getUri();        String authUrl = uri + <span class="hljs-string">"/auth/oauth/token"</span>;        <span class="hljs-comment">//使用LinkedMultiValueMap储存多个header信息</span>        LinkedMultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();        <span class="hljs-comment">//设置basic认证信息</span>        String basicAuth = <span class="hljs-keyword">this</span>.getHttpBasic(clientId, clientSecret);        headers.add(<span class="hljs-string">"Authorization"</span>,basicAuth);        <span class="hljs-comment">//设置请求中的body信息</span>        LinkedMultiValueMap&lt;String, String&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();        body.add(<span class="hljs-string">"grant_type"</span>,<span class="hljs-string">"password"</span>);        body.add(<span class="hljs-string">"username"</span>,username);        body.add(<span class="hljs-string">"password"</span>,password);        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body, headers);        <span class="hljs-comment">//凭证信息错误时候, 指定restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值</span>        restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> DefaultResponseErrorHandler()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(ClientHttpResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">//当响应的值为400或者401时也要正常响应,不要抛出异常</span>                <span class="hljs-keyword">if</span>(response.getRawStatusCode()!=<span class="hljs-number">400</span> &amp;&amp; response.getRawStatusCode()!=<span class="hljs-number">401</span>)&#123;                    <span class="hljs-keyword">super</span>.handleError(response);                &#125;            &#125;        &#125;);        Map map = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//http请求spring security的申请令牌接口</span>            ResponseEntity&lt;Map&gt; mapResponseEntity = restTemplate.exchange(authUrl, HttpMethod.POST,                    <span class="hljs-keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(body, headers), Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            map = mapResponseEntity.getBody();        &#125; <span class="hljs-keyword">catch</span> (RestClientException e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"request oauth_token_password error: &#123;&#125;"</span>,e.getMessage());            e.printStackTrace();            ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);        &#125;        <span class="hljs-comment">//校验获取到的jwt是否完成</span>        <span class="hljs-keyword">if</span>(map == <span class="hljs-keyword">null</span> ||                map.get(<span class="hljs-string">"access_token"</span>) == <span class="hljs-keyword">null</span> ||                map.get(<span class="hljs-string">"refresh_token"</span>) == <span class="hljs-keyword">null</span> ||                map.get(<span class="hljs-string">"jti"</span>) == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//jti是jwt令牌的唯一标识作为用户身份令牌</span>            ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);        &#125;        <span class="hljs-comment">//拼装authToken并返回</span>        AuthToken authToken = <span class="hljs-keyword">new</span> AuthToken();        <span class="hljs-comment">//访问令牌(jwt)</span>        String access_token = (String) map.get(<span class="hljs-string">"access_token"</span>);        <span class="hljs-comment">//刷新令牌(jwt)</span>        String refresh_token = (String) map.get(<span class="hljs-string">"refresh_token"</span>);        <span class="hljs-comment">//jti，作为用户的身份标识,也就是后面我们用于返回给到用户前端的凭证</span>        String jwt_token = (String) map.get(<span class="hljs-string">"jti"</span>);        authToken.setAccess_token(access_token);        authToken.setRefresh_token(refresh_token);        authToken.setJwt_token(jwt_token);        <span class="hljs-keyword">return</span> authToken;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getHttpBasic</span><span class="hljs-params">(String clientId, String clientSecret)</span></span>&#123;        <span class="hljs-comment">//将客户端id和客户端密码拼接，按“客户端id:客户端密码”</span>        String string = clientId+<span class="hljs-string">":"</span>+clientSecret;        <span class="hljs-comment">//进行base64编码</span>        <span class="hljs-keyword">byte</span>[] encode = Base64.encode(string.getBytes());        <span class="hljs-keyword">return</span> <span class="hljs-string">"Basic "</span>+<span class="hljs-keyword">new</span> String(encode);    &#125;&#125;</code></pre></div><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.auth.controller;<span class="hljs-comment">//在配置文件中设置了context-path: /auth 所以这里我们就不用再配置RequestMapping</span><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthControllerApi</span> </span>&#123;    <span class="hljs-comment">//客户端认证信息</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;auth.clientId&#125;"</span>)    String clientId;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;auth.clientSecret&#125;"</span>)    String clientSecret;    <span class="hljs-comment">//cookie域</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;auth.cookieDomain&#125;"</span>)    String cookieDomain;    <span class="hljs-comment">//cookie生命周期</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;auth.cookieMaxAge&#125;"</span>)    <span class="hljs-keyword">int</span> cookieMaxAge;    <span class="hljs-comment">//生命周期</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;auth.tokenValiditySeconds&#125;"</span>)    <span class="hljs-keyword">int</span> tokenValiditySeconds;    <span class="hljs-meta">@Autowired</span>    AuthService authService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户登陆接口</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loginRequest 登陆参数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> LoginResult</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/userlogin"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LoginResult <span class="hljs-title">login</span><span class="hljs-params">(LoginRequest loginRequest)</span> </span>&#123;        <span class="hljs-comment">//校验账号是否输入</span>        <span class="hljs-keyword">if</span>(loginRequest == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(loginRequest.getUsername()))&#123;            ExceptionCast.cast(AuthCode.AUTH_USERNAME_NONE);        &#125;        <span class="hljs-comment">//校验密码是否输入</span>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(loginRequest.getPassword()))&#123;            ExceptionCast.cast(AuthCode.AUTH_PASSWORD_NONE);        &#125;        <span class="hljs-comment">//获取用户token信息并且保存到redis内</span>        AuthToken authToken = authService.login(                loginRequest.getUsername(),loginRequest.getPassword(), clientId, clientSecret);        <span class="hljs-comment">//将用户token写入cookie</span>        String jtw_token = authToken.getJwt_token();        <span class="hljs-comment">//将访问令牌存储到cookie</span>        <span class="hljs-keyword">this</span>.saveCookie(jtw_token);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoginResult(CommonCode.SUCCESS,jtw_token);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">logout</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//将令牌保存到cookie</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveCookie</span><span class="hljs-params">(String token)</span></span>&#123;        HttpServletResponse response = ((ServletRequestAttributes)                RequestContextHolder.getRequestAttributes()).getResponse();        <span class="hljs-comment">//添加cookie 认证令牌，最后一个参数设置为false，表示允许浏览器获取</span>        CookieUtil.addCookie(response, cookieDomain, <span class="hljs-string">"/"</span>, <span class="hljs-string">"uid"</span>, token, cookieMaxAge, <span class="hljs-keyword">false</span>);    &#125;&#125;</code></pre></div><h3 id="登录url放行"><a href="#登录url放行" class="headerlink" title="登录url放行"></a>登录url放行</h3><p>认证服务默认都要校验用户的身份信息，这里需要将登录url放行。</p><p>在 <code>WebSecurityConfig</code> 类中重写 configure(WebSecurity web)方法，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;web.ignoring().antMatchers(<span class="hljs-string">"/userlogin"</span>);&#125;</code></pre></div><h3 id="测试认证接口"><a href="#测试认证接口" class="headerlink" title="测试认证接口"></a>测试认证接口</h3><p>使用 <code>postman</code> 测试：</p><p>POST 请求：<a href="http://localhost:40400/auth/userlogin" target="_blank" rel="noopener">http://localhost:40400/auth/userlogin</a></p><p><a href="https://qnoss.codeyee.com/20200704_16/image40" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image40.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="测试写入Cookie"><a href="#测试写入Cookie" class="headerlink" title="测试写入Cookie"></a>测试写入Cookie</h3><p>cookie最终会写到 <code>xuecheng.com</code> 域名下，可通过 <code>nginx</code> 代理进行认证，测试cookie是否写成功。</p><p><strong>1、配置nginx代理</strong></p><p>在<code>ucenter.xuecheng.com</code>下配置代理路径</p><div class="hljs"><pre><code class="hljs c">#认证location ^~ /openapi/auth/ &#123;    proxy_pass http:<span class="hljs-comment">//auth_server_pool/auth/;</span>&#125;</code></pre></div><p>添加</p><div class="hljs"><pre><code class="hljs c">#认证服务upstream auth_server_pool&#123;    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">40400</span> weight=<span class="hljs-number">10</span>;&#125;</code></pre></div><p>2、检查我们的配置文件中<code>domain</code>的配置</p><p>domain 设置为我们学成的主站域名，<code>xuecheng.com</code></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">auth:</span>  <span class="hljs-attr">tokenValiditySeconds:</span> <span class="hljs-number">1200</span>  <span class="hljs-comment">#token存储到redis的过期时间</span>  <span class="hljs-attr">clientId:</span> <span class="hljs-string">XcWebApp</span>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">XcWebApp</span>  <span class="hljs-attr">cookieDomain:</span> <span class="hljs-string">xuecheng.com</span>  <span class="hljs-attr">cookieMaxAge:</span> <span class="hljs-number">-1</span></code></pre></div><p><strong>3、请求测试</strong></p><p><a href="http://ucenter.xuecheng.com/openapi/auth/userlogin" target="_blank" rel="noopener">http://ucenter.xuecheng.com/openapi/auth/userlogin</a></p><p>观察 <code>cookie</code> 写入结果</p><p><a href="https://qnoss.codeyee.com/20200704_16/image41" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image41.png" srcset="/img/loading.gif" alt="img"></a></p><p>请求成功，cookie也成功拿到</p><p><a href="https://qnoss.codeyee.com/20200704_16/image42" target="_blank" rel="noopener"><img src="/2020/08/24/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday16/image42.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="五、一些需要注意的问题"><a href="#五、一些需要注意的问题" class="headerlink" title="五、一些需要注意的问题"></a>五、一些需要注意的问题</h1><h2 id="通用工程的依赖继承的问题"><a href="#通用工程的依赖继承的问题" class="headerlink" title="通用工程的依赖继承的问题"></a>通用工程的依赖继承的问题</h2><p><code>model</code> 工程中构建 UserJwt 实体时候需要引入 <code>oauth2</code> 的依赖，所以在引入依赖时需要注意使用 <code>optional</code> 标签防止其他服务工程继承到 model 工程下的 <code>oauth2</code> 依赖。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如果不配置 <code>&lt;optional&gt;true&lt;/optional&gt;</code> 会导致暂时无需认证的服务也会被动的开启了认证，并导致所有的接口都被认证拦截。</p><p>并且 model 、api 、common 这三个通用工程在引入本工程需要用到的一些依赖时，也务必加上<code>&lt;optional&gt;true&lt;/optional&gt;</code> 这个标签，防止依赖继承导致的一些问题的出现。</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
      <tag>Oauth2</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day15：媒资管理系统集成</title>
    <link href="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/"/>
    <url>/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day15</code> 的内容</p><ul><li>根据 <code>课程ID</code> 搜索该课程已发布的课程信息，并返回该课程的所有课程计划信息。</li><li>将指定课程 <code>发布时</code> 所的课程计划的媒资信息保存到 <code>teachplan_media_publish</code> 表中，</li><li>根据 <code>课程计划id</code> 搜索该课程计划所对应的媒资信息，需要用到的是该课程计划对应的 <code>m3u8</code> 地址，用于在线播放视频，该接口在课程管理服务中开发，供学习服务进行远程调用。</li><li>在学习服务中远程调用 课程计划媒资信息查询接口，获取该课程计划的视频播放的 <code>m3u8</code> url地址，并返回给前端，前端使用该 <code>url</code> 进行视频的在线播放。</li><li>在线学习完整的测试流程：媒资信息的上传、选择、发布到前端门户、搜索门户测试，在线学习的播放视频。</li></ul><h1 id="一、学习页面：查询课程计划"><a href="#一、学习页面：查询课程计划" class="headerlink" title="一、学习页面：查询课程计划"></a>一、学习页面：查询课程计划</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>到目前为止，我们已可以编辑课程计划信息并上传课程视频，下一步我们要实现在线学习页面动态读取章节对应的视频并进行播放。在线学习页面所需要的信息有两类：</p><ul><li>课程计划信息</li><li>课程学习信息（视频地址、学习进度等）</li></ul><p>如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_15/image1" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p>在线学习集成媒资管理的需求如下：</p><p>1、在线学习页面显示课程计划</p><p>2、点击课程计划播放该课程计划对应的视频</p><p>本章节实现学习页面动态显示课程计划，进入不同课程的学习页面右侧动态显示当前课程的课程计划。</p><h2 id="2-Api接口"><a href="#2-Api接口" class="headerlink" title="2. Api接口"></a>2. Api接口</h2><p>课程计划信息从哪里获取？</p><p>在课程发布完成后会自动发布到一个 <code>course_pub</code> 的表中，<code>logstash</code> 会自动将课程发布后的信息自动采集到 <code>ES</code> 索引库中，这些信息也包含课程计划信息。</p><p>所以考虑性能要求，课程发布后对课程的查询统一从 <code>ES</code> 索引库中查询。</p><p>前端通过请求 <code>搜索服务</code> 获取课程信息，需要单独在 <code>搜索服务</code> 中定义课程信息查询接口。<br>本接口接收课程id，查询课程所有信息返回给前端。</p><p>我们在搜素服务 <code>API</code> 下添加以下方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"根据id搜索课程发布信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,CoursePub&gt; <span class="hljs-title">getdetail</span><span class="hljs-params">(String id)</span></span>;</code></pre></div><p>返回的课程信息为 <code>json</code> 结构：<code>key</code> 为课程id，<code>value</code> 为课程内容。</p><h2 id="3-服务端开发"><a href="#3-服务端开发" class="headerlink" title="3. 服务端开发"></a>3. 服务端开发</h2><p>在搜索服务中开发查询课程信息接口。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在搜素服务下添加以下方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据id搜索课程发布信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 课程id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON数据</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getdetail/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, CoursePub&gt; <span class="hljs-title">getdetail</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span>String id) </span>&#123;    <span class="hljs-keyword">return</span> esCourseService.getdetail(id);&#125;</code></pre></div><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据id搜索课程发布信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 课程id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON数据</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, CoursePub&gt; <span class="hljs-title">getdetail</span><span class="hljs-params">(String id)</span> </span>&#123;    <span class="hljs-comment">//设置索引</span>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(es_index);    <span class="hljs-comment">//设置类型</span>    searchRequest.types(es_type);    <span class="hljs-comment">//创建搜索源对象</span>    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//设置查询条件,根据id进行查询</span>    searchSourceBuilder.query(QueryBuilders.termQuery(<span class="hljs-string">"id"</span>,id));    <span class="hljs-comment">//这里不使用source的原字段过滤,查询所有字段</span>    <span class="hljs-comment">// searchSourceBuilder.fetchSource(new String[]&#123;"name", "grade", "charge","pic"&#125;, newString[]&#123;&#125;);</span>    <span class="hljs-comment">//设置搜索源对象</span>    searchRequest.source(searchSourceBuilder);    <span class="hljs-comment">//执行搜索</span>    SearchResponse searchResponse = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        searchResponse = restHighLevelClient.search(searchRequest);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-comment">//获取搜索结果</span>    SearchHits hits = searchResponse.getHits();    SearchHit[] searchHits = hits.getHits(); <span class="hljs-comment">//获取最优结果</span>    Map&lt;String,CoursePub&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (SearchHit hit: searchHits) &#123;        <span class="hljs-comment">//从搜索结果中取值并添加到coursePub对象</span>        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        String courseId = (String) sourceAsMap.get(<span class="hljs-string">"id"</span>);        String name = (String) sourceAsMap.get(<span class="hljs-string">"name"</span>);        String grade = (String) sourceAsMap.get(<span class="hljs-string">"grade"</span>);        String charge = (String) sourceAsMap.get(<span class="hljs-string">"charge"</span>);        String pic = (String) sourceAsMap.get(<span class="hljs-string">"pic"</span>);        String description = (String) sourceAsMap.get(<span class="hljs-string">"description"</span>);        String teachplan = (String) sourceAsMap.get(<span class="hljs-string">"teachplan"</span>);        CoursePub coursePub = <span class="hljs-keyword">new</span> CoursePub();        coursePub.setId(courseId);        coursePub.setName(name);        coursePub.setPic(pic);        coursePub.setGrade(grade);        coursePub.setTeachplan(teachplan);        coursePub.setDescription(description);        <span class="hljs-comment">//设置map对象</span>        map.put(courseId,coursePub);    &#125;    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用 <code>swagger-ui</code> 或 <code>postman</code> 测试查询课程信息接口。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image2" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image2.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-前端开发"><a href="#4-前端开发" class="headerlink" title="4. 前端开发"></a>4. 前端开发</h2><h3 id="配置NGINX虚拟主机"><a href="#配置NGINX虚拟主机" class="headerlink" title="配置NGINX虚拟主机"></a>配置NGINX虚拟主机</h3><p>学习中心的二级域名为 <code>ucenter.xuecheng.com</code> ，我们在 <code>nginx</code> 中配置 <code>ucenter</code> 虚拟主机。</p><div class="hljs"><pre><code class="hljs c">#学成网用户中心server &#123;    <span class="hljs-built_in">listen</span> <span class="hljs-number">80</span>;    server_name ucenter.xuecheng.com;    #个人中心    location / &#123;        proxy_pass http:<span class="hljs-comment">//ucenter_server_pool;</span>    &#125;&#125; #前端ucenterupstream ucenter_server_pool&#123;    <span class="hljs-meta">#server 127.0.0.1:7081 weight=10;</span>    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">13000</span> weight=<span class="hljs-number">10</span>;&#125;</code></pre></div><p>在学习中心要调用搜索的 <code>API</code>，使用 <code>Nginx</code> 解决代理，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_15/image3" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>在 <code>ucenter</code> 虚拟主机下配置搜索 <code>Api</code> 代理路径</p><div class="hljs"><pre><code class="hljs java">#后台搜索（公开api）upstream search_server_pool&#123;    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">40100</span> weight=<span class="hljs-number">10</span>;&#125; #学成网用户中心server &#123;    listen <span class="hljs-number">80</span>;    server_name ucenter.xuecheng.com;    #个人中心        location / &#123;        proxy_pass http:<span class="hljs-comment">//ucenter_server_pool;</span>    &#125;    #后端搜索服务        location /openapi/search/ &#123;        proxy_pass http:<span class="hljs-comment">//search_server_pool/search/;</span>    &#125;&#125;</code></pre></div><h3 id="前端-API-方法"><a href="#前端-API-方法" class="headerlink" title="前端 API 方法"></a>前端 API 方法</h3><p>在学习中心 <code>xc-ui-pc-leanring</code> 对课程信息的查询属于基础常用功能，所以我们将课程查询的 <code>api</code> 方法定义在<code>base</code> 模块下，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_15/image4" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>在<code>system.js</code> 中定义课程查询方法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./public'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> course_view = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> http.requestGet(<span class="hljs-string">'/openapi/search/course/getdetail/'</span>+id);&#125;</code></pre></div><h3 id="前端-API-方法调用"><a href="#前端-API-方法调用" class="headerlink" title="前端 API 方法调用"></a>前端 API 方法调用</h3><p>在 <code>learning_video.vue</code> 页面中调用课程信息查询接口得到课程计划，将课程计划<code>json</code> 串转成对象。</p><blockquote><p>xc-ui-pc-leanring/src/module/course/page/learning_video.vue</p></blockquote><p>1、定义视图</p><p>课程计划</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--课程计划部分代码--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navCont"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"course-weeklist"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav nav-stacked"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(teachplan_first, index) in teachplanList"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tit nav-justified text-center"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pull-left glyphicon glyphicon-th-list"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#123;&#123;teachplan_first.pname&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pull-right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>   <span class="hljs-attr">v-if</span>=<span class="hljs-string">"teachplan_first.children!=null"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(teachplan_second, index) in teachplan_first.children"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"glyphicon glyphicon-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"url"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"study(teachplan_second.id)"</span>&gt;</span>                    &#123;&#123;teachplan_second.pname&#125;&#125;                <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-comment">&lt;!-- &lt;div class="tit nav-justified text-center"&gt;&lt;i class="pull-left glyphicon glyphicon-th-list"&gt;&lt;/i&gt;第一章&lt;i class="pull-right"&gt;&lt;/i&gt;&lt;/div&gt;</span><span class="hljs-comment">&lt;li  &gt;&lt;i class="glyphicon glyphicon-check"&gt;&lt;/i&gt;</span><span class="hljs-comment">&lt;a :href="url" &gt;</span><span class="hljs-comment">第一节</span><span class="hljs-comment">&lt;/a&gt;</span><span class="hljs-comment">&lt;/li&gt;--&gt;</span>            <span class="hljs-comment">&lt;!--&lt;li&gt;&lt;i class="glyphicon glyphicon-unchecked"&gt;&lt;/i&gt;为什么分为A、B、C部分&lt;/li&gt;--&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>课程名称</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"top text-center"</span>&gt;</span>&#123;&#123;coursename&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>定义数据对象</p><div class="hljs"><pre><code class="hljs js">data() &#123;    <span class="hljs-keyword">return</span> &#123;        url:<span class="hljs-string">''</span>,<span class="hljs-comment">//当前url</span>        courseId:<span class="hljs-string">''</span>,<span class="hljs-comment">//课程id</span>        chapter:<span class="hljs-string">''</span>,<span class="hljs-comment">//章节Id</span>        coursename:<span class="hljs-string">''</span>,<span class="hljs-comment">//课程名称</span>        coursepic:<span class="hljs-string">''</span>,<span class="hljs-comment">//课程图片</span>        teachplanList:[],<span class="hljs-comment">//课程计划</span>        playerOptions: &#123;<span class="hljs-comment">//播放参数</span>            autoplay: <span class="hljs-literal">false</span>,            controls: <span class="hljs-literal">true</span>,            sources: [&#123;                type: <span class="hljs-string">"application/x-mpegURL"</span>,                src: <span class="hljs-string">''</span>            &#125;]        &#125;,    &#125;&#125;</code></pre></div><p>在 <code>created</code> 钩子方法中获取课程信息</p><div class="hljs"><pre><code class="hljs js">created()&#123;    <span class="hljs-comment">//当前请求的url</span>    <span class="hljs-keyword">this</span>.url = <span class="hljs-built_in">window</span>.location    <span class="hljs-comment">//课程id</span>    <span class="hljs-keyword">this</span>.courseId = <span class="hljs-keyword">this</span>.$route.params.courseId    <span class="hljs-comment">//章节id</span>    <span class="hljs-keyword">this</span>.chapter = <span class="hljs-keyword">this</span>.$route.params.chapter    <span class="hljs-comment">//查询课程信息</span>    systemApi.course_view(<span class="hljs-keyword">this</span>.courseId).then(<span class="hljs-function">(<span class="hljs-params">view_course</span>)=&gt;</span>&#123;        <span class="hljs-keyword">if</span>(!view_course || !view_course[<span class="hljs-keyword">this</span>.courseId])&#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"获取课程信息失败，请重新进入此页面！"</span>)            <span class="hljs-keyword">return</span> ;        &#125;         <span class="hljs-keyword">let</span> courseInfo = view_course[<span class="hljs-keyword">this</span>.courseId]        <span class="hljs-built_in">console</span>.log(courseInfo)        <span class="hljs-keyword">this</span>.coursename = courseInfo.name        <span class="hljs-keyword">if</span>(courseInfo.teachplan)&#123;            <span class="hljs-keyword">let</span> teachplan = <span class="hljs-built_in">JSON</span>.parse(courseInfo.teachplan);            <span class="hljs-keyword">this</span>.teachplanList = teachplan.children;        &#125;    &#125;)&#125;,</code></pre></div><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>在浏览器请求：<a href="http://ucenter.xuecheng.com/#/learning/4028e581617f945f01617f9dabc40000/0" target="_blank" rel="noopener">http://ucenter.xuecheng.com/#/learning/4028e581617f945f01617f9dabc40000/0</a></p><ul><li><code>4028e581617f945f01617f9dabc40000</code>：第一个参数为课程 <code>id</code>，测试时从 <code>ES</code>索引库找一个课程 <code>id</code></li><li>0：第二个参数为课程计划 <code>id</code>，此参数用于点击课程计划播放视频。</li></ul><p><a href="https://qnoss.codeyee.com/20200704_15/image5" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image5.png" srcset="/img/loading.gif" alt="img"></a></p><blockquote><p>如果出现跨域问题，但是确定已经配置了跨域，请尝试结束所以 nginx.exe 的进程 和 清空浏览器缓存。</p><p>如果还没有解决？重启电脑试试。</p></blockquote><h1 id="二、学习页面：获取视频播放地址"><a href="#二、学习页面：获取视频播放地址" class="headerlink" title="二、学习页面：获取视频播放地址"></a>二、学习页面：获取视频播放地址</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>用户进入在线学习页面，点击课程计划将播放该课程计划对应的教学视频。</p><p>业务流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_15/image6" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>业务流程说明：</p><p>1、用户进入在线学习页面，页面请求搜索服务获取课程信息（包括课程计划信息）并且在页面展示。</p><p>2、在线学习请求学习服务获取视频播放地址。</p><p>3、学习服务校验当前用户是否有权限学习，如果没有权限学习则提示用户。</p><p>4、学习服务校验通过，请求搜索服务获取课程媒资信息。</p><p>5、搜索服务请求ElasticSearch获取课程媒资信息。</p><p>为什么要请求 <code>ElasticSearch</code> 查询课程媒资信息？</p><p>出于性能的考虑，公开查询课程信息从搜索服务查询，分摊 <code>mysql</code> 数据库的访问压力。</p><p>什么时候将课程媒资信息存储到 <code>ElasticSearch</code> 中？</p><p>课程媒资信息是在课程发布的时候存入 <code>ElasticSearch</code>，因为课程发布后课程信息将基本不再修改。</p><h2 id="2-课程发布：储存媒资信息"><a href="#2-课程发布：储存媒资信息" class="headerlink" title="2. 课程发布：储存媒资信息"></a>2. 课程发布：储存媒资信息</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>课程媒资信息是在课程发布的时候存入 <code>ElasticSearch</code> 索引库，因为课程发布后课程信息将基本不再修改，具体的业务流程如下。</p><p><strong>1、课程发布，向课程媒资信息表写入数据。</strong></p><p>1）根据课程 <code>id</code> 删除 <code>teachplanMediaPub</code> 中的数据</p><p>2）根据课程 <code>id</code> 查询 <code>teachplanMedia</code> 数据</p><p>3）将查询到的 <code>teachplanMedia</code> 数据插入到 <code>teachplanMediaPub</code> 中</p><p><strong>2、Logstash 定时扫描课程媒资信息表，并将课程媒资信息写入索引库。</strong></p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>在 <code>xc_course</code> 数据库创建课程计划媒资发布表：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`teachplan_media_pub`</span> (    <span class="hljs-string">`teachplan_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程计划id'</span>,    <span class="hljs-string">`media_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'媒资文件id'</span>,    <span class="hljs-string">`media_fileoriginalname`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'媒资文件的原始名称'</span>,    <span class="hljs-string">`media_url`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'媒资文件访问地址'</span>,    <span class="hljs-string">`courseid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程Id'</span>,    <span class="hljs-string">`timestamp`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span>    <span class="hljs-string">'logstash使用'</span>,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`teachplan_id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8</code></pre></div><p>数据模型类如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.course;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> org.hibernate.annotations.GenericGenerator;<span class="hljs-keyword">import</span> javax.persistence.*;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"teachplan_media_pub"</span>)<span class="hljs-meta">@GenericGenerator</span>(name = <span class="hljs-string">"jpa-assigned"</span>, strategy = <span class="hljs-string">"assigned"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeachplanMediaPub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">916357110051689485L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(generator = <span class="hljs-string">"jpa-assigned"</span>)    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"teachplan_id"</span>)    <span class="hljs-keyword">private</span> String teachplanId;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"media_id"</span>)    <span class="hljs-keyword">private</span> String mediaId;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"media_fileoriginalname"</span>)    <span class="hljs-keyword">private</span> String mediaFileOriginalName;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"media_url"</span>)    <span class="hljs-keyword">private</span> String mediaUrl;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"courseid"</span>)    <span class="hljs-keyword">private</span> String courseId;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"timestamp"</span>)    <span class="hljs-keyword">private</span> Date timestamp;<span class="hljs-comment">//时间戳</span>&#125;</code></pre></div><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>创建 <code>TeachplanMediaPub</code> 表的 <code>Dao</code>，向 <code>TeachplanMediaPub</code> 存储信息采用先删除该课程的媒资信息，再添加该课程的媒资信息，所以这里定义根据课程 <code>id</code> 删除课程计划媒资方法：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeachplanMediaPubRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">TeachplanMediaPub</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//根据课程id删除课程计划媒资信息</span>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">deleteByCourseId</span><span class="hljs-params">(String courseId)</span></span>;&#125;</code></pre></div><p>从TeachplanMedia查询课程计划媒资信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//从TeachplanMedia查询课程计划媒资信息</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeachplanMediaRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">TeachplanMedia</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-function">List&lt;TeachplanMedia&gt; <span class="hljs-title">findByCourseId</span><span class="hljs-params">(String courseId)</span></span>;&#125;</code></pre></div><h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><p>编写保存课程计划媒资信息方法，并在课程发布时调用此方法。</p><p>1、保存课程计划媒资信息方法</p><p>本方法采用先删除该课程的媒资信息，再添加该课程的媒资信息，在 <code>CourseService</code> 下定义该方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//保存课程计划媒资信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveTeachplanMediaPub</span><span class="hljs-params">(String courseId)</span></span>&#123;    <span class="hljs-comment">//查询课程媒资信息</span>    List&lt;TeachplanMedia&gt; byCourseId = teachplanMediaRepository.findByCourseId(courseId);    <span class="hljs-keyword">if</span>(byCourseId == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//没有查询到媒资数据则直接结束该方法</span>    <span class="hljs-comment">//将课程计划媒资信息储存到待索引表</span>    <span class="hljs-comment">//删除原有的索引信息</span>    teachplanMediaPubRepository.deleteByCourseId(courseId);    <span class="hljs-comment">//一个课程可能会有多个媒资信息,遍历并使用list进行储存</span>    List&lt;TeachplanMediaPub&gt; teachplanMediaPubList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (TeachplanMedia teachplanMedia: byCourseId) &#123;        TeachplanMediaPub teachplanMediaPub = <span class="hljs-keyword">new</span> TeachplanMediaPub();        BeanUtils.copyProperties(teachplanMedia, teachplanMediaPub);        teachplanMediaPubList.add(teachplanMediaPub);    &#125;    <span class="hljs-comment">//保存所有信息</span>    teachplanMediaPubRepository.saveAll(teachplanMediaPubList);&#125;</code></pre></div><p>2、课程发布时调用此方法</p><p>修改课程发布的 <code>coursePublish</code> 方法：</p><div class="hljs"><pre><code class="hljs java">....<span class="hljs-comment">//保存课程计划媒资信息到待索引表</span>saveTeachplanMediaPub(courseId);<span class="hljs-comment">//页面url</span>String pageUrl = cmsPostPageResult.getPageUrl();<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoursePublishResult(CommonCode.SUCCESS,pageUrl);.....</code></pre></div><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>测试课程发布后是否成功将课程媒资信息存储到 <code>teachplan_media_pub</code> 中，测试流程如下：</p><p>1、指定一个课程</p><p>2、为课程计划添加课程媒资</p><p>3、执行课程发布</p><p>4、观察课程计划媒资信息是否存储至 <code>teachplan_media_pub</code> 中</p><p>注意：由于此测试仅用于测试发布课程计划媒资信息的功能，可暂时将 <code>cms</code>页面发布的功能暂时屏蔽，提高测试效率。</p><p>测试结果如下</p><p><a href="https://qnoss.codeyee.com/20200704_15/image7" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image7.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-Logstash：扫描课程计划媒资"><a href="#3-Logstash：扫描课程计划媒资" class="headerlink" title="3. Logstash：扫描课程计划媒资"></a>3. Logstash：扫描课程计划媒资</h2><p><code>Logstash</code> 定时扫描课程媒资信息表，并将课程媒资信息写入索引库。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>1、创建 <code>xc_course_media</code> 索引</p><p><a href="https://qnoss.codeyee.com/20200704_15/image8" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、并向此索引创建如下映射</p><p>POST: <a href="http://localhost:9200/xc_course_media/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course_media/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span> : &#123;        <span class="hljs-attr">"courseid"</span> : &#123;            <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"teachplan_id"</span> : &#123;            <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"media_id"</span> : &#123;            <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"media_url"</span> : &#123;            <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,            <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"media_fileoriginalname"</span> : &#123;            <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,            <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>        &#125;    &#125;&#125;</code></pre></div><p>索引创建成功</p><p><a href="https://qnoss.codeyee.com/20200704_15/image9" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image9.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h3><p>在 <code>logstach</code> 的 <code>config</code> 目录文件 <code>xc_course_media_template.json</code></p><p>文件路径为 <code>%ES_ROOT_DIR%/logstash6.8.8/config/xc_course_media_template.json</code></p><blockquote><p>%ES_ROOT_DIR% 为 ElasticSearch 和 logstash 的安装目录</p></blockquote><p>内容如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"mappings"</span> : &#123;        <span class="hljs-attr">"doc"</span> : &#123;            <span class="hljs-attr">"properties"</span> : &#123;                <span class="hljs-attr">"courseid"</span> : &#123;                    <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>                &#125;,                <span class="hljs-attr">"teachplan_id"</span> : &#123;                    <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>                &#125;,                <span class="hljs-attr">"media_id"</span> : &#123;                    <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>                &#125;,                <span class="hljs-attr">"media_url"</span> : &#123;                    <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,                    <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>                &#125;,                <span class="hljs-attr">"media_fileoriginalname"</span> : &#123;                    <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,                    <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>                &#125;            &#125;        &#125;,        <span class="hljs-attr">"template"</span> : <span class="hljs-string">"xc_course_media"</span>    &#125;&#125;</code></pre></div><h3 id="配置-mysql-conf"><a href="#配置-mysql-conf" class="headerlink" title="配置 mysql.conf"></a>配置 mysql.conf</h3><p>在logstash的 <code>config</code> 目录下配置 <code>mysql_course_media.conf</code> 文件供 <code>logstash</code> 使用，<code>logstash</code> 会根据<br><code>mysql_course_media.conf</code> 文件的配置的地址从 <code>MySQL</code> 中读取数据向 <code>ES</code> 中写入索引。</p><p>参考<a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html</a></p><p>配置输入数据源和输出数据源。</p><div class="hljs"><pre><code class="hljs json">input &#123;    stdin &#123;&#125; jdbc &#123;jdbc_connection_string =&gt; "jdbc:mysql://localhost:3306/xc_course?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC"        # 数据库信息        jdbc_user =&gt; "root"        jdbc_password =&gt; "123123"        # MYSQL 驱动地址,修改为maven仓库对应的位置        jdbc_driver_library =&gt; "D:/soft/apache-maven-3.5.4/repository/mysql/mysql-connector-java/5.1.40/mysql-connector-java-5.1.40.jar"# the name of the driver class for mysqljdbc_driver_class =&gt; "com.mysql.jdbc.Driver"jdbc_paging_enabled =&gt; "true"jdbc_page_size =&gt; "50000"#要执行的sql文件#statement_filepath =&gt; "/conf/course.sql"statement =&gt; "select * from teachplan_media_pub where timestamp &gt; date_add(:sql_last_value,INTERVAL 8 HOUR)"#定时配置schedule =&gt; "* * * * *"record_last_run =&gt; truelast_run_metadata_path =&gt; "D:/soft/elasticsearch/logstash-6.8.8/config/xc_course_media_metadata"&#125;&#125; output &#123;    elasticsearch &#123;#ES的ip地址和端口hosts =&gt; "localhost:9200"#hosts =&gt; ["localhost:9200","localhost:9202","localhost:9203"]#ES索引库名称index =&gt; "xc_course_media"document_id =&gt; "%&#123;teachplan_id&#125;"document_type =&gt; "doc"template =&gt; "D:/soft/elasticsearch/logstash-6.8.8/config/xc_course_media_template.json"template_name =&gt;"xc_course_media"template_overwrite =&gt;"true"&#125; stdout &#123;#日志输出codec =&gt; json_lines&#125;&#125;</code></pre></div><h3 id="启动-logstash-bat"><a href="#启动-logstash-bat" class="headerlink" title="启动 logstash.bat"></a>启动 logstash.bat</h3><p>启动 <code>logstash.bat</code> 采集 <code>teachplan_media_pub</code> 中的数据，向 <code>ES</code> 写入索引。</p><div class="hljs"><pre><code class="hljs c">logstash.bat -f ../<span class="hljs-built_in">config</span>/mysql_course_media.conf</code></pre></div><p>课程发布成功后，Logstash 会自动参加 <code>teachplan_media_pub</code> 表中新增的数据，效果如下</p><p><a href="https://qnoss.codeyee.com/20200704_15/image10" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p><a href="https://qnoss.codeyee.com/20200704_15/image11" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image11.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="Logstash多实例运行"><a href="#Logstash多实例运行" class="headerlink" title="Logstash多实例运行"></a>Logstash多实例运行</h3><p>由于之前我们还启动了一个 <code>Logstash</code> 对课程的发布信息进行采集，所以如果想两个 <code>logstash</code> 实例同时运行，因为每个实例都有一个.lock文件，所以不能使用同一个目录来存放数据，所以我们需要使用 <code>--path.data=</code> 为每个实例指定单独的数据目录，具体的代码如下：</p><blockquote><p>该配置是在windows下进行的</p></blockquote><p><strong>课程发布实例</strong></p><p><code>logstash_start_course_pub.bat</code></p><div class="hljs"><pre><code class="hljs cmd">@<span class="hljs-built_in">title</span> logstash <span class="hljs-keyword">in</span> course_publogstash.bat -f ..\config\mysql.conf --<span class="hljs-built_in">path</span>.data=../data/course_pub</code></pre></div><p><strong>课程计划媒体发布实例</strong></p><p><code>logstash_start_teachplan_media.bat</code></p><div class="hljs"><pre><code class="hljs cmd">@<span class="hljs-built_in">title</span> logstash i n teachplan_media_publogstash.bat -f ../config/mysql_course_media.conf --<span class="hljs-built_in">path</span>.data=../data/teachplan_media/</code></pre></div><p>同时运行效果如下</p><p><a href="https://qnoss.codeyee.com/20200704_15/image12" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image12.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-搜素服务：查询课程媒资接口"><a href="#4-搜素服务：查询课程媒资接口" class="headerlink" title="4. 搜素服务：查询课程媒资接口"></a>4. 搜素服务：查询课程媒资接口</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p><code>搜索服务</code> 提供查询课程媒资接口，此接口供学习服务调用。</p><h3 id="Api接口定义"><a href="#Api接口定义" class="headerlink" title="Api接口定义"></a>Api接口定义</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"根据课程计划查询媒资信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanMediaPub <span class="hljs-title">getmedia</span><span class="hljs-params">(String teachplanId)</span></span>;</code></pre></div><h3 id="Service-2"><a href="#Service-2" class="headerlink" title="Service"></a>Service</h3><p>1、配置课程计划媒资索引库等信息</p><p>在 <code>application.yml</code> 中配置</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">xuecheng:</span>  <span class="hljs-attr">elasticsearch:</span>    <span class="hljs-attr">hostlist:</span> <span class="hljs-string">$&#123;eshostlist:127.0.0.1:9200&#125;</span> <span class="hljs-comment">#多个结点中间用逗号分隔</span>    <span class="hljs-attr">course:</span>      <span class="hljs-attr">index:</span> <span class="hljs-string">xc_course</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">doc</span>      <span class="hljs-attr">source_field:</span> <span class="hljs-string">id,name,grade,mt,st,charge,valid,pic,qq,price,price_old,status,studymodel,teachmode,expires,pub_time,start_time,end_time</span>    <span class="hljs-attr">media:</span>      <span class="hljs-attr">index:</span> <span class="hljs-string">xc_course_media</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">doc</span>      <span class="hljs-attr">source_field:</span> <span class="hljs-string">courseid,media_id,media_url,teachplan_id,media_fileoriginalname</span></code></pre></div><p>2、service 方法开发</p><p>在 <code>课程搜索服务</code> 中定义课程媒资查询接口，为了适应后续需求，<code>service</code> 参数定义为数组，可一次查询多个课程计划的媒资信息。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 根据一个或者多个课程计划id查询媒资信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> teachplanIds 课程id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> QueryResponseResult</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;TeachplanMediaPub&gt; <span class="hljs-title">getmedia</span><span class="hljs-params">(String [] teachplanIds)</span></span>&#123;       <span class="hljs-comment">//设置索引</span>       SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(media_index);       <span class="hljs-comment">//设置类型</span>       searchRequest.types(media_type);       <span class="hljs-comment">//创建搜索源对象</span>       SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();       <span class="hljs-comment">//源字段过滤</span>       String[] media_index_arr = media_field.split(<span class="hljs-string">","</span>);       searchSourceBuilder.fetchSource(media_index_arr, <span class="hljs-keyword">new</span> String[]&#123;&#125;);       <span class="hljs-comment">//查询条件,根据课程计划id查询(可以传入多个课程计划id)</span>       searchSourceBuilder.query(QueryBuilders.termsQuery(<span class="hljs-string">"teachplan_id"</span>, teachplanIds));       searchRequest.source(searchSourceBuilder);       SearchResponse searchResponse = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           searchResponse = restHighLevelClient.search(searchRequest);       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;           e.printStackTrace();       &#125;       <span class="hljs-comment">//获取结果</span>       SearchHits hits = searchResponse.getHits();       <span class="hljs-keyword">long</span> totalHits = hits.getTotalHits();       SearchHit[] searchHits = hits.getHits();       <span class="hljs-comment">//数据列表</span>       List&lt;TeachplanMediaPub&gt; teachplanMediaPubList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();       <span class="hljs-keyword">for</span>(SearchHit hit:searchHits)&#123;           TeachplanMediaPub teachplanMediaPub =<span class="hljs-keyword">new</span> TeachplanMediaPub();           Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();           <span class="hljs-comment">//取出课程计划媒资信息</span>           String courseid = (String) sourceAsMap.get(<span class="hljs-string">"courseid"</span>);           String media_id = (String) sourceAsMap.get(<span class="hljs-string">"media_id"</span>);           String media_url = (String) sourceAsMap.get(<span class="hljs-string">"media_url"</span>);           String teachplan_id = (String) sourceAsMap.get(<span class="hljs-string">"teachplan_id"</span>);           String media_fileoriginalname = (String) sourceAsMap.get(<span class="hljs-string">"media_fileoriginalname"</span>);           teachplanMediaPub.setCourseId(courseid);           teachplanMediaPub.setMediaUrl(media_url);           teachplanMediaPub.setMediaFileOriginalName(media_fileoriginalname);           teachplanMediaPub.setMediaId(media_id);           teachplanMediaPub.setTeachplanId(teachplan_id);           <span class="hljs-comment">//将对象加入到列表中</span>           teachplanMediaPubList.add(teachplanMediaPub);       &#125;       <span class="hljs-comment">//构建返回课程媒资信息对象</span>       QueryResult&lt;TeachplanMediaPub&gt; queryResult = <span class="hljs-keyword">new</span> QueryResult&lt;&gt;();       queryResult.setList(teachplanMediaPubList);       queryResult.setTotal(totalHits);       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult&lt;TeachplanMediaPub&gt;(CommonCode.SUCCESS,queryResult);   &#125;</code></pre></div><h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据课程计划id搜索发布后的媒资信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> teachplanId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@GetMapping</span>(value=<span class="hljs-string">"/getmedia/&#123;teachplanId&#125;"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanMediaPub <span class="hljs-title">getmedia</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"teachplanId"</span>)</span> String teachplanId) </span>&#123;    <span class="hljs-comment">//为了service的拓展性,所以我们service接收的是数组作为参数,以便后续开发查询多个ID的接口</span>    String[] teachplanIds = <span class="hljs-keyword">new</span> String[]&#123;teachplanId&#125;;    <span class="hljs-comment">//通过service查询ES获取课程媒资信息</span>    QueryResponseResult&lt;TeachplanMediaPub&gt; mediaPubQueryResponseResult = esCourseService.getmedia(teachplanIds);    QueryResult&lt;TeachplanMediaPub&gt; queryResult = mediaPubQueryResponseResult.getQueryResult();    <span class="hljs-keyword">if</span>(queryResult!=<span class="hljs-keyword">null</span>&amp;&amp; queryResult.getList()!=<span class="hljs-keyword">null</span>       &amp;&amp; queryResult.getList().size()&gt;<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//返回课程计划对应课程媒资</span>        <span class="hljs-keyword">return</span> queryResult.getList().get(<span class="hljs-number">0</span>);    &#125; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TeachplanMediaPub();&#125;</code></pre></div><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><p>使用 <code>swagger-ui</code> 和 <code>postman</code> 测试课程媒资查询接口。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image13" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image13.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="三、在线学习：接口开发"><a href="#三、在线学习：接口开发" class="headerlink" title="三、在线学习：接口开发"></a>三、在线学习：接口开发</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>根据下边的业务流程，本章节完成前端学习页面请求学习服务获取课程视频地址，并自动播放视频。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image14" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image14.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-搭建开发环境"><a href="#2-搭建开发环境" class="headerlink" title="2. 搭建开发环境"></a>2. 搭建开发环境</h2><p>1、创建数据库</p><p>创建 <code>xc_learning</code> 数据库，学习数据库将记录学生的选课信息、学习信息。</p><p>导入：<code>资料/xc_learning.sql</code></p><p>2、创建学习服务工程</p><p>参考课程管理服务工程结构，创建学习服务工程：</p><p>导入：<code>资料/xc-service-learning.zip</code></p><p>项目工程结构如下</p><p><a href="https://qnoss.codeyee.com/20200704_15/image15" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-Api接口"><a href="#3-Api接口" class="headerlink" title="3. Api接口"></a>3. Api接口</h2><p>此 <code>api</code> 接口是课程学习页面请求学习服务获取课程学习地址。</p><p>定义返回值类型：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.learning.response;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetMediaResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GetMediaResult</span><span class="hljs-params">(ResultCode resultCode, String fileUrl)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.fileUrl = fileUrl;    &#125;    <span class="hljs-comment">//媒资文件播放地址</span>    <span class="hljs-keyword">private</span> String fileUrl;&#125;</code></pre></div><p>定义接口，学习服务根据传入课程 <code>ID</code>、章节 <code>Id</code>(课程计划 <code>ID</code>)来取学习地址。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"录播课程学习管理"</span>,description = <span class="hljs-string">"录播课程学习管理"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseLearningControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"获取课程学习地址"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> GetMediaResult <span class="hljs-title">getMediaPlayUrl</span><span class="hljs-params">(String courseId,String teachplanId)</span></span>;&#125;</code></pre></div><h2 id="4-服务端开发"><a href="#4-服务端开发" class="headerlink" title="4. 服务端开发"></a>4. 服务端开发</h2><h3 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h3><p>学习服务根据传入课程ID、章节Id(课程计划ID)请求搜索服务获取学习地址。</p><h3 id="搜索服务注册Eureka"><a href="#搜索服务注册Eureka" class="headerlink" title="搜索服务注册Eureka"></a>搜索服务注册Eureka</h3><p>学习服务要调用搜索服务查询课程媒资信息，所以需要将搜索服务注册到 <code>eureka</code> 中。</p><p>1、查看服务名称是否为 <code>xc-service-search</code></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-comment"># 注意修改application.xml中的服务名称：</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span><span class="hljs-attr">name:</span> <span class="hljs-string">xc‐service‐search</span></code></pre></div><p>2、配置搜索服务的配置文件 <code>application.yml</code>，加入 <code>Eureka</code> 配置 如下：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">registerWithEureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务注册开关</span>    <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务发现开关</span>    <span class="hljs-attr">serviceUrl:</span> <span class="hljs-comment">#Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">$&#123;EUREKA_SERVER:http://localhost:50101/eureka/,http://localhost:50102/eureka/&#125;</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span>  <span class="hljs-literal">true</span>  <span class="hljs-comment">#将自己的ip地址注册到Eureka服务中</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-string">$&#123;IP_ADDRESS:127.0.0.1&#125;</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment">#指定实例id</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">2</span> <span class="hljs-comment">#最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">3</span> <span class="hljs-comment">#切换实例的重试次数</span>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">5000</span>  <span class="hljs-comment">#请求连接的超时时间</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">6000</span> <span class="hljs-comment">#请求处理的超时时间</span></code></pre></div><p>3、添加 <code>eureka</code> 依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring‐cloud‐starter‐netflix‐eureka‐client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>4、修改启动类，在class上添加如下注解：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span></code></pre></div><h3 id="搜索服务客户端"><a href="#搜索服务客户端" class="headerlink" title="搜索服务客户端"></a>搜索服务客户端</h3><p>在 <code>学习服务</code> 创建搜索服务的客户端接口，此接口会生成代理对象，调用搜索服务：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.learning.client;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.TeachplanMediaPub;<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"xc‐service‐search"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseSearchClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(value=<span class="hljs-string">"/getmedia/&#123;teachplanId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanMediaPub <span class="hljs-title">getmedia</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"teachplanId"</span>)</span> String teachplanId)</span>;&#125;</code></pre></div><h3 id="自定义错误代码"><a href="#自定义错误代码" class="headerlink" title="自定义错误代码"></a>自定义错误代码</h3><p>我们在 <code>com.xuecheng.framework.domain.learning.response</code> 包下自定义一个错误消息模型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.learning.response;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> LearningCode implements ResultCode &#123;    LEARNING_GET_MEDIA_ERROR(<span class="hljs-keyword">false</span>,<span class="hljs-number">23001</span>,<span class="hljs-string">"学习中心获取媒资信息错误！"</span>);    <span class="hljs-comment">//操作代码</span>    <span class="hljs-keyword">boolean</span> success;    <span class="hljs-comment">//操作代码</span>    <span class="hljs-keyword">int</span> code;    <span class="hljs-comment">//提示信息</span>    String message;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LearningCode</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> success, <span class="hljs-keyword">int</span> code, String message)</span></span>&#123;        <span class="hljs-keyword">this</span>.success = success;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.message = message;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">code</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">message</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> message;    &#125;&#125;</code></pre></div><p>该消息模型基于 <code>ResultCode</code> 来实现，代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.model.response;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by mrt on 2018/3/5.</span><span class="hljs-comment"> * 10000-- 通用错误代码</span><span class="hljs-comment"> * 22000-- 媒资错误代码</span><span class="hljs-comment"> * 23000-- 用户中心错误代码</span><span class="hljs-comment"> * 24000-- cms错误代码</span><span class="hljs-comment"> * 25000-- 文件系统</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultCode</span> </span>&#123;    <span class="hljs-comment">//操作是否成功,true为成功，false操作失败</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">success</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//操作代码</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//提示信息</span>    <span class="hljs-function">String <span class="hljs-title">message</span><span class="hljs-params">()</span></span>;</code></pre></div><p>从 <code>ResultCode</code> 中我们可以看出，我们约定了用户中心的错误代码使用 <code>23000</code>，所以我们定义的一些错误信息的代码就从 23000 开始计数。</p><h3 id="Service-3"><a href="#Service-3" class="headerlink" title="Service"></a>Service</h3><p>在学习服务中定义 <code>service</code> 方法，此方法远程请求课程管理服务、媒资管理服务获取课程学习地址。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.learning.service.impl;<span class="hljs-keyword">import</span> com.netflix.discovery.converters.Auto;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.TeachplanMediaPub;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.learning.response.GetMediaResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.learning.client.CourseSearchClient;<span class="hljs-keyword">import</span> com.xuecheng.learning.service.LearningService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LearningServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LearningService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CourseSearchClient courseSearchClient;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 远程调用搜索服务获取已发布媒体信息中的url</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId 课程id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> teachplanId  媒体信息id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> GetMediaResult <span class="hljs-title">getMediaPlayUrl</span><span class="hljs-params">(String courseId, String teachplanId)</span> </span>&#123;        <span class="hljs-comment">//校验学生权限,是否已付费等</span>        <span class="hljs-comment">//远程调用搜索服务进行查询媒体信息</span>        TeachplanMediaPub mediaPub = courseSearchClient.getmedia(teachplanId);        <span class="hljs-keyword">if</span>(mediaPub == <span class="hljs-keyword">null</span>) ExceptionCast.cast(CommonCode.FAIL);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GetMediaResult(CommonCode.SUCCESS, mediaPub.getMediaUrl());    &#125;&#125;</code></pre></div><h3 id="Controller-2"><a href="#Controller-2" class="headerlink" title="Controller"></a>Controller</h3><p>调用 <code>service</code> 根据课程计划 <code>id</code> 查询视频播放地址：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/learning/course"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseLearningController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseLearningControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    LearningService learningService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getmedia/&#123;courseId&#125;/&#123;teachplanId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> GetMediaResult <span class="hljs-title">getMediaPlayUrl</span><span class="hljs-params">(@PathVariable String courseId, @PathVariable String teachplanId)</span> </span>&#123;        <span class="hljs-comment">//获取课程学习地址</span>        <span class="hljs-keyword">return</span> learningService.getMedia(courseId, teachplanId);    &#125;&#125;</code></pre></div><h3 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h3><p>使用 <code>swagger-ui</code> 或<code>postman</code> 测试学习服务查询课程视频地址接口。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image16" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image16.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="5-前端开发"><a href="#5-前端开发" class="headerlink" title="5. 前端开发"></a>5. 前端开发</h2><h3 id="需求分析-3"><a href="#需求分析-3" class="headerlink" title="需求分析"></a>需求分析</h3><p>需要在学习中心前端页面需要完成如下功能：</p><p>1、进入课程学习页面需要带上 <code>课程 Id</code>参数及课程计划Id的参数，其中 <code>课程 Id</code> 参数必带，<code>课程计划 Id</code> 可以为空。</p><p>2、进入页面根据 <code>课程 Id</code> 取出该课程的课程计划显示在右侧。</p><p>3、进入页面后判断如果请求参数中有<code>课程计划 Id</code> 则播放该章节的视频。</p><p>4、进入页面后判断如果 <code>课程计划id</code> 为0则需要取出本课程第一个 <code>课程计划的Id</code>，并播放第一个课程计划的视频。</p><p>进入到模块 <code>xc-ui-pc-leanring/src/module/course</code></p><h3 id="api方法"><a href="#api方法" class="headerlink" title="api方法"></a>api方法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sysConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/../config/sysConfig'</span>)<span class="hljs-keyword">let</span> apiUrl = sysConfig.xcApiUrlPre;<span class="hljs-comment">/*获取播放地址*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> get_media = <span class="hljs-function">(<span class="hljs-params">courseId,chapter</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> http.requestGet(apiUrl+<span class="hljs-string">'/api/learning/course/getmedia/'</span>+courseId+<span class="hljs-string">'/'</span>+chapter);&#125;</code></pre></div><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>在 <code>Nginx</code> 中的 <code>ucenter.xuecheng.com</code> 虚拟主机中配置 <code>/api/learning/</code> 的路径转发，此<code>url</code> 请转发到学习服务。</p><div class="hljs"><pre><code class="hljs conf">#学习服务upstream learning_server_pool&#123;    server 127.0.0.1:40600 weight&#x3D;10;&#125;#学成网用户中心server &#123;    listen 80;    server_name ucenter.xuecheng.com;    #个人中心    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;ucenter_server_pool;    &#125;    #后端搜索服务    location &#x2F;openapi&#x2F;search&#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;search_server_pool&#x2F;search&#x2F;;     &#125;    #学习服务    location ^~ &#x2F;api&#x2F;learning&#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;learning_server_pool&#x2F;learning&#x2F;;    &#125;&#125;</code></pre></div><h3 id="视频播放页面"><a href="#视频播放页面" class="headerlink" title="视频播放页面"></a>视频播放页面</h3><p>1、如果传入的课程计划id为0则取出第一个课程计划id</p><p>在 <code>created</code> 钩子方法中完成</p><div class="hljs"><pre><code class="hljs js">created()&#123;    <span class="hljs-comment">//当前请求的url</span>    <span class="hljs-keyword">this</span>.url = <span class="hljs-built_in">window</span>.location    <span class="hljs-comment">//课程id</span>    <span class="hljs-keyword">this</span>.courseId = <span class="hljs-keyword">this</span>.$route.params.courseId    <span class="hljs-comment">//章节id</span>    <span class="hljs-keyword">this</span>.chapter = <span class="hljs-keyword">this</span>.$route.params.chapter    <span class="hljs-comment">//查询课程信息</span>    systemApi.course_view(<span class="hljs-keyword">this</span>.courseId).then(<span class="hljs-function">(<span class="hljs-params">view_course</span>)=&gt;</span>&#123;        <span class="hljs-keyword">if</span>(!view_course || !view_course[<span class="hljs-keyword">this</span>.courseId])&#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"获取课程信息失败，请重新进入此页面！"</span>)            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">let</span> courseInfo = view_course[<span class="hljs-keyword">this</span>.courseId]        <span class="hljs-built_in">console</span>.log(courseInfo)        <span class="hljs-keyword">this</span>.coursename = courseInfo.name        <span class="hljs-keyword">if</span>(courseInfo.teachplan)&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"准备开始播放视频"</span>)            <span class="hljs-keyword">let</span> teachplan = <span class="hljs-built_in">JSON</span>.parse(courseInfo.teachplan);            <span class="hljs-keyword">this</span>.teachplanList = teachplan.children;            <span class="hljs-comment">//开始学习</span>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.chapter == <span class="hljs-string">"0"</span> || !<span class="hljs-keyword">this</span>.chapter)&#123;                <span class="hljs-comment">//取出第一个教学计划</span>                <span class="hljs-keyword">this</span>.chapter = <span class="hljs-keyword">this</span>.getFirstTeachplan();                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"第一个教学计划id为 "</span>,<span class="hljs-keyword">this</span>.chapter);                <span class="hljs-keyword">this</span>.study(<span class="hljs-keyword">this</span>.chapter);            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">this</span>.study(<span class="hljs-keyword">this</span>.chapter);            &#125;        &#125;    &#125;)&#125;,</code></pre></div><p>取出第一个章节 <code>id</code>，用户未输入课程计划 <code>id</code> 或者输入为 <code>0</code> 时，播放第一个。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//取出第一个章节</span>getFirstTeachplan()&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">this</span>.teachplanList.length;i++)&#123;        <span class="hljs-keyword">let</span> firstTeachplan = <span class="hljs-keyword">this</span>.teachplanList[i];<span class="hljs-comment">//如果当前children存在，则取出第一个返回</span>        <span class="hljs-keyword">if</span>(firstTeachplan.children &amp;&amp; firstTeachplan.children.length&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">let</span> secondTeachplan = firstTeachplan.children[<span class="hljs-number">0</span>];            <span class="hljs-keyword">return</span> secondTeachplan.id;        &#125;    &#125;    <span class="hljs-keyword">return</span> ;&#125;,</code></pre></div><p>开始学习：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//开始学习</span>study(chapter)&#123;    <span class="hljs-comment">// 获取播放地址</span>    courseApi.get_media(<span class="hljs-keyword">this</span>.courseId,chapter).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">let</span> fileUrl = sysConfig.videoUrl + res.fileUrl            <span class="hljs-comment">//播放视频</span>            <span class="hljs-keyword">this</span>.playvideo(fileUrl)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.message)&#123;            <span class="hljs-keyword">this</span>.$message.error(res.message)        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"播放视频失败，请刷新页面重试"</span>)        &#125;    &#125;).catch(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"播放视频失败，请刷新页面重试"</span>)    &#125;);&#125;,</code></pre></div><p>2、点击右侧课程章节切换播放</p><p>在原有代码基础上添加 <code>click</code> 事件，点击调用开始学习方法（<code>study</code>）。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">if</span>=<span class="hljs-string">"teachplan_first.children!=null"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"(teachplan_second, index) in</span></span><span class="hljs-tag"><span class="hljs-string">teachplan_first.children"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"glyphicon glyphicon‐check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"url"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"study(teachplan_second.id)"</span>&gt;</span>&#123;&#123;teachplan_second.pname&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre></div><p>3、地址栏路由url变更</p><p>这里需要注意一个问题，在用户点击课程章节切换播放时，地址栏的 <code>url</code> 也应该同步改变为当前所选择的课程计划 <code>id</code></p><p>4、在线学习按钮</p><p>将 <code>learnstatus</code> 默认更改为 <code>1</code>，这样就能显示出马上学习的按钮，方便我们后续的集成测试。</p><p>文件路径为 <code>xc-ui-pc-static-portal/include/course_detail_dynamic.html</code> 部分代码块如下</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;   <span class="hljs-keyword">var</span> body= <span class="hljs-keyword">new</span> Vue(&#123;   <span class="hljs-comment">//创建一个Vue的实例</span>        el: <span class="hljs-string">"#body"</span>, <span class="hljs-comment">//挂载点是id="app"的地方</span>        data: &#123;            editLoading: <span class="hljs-literal">false</span>,            title:<span class="hljs-string">'测试'</span>,            courseId:<span class="hljs-string">''</span>,            charge:<span class="hljs-string">''</span>,<span class="hljs-comment">//203001免费,203002收费</span>            learnstatus: <span class="hljs-number">1</span> ,<span class="hljs-comment">//课程状态，1：马上学习，2：立即报名、3：立即购买</span>            course:&#123;&#125;,            companyId:<span class="hljs-string">'template'</span>,            company_stat:[],            course_stat:&#123;<span class="hljs-string">"s601001"</span>:<span class="hljs-string">""</span>,<span class="hljs-string">"s601002"</span>:<span class="hljs-string">""</span>,<span class="hljs-string">"s601003"</span>:<span class="hljs-string">""</span>&#125;        &#125;,</code></pre></div><h3 id="简单的测试"><a href="#简单的测试" class="headerlink" title="简单的测试"></a>简单的测试</h3><p>访问在线学习页面：<code>http://ucenter.xuecheng.com/#/learning/课程id/课程计划id</code></p><p>通过 <code>url</code> 传入两个参数：<code>课程id</code> 和 <code>课程计划id</code></p><p>如果没有课程计划则传入0</p><p>测试项目如下：</p><p>1、传入正确的课程id、课程计划id，自动播放本章节的视频</p><p>2、传入正确的课程id、课程计划id传入0，自动播放第一个视频</p><p>3、传入错误的课程id 或 课程计划id，提示错误信息。</p><p>4、通过右侧章节目录切换章节及播放视频。</p><p>访问： <a href="http://ucenter.xuecheng.com/#/learning/4028e58161bcf7f40161bcf8b77c0000/4028e58161bd18ea0161bd1f73190008" target="_blank" rel="noopener">http://ucenter.xuecheng.com/#/learning/4028e58161bcf7f40161bcf8b77c0000/4028e58161bd18ea0161bd1f73190008</a></p><p>传入正确的课程id、课程计划id，自动播放本章节的视频</p><p><a href="https://qnoss.codeyee.com/20200704_15/image17" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image17.png" srcset="/img/loading.gif" alt="img"></a></p><p>传入正确的课程id、课程计划id传入0，自动播放第一个视频</p><p>访问 <a href="http://ucenter.xuecheng.com/#/learning/4028e58161bcf7f40161bcf8b77c0000/0" target="_blank" rel="noopener">http://ucenter.xuecheng.com/#/learning/4028e58161bcf7f40161bcf8b77c0000/0</a></p><p>识别出第一个课程计划的 <code>id</code></p><p><a href="https://qnoss.codeyee.com/20200704_15/image18" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p>需要注意的是这里的 <code>chapter</code> 参数是我自己在 <code>study</code> 函数里加上去的，可以忽略。</p><p>传入错误的课程id或课程计划id，提示错误信息。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image19" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image19.png" srcset="/img/loading.gif" alt="img"></a></p><p>通过右侧章节目录切换章节及播放视频。</p><p>点击章节即可播放，但是点击制定章节后 <code>url</code> 没有发生改变，这个问题暂时还没有解决，关注笔记后面的内容。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image20" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image20.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="完整的测试"><a href="#完整的测试" class="headerlink" title="完整的测试"></a>完整的测试</h3><p>准备工作</p><ul><li>启动 <code>RabbitMQ</code>，启动 <code>Logstash</code>、<code>ElasticSearch</code></li><li>建议把所有后端服务都开起来</li><li>启动 前端静态门户、启动 <code>nginx</code> 、启动课程管理前端</li></ul><p>我们整理一下测试的流程</p><ol><li>上传两个媒资视频文件，用于测试</li><li>进入到课程管理，为课程计划选择媒资信息</li><li>发布课程，等待 <code>logstash</code> 将数据采集到 <code>ElasticSearch</code> 的索引库中</li><li>进入学成网主页，点击课程，进入到搜索门户页面</li><li>搜索课程，进入到课程详情页面</li><li>点击开始学习，进入到课程学习页面，选择课程计划中的一个章节进行学习。</li></ol><h4 id="1、上传文件"><a href="#1、上传文件" class="headerlink" title="1、上传文件"></a>1、上传文件</h4><p>首先我们使用之前开发的媒资管理模块，上传两个视频文件用于测试。</p><p>第一个文件上传成功</p><p><a href="https://qnoss.codeyee.com/20200704_15/image21" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h5 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h5><p>在上传第二个文件时，发生了错误，我们来检查一下问题出在了哪里</p><p><a href="https://qnoss.codeyee.com/20200704_15/image22" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>在媒体服务的控制台中可以看到，在 <code>mergeChunks</code> 方法在校验文件 <code>md5</code> 时候抛出了异常</p><p>我们在 <code>MD5</code> 校验这里打个断点，重新上传文件，分析一下问题所在。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image23" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image23.png" srcset="/img/loading.gif" alt="img"></a></p><p>单步调试后发现，合并文件后的MD5值与用户上传的源文件值不相等</p><p><a href="https://qnoss.codeyee.com/20200704_15/image24" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image24.png" srcset="/img/loading.gif" alt="img"></a></p><h5 id="方案1：删除本地分块文件重新尝试上传"><a href="#方案1：删除本地分块文件重新尝试上传" class="headerlink" title="方案1：删除本地分块文件重新尝试上传"></a><del>方案1：删除本地分块文件重新尝试上传</del></h5><p>考虑到可能是在用户上传完 视频的分块文件时发生了一些问题，导致合并文件后与源文件的大小不等，导致MD5也不相同，这里我们把这个视频上传到本地的文件全部删除，在媒资上传页面重新上传文件。</p><p>对比所有分块文件的字节大小和本地源文件的大小，完全是相等的</p><p><a href="https://qnoss.codeyee.com/20200704_15/image25" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image25.png" srcset="/img/loading.gif" alt="img"></a></p><blockquote><p>删除所有文件后重新上传，md5值还是不等，考虑从调试一下文件合并的代码。</p></blockquote><h5 id="方案2：检查前端提交的MD5值是否正确"><a href="#方案2：检查前端提交的MD5值是否正确" class="headerlink" title="方案2：检查前端提交的MD5值是否正确"></a>方案2：检查前端提交的MD5值是否正确</h5><p>在查阅是否有其他的MD5值获取方案时，发现了一个使用 <code>windows</code> 本地命令获取文件MD5值的方法</p><div class="hljs"><pre><code class="hljs angelscript">certutil -hashfile .\<span class="hljs-number">19</span>-在线学习接口-集成测试.avi md5</code></pre></div><p>惊奇的发现，TM的原来是前端那边转换的MD5值不正确，后端这边是没有问题的。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image26" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image26.png" srcset="/img/loading.gif" alt="img"></a></p><p>从前面的图可以看出，本地和后端转换的都是以一个 <code>f6f0</code> 开头的MD5值</p><p><a href="https://qnoss.codeyee.com/20200704_15/image27" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image27.png" srcset="/img/loading.gif" alt="img"></a></p><p>那么问题就出现在前端了，还需要花一些时间去分析一下，这里暂时就先告一段落，因为上传了几个文件测试中只有这一个文件出现了问题。</p><h4 id="2、为课程计划选择媒资信息"><a href="#2、为课程计划选择媒资信息" class="headerlink" title="2、为课程计划选择媒资信息"></a>2、为课程计划选择媒资信息</h4><p>进入到一个课程的管理页面</p><p><a href="http://localhost:12000/#/course/manage/baseinfo/4028e58161bcf7f40161bcf8b77c0000" target="_blank" rel="noopener">http://localhost:12000/#/course/manage/baseinfo/4028e58161bcf7f40161bcf8b77c0000</a></p><p>将刚才我们上传的媒资文件的信息和课程计划绑定</p><p><a href="https://qnoss.codeyee.com/20200704_15/image28" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image28.png" srcset="/img/loading.gif" alt="img"></a></p><p>选择效果如下</p><p><a href="https://qnoss.codeyee.com/20200704_15/image29" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image29.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、发布课程，等待 <code>logstash</code> 从 <code>course_pub</code> 以及 <code>teachplan_media_pub</code> 表中采集数据到 <code>ElasticSearch</code> 当中</p><p><a href="https://qnoss.codeyee.com/20200704_15/image30" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image30.png" srcset="/img/loading.gif" alt="img"></a></p><p>发布成功后，我们可以从 <code>teachplan_media_pub</code> 表中看到刚才我们发布的媒资信息</p><p><a href="https://qnoss.codeyee.com/20200704_15/image31" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image31.png" srcset="/img/loading.gif" alt="img"></a></p><p>再观察 Logstash 的控制台，发现两个 Logstash 的实例都对更新的课程发布信息进行了采集</p><p><a href="https://qnoss.codeyee.com/20200704_15/image32" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image32.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="3、前端门户测试"><a href="#3、前端门户测试" class="headerlink" title="3、前端门户测试"></a>3、前端门户测试</h4><p>打开我们的门户主站 <code>http://www.xuecheng.com/</code></p><p><a href="https://qnoss.codeyee.com/20200704_15/image33" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image33.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击导航栏的课程，进入到我们的搜索门户页面</p><blockquote><p>如果无法进入到搜索门户，请检查你的 xc-ui-pc-portal 前端工程是否已经启动</p></blockquote><p>进入到搜索门户后，可以看到一些初始化时搜索的课程数据，默认是搜索第一页的数据，每页2个课程。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image34" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image34.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们可以测试搜索一下前面我们选择媒资信息时所用的课程</p><p><a href="https://qnoss.codeyee.com/20200704_15/image35" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image35.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击课程，进入到课程详情页面，然后再点击开始学习。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image36" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image36.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击马上学习后，会进入到该课程的在线学习页面，默认自动播放我们第一个课程计划中的视频。</p><p><a href="https://qnoss.codeyee.com/20200704_15/image37" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image37.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们可以在右侧的目录中选择第二个课程计划，会自动播放所选的课程计划所对应的媒资视频播放地址，该 播放地址正是我们刚才通过 <code>Logstash</code> 自动采集到 <code>ElasticSearch</code> 的索引信息，效果图如下</p><p><a href="https://qnoss.codeyee.com/20200704_15/image38" target="_blank" rel="noopener"><img src="/2020/08/23/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday15/image38.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="四、待完善的一些功能"><a href="#四、待完善的一些功能" class="headerlink" title="四、待完善的一些功能"></a>四、待完善的一些功能</h1><ul><li>课程发布前，校验课程计划里面是否包含二级课程计划</li><li>课程发布前，校验课程计划信息里面是否全部包含媒资信息</li><li>删除媒资信息，并且同步删除ES中的索引</li><li>在获取该课程的播放地址时校验用户的合法、</li><li>在线学习页面，点击右侧目录中的课程计划同时改变url中的课程计划地址</li><li>视频文件 <code>19-在线学习接口-集成测试.avi</code> 前端上传时提交的MD5值不正确</li></ul>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day14：媒资管理</title>
    <link href="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/"/>
    <url>/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day14</code> 的内容</p><ul><li>视频上传成功后通过 <code>RabbitMQ</code> 进行消息发送，再通过 <code>视频处理服务</code> 对视频进行格式转换，以及 <code>m3u8</code> 视频文件的生成。</li><li>实现媒资信息的浏览</li><li><code>Vue</code> 跨组件间的通讯实战，实现课程计划与已上传的媒资文件的关联</li></ul><h1 id="一、视频处理"><a href="#一、视频处理" class="headerlink" title="一、视频处理"></a>一、视频处理</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>原始视频通常需要经过编码处理，生成 <code>m3u8</code> 和 <code>ts</code> 文件方可基于 <code>HLS</code> 协议播放视频。通常用户上传原始视频，系统自动处理成标准格式，系统对用户上传的视频自动编码、转换，最终生成<code>m3u8</code> 文件和 <code>ts</code> 文件，处理流程如下：</p><p>1、用户上传视频成功</p><p>2、系统对上传成功的视频自动开始编码处理</p><p>3、用户查看视频处理结果，没有处理成功的视频用户可在管理界面再次触发处理</p><p>4、视频处理完成将视频地址及处理结果保存到数据库</p><p>视频处理流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image1" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p>视频处理进程的任务是接收视频处理消息进行视频处理，业务流程如下：</p><p>1、监听 <code>MQ</code>，接收视频处理消息。</p><p>2、进行视频处理。</p><p>3、向数据库写入视频处理结果。</p><p>视频处理进程属于媒资管理系统的一部分，考虑提高系统的扩展性，将视频处理单独定义视频处理工程。</p><h2 id="2-视频处理开发"><a href="#2-视频处理开发" class="headerlink" title="2. 视频处理开发"></a>2. 视频处理开发</h2><h3 id="视频处理工程创建"><a href="#视频处理工程创建" class="headerlink" title="视频处理工程创建"></a>视频处理工程创建</h3><p>1、导入“资料” 下的视频处理工程：<code>xc-service-manage-media-processor</code></p><p><a href="https://qnoss.codeyee.com/20200704_14/image2" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、<code>RabbitMQ</code> 配置</p><p>使用 <code>rabbitMQ</code> 的 <code>routing</code> 交换机模式，视频处理程序监听视频处理队列，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image3" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>RabbitMQ配置如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_MEDIA_PROCESSTASK = <span class="hljs-string">"ex_media_processor"</span>;    <span class="hljs-comment">//视频处理队列</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc‐service‐manage‐media.mq.queue‐media‐video‐processor&#125;"</span>)    <span class="hljs-keyword">public</span> String queue_media_video_processtask;    <span class="hljs-comment">//视频处理路由</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc‐service‐manage‐media.mq.routingkey‐media‐video&#125;"</span>)    <span class="hljs-keyword">public</span> String routingkey_media_video;    <span class="hljs-comment">/**</span><span class="hljs-comment">* 交换机配置</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the exchange</span><span class="hljs-comment">*/</span>    <span class="hljs-meta">@Bean</span>(EX_MEDIA_PROCESSTASK)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_MEDIA_VIDEOTASK</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_MEDIA_PROCESSTASK).durable(<span class="hljs-keyword">true</span>).build();    &#125;     <span class="hljs-comment">//声明队列</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"queue_media_video_processtask"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_PROCESSTASK</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(queue_media_video_processtask,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> queue;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">* 绑定队列到交换机 .</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> queue the queue</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> exchange the exchange</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the binding</span><span class="hljs-comment">*/</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding_queue_media_processtask</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"queue_media_video_processtask"</span>)</span>Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_MEDIA_PROCESSTASK)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(routingkey_media_video).noargs();    &#125;&#125;</code></pre></div><p>在 <code>application.yml</code> 中配置队列名称及 <code>routingkey</code></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">xc‐service‐manage‐media:</span>  <span class="hljs-attr">mq:</span>    <span class="hljs-string">queue‐media‐video‐processor:</span> <span class="hljs-string">queue_media_video_processor</span>    <span class="hljs-string">routingkey‐media‐video:</span> <span class="hljs-string">routingkey_media_video</span></code></pre></div><h3 id="视频处理技术方案"><a href="#视频处理技术方案" class="headerlink" title="视频处理技术方案"></a>视频处理技术方案</h3><p>如何通过程序进行视频处理？</p><p><code>ffmpeg</code> 是一个可行的视频处理程序，可以通过 <code>Java</code> 调用 <code>ffmpeg.exe</code> 完成视频处理。</p><p>在 <code>java</code> 中可以使用 <code>Runtime</code> 类和 <code>Process Builder</code> 类两种方式来执行外部程序，工作中至少掌握一种。</p><p>本项目使用 <code>Process Builder</code> 的方式来调用 <code>ffmpeg</code> 完成视频处理。</p><p>关于 <code>Process Builder</code> 的测试如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//测试ping命令</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProcessBuilder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//创建ProcessBuilder对象</span>    ProcessBuilder processBuilder = <span class="hljs-keyword">new</span> ProcessBuilder();    <span class="hljs-comment">//设置执行的第三方程序(命令)</span>    List&lt;String&gt; cmds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    cmds.add(<span class="hljs-string">"ping"</span>);    cmds.add(<span class="hljs-string">"127.0.0.1"</span>);    processBuilder.command(cmds);    <span class="hljs-comment">//合并标准输入流和错误输出</span>    processBuilder.redirectErrorStream(<span class="hljs-keyword">true</span>);    Process start = processBuilder.start();    <span class="hljs-comment">//获取输入流</span>    InputStream inputStream = start.getInputStream();    <span class="hljs-comment">//将输入流转换为字符输入流</span>    InputStreamReader inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(inputStream, <span class="hljs-string">"gbk"</span>);    <span class="hljs-comment">//获取流的数据</span>    <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;    <span class="hljs-comment">//数据缓冲区</span>    <span class="hljs-keyword">char</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];    StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();    <span class="hljs-keyword">while</span> ((len = inputStreamReader.read(cache)) != -<span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">//获取缓冲区内的数据</span>        String outStr = <span class="hljs-keyword">new</span> String(cache, <span class="hljs-number">0</span>, len);        System.out.println(outStr);        stringBuffer.append(outStr);    &#125;    inputStream.close();&#125;<span class="hljs-comment">//测试使用工具类将avi转成mp4</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProcessMp4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    ProcessBuilder processBuilder = <span class="hljs-keyword">new</span> ProcessBuilder();    <span class="hljs-comment">//定义命令内容</span>    List&lt;String&gt; command = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    command.add(<span class="hljs-string">"D:/soft/ffmpeg-20200315-c467328-win64-static/bin/ffmpeg.exe"</span>);    command.add(<span class="hljs-string">"-i"</span>);    command.add(<span class="hljs-string">"E:/temp/1.avi"</span>);    command.add(<span class="hljs-string">"-y"</span>); <span class="hljs-comment">//覆盖输出文件</span>    command.add(<span class="hljs-string">"-c:v"</span>);    command.add(<span class="hljs-string">"libx264"</span>);    command.add(<span class="hljs-string">"-s"</span>);    command.add(<span class="hljs-string">"1280x720"</span>);    command.add(<span class="hljs-string">"-pix_fmt"</span>);    command.add(<span class="hljs-string">"yuv420p"</span>);    command.add(<span class="hljs-string">"-b:a"</span>);    command.add(<span class="hljs-string">"63k"</span>);    command.add(<span class="hljs-string">"-b:v"</span>);    command.add(<span class="hljs-string">"753k"</span>);    command.add(<span class="hljs-string">"-r"</span>);    command.add(<span class="hljs-string">"18"</span>);    command.add(<span class="hljs-string">"E:/temp/1.mp4"</span>);    processBuilder.command(command);    <span class="hljs-comment">//将标准输入流和错误输入流合并，通过标准输入流读取信息</span>    processBuilder.redirectErrorStream(<span class="hljs-keyword">true</span>);    Process start = processBuilder.start();    InputStream inputStream = start.getInputStream();    InputStreamReader streamReader = <span class="hljs-keyword">new</span> InputStreamReader(inputStream, <span class="hljs-string">"gbk"</span>);    <span class="hljs-comment">//获取输入流数据</span>    <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;    <span class="hljs-comment">//数据缓冲区</span>    <span class="hljs-keyword">char</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];    StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();    <span class="hljs-keyword">while</span> ((len=streamReader.read(cache)) != -<span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">//从缓冲区获取数据</span>        String out = <span class="hljs-keyword">new</span> String(cache, <span class="hljs-number">0</span>, len);        System.out.println(out);        stringBuffer.append(out);    &#125;    inputStream.close();&#125;</code></pre></div><p>上边的代码已经封装成工具类，参见：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image4" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>上边的工具类中：</p><p><code>Mp4VideoUtil.java</code> 完成 <code>avi</code> 转 <code>mp4</code></p><p><code>HlsVideoUtil.java</code> 完成 <code>mp4</code> 转 <code>hls</code></p><p>分别测试每个工具类的使用方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    String ffmpeg_path = <span class="hljs-string">"D:/soft/ffmpeg-20200315-c467328-win64-static/bin/ffmpeg.exe"</span>;<span class="hljs-comment">//ffmpeg的安装位置</span>    String video_path = <span class="hljs-string">"E:\\temp\\1.avi"</span>;    String mp4_name = <span class="hljs-string">"2.mp4"</span>;    String mp4_path = <span class="hljs-string">"E:\\temp\\"</span>;    Mp4VideoUtil videoUtil = <span class="hljs-keyword">new</span> Mp4VideoUtil(ffmpeg_path,video_path,mp4_name,mp4_path);    String s = videoUtil.generateMp4();    System.out.println(s);&#125;</code></pre></div><h3 id="视频处理实现"><a href="#视频处理实现" class="headerlink" title="视频处理实现"></a>视频处理实现</h3><h4 id="1、确定消息格式"><a href="#1、确定消息格式" class="headerlink" title="1、确定消息格式"></a>1、确定消息格式</h4><p><code>MQ</code> 消息统一采用 <code>json</code> 格式，视频处理生产方会向 <code>MQ</code> 发送如下消息，视频处理消费方接收此消息后进行视频处<br>理：</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"mediaId"</span>:XXX&#125;</code></pre></div><h4 id="2、处理流程"><a href="#2、处理流程" class="headerlink" title="2、处理流程"></a>2、处理流程</h4><p>1）接收视频处理消息</p><p>2）判断媒体文件是否需要处理（本视频处理程序目前只接收<code>avi</code> 视频的处理）当前只有 <code>avi</code> 文件需要处理，其它文件需要更新处理状态为 “<code>无需处理</code>”。</p><p>3）处理前初始化处理状态为 “<code>未处理</code>”</p><p>4）处理失败需要在数据库记录处理日志，及处理状态为 “<code>处理失败</code>”</p><p>5）处理成功记录处理状态为 “<code>处理成功</code>“</p><h4 id="3、数据模型"><a href="#3、数据模型" class="headerlink" title="3、数据模型"></a>3、数据模型</h4><p>在 <code>MediaFile</code> 类中添加 <code>mediaFileProcess_m3u8</code> 属性记录 <code>ts</code> 文件列表，代码如下 ：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//处理状态</span><span class="hljs-keyword">private</span> String processStatus;<span class="hljs-comment">//hls处理</span><span class="hljs-keyword">private</span> MediaFileProcess_m3u8 mediaFileProcess_m3u8;</code></pre></div><p><code>MediaFileProcess_m3u8</code> 如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaFileProcess_m3u8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MediaFileProcess</span> </span>&#123;<span class="hljs-comment">//ts列表</span><span class="hljs-keyword">private</span> List&lt;String&gt; tslist;&#125;</code></pre></div><h4 id="4、视频处理生成-MP4"><a href="#4、视频处理生成-MP4" class="headerlink" title="4、视频处理生成 MP4"></a>4、视频处理生成 MP4</h4><p>1）创建 dao</p><p>视频处理结果需要保存到媒资数据库，创建 <code>dao</code> 如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaFileRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">MediaFile</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><p>2）在 <code>application.yml</code> 中配置 <code>ffmpeg</code> 的位置及视频目录的根目录</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">xc‐service‐manage‐media:</span>  <span class="hljs-string">video‐location:</span> <span class="hljs-string">F:/develop/video/</span>  <span class="hljs-string">ffmpeg‐path:</span> <span class="hljs-string">D:/Program</span> <span class="hljs-string">Files/ffmpeg‐20180227‐fa0c9d6‐win64‐static/bin/ffmpeg.exe</span></code></pre></div><p>3）处理任务类</p><p>在 <code>mq</code> 包下创建 <code>MediaProcessTask</code> 类，此类负责监听视频处理队列，并进行视频处理。</p><p>整个视频处理内容较多，这里分两部分实现：生成 <code>Mp4</code> 和生成 <code>m3u8</code>，下边代码实现了生成 <code>mp4</code> 。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaProcessTask</span> </span>&#123;    <span class="hljs-comment">//日志对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MediaProcessTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//ffmpeg绝对路径</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.ffmpeg-path&#125;"</span>)    String ffmpeg_path;    <span class="hljs-comment">//上传文件根目录</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.video-location&#125;"</span>)    String serverPath;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;xc-service-manage-media.mq.queue-media-video-processor&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMediaProcessTask</span><span class="hljs-params">(String msg)</span></span>&#123;        <span class="hljs-comment">//将接收到的消息转换为json数据</span>        Map msgMap = JSON.parseObject(msg);        LOGGER.info(<span class="hljs-string">"receive media process task msg :&#123;&#125; "</span>,msgMap);        <span class="hljs-comment">//解析消息</span>        <span class="hljs-comment">//媒资文件id</span>        String mediaId = (String) msgMap.get(<span class="hljs-string">"mediaId"</span>);        <span class="hljs-comment">//获取媒资文件信息</span>        Optional&lt;MediaFile&gt; byId = mediaFileRepository.findById(mediaId);        <span class="hljs-keyword">if</span>(!byId.isPresent())&#123;            <span class="hljs-keyword">return</span>;        &#125;        MediaFile mediaFile = byId.get();        <span class="hljs-comment">//媒资文件类型</span>        String fileType = mediaFile.getFileType();        <span class="hljs-comment">//目前只处理avi文件</span>        <span class="hljs-keyword">if</span>(fileType == <span class="hljs-keyword">null</span> || !fileType.equals(<span class="hljs-string">"avi"</span>))&#123;            mediaFile.setProcessStatus(<span class="hljs-string">"303004"</span>); <span class="hljs-comment">// 处理状态为无需处理</span>            mediaFileRepository.save(mediaFile);        &#125;<span class="hljs-keyword">else</span>&#123;            mediaFile.setProcessStatus(<span class="hljs-string">"303001"</span>); <span class="hljs-comment">//处理状态为未处理</span>        &#125;        <span class="hljs-comment">//生成MP4</span>        String videoPath = serverPath + mediaFile.getFilePath() + mediaFile.getFileName();        String mp4Name = mediaFile.getFileId() + <span class="hljs-string">".mp4"</span>;        String mp4FloderPath = serverPath  + mediaFile.getFilePath();        Mp4VideoUtil mp4VideoUtil = <span class="hljs-keyword">new</span> Mp4VideoUtil(ffmpeg_path, videoPath, mp4Name, mp4FloderPath);        String result = mp4VideoUtil.generateMp4();        <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span> || !result.equals(<span class="hljs-string">"success"</span>))&#123;            <span class="hljs-comment">//操作失败写入处理日志</span>            mediaFile.setProcessStatus(<span class="hljs-string">"303003"</span>);<span class="hljs-comment">//处理状态为处理失败</span>            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();            mediaFileProcess_m3u8.setErrormsg(result);            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);            mediaFileRepository.save(mediaFile);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//生成m3u8...</span>    &#125;&#125;</code></pre></div><p>说明：</p><p>1、原始视频转成 <code>mp4</code> 如何判断转换成功？</p><p>根据视频时长来判断，取原视频和转换成功视频的时长（时分秒），如果相等则相同。</p><h4 id="5、视频处理生成-m3u8"><a href="#5、视频处理生成-m3u8" class="headerlink" title="5、视频处理生成 m3u8"></a>5、视频处理生成 m3u8</h4><p>下边是完整的视频处理任务类代码，包括了生成 <code>m3u8</code> 及生成 <code>mp4</code> 的代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media_process.mq;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFileProcess_m3u8;<span class="hljs-keyword">import</span> com.xuecheng.framework.utils.HlsVideoUtil;<span class="hljs-keyword">import</span> com.xuecheng.framework.utils.Mp4VideoUtil;<span class="hljs-keyword">import</span> com.xuecheng.manage_media_process.dao.MediaFileRepository;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaProcessTask</span> </span>&#123;    <span class="hljs-comment">//日志对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MediaProcessTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//ffmpeg绝对路径</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.ffmpeg-path&#125;"</span>)    String ffmpeg_path;    <span class="hljs-comment">//上传文件根目录</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.video-location&#125;"</span>)    String serverPath;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;xc-service-manage-media.mq.queue-media-video-processor&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMediaProcessTask</span><span class="hljs-params">(String msg)</span></span>&#123;        <span class="hljs-comment">//将接收到的消息转换为json数据</span>        Map msgMap = JSON.parseObject(msg);        LOGGER.info(<span class="hljs-string">"receive media process task msg :&#123;&#125; "</span>,msgMap);        <span class="hljs-comment">//解析消息</span>        <span class="hljs-comment">//媒资文件id</span>        String mediaId = (String) msgMap.get(<span class="hljs-string">"mediaId"</span>);        <span class="hljs-comment">//获取媒资文件信息</span>        Optional&lt;MediaFile&gt; byId = mediaFileRepository.findById(mediaId);        <span class="hljs-keyword">if</span>(!byId.isPresent())&#123;            <span class="hljs-keyword">return</span>;        &#125;        MediaFile mediaFile = byId.get();        <span class="hljs-comment">//媒资文件类型</span>        String fileType = mediaFile.getFileType();        <span class="hljs-comment">//目前只处理avi文件</span>        <span class="hljs-keyword">if</span>(fileType == <span class="hljs-keyword">null</span> || !fileType.equals(<span class="hljs-string">"avi"</span>))&#123;            mediaFile.setProcessStatus(<span class="hljs-string">"303004"</span>); <span class="hljs-comment">// 处理状态为无需处理</span>            mediaFileRepository.save(mediaFile);        &#125;<span class="hljs-keyword">else</span>&#123;            mediaFile.setProcessStatus(<span class="hljs-string">"303001"</span>); <span class="hljs-comment">//处理状态为未处理</span>        &#125;        <span class="hljs-comment">//生成MP4</span>        String videoPath = serverPath + mediaFile.getFilePath() + mediaFile.getFileName();        String mp4Name = mediaFile.getFileId() + <span class="hljs-string">".mp4"</span>;        String mp4FloderPath = serverPath  + mediaFile.getFilePath();        Mp4VideoUtil mp4VideoUtil = <span class="hljs-keyword">new</span> Mp4VideoUtil(ffmpeg_path, videoPath, mp4Name, mp4FloderPath);        String result = mp4VideoUtil.generateMp4();        <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span> || !result.equals(<span class="hljs-string">"success"</span>))&#123;            <span class="hljs-comment">//操作失败写入处理日志</span>            mediaFile.setProcessStatus(<span class="hljs-string">"303003"</span>);<span class="hljs-comment">//处理状态为处理失败</span>            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();            mediaFileProcess_m3u8.setErrormsg(result);            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);            mediaFileRepository.save(mediaFile);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//生成m3u8列表</span>        <span class="hljs-comment">//生成m3u8</span>        String mp4VideoPath = serverPath + mediaFile.getFilePath()+ mp4Name;<span class="hljs-comment">//此地址为mp4的地址</span>        String m3u8Name = mediaFile.getFileId()+<span class="hljs-string">".m3u8"</span>;        String m3u8FolderPath = serverPath + mediaFile.getFilePath()+<span class="hljs-string">"hls/"</span>;        <span class="hljs-comment">//调用工具类进行生成m3u8</span>        HlsVideoUtil hlsVideoUtil = <span class="hljs-keyword">new</span> HlsVideoUtil(ffmpeg_path, mp4VideoPath, m3u8Name, m3u8FolderPath);        String m3u8Result = hlsVideoUtil.generateM3u8();        <span class="hljs-keyword">if</span>(m3u8Result==<span class="hljs-keyword">null</span> || !m3u8Result.equals(<span class="hljs-string">"success"</span>))&#123;            <span class="hljs-comment">//操作失败写入处理日志</span>            mediaFile.setProcessStatus(<span class="hljs-string">"303003"</span>);<span class="hljs-comment">//处理状态为处理失败</span>            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();            mediaFileProcess_m3u8.setErrormsg(m3u8Result);            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);            mediaFileRepository.save(mediaFile);            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-comment">//获取m3u8列表</span>        List&lt;String&gt; ts_list = hlsVideoUtil.get_ts_list();        <span class="hljs-comment">//更新处理状态为成功</span>        mediaFile.setProcessStatus(<span class="hljs-string">"303002"</span>);<span class="hljs-comment">//处理状态为处理成功</span>        MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();        mediaFileProcess_m3u8.setTslist(ts_list);        mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);        <span class="hljs-comment">//m3u8文件url</span>        mediaFile.setFileUrl(mediaFile.getFilePath()+<span class="hljs-string">"hls/"</span>+m3u8Name);        mediaFileRepository.save(mediaFile);    &#125;&#125;</code></pre></div><h2 id="3-发送视频处理消息"><a href="#3-发送视频处理消息" class="headerlink" title="3. 发送视频处理消息"></a>3. 发送视频处理消息</h2><p>当视频上传成功后向 <code>MQ</code> 发送视频 处理消息。</p><p>修改媒资管理服务的文件上传代码，当文件上传成功向 <code>MQ</code> 发送视频处理消息。</p><h3 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h3><p>1、将<code>media-processor</code> 工程下的 <code>RabbitmqConfig</code> 配置类拷贝到 <code>media</code> 工程下。</p><p>2、在 <code>media</code> 工程下配置 <code>mq</code> 队列等信息</p><p>修改 <code>application.yml</code></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">xc-service-manage-media:</span>  <span class="hljs-attr">mq:</span>    <span class="hljs-attr">queue-media-video-processor:</span> <span class="hljs-string">queue_media_video_processor</span>    <span class="hljs-attr">routingkey-media-video:</span> <span class="hljs-string">routingkey_media_video</span></code></pre></div><h3 id="配置Service"><a href="#配置Service" class="headerlink" title="配置Service"></a>配置Service</h3><p>在文件合并方法中添加向 <code>mq</code> 发送视频处理消息的代码：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//视频处理路由</span><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.mq.routingkey-media-video&#125;"</span>)<span class="hljs-keyword">public</span> String routingkey_media_video;<span class="hljs-meta">@Autowired</span>RabbitTemplate rabbitTemplate;<span class="hljs-comment">//向MQ发送视频处理消息</span><span class="hljs-function"><span class="hljs-keyword">private</span> ResponseResult <span class="hljs-title">sendProcessVideoMsg</span><span class="hljs-params">(String mediaId)</span></span>&#123;    Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(mediaId);    <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);    &#125;    MediaFile mediaFile = optional.get();    <span class="hljs-comment">//发送视频处理消息</span>    Map&lt;String,String&gt; msgMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    msgMap.put(<span class="hljs-string">"mediaId"</span>,mediaId);    <span class="hljs-comment">//发送的消息</span>    String msg = JSON.toJSONString(msgMap);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">this</span>.rabbitTemplate.convertAndSend(RabbitMQConfig.EX_MEDIA_PROCESSTASK,routingkey_media_video,msg);        LOGGER.info(<span class="hljs-string">"send media process task msg:&#123;&#125;"</span>,msg);    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;        e.printStackTrace();        LOGGER.info(<span class="hljs-string">"send media process task error,msg is:&#123;&#125;,error:&#123;&#125;"</span>,msg,e.getMessage());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);&#125;</code></pre></div><p>在 <code>mergechunks</code> 方法最后调用 <code>sendProcessVideo</code> 方法。</p><div class="hljs"><pre><code class="hljs java">......<span class="hljs-comment">//状态为上传成功</span>mediaFile.setFileStatus(<span class="hljs-string">"301002"</span>);mediaFileRepository.save(mediaFile);String mediaId = mediaFile.getFileId();<span class="hljs-comment">//向MQ发送视频处理消息</span>sendProcessVideoMsg(mediaId);......</code></pre></div><h2 id="4-视频处理测试"><a href="#4-视频处理测试" class="headerlink" title="4. 视频处理测试"></a>4. 视频处理测试</h2><p>测试流程：</p><p>1、上传avi文件</p><p>2、观察日志是否发送消息</p><p>3、观察视频处理进程是否接收到消息进行处理</p><p>4、观察 <code>mp4</code> 文件是否生成</p><p>5、观察 <code>m3u8</code> 及 <code>ts</code> 文件是否生成</p><h2 id="5-视频处理并发设置"><a href="#5-视频处理并发设置" class="headerlink" title="5. 视频处理并发设置"></a>5. 视频处理并发设置</h2><p>代码中使用 <code>@RabbitListener</code> 注解指定消费方法，默认情况是单线程监听队列，可以观察当队列有多个任务时消费端每次只消费一个消息，单线程处理消息容易引起消息处理缓慢，消息堆积，不能最大利用硬件资源。</p><p>可以配置 <code>mq</code> 的容器工厂参数，增加并发处理数量即可实现多线程处理监听队列，实现多线程处理消息。</p><p>1、在 <code>RabbitmqConfig.java</code> 中添加容器工厂配置：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 多线程处理消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> configurer</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connectionFactory</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@Bean</span>(<span class="hljs-string">"customContainerFactory"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title">containerFactory</span><span class="hljs-params">(SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory</span></span><span class="hljs-function"><span class="hljs-params">                                                             connectionFactory)</span> </span>&#123;    SimpleRabbitListenerContainerFactory factory = <span class="hljs-keyword">new</span> SimpleRabbitListenerContainerFactory();    factory.setConcurrentConsumers(DEFAULT_CONCURRENT);    factory.setMaxConcurrentConsumers(DEFAULT_CONCURRENT);    configurer.configure(factory,connectionFactory);    <span class="hljs-keyword">return</span> factory;&#125;</code></pre></div><p>2、在 <code>@RabbitListener</code> 注解中指定容器工厂</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//视频处理方法</span><span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">"$&#123;xc‐service‐manage‐media.mq.queue‐media‐video‐processor&#125;"</span>&#125;,containerFactory=<span class="hljs-string">"customContainerFactory"</span>)</code></pre></div><p>再次测试当队列有多个任务时消费端的并发处理能力。</p><h2 id="6-完整代码"><a href="#6-完整代码" class="headerlink" title="6. 完整代码"></a>6. 完整代码</h2><h3 id="RabbitMQConfig"><a href="#RabbitMQConfig" class="headerlink" title="RabbitMQConfig"></a>RabbitMQConfig</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media_process.config;<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_MEDIA_PROCESSTASK = <span class="hljs-string">"ex_media_processor"</span>;    <span class="hljs-comment">//视频处理队列</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.mq.queue-media-video-processor&#125;"</span>)    <span class="hljs-keyword">public</span>  String queue_media_video_processtask;    <span class="hljs-comment">//视频处理路由</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.mq.routingkey-media-video&#125;"</span>)    <span class="hljs-keyword">public</span>  String routingkey_media_video;    <span class="hljs-comment">//消费者并发数量</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CONCURRENT = <span class="hljs-number">10</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换机配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the exchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EX_MEDIA_PROCESSTASK)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_MEDIA_VIDEOTASK</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_MEDIA_PROCESSTASK).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">//声明队列</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"queue_media_video_processtask"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_PROCESSTASK</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(queue_media_video_processtask,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定队列到交换机 .</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    the queue</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange the exchange</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the binding</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding_queue_media_processtask</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"queue_media_video_processtask"</span>)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_MEDIA_PROCESSTASK)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(routingkey_media_video).noargs();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 多线程处理消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> configurer</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connectionFactory</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"customContainerFactory"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title">containerFactory</span><span class="hljs-params">(SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory</span></span><span class="hljs-function"><span class="hljs-params">            connectionFactory)</span> </span>&#123;        SimpleRabbitListenerContainerFactory factory = <span class="hljs-keyword">new</span> SimpleRabbitListenerContainerFactory();        factory.setConcurrentConsumers(DEFAULT_CONCURRENT);        factory.setMaxConcurrentConsumers(DEFAULT_CONCURRENT);        configurer.configure(factory,connectionFactory);        <span class="hljs-keyword">return</span> factory;    &#125;&#125;</code></pre></div><h3 id="MediaProcessTask"><a href="#MediaProcessTask" class="headerlink" title="MediaProcessTask"></a>MediaProcessTask</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media_process.mq;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFileProcess_m3u8;<span class="hljs-keyword">import</span> com.xuecheng.framework.utils.HlsVideoUtil;<span class="hljs-keyword">import</span> com.xuecheng.framework.utils.Mp4VideoUtil;<span class="hljs-keyword">import</span> com.xuecheng.manage_media_process.dao.MediaFileRepository;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaProcessTask</span> </span>&#123;    <span class="hljs-comment">//日志对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MediaProcessTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//ffmpeg绝对路径</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.ffmpeg-path&#125;"</span>)    String ffmpeg_path;    <span class="hljs-comment">//上传文件根目录</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.video-location&#125;"</span>)    String serverPath;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"$&#123;xc-service-manage-media.mq.queue-media-video-processor&#125;"</span> , containerFactory=<span class="hljs-string">"customContainerFactory"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMediaProcessTask</span><span class="hljs-params">(String msg)</span></span>&#123;        <span class="hljs-comment">//将接收到的消息转换为json数据</span>        Map msgMap = JSON.parseObject(msg);        LOGGER.info(<span class="hljs-string">"receive media process task msg :&#123;&#125; "</span>,msgMap);        <span class="hljs-comment">//解析消息</span>        <span class="hljs-comment">//媒资文件id</span>        String mediaId = (String) msgMap.get(<span class="hljs-string">"mediaId"</span>);        <span class="hljs-comment">//获取媒资文件信息</span>        Optional&lt;MediaFile&gt; byId = mediaFileRepository.findById(mediaId);        <span class="hljs-keyword">if</span>(!byId.isPresent())&#123;            <span class="hljs-keyword">return</span>;        &#125;        MediaFile mediaFile = byId.get();        <span class="hljs-comment">//媒资文件类型</span>        String fileType = mediaFile.getFileType();        <span class="hljs-comment">//目前只处理avi文件</span>        <span class="hljs-keyword">if</span>(fileType == <span class="hljs-keyword">null</span> || !fileType.equals(<span class="hljs-string">"avi"</span>))&#123;            mediaFile.setProcessStatus(<span class="hljs-string">"303004"</span>); <span class="hljs-comment">// 处理状态为无需处理</span>            mediaFileRepository.save(mediaFile);        &#125;<span class="hljs-keyword">else</span>&#123;            mediaFile.setProcessStatus(<span class="hljs-string">"303001"</span>); <span class="hljs-comment">//处理状态为未处理</span>        &#125;        <span class="hljs-comment">//生成MP4</span>        String videoPath = serverPath + mediaFile.getFilePath() + mediaFile.getFileName();        String mp4Name = mediaFile.getFileId() + <span class="hljs-string">".mp4"</span>;        String mp4FloderPath = serverPath  + mediaFile.getFilePath();        Mp4VideoUtil mp4VideoUtil = <span class="hljs-keyword">new</span> Mp4VideoUtil(ffmpeg_path, videoPath, mp4Name, mp4FloderPath);        String result = mp4VideoUtil.generateMp4();        <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span> || !result.equals(<span class="hljs-string">"success"</span>))&#123;            <span class="hljs-comment">//操作失败写入处理日志</span>            mediaFile.setProcessStatus(<span class="hljs-string">"303003"</span>);<span class="hljs-comment">//处理状态为处理失败</span>            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();            mediaFileProcess_m3u8.setErrormsg(result);            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);            mediaFileRepository.save(mediaFile);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//生成m3u8列表</span>        <span class="hljs-comment">//生成m3u8</span>        String mp4VideoPath = serverPath + mediaFile.getFilePath()+ mp4Name;<span class="hljs-comment">//此地址为mp4的地址</span>        String m3u8Name = mediaFile.getFileId()+<span class="hljs-string">".m3u8"</span>;        String m3u8FolderPath = serverPath + mediaFile.getFilePath()+<span class="hljs-string">"hls/"</span>;        <span class="hljs-comment">//调用工具类进行生成m3u8</span>        HlsVideoUtil hlsVideoUtil = <span class="hljs-keyword">new</span> HlsVideoUtil(ffmpeg_path, mp4VideoPath, m3u8Name, m3u8FolderPath);        String m3u8Result = hlsVideoUtil.generateM3u8();        <span class="hljs-keyword">if</span>(m3u8Result==<span class="hljs-keyword">null</span> || !m3u8Result.equals(<span class="hljs-string">"success"</span>))&#123;            <span class="hljs-comment">//操作失败写入处理日志</span>            mediaFile.setProcessStatus(<span class="hljs-string">"303003"</span>);<span class="hljs-comment">//处理状态为处理失败</span>            MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();            mediaFileProcess_m3u8.setErrormsg(m3u8Result);            mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);            mediaFileRepository.save(mediaFile);            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-comment">//获取m3u8列表</span>        List&lt;String&gt; ts_list = hlsVideoUtil.get_ts_list();        <span class="hljs-comment">//更新处理状态为成功</span>        mediaFile.setProcessStatus(<span class="hljs-string">"303002"</span>);<span class="hljs-comment">//处理状态为处理成功</span>        MediaFileProcess_m3u8 mediaFileProcess_m3u8 = <span class="hljs-keyword">new</span> MediaFileProcess_m3u8();        mediaFileProcess_m3u8.setTslist(ts_list);        mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8);        <span class="hljs-comment">//m3u8文件url</span>        mediaFile.setFileUrl(mediaFile.getFilePath()+<span class="hljs-string">"hls/"</span>+m3u8Name);        mediaFileRepository.save(mediaFile);    &#125;&#125;</code></pre></div><h3 id="MediaUploadServiceImpl"><a href="#MediaUploadServiceImpl" class="headerlink" title="MediaUploadServiceImpl"></a>MediaUploadServiceImpl</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.service.impl;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.netflix.discovery.converters.Auto;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.CheckChunkResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.MediaCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.config.RabbitMQConfig;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.controller.MediaUploadController;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.dao.MediaFileRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.service.MediaUploadService;<span class="hljs-keyword">import</span> org.apache.commons.codec.digest.DigestUtils;<span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-keyword">import</span> javax.jws.Oneway;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-meta">@Service</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaUploadServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaUploadService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(MediaUploadController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-comment">//上传文件根目录</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.upload-location&#125;"</span>)    String uploadPath;   <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查文件信息是否已经存在本地以及mongodb内,其中一者不存在则重新注册</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件扩展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 文件路径</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">register</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-comment">//1.检查文件在磁盘上是否存在</span>        <span class="hljs-comment">//2.检查文件信息在mongodb上是否存在</span>        <span class="hljs-comment">//获取文件所属目录以及文件路径</span>        String fileFloderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String filePath = <span class="hljs-keyword">this</span>.getFileFullPath(fileMd5, fileExt);        File file = <span class="hljs-keyword">new</span> File(filePath);        <span class="hljs-keyword">boolean</span> exists = file.exists();        <span class="hljs-comment">//查询mongodb上的文件信息</span>        Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5);        <span class="hljs-keyword">if</span>(exists &amp;&amp; optional.isPresent())&#123;            ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST);        &#125;        <span class="hljs-comment">//其中一者不存在则重新注册文件信息</span>        File fileFloder = <span class="hljs-keyword">new</span> File(fileFloderPath);        <span class="hljs-keyword">if</span>(!fileFloder.exists())&#123;            <span class="hljs-comment">//创建文件目录</span>            fileFloder.mkdirs();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查文件块是否存在</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 块编号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunkSize 块大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CheckChunkResult</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CheckChunkResult <span class="hljs-title">checkChunk</span><span class="hljs-params">(String fileMd5, Integer chunk, Integer chunkSize)</span> </span>&#123;        <span class="hljs-comment">//获取文件块路径</span>        String chunkFloder = <span class="hljs-keyword">this</span>.getChunkFloderPath(fileMd5);        File chunkFile = <span class="hljs-keyword">new</span> File(chunkFloder + chunk);        <span class="hljs-keyword">if</span>(chunkFile.exists())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CheckChunkResult(CommonCode.SUCCESS, <span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CheckChunkResult(CommonCode.SUCCESS, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 上传分块文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file 上传的文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 分块号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">uploadChunk</span><span class="hljs-params">(MultipartFile file, Integer chunk, String fileMd5)</span> </span>&#123;        <span class="hljs-comment">//获取分块文件所属目录</span>        String chunkFloder = <span class="hljs-keyword">this</span>.getChunkFloderPath(fileMd5);        InputStream inputStream = <span class="hljs-keyword">null</span>;        FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            inputStream = file.getInputStream();            fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(chunkFloder + chunk);            IOUtils.copy(inputStream,fileOutputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-comment">//文件保存失败</span>            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"upload chunk file fail:&#123;&#125;"</span>,e.getMessage());            ExceptionCast.cast(MediaCode.CHUNK_FILE_UPLOAD_FAIL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 合并文件块信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 文件名称</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileSize 文件大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mimetype 文件类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件拓展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ResponseResult</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">mergeChunks</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-comment">//获取文件块路径</span>        String chunkFloderPath = getChunkFloderPath(fileMd5);        <span class="hljs-comment">//合并文件路径</span>        String fileFullPath = <span class="hljs-keyword">this</span>.getFileFullPath(fileMd5, fileExt);        File mergeFile = <span class="hljs-keyword">new</span> File(fileFullPath);        <span class="hljs-comment">//创建合并文件,如果存在则先删除再创建</span>        <span class="hljs-keyword">if</span>(mergeFile.exists())&#123;            mergeFile.delete();        &#125;        <span class="hljs-keyword">boolean</span> newFile = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            newFile = mergeFile.createNewFile();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"mergechunks..create mergeFile fail:&#123;&#125;"</span>,e.getMessage());        &#125;        <span class="hljs-keyword">if</span>(!newFile)&#123;            <span class="hljs-comment">//文件创建失败</span>            ExceptionCast.cast(MediaCode.MERGE_FILE_CREATEFAIL);        &#125;        <span class="hljs-comment">//获取块文件列表,此列表是已经排序好的</span>        List&lt;File&gt; chunkFiles = <span class="hljs-keyword">this</span>.getChunkFiles(chunkFloderPath);        <span class="hljs-comment">//合并文件</span>        mergeFile = <span class="hljs-keyword">this</span>.mergeFile(mergeFile, chunkFiles);        <span class="hljs-keyword">if</span>(mergeFile == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(MediaCode.MERGE_FILE_FAIL);        &#125;        <span class="hljs-comment">//校验文件</span>        <span class="hljs-keyword">boolean</span> checkResult = <span class="hljs-keyword">this</span>.checkFileMd5(mergeFile, fileMd5);        <span class="hljs-keyword">if</span>(!checkResult)&#123;            ExceptionCast.cast(MediaCode.MERGE_FILE_CHECKFAIL);        &#125;        <span class="hljs-comment">//将文件信息保存到数据库</span>        MediaFile mediaFile = <span class="hljs-keyword">new</span> MediaFile();        mediaFile.setFileId(fileMd5);        mediaFile.setFileName(fileMd5+<span class="hljs-string">"."</span>+fileExt);        mediaFile.setFileOriginalName(fileName);        <span class="hljs-comment">//文件路径保存相对路径</span>        String filePath = <span class="hljs-keyword">this</span>.getFilePath(fileMd5,fileExt);        mediaFile.setFilePath(<span class="hljs-keyword">this</span>.getFilePath(fileMd5,fileExt));        mediaFile.setFileUrl(filePath + fileName + <span class="hljs-string">"."</span> + fileExt);        mediaFile.setFileSize(fileSize);        mediaFile.setUploadTime(<span class="hljs-keyword">new</span> Date());        mediaFile.setMimeType(mimetype);        mediaFile.setFileType(fileExt);        <span class="hljs-comment">//状态为上传成功</span>        mediaFile.setFileStatus(<span class="hljs-string">"301002"</span>);        MediaFile save = mediaFileRepository.save(mediaFile);        <span class="hljs-comment">//向MQ发送视频处理消息</span>        <span class="hljs-keyword">this</span>.sendProcessVideoMsg(fileMd5);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">//视频处理路由</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.mq.routingkey-media-video&#125;"</span>)    <span class="hljs-keyword">public</span> String routingkey_media_video;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-comment">//向MQ发送视频处理消息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> ResponseResult <span class="hljs-title">sendProcessVideoMsg</span><span class="hljs-params">(String mediaId)</span></span>&#123;        Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(mediaId);        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);        &#125;        MediaFile mediaFile = optional.get();        <span class="hljs-comment">//发送视频处理消息</span>        Map&lt;String,String&gt; msgMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        msgMap.put(<span class="hljs-string">"mediaId"</span>,mediaId);        <span class="hljs-comment">//发送的消息</span>        String msg = JSON.toJSONString(msgMap);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.rabbitTemplate.convertAndSend(RabbitMQConfig.EX_MEDIA_PROCESSTASK,routingkey_media_video,msg);            LOGGER.info(<span class="hljs-string">"send media process task msg:&#123;&#125;"</span>,msg);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();            LOGGER.info(<span class="hljs-string">"send media process task error,msg is:&#123;&#125;,error:&#123;&#125;"</span>,msg,e.getMessage());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">//校验文件MD5</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkFileMd5</span><span class="hljs-params">(File mergeFile, String fileMd5)</span> </span>&#123;        <span class="hljs-keyword">if</span>(mergeFile == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(fileMd5))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//进行md5校验</span>        <span class="hljs-keyword">try</span> &#123;            FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(mergeFile);            <span class="hljs-comment">//得到文件的MD5</span>            String md5Hex = DigestUtils.md5Hex(fileInputStream);            <span class="hljs-comment">//比较两个MD5值</span>            <span class="hljs-keyword">if</span>(md5Hex.equalsIgnoreCase(fileMd5))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"未找到该文件 &#123;&#125;"</span>,e.getMessage());        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//合并文件</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> File <span class="hljs-title">mergeFile</span><span class="hljs-params">(File mergeFile, List&lt;File&gt; chunkFiles)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建写文件对象</span>            RandomAccessFile raf_write = <span class="hljs-keyword">new</span> RandomAccessFile(mergeFile,<span class="hljs-string">"rw"</span>);            <span class="hljs-comment">//遍历分块文件开始合并</span>            <span class="hljs-comment">//读取文件缓冲区</span>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">for</span>(File chunkFile:chunkFiles)&#123;                RandomAccessFile raf_read = <span class="hljs-keyword">new</span> RandomAccessFile(chunkFile,<span class="hljs-string">"r"</span>);                <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;                <span class="hljs-comment">//读取分块文件</span>                <span class="hljs-keyword">while</span>((len = raf_read.read(b))!= -<span class="hljs-number">1</span>)&#123;                    <span class="hljs-comment">//向合并文件中写数据</span>                    raf_write.write(b,<span class="hljs-number">0</span>,len);                &#125;                 raf_read.close();            &#125;             raf_write.close();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"merge file error:&#123;&#125;"</span>,e.getMessage());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-keyword">return</span> mergeFile;    &#125;    <span class="hljs-comment">//获取块文件列表</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;File&gt; <span class="hljs-title">getChunkFiles</span><span class="hljs-params">(String chunkFloderPath)</span> </span>&#123;        <span class="hljs-comment">//块文件目录</span>        File chunkFolder = <span class="hljs-keyword">new</span> File(chunkFloderPath);        <span class="hljs-comment">//分块文件列表</span>        File[] fileArray = chunkFolder.listFiles();        <span class="hljs-comment">//将分块列表转为集合,便于排序</span>        ArrayList&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(fileArray));        <span class="hljs-comment">//从小到大排序,按名称升序</span>        Collections.sort(fileList, <span class="hljs-keyword">new</span> Comparator&lt;File&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(File o1, File o2)</span> </span>&#123;                <span class="hljs-comment">//比较两个文件的名称</span>                <span class="hljs-keyword">if</span> (Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName())) &#123;                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;        &#125;);        <span class="hljs-keyword">return</span> fileList;    &#125;    <span class="hljs-comment">//获取文件块路径</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getChunkFloderPath</span><span class="hljs-params">(String fileMd5)</span> </span>&#123;        <span class="hljs-comment">//获取分块文件所属目录</span>        String fileFloderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String chunkFloder = fileFloderPath + <span class="hljs-string">"chunk/"</span>;        File fileChunkFloder = <span class="hljs-keyword">new</span> File(chunkFloder);        <span class="hljs-comment">//如果分块所属目录不存在则创建</span>        <span class="hljs-keyword">if</span>(!fileChunkFloder.exists())&#123;            fileChunkFloder.mkdirs();        &#125;        <span class="hljs-keyword">return</span> chunkFloder;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据文件md5得到文件的所属目录</span><span class="hljs-comment">     * 规则：</span><span class="hljs-comment">     * 一级目录：md5的第一个字符</span><span class="hljs-comment">     * 二级目录：md5的第二个字符</span><span class="hljs-comment">     * 三级目录：md5</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileFloderPath</span><span class="hljs-params">(String fileMd5)</span></span>&#123;            String floderPath = uploadPath + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) + <span class="hljs-string">"/"</span> +fileMd5  + <span class="hljs-string">"/"</span>;            <span class="hljs-keyword">return</span> floderPath;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取全文件路径</span><span class="hljs-comment">     * 文件名：md5+文件扩展名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileFullPath</span><span class="hljs-params">(String fileMd5, String fileExt)</span></span>&#123;        String floderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String filePath = floderPath + fileMd5 + <span class="hljs-string">"."</span> + fileExt;        <span class="hljs-keyword">return</span> filePath;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取文件路径</span><span class="hljs-comment">     * 文件名：md5+文件扩展名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFilePath</span><span class="hljs-params">(String fileMd5, String fileExt)</span></span>&#123;        String filePath = <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) + <span class="hljs-string">"/"</span> + fileMd5 + <span class="hljs-string">"/"</span>;        <span class="hljs-keyword">return</span> filePath;    &#125;&#125;</code></pre></div><h1 id="二、我的媒资"><a href="#二、我的媒资" class="headerlink" title="二、我的媒资"></a>二、我的媒资</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>通过我的媒资可以查询本教育机构拥有的媒资文件，进行文件处理、删除文件、修改文件信息等操作，具体需求如<br>下：</p><p>1、分页查询我的媒资文件</p><p>2、删除媒资文件</p><p>3、处理媒资文件</p><p>4、修改媒资文件信息</p><p><a href="https://qnoss.codeyee.com/20200704_14/image5" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image5.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h2><p>本节讲解我的媒资文件分页查询、处理媒资文件，其它功能请学员自行实现</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"媒体文件管理"</span>,description = <span class="hljs-string">"媒体文件管理接口"</span>,tags = &#123;<span class="hljs-string">"媒体文件管理接口"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaFileControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"查询文件列表"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryMediaFileRequest queryMediaFileRequest)</span></span>;&#125;</code></pre></div><h2 id="3-服务端开发"><a href="#3-服务端开发" class="headerlink" title="3. 服务端开发"></a>3. 服务端开发</h2><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaFileRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">MediaFile</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>定义 <code>findList</code> 方法实现媒资文件查询列表</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.service;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.request.QueryMediaFileRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaFileService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询媒体问价内信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 每页数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queryMediaFileRequest 查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> QueryResponseResult</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryMediaFileRequest queryMediaFileRequest)</span></span>;&#125;</code></pre></div><p>实现</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.service.impl;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.request.QueryMediaFileRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.dao.MediaFileRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.service.MediaFileService;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.domain.Example;<span class="hljs-keyword">import</span> org.springframework.data.domain.ExampleMatcher;<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;<span class="hljs-keyword">import</span> org.springframework.data.domain.PageRequest;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaFileServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaFileService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(MediaFileService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询文件信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 每页数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queryMediaFileRequest 查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> QueryResponseResult</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryMediaFileRequest queryMediaFileRequest)</span> </span>&#123;        MediaFile mediaFile = <span class="hljs-keyword">new</span> MediaFile();        <span class="hljs-comment">//查询条件</span>        <span class="hljs-keyword">if</span>(queryMediaFileRequest == <span class="hljs-keyword">null</span>)&#123;            queryMediaFileRequest = <span class="hljs-keyword">new</span> QueryMediaFileRequest();        &#125;        <span class="hljs-comment">//查询条件匹配器</span>        ExampleMatcher exampleMatcher = ExampleMatcher.matching()                .withMatcher(<span class="hljs-string">"tag"</span>, ExampleMatcher.GenericPropertyMatchers.contains()) <span class="hljs-comment">//模糊匹配</span>                .withMatcher(<span class="hljs-string">"fileOriginalName"</span>, ExampleMatcher.GenericPropertyMatchers.contains()) <span class="hljs-comment">//模糊匹配文件原始名称</span>                .withMatcher(<span class="hljs-string">"processStatus"</span>, ExampleMatcher.GenericPropertyMatchers.exact());<span class="hljs-comment">//精确匹配</span>        <span class="hljs-comment">//设置查询条件对象</span>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(queryMediaFileRequest.getTag()))&#123;            <span class="hljs-comment">//设置标签</span>            mediaFile.setTag(queryMediaFileRequest.getTag());        &#125;        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(queryMediaFileRequest.getFileOriginalName()))&#123;            <span class="hljs-comment">//设置文件原始名称</span>            mediaFile.setFileOriginalName(queryMediaFileRequest.getFileOriginalName());        &#125;        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(queryMediaFileRequest.getProcessStatus()))&#123;            <span class="hljs-comment">//设置处理状态</span>            mediaFile.setProcessStatus(queryMediaFileRequest.getProcessStatus());        &#125;        <span class="hljs-comment">//定义Example实例</span>        Example&lt;MediaFile&gt; example = Example.of(mediaFile, exampleMatcher);        <span class="hljs-comment">//校验page和size参数的合法性,并设置默认值</span>        <span class="hljs-keyword">if</span>(page &lt;=<span class="hljs-number">0</span>)&#123;            page = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            page = page -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(size &lt;=<span class="hljs-number">0</span>)&#123;            size = <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">//分页对象</span>        PageRequest pageRequest = <span class="hljs-keyword">new</span> PageRequest(page, size);        <span class="hljs-comment">//分页查询</span>        Page&lt;MediaFile&gt; all = mediaFileRepository.findAll(example, pageRequest);        <span class="hljs-comment">//设置响应对象属性</span>        QueryResult&lt;MediaFile&gt; mediaFileQueryResult = <span class="hljs-keyword">new</span> QueryResult&lt;MediaFile&gt;();        mediaFileQueryResult.setList(all.getContent());        mediaFileQueryResult.setTotal(all.getTotalElements());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,mediaFileQueryResult);    &#125;&#125;</code></pre></div><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/media/file"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaFileController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaFileControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MediaFileService mediaFileService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list/&#123;page&#125;/&#123;size&#125;"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page,@<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size, QueryMediaFileRequest queryMediaFileRequest) </span>&#123;        <span class="hljs-comment">//媒资文件信息查询</span>        <span class="hljs-keyword">return</span> mediaFileService.findList(page,size,queryMediaFileRequest);    &#125;&#125;</code></pre></div><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p>使用 <code>swagger</code> 进行接口测试</p><p><a href="https://qnoss.codeyee.com/20200704_14/image6" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image6.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-前端开发"><a href="#4-前端开发" class="headerlink" title="4. 前端开发"></a>4. 前端开发</h2><h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><p>在 <code>media</code> 模块定义api方法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./../../../base/api/public'</span><span class="hljs-keyword">import</span> querystring <span class="hljs-keyword">from</span> <span class="hljs-string">'querystring'</span><span class="hljs-keyword">let</span> sysConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/../config/sysConfig'</span>)<span class="hljs-keyword">let</span> apiUrl = sysConfig.xcApiUrlPre;<span class="hljs-comment">/*页面列表*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> media_list = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;    <span class="hljs-comment">//params为json格式</span>    <span class="hljs-comment">//使用querystring将json对象转成key/value串</span>    <span class="hljs-keyword">let</span> querys = querystring.stringify(params)    <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">'/media/file/list/'</span>+page+<span class="hljs-string">'/'</span>+size+<span class="hljs-string">'/?'</span>+querys)&#125;<span class="hljs-comment">/*发送处理消息*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> media_process = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/media/file/process/'</span>+id)&#125;</code></pre></div><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>在 <code>media</code> 模块创建 <code>media_list.vue</code>，可参考 <code>cms</code>系统的 <code>page_list.vue</code> 来编写此页面。</p><p>1、视图</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;!--查询表单--&gt;    &lt;el-form :model&#x3D;&quot;params&quot;&gt;      标签：      &lt;el-input v-model&#x3D;&quot;params.tag&quot; style&#x3D;&quot;width:160px&quot;&gt;&lt;&#x2F;el-input&gt;      原始名称：      &lt;el-input v-model&#x3D;&quot;params.fileOriginalName&quot; style&#x3D;&quot;width:160px&quot;&gt;&lt;&#x2F;el-input&gt;      处理状态：      &lt;el-select v-model&#x3D;&quot;params.processStatus&quot; placeholder&#x3D;&quot;请选择处理状态&quot;&gt;        &lt;el-option          v-for&#x3D;&quot;item in processStatusList&quot;          :key&#x3D;&quot;item.id&quot;          :label&#x3D;&quot;item.name&quot;          :value&#x3D;&quot;item.id&quot;&gt;        &lt;&#x2F;el-option&gt;      &lt;&#x2F;el-select&gt;      &lt;br&#x2F;&gt;      &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;query&quot; size&#x3D;&quot;small&quot;&gt;查询&lt;&#x2F;el-button&gt;      &lt;router-link class&#x3D;&quot;mui-tab-item&quot; :to&#x3D;&quot;&#123;path:&#39;&#x2F;upload&#39;&#125;&quot;&gt;        &lt;el-button  type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot; v-if&#x3D;&quot;ischoose !&#x3D; true&quot;&gt;上传文件&lt;&#x2F;el-button&gt;      &lt;&#x2F;router-link&gt;    &lt;&#x2F;el-form&gt;    &lt;!--列表--&gt;    &lt;el-table :data&#x3D;&quot;list&quot; highlight-current-row v-loading&#x3D;&quot;listLoading&quot; style&#x3D;&quot;width: 100%;&quot;&gt;      &lt;el-table-column type&#x3D;&quot;index&quot; width&#x3D;&quot;30&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;fileOriginalName&quot; label&#x3D;&quot;原始文件名称&quot; width&#x3D;&quot;220&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;fileName&quot; label&#x3D;&quot;文件名称&quot; width&#x3D;&quot;220&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;fileUrl&quot; label&#x3D;&quot;访问url&quot; width&#x3D;&quot;260&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;tag&quot; label&#x3D;&quot;标签&quot; width&#x3D;&quot;100&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;fileSize&quot; label&#x3D;&quot;文件大小&quot; width&#x3D;&quot;120&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;processStatus&quot; label&#x3D;&quot;处理状态&quot; width&#x3D;&quot;100&quot; :formatter&#x3D;&quot;formatProcessStatus&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column prop&#x3D;&quot;uploadTime&quot; label&#x3D;&quot;创建时间&quot; width&#x3D;&quot;110&quot; :formatter&#x3D;&quot;formatCreatetime&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column label&#x3D;&quot;开始处理&quot; width&#x3D;&quot;&quot; v-if&#x3D;&quot;ischoose !&#x3D; true&quot;&gt;        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;          &lt;el-button            size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot; plain @click&#x3D;&quot;process(scope.row.fileId)&quot;&gt;开始处理          &lt;&#x2F;el-button&gt;        &lt;&#x2F;template&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column label&#x3D;&quot;选择&quot; width&#x3D;&quot;80&quot; v-if&#x3D;&quot;ischoose &#x3D;&#x3D; true&quot;&gt;        &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;        &lt;el-button          size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot; plain @click&#x3D;&quot;choose(scope.row)&quot;&gt;选择&lt;&#x2F;el-button&gt;        &lt;&#x2F;template&gt;      &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;    &lt;!--分页--&gt;    &lt;el-col :span&#x3D;&quot;24&quot; class&#x3D;&quot;toolbar&quot;&gt;      &lt;el-pagination background layout&#x3D;&quot;prev, pager, next&quot; @current-change&#x3D;&quot;changePage&quot; :page-size&#x3D;&quot;this.params.size&quot;                     :total&#x3D;&quot;total&quot; :current-page&#x3D;&quot;this.params.page&quot;                     style&#x3D;&quot;float:right;&quot;&gt;      &lt;&#x2F;el-pagination&gt;    &lt;&#x2F;el-col&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><p>2、数据对象、方法、钩子函数</p><div class="hljs"><pre><code class="hljs vue">&lt;script&gt;  import * as mediaApi from &#39;..&#x2F;api&#x2F;media&#39;  import utilApi from &#39;@&#x2F;common&#x2F;utils&#39;;  export default&#123;    props: [&#39;ischoose&#39;],    &#x2F;&#x2F; 页面数据    data()&#123;      return &#123;        params:&#123;          page:1,&#x2F;&#x2F;页码          size:10,&#x2F;&#x2F;每页显示个数          tag:&#39;&#39;,&#x2F;&#x2F;标签          fileName:&#39;&#39;,&#x2F;&#x2F;文件名称          processStatus:&#39;&#39;&#x2F;&#x2F;处理状态        &#125;,        listLoading:false,        list:[],        total:0,        processStatusList:[]      &#125;    &#125;,    &#x2F;&#x2F;方法    methods:&#123;      formatCreatetime(row, column)&#123;        var createTime &#x3D; new Date(row.uploadTime);        if (createTime) &#123;          return utilApi.formatDate(createTime, &#39;yyyy-MM-dd hh:mm:ss&#39;);        &#125;      &#125;,      formatProcessStatus(row,column)&#123;        var processStatus &#x3D; row.processStatus;        if (processStatus) &#123;            if(processStatus &#x3D;&#x3D; &#39;303001&#39;)&#123;              return &quot;处理中&quot;;            &#125;else if(processStatus &#x3D;&#x3D; &#39;303002&#39;)&#123;              return &quot;处理成功&quot;;            &#125;else if(processStatus &#x3D;&#x3D; &#39;303003&#39;)&#123;              return &quot;处理失败&quot;;            &#125;else if(processStatus &#x3D;&#x3D; &#39;303004&#39;)&#123;              return &quot;无需处理&quot;;            &#125;        &#125;      &#125;,      choose(mediaFile)&#123;          if(mediaFile.processStatus !&#x3D;&#39;303002&#39; &amp;&amp; mediaFile.processStatus !&#x3D;&#39;303004&#39;)&#123;            this.$message.error(&#39;该文件未处理，不允许选择&#39;);            return ;          &#125;        if(!mediaFile.fileUrl)&#123;          this.$message.error(&#39;该文件的访问url为空，不允许选择&#39;);          return ;        &#125;        &#x2F;&#x2F;调用父组件的choosemedia方法        this.$emit(&#39;choosemedia&#39;,mediaFile.fileId,mediaFile.fileOriginalName,mediaFile.fileUrl);      &#125;,      changePage(page)&#123;        this.params.page &#x3D; page;        this.query()      &#125;,      process (id) &#123;&#x2F;&#x2F;        console.log(id)        mediaApi.media_process(id).then((res)&#x3D;&gt;&#123;          console.log(res)         if(res.success)&#123;           this.$message.success(&#39;开始处理，请稍后查看处理结果&#39;);         &#125;else&#123;           this.$message.error(&#39;操作失败，请刷新页面重试&#39;);         &#125;        &#125;)      &#125;,      query()&#123;        mediaApi.media_list(this.params.page,this.params.size,this.params).then((res)&#x3D;&gt;&#123;          console.log(res)          this.total &#x3D; res.queryResult.total          this.list &#x3D; res.queryResult.list        &#125;)      &#125;    &#125;,    &#x2F;&#x2F;页面初始化完成前钩子    created()&#123;        &#x2F;&#x2F;默认第一页      this.params.page &#x3D; Number.parseInt(this.$route.query.page||1);    &#125;,    &#x2F;&#x2F;页面初始化加载前的钩子    mounted() &#123;      &#x2F;&#x2F;默认查询页面      this.query()      &#x2F;&#x2F;初始化处理状态      this.processStatusList &#x3D; [        &#123;          id:&#39;&#39;,          name:&#39;全部&#39;        &#125;,        &#123;          id:&#39;303001&#39;,          name:&#39;处理中&#39;        &#125;,        &#123;          id:&#39;303002&#39;,          name:&#39;处理成功&#39;        &#125;,        &#123;          id:&#39;303003&#39;,          name:&#39;处理失败&#39;        &#125;,        &#123;          id:&#39;303004&#39;,          name:&#39;无需处理&#39;        &#125;      ]    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><h1 id="三、媒资与课程计划关联"><a href="#三、媒资与课程计划关联" class="headerlink" title="三、媒资与课程计划关联"></a>三、媒资与课程计划关联</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>到目前为止，媒资管理已完成文件上传、视频处理、我的媒资功能等基本功能。其它模块已可以使用媒资管理功<br>能，本节要讲解课程计划在编辑时如何选择媒资文件。</p><p>操作的业务流程如下：</p><p>1、进入课程计划修改页面</p><p>2、选择视频</p><p>打开媒资文件查询窗口，找到该课程章节的视频，选择此视频。</p><p>点击 “<code>选择媒资文件</code>” 打开媒资文件列表</p><p><a href="https://qnoss.codeyee.com/20200704_14/image7" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image7.png" srcset="/img/loading.gif" alt="img"></a></p><p>3、 选择成功后，将在课程管理数据库保存课程计划对应在的课程视频地址。</p><p>在课程管理数据库创建表 <code>teachplan_media</code> 存储课程计划与媒资关联信息，表结构如下：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image8" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image8.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-选择视频"><a href="#2-选择视频" class="headerlink" title="2. 选择视频"></a>2. 选择视频</h2><h3 id="Vue-父子组件通信"><a href="#Vue-父子组件通信" class="headerlink" title="Vue 父子组件通信"></a>Vue 父子组件通信</h3><p>上一章已实现了我的媒资页面，所以媒资查询窗口页面不需要再开发，将 “<code>我的媒资页面</code>” 作为一个组件在修改课程<br>计划页面中引用，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image9" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>修改课程计划页面为父组件，我的媒资查询页面为子组件。</p><p>问题1：</p><p>我的媒资页面在选择媒资文件时不允许显示，比如 <code>视频处理</code> 按钮，该如何控制？</p><p>这时就需要父组件（<code>修改课程计划页面</code>）向子组件（<code>我的媒资页面</code>）传入一个变量，使用此变量来控制当前是否进入选择媒资文件业务，从而控制哪些元素不显示，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image10" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>问题2：</p><p>在我的媒资页面选择了媒资文件，如何将选择的媒资文件信息传到父组件？</p><p>这时就需要子组件调用父组件的方法来解决此问题，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image11" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image11.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="父组件：修改课程计划"><a href="#父组件：修改课程计划" class="headerlink" title="父组件：修改课程计划"></a>父组件：修改课程计划</h3><p>本节实现功能：在课程计划页面打开我的媒资页面。</p><p>1、引入子组件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> mediaList <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/media/page/media_list.vue'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    components:&#123;        mediaList    &#125;,    data() &#123;        ....</code></pre></div><p>2、使用子组件</p><p>在父组件的视图中使用子组件，同时传入变量 <code>ischoose</code>，并指定父组件的方法名为<code>choosemedia</code></p><p>这里使用 <code>el-dialog</code> 实现弹出窗口。</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐dialog title&#x3D;&quot;选择媒资文件&quot; :visible.sync&#x3D;&quot;mediaFormVisible&quot;&gt;&lt;media‐list v‐bind:ischoose&#x3D;&quot;true&quot; @choosemedia&#x3D;&quot;choosemedia&quot;&gt;&lt;&#x2F;media‐list&gt;&lt;&#x2F;el‐dialog&gt;</code></pre></div><p>3、choosemedia 方法</p><p>在父组件中定义 <code>choosemedia</code> 方法，接收子组件调用，参数包括：媒资文件 <code>id</code>、媒资文件的原始名称、媒资文件 <code>url</code></p><div class="hljs"><pre><code class="hljs js">choosemedia(mediaId,fileOriginalName,mediaUrl)&#123;&#125;</code></pre></div><p>4、打开子组件窗口</p><p>1）打开子组件窗口按钮定义</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font‐size: 12px;"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">on</span>‐<span class="hljs-attr">click</span>=<span class="hljs-string">&#123;</span> () =&gt;</span> this.choosevideo(data.id) &#125;&gt;选择视频<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span></code></pre></div><p>效果如下：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image12" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>2）打开子组件窗口方法</p><p>定义 <code>querymedia</code> 方法：</p><div class="hljs"><pre><code class="hljs js">methods: &#123;    <span class="hljs-comment">//打开查询媒资文件窗口，传入课程计划id</span>    choosevideo(teachplanId)&#123;        <span class="hljs-keyword">this</span>.activeTeachplanId = teachplanId;        <span class="hljs-keyword">this</span>.mediaFormVisible = <span class="hljs-literal">true</span>;    &#125;,    ...&#125;</code></pre></div><h3 id="子组件：我的媒资查询"><a href="#子组件：我的媒资查询" class="headerlink" title="子组件：我的媒资查询"></a>子组件：我的媒资查询</h3><p>1、定义 <code>ischoose</code> 变量，接收父组件传入的 <code>ischoose</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;    props: [<span class="hljs-string">'ischoose'</span>],    data()&#123;</code></pre></div><p>2、父组件传的 <code>ischoose</code> 变量为 <code>true</code> 时表示当前是选择媒资文件业务，需要控制页面元素是否显示</p><p>1）<code>ischoose=true</code>，选择按钮显示</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐table‐column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"选择"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"80"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">if</span>=<span class="hljs-string">"ischoose == true"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>‐<span class="hljs-attr">scope</span>=<span class="hljs-string">"scope"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">plain</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"choose(scope.row)"</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐table‐column</span>&gt;</span></code></pre></div><p>2）<code>ischoose=false</code>，视频处理按钮显示</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐table‐column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"开始处理"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">if</span>=<span class="hljs-string">"ischoose != true"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>‐<span class="hljs-attr">scope</span>=<span class="hljs-string">"scope"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span></span><span class="hljs-tag">                   <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">plain</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"process(scope.row.fileId)"</span>&gt;</span>开始处理            <span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐table‐column</span>&gt;</span></code></pre></div><p>3）选择媒资文件方法</p><p>用户点击“选择”按钮将向父组件传递媒资文件信息</p><div class="hljs"><pre><code class="hljs js">choose(mediaFile)&#123;    <span class="hljs-keyword">if</span>(mediaFile.processStatus !=<span class="hljs-string">'303002'</span> &amp;&amp; mediaFile.processStatus !=<span class="hljs-string">'303004'</span>)&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'该文件未处理，不允许选择'</span>);        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">if</span>(!mediaFile.fileUrl)&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'该文件的访问url为空，不允许选择'</span>);        <span class="hljs-keyword">return</span> ;    &#125;     <span class="hljs-comment">//调用父组件的choosemedia方法</span>    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'choosemedia'</span>,mediaFile.fileId,mediaFile.fileOriginalName);&#125;</code></pre></div><h3 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h3><p><a href="https://qnoss.codeyee.com/20200704_14/image13" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image13.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><h4 id="course-plan-vue"><a href="#course-plan-vue" class="headerlink" title="course_plan.vue"></a>course_plan.vue</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"teachplayFormVisible = true"</span>&gt;</span>添加课程计划<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-tree</span></span><span class="hljs-tag">      <span class="hljs-attr">:data</span>=<span class="hljs-string">"teachplanList"</span></span><span class="hljs-tag">      <span class="hljs-attr">:props</span>=<span class="hljs-string">"defaultProps"</span></span><span class="hljs-tag">      <span class="hljs-attr">node-key</span>=<span class="hljs-string">"id"</span></span><span class="hljs-tag">      <span class="hljs-attr">default-expand-all</span></span><span class="hljs-tag">      <span class="hljs-attr">:expand-on-click-node</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">      <span class="hljs-attr">:render-content</span>=<span class="hljs-string">"renderContent"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-tree</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"添加课程计划"</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">"teachplayFormVisible"</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"teachplanForm"</span>  <span class="hljs-attr">:model</span>=<span class="hljs-string">"teachplanActive"</span> <span class="hljs-attr">label-width</span>=<span class="hljs-string">"140px"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:600px;"</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">"teachplanRules"</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"上级结点"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.parentid"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"不填表示根结点"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span></span><span class="hljs-tag">              <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in teachplanList"</span></span><span class="hljs-tag">              <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span></span><span class="hljs-tag">              <span class="hljs-attr">:label</span>=<span class="hljs-string">"item.pname"</span></span><span class="hljs-tag">              <span class="hljs-attr">:value</span>=<span class="hljs-string">"item.id"</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"章节/课时名称"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"pname"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.pname"</span> <span class="hljs-attr">auto-complete</span>=<span class="hljs-string">"off"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程类型"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-radio-group</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.ptype"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">'1'</span>&gt;</span>视频<span class="hljs-tag">&lt;/<span class="hljs-name">el-radio</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">'2'</span>&gt;</span>文档<span class="hljs-tag">&lt;/<span class="hljs-name">el-radio</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el-radio-group</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"学习时长（分钟）  请输入数字"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.timelength"</span> <span class="hljs-attr">auto-complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"排序字段"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.orderby"</span> <span class="hljs-attr">auto-complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"章节/课时介绍"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"description"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.description"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"状态"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"status"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-radio-group</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"teachplanActive.status"</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"0"</span> &gt;</span>未发布<span class="hljs-tag">&lt;/<span class="hljs-name">el-radio</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">'1'</span>&gt;</span>已发布<span class="hljs-tag">&lt;/<span class="hljs-name">el-radio</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el-radio-group</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>  &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"addTeachplan"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"resetForm"</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"选择媒资文件"</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">"mediaFormVisible"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">media-list</span> <span class="hljs-attr">v-bind:ischoose</span>=<span class="hljs-string">"true"</span> @<span class="hljs-attr">choosemedia</span>=<span class="hljs-string">"choosemedia"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">media-list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> id = <span class="hljs-number">1000</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../api/course'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../common/utils'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> systemApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../base/api/system'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> mediaList <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/media/page/media_list.vue'</span>;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    components:&#123;      mediaList    &#125;,    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        mediaFormVisible:<span class="hljs-literal">false</span>,</span><span class="actionscript">        teachplayFormVisible:<span class="hljs-literal">false</span>,<span class="hljs-comment">//控制添加窗口是否显示</span></span>        teachplanList : [&#123;          id: 1,<span class="actionscript">          pname: <span class="hljs-string">'一级 1'</span>,</span>          children: [&#123;            id: 4,<span class="actionscript">            pname: <span class="hljs-string">'二级 1-1'</span>,</span>            children: [&#123;              id: 9,<span class="actionscript">              pname: <span class="hljs-string">'三级 1-1-1'</span></span>            &#125;, &#123;              id: 10,<span class="actionscript">              pname: <span class="hljs-string">'三级 1-1-2'</span></span>            &#125;]          &#125;]        &#125;],        defaultProps:&#123;<span class="actionscript">          children: <span class="hljs-string">'children'</span>,</span><span class="actionscript">          label: <span class="hljs-string">'pname'</span></span>        &#125;,        teachplanRules: &#123;          pname: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请输入课程计划名称'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          status: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择状态'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ]        &#125;,        teachplanActive:&#123;&#125;,<span class="actionscript">        teachplanId:<span class="hljs-string">''</span></span>      &#125;    &#125;,    methods: &#123;<span class="actionscript">        <span class="hljs-comment">//选择视频，打开窗口</span></span>      choosevideo(data)&#123;<span class="actionscript">          <span class="hljs-comment">//得到当前的课程计划</span></span><span class="actionscript">          <span class="hljs-keyword">this</span>.teachplanId = data.id</span><span class="actionscript"><span class="hljs-comment">//        alert(this.teachplanId)</span></span><span class="actionscript">          <span class="hljs-keyword">this</span>.mediaFormVisible = <span class="hljs-literal">true</span>;<span class="hljs-comment">//打开窗口</span></span>      &#125;,<span class="actionscript">      <span class="hljs-comment">//保存选择的视频</span></span>      choosemedia(mediaId,fileOriginalName,mediaUrl)&#123;<span class="actionscript">        <span class="hljs-comment">//保存视频到课程计划表中</span></span><span class="javascript">        <span class="hljs-keyword">let</span> teachplanMedia =&#123;&#125;</span>        teachplanMedia.mediaId =mediaId;        teachplanMedia.mediaFileOriginalName =fileOriginalName;        teachplanMedia.mediaUrl =mediaUrl;<span class="actionscript">        teachplanMedia.courseId =<span class="hljs-keyword">this</span>.courseid;</span><span class="actionscript">        <span class="hljs-comment">//课程计划</span></span><span class="actionscript">        teachplanMedia.teachplanId=<span class="hljs-keyword">this</span>.teachplanId</span><span class="javascript">        courseApi.savemedia(teachplanMedia).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;</span>            if(res.success)&#123;<span class="actionscript">                <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"选择视频成功"</span>)</span><span class="actionscript">              <span class="hljs-comment">//查询课程计划</span></span><span class="actionscript">              <span class="hljs-keyword">this</span>.findTeachplan()</span><span class="actionscript">            &#125;<span class="hljs-keyword">else</span>&#123;</span><span class="actionscript">              <span class="hljs-keyword">this</span>.$message.error(res.message)</span>            &#125;        &#125;)      &#125;,<span class="actionscript">      <span class="hljs-comment">//提交课程计划</span></span>      addTeachplan()&#123;<span class="actionscript">        <span class="hljs-comment">//校验表单</span></span><span class="javascript">        <span class="hljs-keyword">this</span>.$refs.teachplanForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;</span>            if (valid) &#123;<span class="actionscript">                <span class="hljs-comment">//调用api方法</span></span><span class="actionscript">              <span class="hljs-comment">//将课程id设置到teachplanActive</span></span><span class="actionscript">              <span class="hljs-keyword">this</span>.teachplanActive.courseid = <span class="hljs-keyword">this</span>.courseid</span><span class="javascript">              courseApi.addTeachplan(<span class="hljs-keyword">this</span>.teachplanActive).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;</span>                if(res.success)&#123;<span class="actionscript">                    <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"添加成功"</span>)</span><span class="actionscript">                    <span class="hljs-comment">//刷新树</span></span><span class="actionscript">                    <span class="hljs-keyword">this</span>.findTeachplan()</span><span class="actionscript">                &#125;<span class="hljs-keyword">else</span>&#123;</span><span class="actionscript">                  <span class="hljs-keyword">this</span>.$message.error(res.message)</span>                &#125;              &#125;)            &#125;        &#125;)      &#125;,<span class="actionscript">  <span class="hljs-comment">//重置表单</span></span>      resetForm()&#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.teachplanActive = &#123;&#125;</span>      &#125;,      append(data) &#123;<span class="actionscript">        <span class="hljs-keyword">const</span> newChild = &#123; id: id++, label: <span class="hljs-string">'testtest'</span>, children: [] &#125;;</span>        if (!data.children) &#123;<span class="actionscript">          <span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(data, <span class="hljs-string">'children'</span>, []);</span>        &#125;        data.children.push(newChild);      &#125;,      edit(data)&#123;<span class="actionscript">        <span class="hljs-comment">//alert(data.id);</span></span>      &#125;,      remove(node, data) &#123;<span class="actionscript">        <span class="hljs-keyword">const</span> parent = node.parent;</span><span class="actionscript">        <span class="hljs-keyword">const</span> children = parent.data.children || parent.data;</span><span class="javascript">        <span class="hljs-keyword">const</span> index = children.findIndex(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.id === data.id);</span>        children.splice(index, 1);      &#125;,      renderContent(h, &#123; node, data, store &#125;) &#123;<span class="actionscript">        <span class="hljs-keyword">return</span> (</span><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"flex: 1; display: flex; align-items: center; justify-content: space-between; font-size: 14px; padding-right: 8px;"</span>&gt;</span></span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span></span><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;node.label&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span></span><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 12px;"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">on-click</span>=<span class="hljs-string">&#123;</span> () =&gt;</span> this.choosevideo(data) &#125;&gt;&#123;data.mediaFileOriginalName&#125;<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span> 选择视频<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span></span><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 12px;"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">on-click</span>=<span class="hljs-string">&#123;</span> () =&gt;</span> this.edit(data) &#125;&gt;修改<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span></span><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 12px;"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">on-click</span>=<span class="hljs-string">&#123;</span> () =&gt;</span> this.remove(node, data) &#125;&gt;删除<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>);</span></span>      &#125;,      findTeachplan()&#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.teachplanList = []</span><span class="actionscript">        <span class="hljs-comment">//查询课程计划</span></span><span class="javascript">        courseApi.findTeachplanList(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;</span>            if(res &amp;&amp; res.children)&#123;<span class="actionscript">              <span class="hljs-keyword">this</span>.teachplanList = res.children;</span><span class="actionscript">            &#125;<span class="hljs-keyword">else</span> &#123;</span><span class="actionscript">              <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"课程计划查询失败"</span>)</span><span class="javascript">              <span class="hljs-built_in">console</span>.log(res)</span>            &#125;        &#125;)      &#125;    &#125;,    mounted()&#123;<span class="actionscript">      <span class="hljs-comment">//课程id</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid;</span><span class="actionscript">      <span class="hljs-comment">//查询课程计划</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.findTeachplan()</span>    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h4 id="media-list-vue"><a href="#media-list-vue" class="headerlink" title="media_list.vue"></a>media_list.vue</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!--查询表单--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">"params"</span>&gt;</span>      标签：      <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"params.tag"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:160px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>      原始名称：      <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"params.fileOriginalName"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:160px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>      处理状态：      <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"params.processStatus"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请选择处理状态"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span></span><span class="hljs-tag">          <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in processStatusList"</span></span><span class="hljs-tag">          <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span></span><span class="hljs-tag">          <span class="hljs-attr">:label</span>=<span class="hljs-string">"item.name"</span></span><span class="hljs-tag">          <span class="hljs-attr">:value</span>=<span class="hljs-string">"item.id"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"query"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui-tab-item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/upload'&#125;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ischoose != true"</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span>    <span class="hljs-comment">&lt;!--列表--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">highlight-current-row</span> <span class="hljs-attr">v-loading</span>=<span class="hljs-string">"listLoading"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 100%;"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"30"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"fileOriginalName"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"原始文件名称"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"220"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"fileName"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"文件名称"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"220"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"fileUrl"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"访问url"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"260"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"tag"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"标签"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"fileSize"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"文件大小"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"120"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"processStatus"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"处理状态"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">:formatter</span>=<span class="hljs-string">"formatProcessStatus"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"uploadTime"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"创建时间"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"110"</span> <span class="hljs-attr">:formatter</span>=<span class="hljs-string">"formatCreatetime"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"开始处理"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">""</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ischoose != true"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"scope"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span><span class="hljs-tag">            <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">plain</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"process(scope.row.fileId)"</span>&gt;</span>开始处理          <span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"选择"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"80"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ischoose == true"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"scope"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span><span class="hljs-tag">          <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">plain</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"choose(scope.row)"</span>&gt;</span>选择<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span>    <span class="hljs-comment">&lt;!--分页--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">"24"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"toolbar"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span> <span class="hljs-attr">background</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">"prev, pager, next"</span> @<span class="hljs-attr">current-change</span>=<span class="hljs-string">"changePage"</span> <span class="hljs-attr">:page-size</span>=<span class="hljs-string">"this.params.size"</span></span><span class="hljs-tag">                     <span class="hljs-attr">:total</span>=<span class="hljs-string">"total"</span> <span class="hljs-attr">:current-page</span>=<span class="hljs-string">"this.params.page"</span></span><span class="hljs-tag">                     <span class="hljs-attr">style</span>=<span class="hljs-string">"float:right;"</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mediaApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/media'</span></span><span class="javascript">  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'@/common/utils'</span>;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><span class="actionscript">    props: [<span class="hljs-string">'ischoose'</span>],</span><span class="actionscript">    <span class="hljs-comment">// 页面数据</span></span>    data()&#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span>        params:&#123;<span class="actionscript">          page:<span class="hljs-number">1</span>,<span class="hljs-comment">//页码</span></span><span class="actionscript">          size:<span class="hljs-number">10</span>,<span class="hljs-comment">//每页显示个数</span></span><span class="actionscript">          tag:<span class="hljs-string">''</span>,<span class="hljs-comment">//标签</span></span><span class="actionscript">          fileName:<span class="hljs-string">''</span>,<span class="hljs-comment">//文件名称</span></span><span class="actionscript">          processStatus:<span class="hljs-string">''</span><span class="hljs-comment">//处理状态</span></span>        &#125;,<span class="actionscript">        listLoading:<span class="hljs-literal">false</span>,</span>        list:[],        total:0,        processStatusList:[]      &#125;    &#125;,<span class="actionscript">    <span class="hljs-comment">//方法</span></span>    methods:&#123;      formatCreatetime(row, column)&#123;<span class="javascript">        <span class="hljs-keyword">var</span> createTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(row.uploadTime);</span>        if (createTime) &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> utilApi.formatDate(createTime, <span class="hljs-string">'yyyy-MM-dd hh:mm:ss'</span>);</span>        &#125;      &#125;,      formatProcessStatus(row,column)&#123;<span class="actionscript">        <span class="hljs-keyword">var</span> processStatus = row.processStatus;</span>        if (processStatus) &#123;<span class="actionscript">            <span class="hljs-keyword">if</span>(processStatus == <span class="hljs-string">'303001'</span>)&#123;</span><span class="actionscript">              <span class="hljs-keyword">return</span> <span class="hljs-string">"处理中"</span>;</span><span class="actionscript">            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(processStatus == <span class="hljs-string">'303002'</span>)&#123;</span><span class="actionscript">              <span class="hljs-keyword">return</span> <span class="hljs-string">"处理成功"</span>;</span><span class="actionscript">            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(processStatus == <span class="hljs-string">'303003'</span>)&#123;</span><span class="actionscript">              <span class="hljs-keyword">return</span> <span class="hljs-string">"处理失败"</span>;</span><span class="actionscript">            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(processStatus == <span class="hljs-string">'303004'</span>)&#123;</span><span class="actionscript">              <span class="hljs-keyword">return</span> <span class="hljs-string">"无需处理"</span>;</span>            &#125;        &#125;      &#125;,      choose(mediaFile)&#123;<span class="actionscript">          <span class="hljs-keyword">if</span>(mediaFile.processStatus !=<span class="hljs-string">'303002'</span> &amp;&amp; mediaFile.processStatus !=<span class="hljs-string">'303004'</span>)&#123;</span><span class="actionscript">            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'该文件未处理，不允许选择'</span>);</span><span class="actionscript">            <span class="hljs-keyword">return</span> ;</span>          &#125;        if(!mediaFile.fileUrl)&#123;<span class="actionscript">          <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'该文件的访问url为空，不允许选择'</span>);</span><span class="actionscript">          <span class="hljs-keyword">return</span> ;</span>        &#125;<span class="actionscript">        <span class="hljs-comment">//调用父组件的choosemedia方法</span></span><span class="actionscript">        <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'choosemedia'</span>,mediaFile.fileId,mediaFile.fileOriginalName,mediaFile.fileUrl);</span>      &#125;,      changePage(page)&#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.params.page = page;</span><span class="actionscript">        <span class="hljs-keyword">this</span>.query()</span>      &#125;,      process (id) &#123;<span class="actionscript"><span class="hljs-comment">//        console.log(id)</span></span><span class="javascript">        mediaApi.media_process(id).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;</span><span class="javascript">          <span class="hljs-built_in">console</span>.log(res)</span>         if(res.success)&#123;<span class="actionscript">           <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'开始处理，请稍后查看处理结果'</span>);</span><span class="actionscript">         &#125;<span class="hljs-keyword">else</span>&#123;</span><span class="actionscript">           <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'操作失败，请刷新页面重试'</span>);</span>         &#125;        &#125;)      &#125;,      query()&#123;<span class="javascript">        mediaApi.media_list(<span class="hljs-keyword">this</span>.params.page,<span class="hljs-keyword">this</span>.params.size,<span class="hljs-keyword">this</span>.params).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;</span><span class="javascript">          <span class="hljs-built_in">console</span>.log(res)</span><span class="actionscript">          <span class="hljs-keyword">this</span>.total = res.queryResult.total</span><span class="actionscript">          <span class="hljs-keyword">this</span>.list = res.queryResult.list</span>        &#125;)      &#125;    &#125;,<span class="actionscript">    <span class="hljs-comment">//页面初始化完成前钩子</span></span>    created()&#123;<span class="actionscript">        <span class="hljs-comment">//默认第一页</span></span><span class="javascript">      <span class="hljs-keyword">this</span>.params.page = <span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.$route.query.page||<span class="hljs-number">1</span>);</span>    &#125;,<span class="actionscript">    <span class="hljs-comment">//页面初始化加载前的钩子</span></span>    mounted() &#123;<span class="actionscript">      <span class="hljs-comment">//默认查询页面</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.query()</span><span class="actionscript">      <span class="hljs-comment">//初始化处理状态</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.processStatusList = [</span>        &#123;<span class="actionscript">          id:<span class="hljs-string">''</span>,</span><span class="actionscript">          name:<span class="hljs-string">'全部'</span></span>        &#125;,        &#123;<span class="actionscript">          id:<span class="hljs-string">'303001'</span>,</span><span class="actionscript">          name:<span class="hljs-string">'处理中'</span></span>        &#125;,        &#123;<span class="actionscript">          id:<span class="hljs-string">'303002'</span>,</span><span class="actionscript">          name:<span class="hljs-string">'处理成功'</span></span>        &#125;,        &#123;<span class="actionscript">          id:<span class="hljs-string">'303003'</span>,</span><span class="actionscript">          name:<span class="hljs-string">'处理失败'</span></span>        &#125;,        &#123;<span class="actionscript">          id:<span class="hljs-string">'303004'</span>,</span><span class="actionscript">          name:<span class="hljs-string">'无需处理'</span></span>        &#125;      ]    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h2 id="3-保存视频信息"><a href="#3-保存视频信息" class="headerlink" title="3. 保存视频信息"></a>3. 保存视频信息</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>用户进入课程计划页面，选择视频，将课程计划与视频信息保存在课程管理数据库中。</p><p>用户操作流程：</p><p>1、进入课程计划，点击”选择视频“，打开我的媒资查询页面</p><p>2、为课程计划选择对应的视频，选择“选择”</p><p>3、前端请求课程管理服务保存课程计划与视频信息</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>在课程管理数据库创建表 <code>teachplan_media</code> 存储课程计划与媒资关联信息，如下：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image14" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image14.png" srcset="/img/loading.gif" alt="img"></a></p><p>创建 <code>teachplanMedia</code> 模型类：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"teachplan_media"</span>)<span class="hljs-meta">@GenericGenerator</span>(name = <span class="hljs-string">"jpa‐assigned"</span>, strategy = <span class="hljs-string">"assigned"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeachplanMedia</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = ‐<span class="hljs-number">916357110051689485L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(generator = <span class="hljs-string">"jpa‐assigned"</span>)    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"teachplan_id"</span>)    <span class="hljs-keyword">private</span> String teachplanId;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"media_id"</span>)    <span class="hljs-keyword">private</span> String mediaId;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"media_fileoriginalname"</span>)    <span class="hljs-keyword">private</span> String mediaFileOriginalName;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"media_url"</span>)    <span class="hljs-keyword">private</span> String mediaUrl;    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"courseid"</span>)    <span class="hljs-keyword">private</span> String courseId;&#125;</code></pre></div><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><p>此接口作为前端请求课程管理服务保存课程计划与视频信息的接口：</p><p>在 <code>TeachplanControllerApi</code> 增加接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"保存媒资信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">saveTeachplanMedia</span><span class="hljs-params">(TeachplanMedia teachplanMedia)</span></span>;</code></pre></div><h3 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h3><h4 id="1、Controller"><a href="#1、Controller" class="headerlink" title="1、Controller"></a>1、Controller</h4><p>在 <code>TeachplanController</code> 下添加该方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/savemedia"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">saveTeachplanMedia</span><span class="hljs-params">(@RequestBody TeachplanMedia teachplanMedia)</span> </span>&#123;    <span class="hljs-keyword">return</span> teachplanService.saveTeachplanMedia(teachplanMedia);&#125;</code></pre></div><h4 id="2、Dao"><a href="#2、Dao" class="headerlink" title="2、Dao"></a>2、Dao</h4><p>创建 <code>TeachplanMediaRepository</code> 用于对 <code>TeachplanMedia</code> 的操作。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeachplanMediaRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">TeachplanMedia</span>, <span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h4 id="3、Service"><a href="#3、Service" class="headerlink" title="3、Service"></a>3、Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//保存媒资信息public ResponseResult saveTeachplanMedia(TeachplanMedia teachplanMedia) &#123;    if(teachplanMedia == null)&#123;        ExceptionCast.cast(CommonCode.INVALIDPARAM);    &#125;     //课程计划        String teachplanId = teachplanMedia.getTeachplanId();    //查询课程计划    Optional&lt;Teachplan&gt; optional = teachplanRepository.findById(teachplanId);    if(!optional.isPresent())&#123;        ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_ISNULL);    &#125; Teachplan teachplan = optional.get();    //只允许为叶子结点课程计划选择视频    String grade = teachplan.getGrade();    if(StringUtils.isEmpty(grade) || !grade.equals("3"))&#123;        ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_GRADEERROR);    &#125;     TeachplanMedia one = null;    Optional&lt;TeachplanMedia&gt; teachplanMediaOptional =        teachplanMediaRepository.findById(teachplanId);    if(!teachplanMediaOptional.isPresent())&#123;        one = new TeachplanMedia();    &#125;else&#123;        one = teachplanMediaOptional.get();    &#125;     //保存媒资信息与课程计划信息    one.setTeachplanId(teachplanId);    one.setCourseId(teachplanMedia.getCourseId());    one.setMediaFileOriginalName(teachplanMedia.getMediaFileOriginalName());    one.setMediaId(teachplanMedia.getMediaId());    one.setMediaUrl(teachplanMedia.getMediaUrl());    teachplanMediaRepository.save(one);    return new ResponseResult(CommonCode.SUCCESS);&#125;//保存媒资信息</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">saveTeachplanMedia</span><span class="hljs-params">(TeachplanMedia teachplanMedia)</span> </span>&#123;    <span class="hljs-keyword">if</span>(teachplanMedia == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(CommonCode.INVALIDPARAM);    &#125;     <span class="hljs-comment">//课程计划</span>        String teachplanId = teachplanMedia.getTeachplanId();    <span class="hljs-comment">//查询课程计划</span>    Optional&lt;Teachplan&gt; optional = teachplanRepository.findById(teachplanId);    <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;        ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_ISNULL);    &#125; Teachplan teachplan = optional.get();    <span class="hljs-comment">//只允许为叶子结点课程计划选择视频</span>    String grade = teachplan.getGrade();    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(grade) || !grade.equals(<span class="hljs-string">"3"</span>))&#123;        ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_GRADEERROR);    &#125;     TeachplanMedia one = <span class="hljs-keyword">null</span>;    Optional&lt;TeachplanMedia&gt; teachplanMediaOptional =        teachplanMediaRepository.findById(teachplanId);    <span class="hljs-keyword">if</span>(!teachplanMediaOptional.isPresent())&#123;        one = <span class="hljs-keyword">new</span> TeachplanMedia();    &#125;<span class="hljs-keyword">else</span>&#123;        one = teachplanMediaOptional.get();    &#125;     <span class="hljs-comment">//保存媒资信息与课程计划信息</span>    one.setTeachplanId(teachplanId);    one.setCourseId(teachplanMedia.getCourseId());    one.setMediaFileOriginalName(teachplanMedia.getMediaFileOriginalName());    one.setMediaId(teachplanMedia.getMediaId());    one.setMediaUrl(teachplanMedia.getMediaUrl());    teachplanMediaRepository.save(one);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);&#125;</code></pre></div><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><h4 id="1、API方法"><a href="#1、API方法" class="headerlink" title="1、API方法"></a>1、API方法</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*保存媒资信息*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> savemedia = <span class="hljs-function"><span class="hljs-params">teachplanMedia</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/course/savemedia'</span>,teachplanMedia);&#125;</code></pre></div><h4 id="2、API调用"><a href="#2、API调用" class="headerlink" title="2、API调用"></a>2、API调用</h4><p>在课程视频方法中调用 <code>api</code>：</p><div class="hljs"><pre><code class="hljs java">choosemedia(mediaId,fileOriginalName,mediaUrl)&#123;    <span class="hljs-keyword">this</span>.mediaFormVisible = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//保存课程计划与视频对应关系</span>    let teachplanMedia = &#123;&#125;;    teachplanMedia.teachplanId = <span class="hljs-keyword">this</span>.activeTeachplanId;    teachplanMedia.mediaId = mediaId;    teachplanMedia.mediaFileOriginalName = fileOriginalName;    teachplanMedia.mediaUrl = mediaUrl;    teachplanMedia.courseId = <span class="hljs-keyword">this</span>.courseid;    <span class="hljs-comment">//保存媒资信息到课程数据库</span>    courseApi.savemedia(teachplanMedia).then(res=&gt;&#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"选择视频成功"</span>)        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.$message.error(res.message)        &#125;    &#125;)&#125;,</code></pre></div><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p>1、向叶子结点课程计划保存媒资信息</p><p>操作结果：保存成功</p><p>2、向非叶子结点课程计划保存媒资信息</p><p>操作结果：保存失败</p><h2 id="4-查询视频信息"><a href="#4-查询视频信息" class="headerlink" title="4. 查询视频信息"></a>4. 查询视频信息</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>课程计划的视频信息保存后在页面无法查看，本节解决课程计划页面显示相关联的媒资信息。</p><p>解决方案：</p><p>在获取课程计划树结点信息时将关联的媒资信息一并查询，并在前端显示，下图说明了课程计划显示的区域。</p><p><a href="https://qnoss.codeyee.com/20200704_14/image15" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h3><p>修改课程计划查询的 <code>Dao</code>:</p><p>1、修改模型</p><p>在课程计划结果信息中添加媒资信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.course.ext;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.Teachplan;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeachplanNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Teachplan</span> </span>&#123;    List&lt;TeachplanNode&gt; children;    <span class="hljs-comment">//媒资信息</span>    <span class="hljs-keyword">private</span> String media_id;    <span class="hljs-keyword">private</span> String media_fileoriginalname;&#125;</code></pre></div><p>2、修改<code>sql</code> 语句，添加关联查询媒资信息</p><p>添加 <code>mediaId</code>、<code>mediaFileOriginalName</code></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.xuecheng.manage_course.dao.TeachplanMapper"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"teachplanMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.TeachplanNode"</span>&gt;</span>        <span class="hljs-comment">&lt;!--一级节点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_id"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_pname"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"children"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.TeachplanNode"</span>&gt;</span>            <span class="hljs-comment">&lt;!--二级节点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_id"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_pname"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"children"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.TeachplanNode"</span>&gt;</span>                <span class="hljs-comment">&lt;!--三级节点--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_id"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_pname"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"media_id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"media_id"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"media_fileoriginalname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"media_fileoriginalname"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--三级菜单查询--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectList"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"teachplanMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>        SELECT            a.id one_id,            a.pname one_pname,            a.courseid one_course,            b.id two_id,            b.pname two_pname,            c.id three_id,            c.pname three_pname,            media.media_id media_id,            media.media_fileoriginalname media_fileoriginalname        FROM            teachplan a        LEFT JOIN teachplan b            ON b.parentid = a.id        LEFT JOIN teachplan c            ON c.parentid = b.id        LEFT JOIN teachplan_media media            ON c.id = media.teachplan_id        WHERE            a.parentid = '0'        <span class="hljs-comment">&lt;!--判断参数不为空时才进行参数的匹配--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"_parameter!=null and _parameter!=''"</span>&gt;</span>            and a.courseid = #&#123;courseId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        ORDER BY a.orderby,            b.orderby,            c.orderby    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>这里的核心代码是使用 <code>LEFT JOIN</code> 关联 <code>teachplan_media</code> 表中的数据，再获取该课程计划下的 <code>mediaId</code> 与 <code>mediaFileOriginalName</code> 代码如下</p><div class="hljs"><pre><code class="hljs sql">LEFT JOIN teachplan_media media ON c.id = media.teachplan_idWHERE</code></pre></div><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--三级节点--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_pname"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"media_id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"media_id"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"media_fileoriginalname"</span></span></code></pre></div><p>使用swagger进行接口测试</p><p><a href="https://qnoss.codeyee.com/20200704_14/image16" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image16.png" srcset="/img/loading.gif" alt="img"></a></p><p>从结果中成功的查询到了课程计划所关联的媒资信息。</p><h3 id="页面查询视频"><a href="#页面查询视频" class="headerlink" title="页面查询视频"></a>页面查询视频</h3><p>课程计划结点信息已包括媒资信息，可在页面获取信息后显示。</p><p>通过 <code>data.media_fileoriginalname</code> 获取媒资视频的原始名称</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font‐size: 12px;"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">on</span>‐<span class="hljs-attr">click</span>=<span class="hljs-string">&#123;</span> () =&gt;</span> this.querymedia(data.id) &#125;&gt;&#123;data.media_fileoriginalname&#125;<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>选择视频<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span></code></pre></div><p>效果如下：</p><p><a href="https://qnoss.codeyee.com/20200704_14/image17" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday14/image17.png" srcset="/img/loading.gif" alt="img"></a></p><p>选择视频后立即刷新课程计划树，在提交成功后，添加查询课程计划代码：<code>this.findTeachplan()</code>，完整代码如下：</p><div class="hljs"><pre><code class="hljs js">choosemedia(mediaId,fileOriginalName,mediaUrl)&#123;    <span class="hljs-keyword">this</span>.mediaFormVisible = <span class="hljs-literal">false</span>;    <span class="hljs-comment">//保存课程计划与视频对应关系</span>    <span class="hljs-keyword">let</span> teachplanMedia = &#123;&#125;;    teachplanMedia.teachplanId = <span class="hljs-keyword">this</span>.activeTeachplanId;    teachplanMedia.mediaId = mediaId;    teachplanMedia.mediaFileOriginalName = fileOriginalName;    teachplanMedia.mediaUrl = mediaUrl;    teachplanMedia.courseId = <span class="hljs-keyword">this</span>.courseid;    <span class="hljs-comment">//保存媒资信息到课程数据库</span>    courseApi.savemedia(teachplanMedia).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"选择视频成功"</span>)            <span class="hljs-comment">//查询课程计划</span>            <span class="hljs-keyword">this</span>.findTeachplan()        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.$message.error(res.message)        &#125;    &#125;)&#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>FFmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day13：使用FFmpeg进行格式转换以及m3u8文件生成、文件分块上传接口实现</title>
    <link href="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/"/>
    <url>/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day13</code> 的内容</p><ul><li><code>FFmpeg</code> 的基本使用</li><li>使用 <code>m3u8</code> 和 <code>video.js</code>技术实现视频的在线播放</li><li>搭建媒资服务工程实现文件的分块储存</li></ul><h1 id="一、在线学习需求分析"><a href="#一、在线学习需求分析" class="headerlink" title="一、在线学习需求分析"></a>一、在线学习需求分析</h1><h2 id="1-需求描述"><a href="#1-需求描述" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h2><p>学成在线作为在线教育网站，提供多种学习形式，包括：录播、直播、图文、社群等，学生登录进入学习中心即可</p><p>在线学习，本章节将开发录播课程的在线学习功能，需求如下：</p><p>1、学生可以在 <code>windows</code> 浏览器上在线观看视频。</p><p>2、播放器具有快进、快退、暂停等基本功能。</p><p>3、学生可以方便切换章节进行学习。</p><p><a href="https://qnoss.codeyee.com/20200704_13/image1" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p>什么是录播课程？</p><p>录播课程就是提供录制好课程视频，供用户在线点播，反复学习。</p><p>课程视频如何管理？</p><p>媒资管理系统专门来管理课程视频，用户视频文件上传到媒资系统，并对视频进行编码处理。</p><h2 id="2-视频点播解决方案"><a href="#2-视频点播解决方案" class="headerlink" title="2. 视频点播解决方案"></a>2. 视频点播解决方案</h2><h3 id="流媒体方案"><a href="#流媒体方案" class="headerlink" title="流媒体方案"></a>流媒体方案</h3><p>详细参考：<a href="https://baike.baidu.com/item/%E6%B5%81%E5%AA%92%E4%BD%93/98740?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%B5%81%E5%AA%92%E4%BD%93/98740?fr=aladdin</a></p><p>概括理解：流媒体就是将视频文件分成许多小块儿，将这些小块儿作为数据包通过网络发送出去，实现一边传输视<br>频 数据 包一边观看视频。</p><ul><li><p>流式传输</p><p>在网络上传输音、视频信息有两个方式：下载 和 流式传输。</p><p>下载：就是把音、视频文件完全下载到本机后开始播放，它的特点是必须等到视频文件下载完成方可播放，播放等待时间较长，无法去播放还未下载的部分视频。</p><p>流式传输：就是客户端通过链接视频服务器实时传输音、视频信息，实现 “<strong>边下载边播放</strong>”。</p><p>流式传输包括如下两种方式：</p><ul><li><p>1） 顺序流式传输</p><p>即顺序下载音、视频文件，可以实现边下载边播放，不过，用户只能观看已下载的视频内容，无法快进到未下载的视频部分，顺序流式传输可以使用 <code>Http</code> 服务器来实现，比如 <code>Nginx</code>、<code>Apache</code> 等。</p></li><li><p>2）实时流式传输</p><p>实时流式传输可以解决顺序流式传输无法快进的问题，它与Http流式传输不同，它必须使用流媒体服务器并且使用流媒体协议来传输视频，它比 <code>Http</code> 流式传输复杂。常见的实时流式传输协议有<code>RTSP</code>、<code>RTMP</code>、<code>RSVP</code> 等。</p></li></ul></li><li><p>流媒体系统的概要结构</p><p>通过流媒体系统的概要结构，学习流媒体系统的基本业务流程。</p></li></ul><p><a href="https://qnoss.codeyee.com/20200704_13/image2" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、将原始的视频文件通过编码器转换为适合网络传输的流格式，编码后的视频直接输送给媒体服务器。<br>原始的视频文件通常是事先录制好的视频，比如通过摄像机、摄像头等录像、录音设备采集到的音视频文<br>件，体积较大，要想在网络上传输需要经过压缩处理，即通过编码器进行编码 。</p><p>2、媒体服务获取到编码好的视频文件，对外提供流媒体数据传输接口，接口协议包括 ：<code>HTTP</code>、<code>RTSP</code>、<code>RTMP</code> 等 。</p><p>3、播放器通过流媒体协议与媒体服务器通信，获取视频数据，播放视频。</p><h3 id="点播方案"><a href="#点播方案" class="headerlink" title="点播方案"></a>点播方案</h3><p>本项目包括点播和直播两种方式，我们先调研一下几个点播的方案，如下：</p><ol><li><p>播放器通过 <code>http</code> 协议从 <code>http</code> 服务器上下载视频文件进行播放</p><p>问题：必须等到视频下载完才可以播放，不支持快进到某个时间点进行播放</p></li><li><p>播放器通过 <code>rtmp</code> 协议连接媒体服务器以实时流方式播放视频</p><p>使用rtmp协议需要架设媒体服务器，造价高，对于直播多采用此方案。</p></li><li><p>播放器使用 <code>HLS</code> 协议连接 <code>http</code> 服务器（<code>Nginx</code>、<code>Apache</code>等）实现近实时流方式播放视频</p><p>HLS协议规定：基于 <code>Http</code> 协议，视频封装格式为 <code>ts</code>，视频的编码格式为 <code>H264</code>,音频编码格式为<code>MP3</code>、<code>AAC</code>或者 <code>AC-3</code>。</p></li></ol><p>那么 <code>HLS</code> 是什么？</p><p><a href="https://qnoss.codeyee.com/20200704_13/image3" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p><code>HLS</code> 的工作方式是：将视频拆分成若干 <code>ts</code> 格式的小文件，通过 <code>m3u8</code> 格式的索引文件对这些 <code>ts</code> 小文件建立索引。一般 <code>10</code> 秒一个 <code>ts</code> 文件，播放器连接 <code>m3u8</code> 文件播放，当快进时通过 <code>m3u8</code> 即可找到对应的索引文件，并去下载对应的 <code>ts</code> 文件，从而实现快进、快退以近实时的方式播放视频。</p><p>IOS、Android 设备、及各大浏览器都支持 <code>HLS</code> 协议。</p><p><a href="https://qnoss.codeyee.com/20200704_13/image4" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>详细参考：<a href="https://baike.baidu.com/item/HLS/8328931?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/HLS/8328931?fr=aladdin</a></p><p>采用 <code>HLS</code> 方案即可实现边下载边播放，并可不用使用 <code>rtmp</code> 等流媒体协议，不用构建专用的媒体服务器，节省成本。所以本项目点播方案确定为方案 <code>3</code>。</p><h1 id="二、视频编码"><a href="#二、视频编码" class="headerlink" title="二、视频编码"></a>二、视频编码</h1><h2 id="1-视频编码格式"><a href="#1-视频编码格式" class="headerlink" title="1. 视频编码格式"></a>1. 视频编码格式</h2><p>先来看一下百度百科中的简介</p><p><a href="https://qnoss.codeyee.com/20200704_13/image5" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>详情参考 ：<a href="https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/839038" target="_blank" rel="noopener">https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/839038</a></p><p>首先我们要分清文件格式和编码格式：</p><p>文件格式：是指 <code>.mp4</code>、<code>.avi</code>、<code>.rmvb</code> 等 这些不同扩展名的视频文件的文件格式 ，视频文件的内容主要包括视频和音频，其文件格式是按照一 定的编码格式去编码，并且按照该文件所规定的封装格式将视频、音频、字幕等信息封装在一起，播放器会根据它们的封装格式去提取出编码，然后由播放器解码，最终播放音视频。</p><p>音视频编码格式：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。</p><p>比如：一个 <code>.avi</code> 的视频文件原来的编码是 <code>a</code>，通过编码后编码格式变为 <code>b</code>，音频原来为 <code>c</code>，通过编码后变为<code>d</code>。</p><h2 id="2-FFmpeg-的基本使用"><a href="#2-FFmpeg-的基本使用" class="headerlink" title="2. FFmpeg 的基本使用"></a>2. FFmpeg 的基本使用</h2><p>我们将视频录制完成后，使用视频编码软件对视频进行编码，本项目 使用 <code>FFmpeg</code> 对视频进行编码。</p><p><a href="https://qnoss.codeyee.com/20200704_13/image6" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p><code>FFmpeg</code> 被许多开源项目采用，QQ影音、暴风影音、VLC 等。</p><p>下载：FFmpeg <a href="https://www.ffmpeg.org/download.html#build-windows" target="_blank" rel="noopener">https://www.ffmpeg.org/download.html#build-windows</a></p><p><a href="https://qnoss.codeyee.com/20200704_13/image7" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image7.png" srcset="/img/loading.gif" alt="img"></a></p><p>下载完成后，将 <code>ffmpeg</code> 解压到磁盘下，设置环境变量 <code>FFMPEG_HOME</code> 的值为 <code>ffmpeg</code> 的安装目录</p><p><a href="https://qnoss.codeyee.com/20200704_13/image8" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>将 <code>%FFMPEG_HOME%/bin</code> 添加到环境变量<code>Path</code> 中</p><p><a href="https://qnoss.codeyee.com/20200704_13/image9" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image9.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-生成-m3u8-ts-文件"><a href="#3-生成-m3u8-ts-文件" class="headerlink" title="3. 生成 m3u8/ts 文件"></a>3. 生成 m3u8/ts 文件</h2><p>使用 <code>ffmpeg</code> 生成 <code>m3u8</code> 的步骤如下：</p><p>第一步：先将 <code>avi</code> 视频转成 <code>mp4</code></p><div class="hljs"><pre><code class="hljs shell">ffmpeg.exe -i lucene.avi -c:v libx264 -s 1280x720 -pix_fmt yuv420p -b:a 63k -b:v 753k -r 18 lucene.mp4</code></pre></div><p>下面把各参数意思大概讲讲，大概了解意思即可，不再此展开流媒体专业知识的讲解。</p><ul><li><code>-c:v</code> 视频编码为 <code>x264</code> ，<code>x264</code> 编码是 <code>H264</code> 的一种开源编码格式。</li><li><code>-s</code> 设置分辨率</li><li><code>-pix_fmt yuv420p</code>：设置像素采样方式，主流的采样方式有三种，<code>YUV4:4:4</code>，<code>YUV4:2:2</code>，<code>YUV4:2:0</code>，它的作用是根据采样方式来从码流中还原每个像素点的YUV（亮度信息与色彩信息）值。</li><li><code>-b</code> 设置码率，<code>-b:a</code> 和 <code>-b:v</code> 分别表示音频的码率和视频的码率，<code>-b</code> 表示音频加视频的总码率。码率对一个视频质量有很大的作用，后边会介绍。</li><li><code>-r</code>：帧率，表示每秒更新图像画面的次数，通常大于 <code>24</code> 肉眼就没有连贯与停顿的感觉了。</li></ul><p>第二步：将 <code>mp4</code> 生成 <code>m3u8</code></p><div class="hljs"><pre><code class="hljs shell">mkdir hlsffmpeg -i lucene.mp4 -hls_time 10 -hls_list_size 0 -hls_segment_filename ./hls/lucene_%05d.ts ./hls/lucene.m3u8</code></pre></div><ul><li><p><code>-hls_time</code> 设置每片的长度，单位为秒</p></li><li><p><code>-hls_list_size n</code>: 保存的分片的数量，设置为 <code>0</code> 表示保存所有分片</p></li><li><p><code>-hls_segment_filename</code> ：段文件的名称，<code>%05d</code> 表示 <code>5</code> 位数字</p><p>生成的效果是：将 <code>lucene.mp4</code> 视频文件每 <code>10</code> 秒生成一个 <code>ts</code> 文件，最后生成一个 <code>m3u8</code> 文件，<code>m3u8</code> 文件是 <code>ts</code> 的索引文件。</p></li></ul><p>使用 <code>VLC</code> 打开 <code>m3u8</code> 文件，测试播放效果，<code>VLC</code> 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 <code>DVD</code>、音频 <code>CD</code>、<code>VCD</code> 及各类流媒体协议。（<a href="http://www.videolan.org/%EF%BC%89" target="_blank" rel="noopener">http://www.videolan.org/）</a></p><p><a href="https://qnoss.codeyee.com/20200704_13/image10" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image10.png" srcset="/img/loading.gif" alt="img"></a></p><blockquote><p>如果这里出现无法播放的情况，请将 <code>FFmpeg</code> 和 <code>VLC</code> 播放器更新到最新版本。</p></blockquote><h3 id="码率的设置"><a href="#码率的设置" class="headerlink" title="码率的设置"></a>码率的设置</h3><p>码率又叫比特率即每秒传输的 <code>bit</code> 数，单位为 <code>bps(Bit Per Second)</code>，码率越大传送数据的速度越快。</p><p>码率的计算公式是：<code>文件大小（转成 bit）/ 时长（秒）/1024 = kbps</code> 即每秒传输千位数</p><p>例如一个 <code>1M</code> 的视频，它的时长是 <code>10s</code>，它的码率等于 <code>1*1024*1024*8/10/1024 = 819Kbps</code></p><p>码率设置到多少才能达到最好，通过根据个人的经验或参考一些视频网台给出的参考，下图是优酷对码率的要求：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image11" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p>如果要将视频上传到优酷则必须按照上面的要求，如果是自己搭建视频服务器，码率设置不易过大，最终达到的视频清晰度满足业务需求即可。</p><h1 id="三、播放器"><a href="#三、播放器" class="headerlink" title="三、播放器"></a>三、播放器</h1><h2 id="1-技术选型"><a href="#1-技术选型" class="headerlink" title="1. 技术选型"></a>1. 技术选型</h2><p>视频编码后要使用播放器对其进行解码、播放视频内容。在 <code>web</code> 应用中常用的播放器有 <code>flash</code> 播放器、<code>H5</code> 播放器或浏览器插件播放器，其中以 <code>flash</code> 和 <code>H5</code> 播放器最常见。</p><p>flash 播放器：缺点是需要在客户机安装 <code>Adobe Flash Player</code> 播放器，优点是 <code>flash</code> 播放器已经很成熟了，并且浏览器对 <code>flash</code> 支持也很好。</p><p>H5播放器：基于 <code>h5</code> 自带 <code>video</code> 标签进行构建，优点是大部分浏览器支持 <code>H5</code>，不用再安装第三方的<code>flash</code> 播放器，并且随着前端技术的发展，<code>h5</code> 技术会越来越成熟。</p><p>本项目采用H5播放器，使用 <code>Video.js</code> 开源播放器。</p><p><code>Video.js</code> 是一款基于 <code>HTML5</code> 世界的网络视频播放器。它支持 <code>HTML5</code> 和 <code>Flash</code> 视频，它支持在台式机和移动设备上播放视频。这个项目于 <code>2010</code> 年中开始，目前已在 <code>40</code> 万网站使用。</p><p>官方地址：<a href="http://videojs.com/" target="_blank" rel="noopener">http://videojs.com/</a></p><h2 id="2-下载-video-js"><a href="#2-下载-video-js" class="headerlink" title="2. 下载 video.js"></a>2. 下载 video.js</h2><p>Video.js： <a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">https://github.com/videojs/video.js</a></p><p>videojs-contrib-hls： <a href="https://github.com/videojs/videojs-contrib-hls#installation%EF%BC%88videojs-contrib-hls%E6%98%AF%E6%92%AD%E6%94%BE" target="_blank" rel="noopener">https://github.com/videojs/videojs-contrib-hls#installation（videojs-contrib-hls是播放</a> <code>hls</code> 的一个插件）</p><p>使用文档：<a href="http://docs.videojs.com/tutorial-videojs_.html" target="_blank" rel="noopener">http://docs.videojs.com/tutorial-videojs_.html</a></p><p>本教程使用 video.js <code>6.7.3</code> 版本，videojs-contrib-hls <code>5.14.1</code> 版本。</p><p>下载上边两个文件，为了测试需求将其放在门户工程的 <code>plugins</code> 目录中。</p><h2 id="3-搭建媒体播放器"><a href="#3-搭建媒体播放器" class="headerlink" title="3. 搭建媒体播放器"></a>3. 搭建媒体播放器</h2><p>正常使用 <code>video.js</code> 播放视频是通过一个网页，用户通过浏览器打开网页去播放视频，网页和视频都从web服务器请求，通常视频的 <code>url</code> 地址使用单独的域名。</p><h3 id="配置-Nginx媒体服务器"><a href="#配置-Nginx媒体服务器" class="headerlink" title="配置 Nginx媒体服务器"></a>配置 Nginx媒体服务器</h3><p>HLS 协议基于 <code>Http</code> 协议，本项目使用 <code>Nginx</code> 作为视频服务器。下图是 <code>Nginx</code> 媒体服务器的配置流程图：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image12" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、用户打开<a href="http://www.xuecheng.xn--com-x28dk46phv5a/" target="_blank" rel="noopener">www.xuecheng.com上边的</a> <code>video.html</code> 网页 ，在此网页中引入视频链接，视频地址指向video.xuecheng.com</p><p>2、video.xuecheng.com 进行负载均衡处理，将视频请求转发到媒体服务器</p><p>根据上边的流程，我们在媒体服务器上安装 <code>Nginx</code>，并配置如下：</p><div class="hljs"><pre><code class="hljs c">#学成网媒体服务server &#123;    <span class="hljs-built_in">listen</span> <span class="hljs-number">90</span>;    server_name localhost;    #视频目录    location /video/ &#123;        alias F:/develop/video/;    &#125;&#125;</code></pre></div><h3 id="配置媒体服务器代理"><a href="#配置媒体服务器代理" class="headerlink" title="配置媒体服务器代理"></a>配置媒体服务器代理</h3><p>媒体服务器不止一台，通过代理实现负载均衡功能，使用 <code>Nginx</code> 作为媒体服务器的代理，此代理服务器作为 <code>video.xuecheng.com</code> 域名服务器。</p><p>配置 <code>video.xuecheng.com</code> 虚拟主机：</p><p>注意：这里我们开发环境中代理服务器和媒体服务器在同一台服务器，使用同一个<code>Nginx</code>。</p><div class="hljs"><pre><code class="hljs c">#学成网媒体服务代理<span class="hljs-built_in">map</span> $http_origin $origin_list&#123;    <span class="hljs-keyword">default</span> http:<span class="hljs-comment">//www.xuecheng.com;</span>    <span class="hljs-string">"~http://www.xuecheng.com"</span> http:<span class="hljs-comment">//www.xuecheng.com;</span>    <span class="hljs-string">"~http://ucenter.xuecheng.com"</span> http:<span class="hljs-comment">//ucenter.xuecheng.com;</span>&#125; #学成网媒体服务代理server &#123;    <span class="hljs-built_in">listen</span> <span class="hljs-number">80</span>;    server_name video.xuecheng.com;    location /video &#123;        proxy_pass http:<span class="hljs-comment">//video_server_pool;</span>        add_header Access-Control-Allow-Origin $origin_list;        #add_header Access-Control-Allow-Origin *;        add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;        add_header Access-Control-Allow-Methods GET;    &#125;&#125;</code></pre></div><p>cors跨域参数：</p><ul><li>Access-Control-Allow-Origin：允许跨域访问的外域地址</li><li>Access-Control-Allow-Credentials： 允许客户端携带证书访问</li><li>Access-Control-Allow-Methods：允许客户端跨域访问的方法</li></ul><p>通常允许跨域访问的站点不是一个，所以这里用 <code>map</code> 定义了多个站点。</p><p>如果允许任何站点跨域访问则设置为 *，通常这是不建议的。</p><p><code>video_server_pool</code> 的配置如下：</p><div class="hljs"><pre><code class="hljs c">#媒体服务upstream video_server_pool&#123;    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">90</span> weight=<span class="hljs-number">10</span>;&#125;</code></pre></div><p>配置 <code>hosts</code> 文件，本教程开发环境使用 <code>Windows10</code>，修改 <code>hosts</code> 文件，路径为 <code>C:\Windows\System32\drivers\etc\hosts</code></p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> video.xuecheng.com</code></pre></div><h2 id="4-测试-video-js"><a href="#4-测试-video-js" class="headerlink" title="4. 测试 video.js"></a>4. 测试 video.js</h2><p>参考文档如下：</p><p><a href="https://github.com/videojs/videojs-contrib-hls#installation" target="_blank" rel="noopener">https://github.com/videojs/videojs-contrib-hls#installation</a></p><p><a href="http://jsbin.com/vokipos/8/edit?html,output" target="_blank" rel="noopener">http://jsbin.com/vokipos/8/edit?html,output</a></p><p>1、编写测试页面 <code>video.html</code>。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"content-type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>视频播放<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/plugins/videojs/video-js.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">example-video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">800</span> <span class="hljs-attr">height</span>=<span class="hljs-string">600</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"video-js vjs-default-skin vjs-big-play-</span></span><span class="hljs-tag"><span class="hljs-string">                                                            centered"</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">"http://127.0.0.1:90/video/add.jpg"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">source</span></span><span class="hljs-tag">                    <span class="hljs-attr">src</span>=<span class="hljs-string">"http://video.xuecheng.com/video/hls/lucene.m3u8"</span></span><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">"application/x-mpegURL"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">"switchvideo()"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"switch"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/plugins/videojs/video.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/plugins/videojs/videojs-contrib-hls.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">            <span class="hljs-keyword">var</span> player = videojs(<span class="hljs-string">'example-video'</span>);</span><span class="actionscript">            <span class="hljs-comment">//player.play();</span></span><span class="actionscript">            <span class="hljs-comment">//切换视频</span></span><span class="actionscript">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">switchvideo</span><span class="hljs-params">()</span></span>&#123;</span>                player.src(&#123;<span class="actionscript">                    src: <span class="hljs-string">'http://video.xuecheng.com/video/hls/lucene.m3u8'</span>,</span><span class="actionscript">                    type: <span class="hljs-string">'application/x-mpegURL'</span>,</span><span class="actionscript">                    withCredentials: <span class="hljs-literal">true</span></span>                &#125;);                player.play();            &#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>2、测试</p><p><a href="https://qnoss.codeyee.com/20200704_13/image13" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image13.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击 <code>switch</code> 测试切换视频功能。</p><h1 id="四、搭建学习中心前端"><a href="#四、搭建学习中心前端" class="headerlink" title="四、搭建学习中心前端"></a>四、搭建学习中心前端</h1><h2 id="1-界面原型"><a href="#1-界面原型" class="headerlink" title="1. 界面原型"></a>1. 界面原型</h2><p>先看一下界面原型，如下图，最终的目标是在此页面使用 <code>video.js</code> 播放视频。</p><p><a href="https://qnoss.codeyee.com/20200704_13/image14" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image14.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-创建学习中心工程"><a href="#2-创建学习中心工程" class="headerlink" title="2. 创建学习中心工程"></a>2. 创建学习中心工程</h2><p>学习中心的用户是学生，为了便于系统维护和扩展，单独创建学习中心工程：</p><p>1、从资料目录拷贝 <code>xc-ui-pc-leanring.zip</code> 并解压到 <code>xc-ui-pc-leanring</code> 目录。</p><p>2、使用 <code>webstorm</code> 创建打开 <code>xc-ui-pc-leanring</code> 目录</p><p>3、进入 <code>xc-ui-pc-leanring</code> 目录，执行 <code>cnpm install</code>，将根据 <code>package.json</code> 的依赖配置远程下载依赖的 <code>js</code> 包。</p><p>创建完成，<code>xc-ui-pc-leanring</code>工程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image15" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>学习中心的二级域名为 <code>ucenter.xuecheng.com</code>，我们在 <code>nginx</code> 中配置 <code>ucenter</code> 虚拟主机。</p><div class="hljs"><pre><code class="hljs c">#学成网用户中心server &#123;    <span class="hljs-built_in">listen</span> <span class="hljs-number">80</span>;    server_name ucenter.xuecheng.com;    #个人中心    location / &#123;        proxy_pass http:<span class="hljs-comment">//ucenter_server_pool;</span>    &#125;&#125; #前端ucenterupstream ucenter_server_pool&#123;    <span class="hljs-meta">#server 127.0.0.1:7081 weight=10;</span>    server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">13000</span> weight=<span class="hljs-number">10</span>;&#125;</code></pre></div><p>在根服务下添加一个 <code>/plugins/</code> 站点</p><div class="hljs"><pre><code class="hljs c"># 根服务server&#123;    <span class="hljs-built_in">listen</span>       <span class="hljs-number">80</span>;    server_name  www.xuecheng.com;    ssi on;    ssi_silent_errors on;    location /plugins/ &#123;              # 跨域参数        alias  E:/Project/XueChengOnline/xcEduUI01/xc-ui-pc-<span class="hljs-keyword">static</span>-portal/plugins/;           add_header Access-Control-Allow-Origin http:<span class="hljs-comment">//ucenter.xuecheng.com; </span>        add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;                  add_header Access-Control-Allow-Methods GET;            &#125;    .....&#125;</code></pre></div><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p>启动工程，看到下边的界面说明本工程创建完成</p><p><a href="https://qnoss.codeyee.com/20200704_13/image16" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image16.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-调试视频播放页面"><a href="#3-调试视频播放页面" class="headerlink" title="3. 调试视频播放页面"></a>3. 调试视频播放页面</h2><p>使用 <code>vue-video-player</code> 组件将 <code>video.js</code> 集成到 <code>vue.js</code> 中，本项目使用 <code>vue-video-player</code>实现<code>video.js</code> 播放。</p><p>组件地址：<a href="https://github.com/surmon-china/vue-video-player" target="_blank" rel="noopener">https://github.com/surmon-china/vue-video-player</a></p><p>上面的 <code>xc-ui-pc-learning</code> 工程已经添加 <code>vue-video-player</code> 组件，我们在 <code>vue</code> 页面直接使用即可。</p><p>前边我们已经测试通过 <code>video.js</code>，下面我们直接在 <code>vue</code> 页面中使用 <code>vue-video-player</code> 完成视频播放。</p><p>导入 <code>learning_video.vue</code> 页面到 <code>course</code> 模块下。</p><p>配置路由</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> learning_video <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/learning_video.vue'</span>;&#123;    path: <span class="hljs-string">'/learning/:courseId/:chapter'</span>,    component: learning_video,    name: <span class="hljs-string">'录播视频学习'</span>,    hidden: <span class="hljs-literal">false</span>,    iconCls: <span class="hljs-string">'el‐icon‐document'</span>&#125;</code></pre></div><p>预览效果</p><p>请求：<a href="http://ucenter.xuecheng.com/#/learning/1/2" target="_blank" rel="noopener">http://ucenter.xuecheng.com/#/learning/1/2</a></p><p>第一个参数：<code>courseId</code>，课程id，这里是测试页面效果随便输入一个 <code>ID</code> 即可，这里输入1</p><p>第二个参数：<code>chapter</code>，课程计划id，这里是测试页面效果随便输入一个 <code>ID</code> 即可，这里输入2</p><p><a href="https://qnoss.codeyee.com/20200704_13/image17" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image17.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="五、媒资管理"><a href="#五、媒资管理" class="headerlink" title="五、媒资管理"></a>五、媒资管理</h1><p>前边章节完成在线视频播放，如何实现点击课程计划播放视频呢，课程视频如何管理呢？</p><p>本节开始将对课程视频进行管理。</p><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>媒资管理系统是每个在线教育平台所必须具备的，百度百科对它的定义如下：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image18" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p>每个教学机构都可以在媒资系统管理自己的教学资源，包括：视频、教案等文件。</p><p>目前媒资管理的主要管理对象是课程录播视频，包括：媒资文件的查询、视频上传、视频删除、视频处理等。</p><ul><li>媒资查询：教学机构查询自己所拥有的媒体文件。</li><li>视频上传：将用户线下录制的教学视频上传到媒资系统。</li><li>视频处理：视频上传成功，系统自动对视频进行编码处理。</li><li>视频删除 ：如果该视频已不再使用，可以从媒资系统删除。</li></ul><p>下边是媒资系统与其它系统的交互情况：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image19" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image19.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、上传媒资文件</p><p>前端/客户端请求媒资系统上传文件。</p><p>文件上传成功将文件存储到媒资服务器，将文件信息存储到数据库。</p><p>2、使用媒资</p><p>课程管理请求媒资系统查询媒资信息，将课程计划与媒资信息对应、存储。</p><p>3、视频播放</p><p>用户进入学习中心请求学习服务学习在线播放视频。</p><p>学习服务校验用户资格通过后请求媒资系统获取视频地址。</p><h2 id="2-开发环境搭建"><a href="#2-开发环境搭建" class="headerlink" title="2. 开发环境搭建"></a>2. 开发环境搭建</h2><h3 id="创建媒资数据库"><a href="#创建媒资数据库" class="headerlink" title="创建媒资数据库"></a>创建媒资数据库</h3><p>1、媒资文件信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.media;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> org.springframework.data.annotation.Id;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Document</span>(collection = <span class="hljs-string">"media_file"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaFile</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">    文件id、名称、大小、文件类型、文件状态（未上传、上传完成、上传失败）、上传时间、视频处理方式、视频处理状态、hls_m3u8,hls_ts_list、课程视频信息（课程id、章节id）</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Id</span>    <span class="hljs-comment">//文件id</span>    <span class="hljs-keyword">private</span> String fileId;    <span class="hljs-comment">//文件名称</span>    <span class="hljs-keyword">private</span> String fileName;    <span class="hljs-comment">//文件原始名称</span>    <span class="hljs-keyword">private</span> String fileOriginalName;    <span class="hljs-comment">//文件路径</span>    <span class="hljs-keyword">private</span> String filePath;    <span class="hljs-comment">//文件url</span>    <span class="hljs-keyword">private</span> String fileUrl;    <span class="hljs-comment">//文件类型</span>    <span class="hljs-keyword">private</span> String fileType;    <span class="hljs-comment">//mimetype</span>    <span class="hljs-keyword">private</span> String mimeType;    <span class="hljs-comment">//文件大小</span>    <span class="hljs-keyword">private</span> Long fileSize;    <span class="hljs-comment">//文件状态</span>    <span class="hljs-keyword">private</span> String fileStatus;    <span class="hljs-comment">//上传时间</span>    <span class="hljs-keyword">private</span> Date uploadTime;    <span class="hljs-comment">//处理状态</span>    <span class="hljs-keyword">private</span> String processStatus;    <span class="hljs-comment">//hls处理</span>    <span class="hljs-keyword">private</span> MediaFileProcess_m3u8 mediaFileProcess_m3u8;    <span class="hljs-comment">//tag标签用于查询</span>    <span class="hljs-keyword">private</span> String tag;&#125;</code></pre></div><p>2、创建 <code>xc_media</code> 数据库</p><p>媒资系统使用 <code>mongodb</code> 数据库存储媒资信息，再创建集合 <code>media_file</code></p><p><a href="https://qnoss.codeyee.com/20200704_13/image20" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image20.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="创建媒资服务工程"><a href="#创建媒资服务工程" class="headerlink" title="创建媒资服务工程"></a>创建媒资服务工程</h3><p>媒资管理的相关功能单独在媒资服务中开发，下边创建媒资服务工程（<code>xc-service-manage-media</code>）。<br>媒资服务的配置与 <code>cms</code> 类似，导入 <code>资料/xc-service-manage-media</code> 工程，工程结构如下：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image21" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-上传文件"><a href="#3-上传文件" class="headerlink" title="3. 上传文件"></a>3. 上传文件</h2><h3 id="断点续传解决方案"><a href="#断点续传解决方案" class="headerlink" title="断点续传解决方案"></a>断点续传解决方案</h3><p>通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足<code>大文件</code> 的上传要求。<code>http</code> 协议本身对上传文件大小没有限制，但是客户的网络环境质量、电脑硬件环境等参差不齐，如果一个大文件快上传完了网断了，电断了没有上传完成，需要客户重新上传，这是致命的，所以对于大文件上传的要求最基本的是断点续传。</p><p>什么是断点续传?</p><p>引用百度百科：断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性。</p><p>如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image22" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>上传流程如下：</p><p>1、上传前先把文件分成块</p><p>2、一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传</p><p>3、各分块上传完成最后合并文件</p><p>文件下载则同理。</p><h3 id="文件分块与合并"><a href="#文件分块与合并" class="headerlink" title="文件分块与合并"></a>文件分块与合并</h3><p>为了更好的理解文件分块上传的原理，下边用java代码测试文件的分块与合并。</p><h4 id="1、分块"><a href="#1、分块" class="headerlink" title="1、分块"></a>1、分块</h4><p>文件分块的流程如下：</p><p>1、获取源文件长度</p><p>2、根据设定的分块文件的大小计算出块数</p><p>3、从源文件读数据，再依次向每一个块文件写入数据。</p><p>单元测试代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 测试文件分块</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testChunk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    String chunkPath = <span class="hljs-string">"E:/Project/XueChengOnline/xcEduUI01/xuecheng/video/"</span>;    String fileName = <span class="hljs-string">"lucene.mp4"</span>;    File sourceFile = <span class="hljs-keyword">new</span> File(chunkPath + fileName);    File chunkFolder = <span class="hljs-keyword">new</span> File(chunkPath + fileName + <span class="hljs-string">".chunk"</span>);    <span class="hljs-keyword">if</span>(!chunkFolder.exists())&#123;        chunkFolder.mkdir();    &#125;    <span class="hljs-comment">//分块大小</span>    <span class="hljs-keyword">long</span> chunkSize = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1</span>;    <span class="hljs-comment">//分块数量</span>    <span class="hljs-comment">//Math.ceil向上取整,例如 12.1=13,12.8=13</span>    <span class="hljs-keyword">long</span> chunkNum = (<span class="hljs-keyword">long</span>) Math.ceil((sourceFile.length() * <span class="hljs-number">1.0</span>) / chunkSize);    chunkNum = chunkNum &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : chunkNum;    <span class="hljs-comment">//缓冲区大小</span>    <span class="hljs-keyword">byte</span>[] byte_cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-comment">//使用RandomAccessFile访问文件</span>    RandomAccessFile rafRead = <span class="hljs-keyword">new</span> RandomAccessFile(sourceFile, <span class="hljs-string">"r"</span>);    <span class="hljs-comment">//分块</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chunkNum; i++) &#123;        <span class="hljs-comment">//创建分块文件</span>        File chunkFile = <span class="hljs-keyword">new</span> File(chunkFolder.getPath() + <span class="hljs-string">"/"</span> + i);        <span class="hljs-keyword">boolean</span> newFile = chunkFile.createNewFile();        <span class="hljs-keyword">if</span> (newFile)&#123;            <span class="hljs-comment">//向分块文件中写入数据</span>            RandomAccessFile raf_write = <span class="hljs-keyword">new</span> RandomAccessFile(chunkFile, <span class="hljs-string">"rw"</span>);            <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;            <span class="hljs-comment">//读取到-1则表示读取完成</span>            len = rafRead.read(byte_cache);            <span class="hljs-keyword">while</span> (len != -<span class="hljs-number">1</span>)&#123;                raf_write.write(byte_cache,<span class="hljs-number">0</span>, len);                <span class="hljs-comment">//读取到预期块大小时结束</span>                <span class="hljs-keyword">if</span> (chunkFile.length() &gt;= chunkSize)&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            raf_write.close();        &#125;    &#125;    rafRead.close();&#125;</code></pre></div><h4 id="2、合并"><a href="#2、合并" class="headerlink" title="2、合并"></a>2、合并</h4><p>文件合并流程：</p><p>1、找到要合并的文件并按文件合并的先后进行排序。</p><p>2、创建合并文件</p><p>3、依次从合并的文件中读取数据向合并文件写入数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//测试文件合并方法</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMerge</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//块文件目录</span>    File chunkFolder = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"F:/develop/ffmpeg/chunk/"</span>);    <span class="hljs-comment">//合并文件</span>    File mergeFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"F:/develop/ffmpeg/lucene1.mp4"</span>);    <span class="hljs-keyword">if</span>(mergeFile.exists())&#123;        mergeFile.delete();    &#125;     <span class="hljs-comment">//创建新的合并文件</span>    mergeFile.createNewFile();    <span class="hljs-comment">//用于写文件</span>    RandomAccessFile raf_write = <span class="hljs-keyword">new</span> RandomAccessFile(mergeFile, <span class="hljs-string">"rw"</span>);    <span class="hljs-comment">//指针指向文件顶端</span>    raf_write.seek(<span class="hljs-number">0</span>);    <span class="hljs-comment">//缓冲区</span>    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];    <span class="hljs-comment">//分块列表</span>    File[] fileArray = chunkFolder.listFiles();    <span class="hljs-comment">// 转成集合，便于排序</span>    List&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;File&gt;(Arrays.asList(fileArray));    <span class="hljs-comment">// 从小到大排序</span>    Collections.sort(fileList, <span class="hljs-keyword">new</span> Comparator&lt;File&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(File o1, File o2)</span> </span>&#123;            <span class="hljs-keyword">if</span> (Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName())) &#123;                <span class="hljs-keyword">return</span> ‐<span class="hljs-number">1</span>;            &#125;             <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;);    <span class="hljs-comment">//合并文件</span>    <span class="hljs-keyword">for</span>(File chunkFile:fileList)&#123;        RandomAccessFile raf_read = <span class="hljs-keyword">new</span> RandomAccessFile(chunkFile,<span class="hljs-string">"rw"</span>);        <span class="hljs-keyword">int</span> len = ‐<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>((len=raf_read.read(b))!=‐<span class="hljs-number">1</span>)&#123;            raf_write.write(b,<span class="hljs-number">0</span>,len);        &#125;         raf_read.close();    &#125;     raf_write.close();&#125;</code></pre></div><h3 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h3><p>上传文件的页面内容参考：<code>资料/upload.vue</code> 文件</p><h4 id="1、WebUploader-介绍"><a href="#1、WebUploader-介绍" class="headerlink" title="1、WebUploader 介绍"></a>1、WebUploader 介绍</h4><p>如何在web页面实现断点续传？</p><p>常见的方案有：</p><p>1、通过 <code>Flash</code> 上传，比如 <code>SWFupload</code>、<code>Uploadify</code>。</p><p>2、安装浏览器插件，变相的pc客户端，用的比较少。</p><p>3、HTML5</p><p>随着 <code>HTML5</code> 的流行，本项目采用 <code>HTML5</code> 完成文件分块上传。</p><p>本项目使用 <code>WebUploader</code> 完成大文件上传功能的开发，<code>WebUploader</code> 官网地址：<br><a href="http://fexteam.gz01.bdysite.com/webuploader/" target="_blank" rel="noopener">http://fexteam.gz01.bdysite.com/webuploader/</a></p><p><code>WebUploader</code> 简介</p><p><a href="https://qnoss.codeyee.com/20200704_13/image23" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image23.png" srcset="/img/loading.gif" alt="img"></a></p><p><code>WebUploader</code> 的特性</p><p><a href="https://qnoss.codeyee.com/20200704_13/image24" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image24.png" srcset="/img/loading.gif" alt="img"></a></p><p>使用 <code>WebUploader</code> 的上传流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image25" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image25.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="2、钩子方法"><a href="#2、钩子方法" class="headerlink" title="2、钩子方法"></a>2、钩子方法</h4><p>在 <code>webuploader</code> 中提供很多钩子方法，下边列出一些重要的：</p><p><a href="https://qnoss.codeyee.com/20200704_13/image26" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image26.png" srcset="/img/loading.gif" alt="img"></a></p><p>本项目使用如下钩子方法：</p><ul><li><p><code>before-send-file</code></p><p>在开始对文件分块儿之前调用，可以做一些上传文件前的准备工作，比如检查文件目录是否创建完成等</p></li><li><p><code>before-send</code></p><p>在上传文件分块之前调用此方法，可以请求服务端检查分块是否存在，如果已存在则此分块儿不再上传。</p></li><li><p><code>after-send-file</code></p><p>在所有分块上传完成后触发，可以请求服务端合并分块文件。</p></li></ul><p>注册钩子方法源代码：</p><div class="hljs"><pre><code class="hljs js">WebUploader.Uploader.register(&#123;    <span class="hljs-string">"before‐send‐file"</span>:<span class="hljs-string">"beforeSendFile"</span>,    <span class="hljs-string">"before‐send"</span>:<span class="hljs-string">"beforeSend"</span>,    <span class="hljs-string">"after‐send‐file"</span>:<span class="hljs-string">"afterSendFile"</span>&#125;</code></pre></div><h4 id="3、构建-WebUploader"><a href="#3、构建-WebUploader" class="headerlink" title="3、构建 WebUploader"></a>3、构建 WebUploader</h4><p>使用 <code>webUploader</code> 前需要创建<code>webUploader</code> 对象。</p><p>指定上传分块的地址：<code>/api/media/upload/uploadchunk</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 创建uploader对象，配置参数</span><span class="hljs-keyword">this</span>.uploader = WebUploader.create(    &#123;        swf:<span class="hljs-string">"/static/plugins/webuploader/dist/Uploader.swf"</span>,<span class="hljs-comment">//上传文件的flash文件，浏览器不支持h5时启动</span>        flash        server:<span class="hljs-string">"/api/media/upload/uploadchunk"</span>,<span class="hljs-comment">//上传分块的服务端地址，注意跨域问题</span>        fileVal:<span class="hljs-string">"file"</span>,<span class="hljs-comment">//文件上传域的name</span>        pick:<span class="hljs-string">"#picker"</span>,<span class="hljs-comment">//指定选择文件的按钮容器</span>        auto:<span class="hljs-literal">false</span>,<span class="hljs-comment">//手动触发上传</span>        disableGlobalDnd:<span class="hljs-literal">true</span>,<span class="hljs-comment">//禁掉整个页面的拖拽功能</span>        chunked:<span class="hljs-literal">true</span>,<span class="hljs-comment">// 是否分块上传</span>        chunkSize:<span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>, <span class="hljs-comment">// 分块大小（默认5M）</span>        threads:<span class="hljs-number">3</span>, <span class="hljs-comment">// 开启多个线程（默认3个）</span>        prepareNextFile:<span class="hljs-literal">true</span><span class="hljs-comment">// 允许在文件传输时提前把下一个文件准备好</span>    &#125;)</code></pre></div><h4 id="3、before-send-file"><a href="#3、before-send-file" class="headerlink" title="3、before-send-file"></a>3、before-send-file</h4><p>文件开始上传前前端请求服务端准备上传工作。</p><p>参考源代码如下：</p><div class="hljs"><pre><code class="hljs js">type:<span class="hljs-string">"POST"</span>,url:<span class="hljs-string">"/api/media/upload/register"</span>,data:&#123;    <span class="hljs-comment">// 文件唯一表示</span>    fileMd5:<span class="hljs-keyword">this</span>.fileMd5,    fileName: file.name,    fileSize:file.size,    mimetype:file.type,    fileExt:file.ext&#125;</code></pre></div><h4 id="4、before-send"><a href="#4、before-send" class="headerlink" title="4、before-send"></a>4、before-send</h4><p>上传分块前前端请求服务端校验分块是否存在。</p><p>参考源代码如下：</p><div class="hljs"><pre><code class="hljs js">type:<span class="hljs-string">"POST"</span>,url:<span class="hljs-string">"/api/media/upload/register"</span>,data:&#123;    <span class="hljs-comment">// 文件唯一表示</span>    fileMd5:<span class="hljs-keyword">this</span>.fileMd5,    fileName: file.name,    fileSize:file.size,    mimetype:file.type,    fileExt:file.ext&#125;</code></pre></div><h4 id="5、after-send-file"><a href="#5、after-send-file" class="headerlink" title="5、after-send-file"></a>5、after-send-file</h4><p>在所有分块上传完成后触发，可以请求服务端合并分块文件</p><p>参考代码如下：</p><div class="hljs"><pre><code class="hljs js">type:<span class="hljs-string">"POST"</span>,url:<span class="hljs-string">"/api/media/upload/checkchunk"</span>,data:&#123;<span class="hljs-comment">// 文件唯一表示</span>fileMd5:<span class="hljs-keyword">this</span>.fileMd5,<span class="hljs-comment">// 当前分块下标</span>chunk:block.chunk,<span class="hljs-comment">// 当前分块大小</span>chunkSize:block.end‐block.start&#125;</code></pre></div><h4 id="6、页面效果"><a href="#6、页面效果" class="headerlink" title="6、页面效果"></a>6、页面效果</h4><p><a href="https://qnoss.codeyee.com/20200704_13/image27" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image27.png" srcset="/img/loading.gif" alt="img"></a></p><p>定义文件上传的Api接口，此接收是前端 <code>WebUploader</code> 调用服务端的接口。</p><p>编写此接口需要参数前端 <code>WebUploader</code> 应用代码。</p><h3 id="Api接口"><a href="#Api接口" class="headerlink" title="Api接口"></a>Api接口</h3><p>定义文件上传的 <code>Api</code> 接口，此接收是前端 <code>WebUploader</code> 调用服务端的接口。</p><p>编写此接口需要参数前端 <code>WebUploader</code> 应用代码。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.media;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.CheckChunkResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"媒资管理接口"</span>, description = <span class="hljs-string">"媒资管理接口，提供文件上传，文件处理等接口"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaUploadControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"文件上传注册"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">register</span><span class="hljs-params">(String fileMd5,</span></span><span class="hljs-function"><span class="hljs-params">                                   String fileName,</span></span><span class="hljs-function"><span class="hljs-params">                                   Long fileSize,</span></span><span class="hljs-function"><span class="hljs-params">                                   String mimetype,</span></span><span class="hljs-function"><span class="hljs-params">                                   String fileExt)</span></span>;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"分块检查"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CheckChunkResult <span class="hljs-title">checkchunk</span><span class="hljs-params">(String fileMd5,</span></span><span class="hljs-function"><span class="hljs-params">                                       Integer chunk,</span></span><span class="hljs-function"><span class="hljs-params">                                       Integer chunkSize)</span></span>;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"上传分块"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">uploadchunk</span><span class="hljs-params">(MultipartFile file,</span></span><span class="hljs-function"><span class="hljs-params">                                      Integer chunk,</span></span><span class="hljs-function"><span class="hljs-params">                                      String fileMd5)</span></span>;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"合并文件"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">mergechunks</span><span class="hljs-params">(String fileMd5,</span></span><span class="hljs-function"><span class="hljs-params">                                      String fileName,</span></span><span class="hljs-function"><span class="hljs-params">                                      Long fileSize,</span></span><span class="hljs-function"><span class="hljs-params">                                      String mimetype,</span></span><span class="hljs-function"><span class="hljs-params">                                      String fileExt)</span></span>;&#125;</code></pre></div><h3 id="媒资服务端编写"><a href="#媒资服务端编写" class="headerlink" title="媒资服务端编写"></a>媒资服务端编写</h3><h4 id="1、业务流程"><a href="#1、业务流程" class="headerlink" title="1、业务流程"></a>1、业务流程</h4><p>服务端需要实现如下功能：</p><p>1）上传前检查上传环境</p><p>检查文件是否上传，已上传则直接返回。</p><p>检查文件上传路径是否存在，不存在则创建。</p><p>2）分块检查</p><p>检查分块文件是否上传，已上传则返回 <code>true</code></p><p>未上传则检查上传路径是否存在，不存在则创建。</p><p>3）分块上传</p><p>将分块文件上传到指定的路径。</p><p>4）合并分块</p><p>将所有分块文件合并为一个文件，在数据库记录文件信息。</p><h4 id="2、上传注册"><a href="#2、上传注册" class="headerlink" title="2、上传注册"></a>2、上传注册</h4><p>由于上传过程复杂，开发时按业务流程分别实现。</p><p>1、配置</p><p><code>application.yml</code> 配置上传文件的路径：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">xc‐service‐manage‐media:</span>  <span class="hljs-comment"># 媒体文件存放路径</span>  <span class="hljs-string">upload‐location:</span> <span class="hljs-string">F:/develop/video/</span></code></pre></div><p>2、定义DAO</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaFileRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">MediaFile</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><p>3、编写Service</p><p>功能：</p><p>1）检查上传文件是否存在</p><p>2）创建文件目录</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.service.impl;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.MediaCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.controller.MediaUploadController;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.dao.MediaFileRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.service.MediaUploadService;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaUploadServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaUploadService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(MediaUploadController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-comment">//上传文件根目录</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc‐service‐manage‐media.upload‐location&#125;"</span>)    String uploadPath;   <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查文件信息是否已经存在本地以及mongodb内,其中一者不存在则重新注册</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件扩展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 文件路径</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">register</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-comment">//1.检查文件在磁盘上是否存在</span>        <span class="hljs-comment">//2.检查文件信息在mongodb上是否存在</span>        <span class="hljs-comment">//获取文件所属目录以及文件路径</span>        String fileFloderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String filePath = <span class="hljs-keyword">this</span>.getFileFullPath(fileMd5, fileExt);        File file = <span class="hljs-keyword">new</span> File(filePath);        <span class="hljs-keyword">boolean</span> exists = file.exists();        <span class="hljs-comment">//查询mongodb上的文件信息</span>        Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5);        <span class="hljs-keyword">if</span>(exists &amp;&amp; optional.isPresent())&#123;            ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST);        &#125;        <span class="hljs-comment">//其中一者不存在则重新注册文件信息</span>        File fileFloder = <span class="hljs-keyword">new</span> File(fileFloderPath);        <span class="hljs-keyword">if</span>(!fileFloder.exists())&#123;            <span class="hljs-comment">//创建文件目录</span>            fileFloder.mkdirs();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据文件md5得到文件的所属目录</span><span class="hljs-comment">     * 规则：</span><span class="hljs-comment">     * 一级目录：md5的第一个字符</span><span class="hljs-comment">     * 二级目录：md5的第二个字符</span><span class="hljs-comment">     * 三级目录：md5</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileFloderPath</span><span class="hljs-params">(String fileMd5)</span></span>&#123;        String floderPath = uploadPath + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) + <span class="hljs-string">"/"</span> + fileMd5  + <span class="hljs-string">"/"</span>;        <span class="hljs-keyword">return</span> floderPath;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取全文件路径</span><span class="hljs-comment">     * 文件名：md5+文件扩展名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileFullPath</span><span class="hljs-params">(String fileMd5, String fileExt)</span></span>&#123;        String floderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String filePath = floderPath + fileMd5 + <span class="hljs-string">"."</span> + fileExt;        <span class="hljs-keyword">return</span> filePath;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取文件路径</span><span class="hljs-comment">     * 文件名：md5+文件扩展名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFilePath</span><span class="hljs-params">(String fileMd5, String fileExt)</span></span>&#123;        String filePath = <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) + <span class="hljs-string">"/"</span> + fileMd5 + <span class="hljs-string">"/"</span>;        <span class="hljs-keyword">return</span> filePath;    &#125;&#125;</code></pre></div><h4 id="3、分块检查"><a href="#3、分块检查" class="headerlink" title="3、分块检查"></a>3、分块检查</h4><p>在 Service 中定义分块检查方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 检查文件块是否存在</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fileMd5 文件md5</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> chunk 块编号</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> chunkSize 块大小</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> CheckChunkResult</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> CheckChunkResult <span class="hljs-title">checkChunk</span><span class="hljs-params">(String fileMd5, Integer chunk, Integer chunkSize)</span> </span>&#123;    <span class="hljs-comment">//获取文件块路径</span>    String chunkFloder = <span class="hljs-keyword">this</span>.getChunkFloderPath(fileMd5);    File chunkFile = <span class="hljs-keyword">new</span> File(chunkFloder + chunk);    <span class="hljs-keyword">if</span>(chunkFile.exists())&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CheckChunkResult(CommonCode.SUCCESS, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CheckChunkResult(CommonCode.SUCCESS, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">//获取文件块路径</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getChunkFloderPath</span><span class="hljs-params">(String fileMd5)</span> </span>&#123;    <span class="hljs-comment">//获取分块文件所属目录</span>    String fileFloderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);    String chunkFloder = fileFloderPath + <span class="hljs-string">"chunk/"</span>;    File fileChunkFloder = <span class="hljs-keyword">new</span> File(chunkFloder);    <span class="hljs-comment">//如果分块所属目录不存在则创建</span>    <span class="hljs-keyword">if</span>(!fileChunkFloder.exists())&#123;        fileChunkFloder.mkdirs();    &#125;    <span class="hljs-keyword">return</span> chunkFloder;&#125;</code></pre></div><h4 id="4、上传分块"><a href="#4、上传分块" class="headerlink" title="4、上传分块"></a>4、上传分块</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 上传分块文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file 上传的文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 分块号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">uploadChunk</span><span class="hljs-params">(MultipartFile file, Integer chunk, String fileMd5)</span> </span>&#123;    <span class="hljs-comment">//获取分块文件所属目录</span>    String chunkFloder = <span class="hljs-keyword">this</span>.getChunkFloderPath(fileMd5);    InputStream inputStream = <span class="hljs-keyword">null</span>;    FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        inputStream = file.getInputStream();        fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(chunkFloder + chunk);        IOUtils.copy(inputStream,fileOutputStream);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-comment">//文件保存失败</span>        e.printStackTrace();        LOGGER.error(<span class="hljs-string">"upload chunk file fail:&#123;&#125;"</span>,e.getMessage());        ExceptionCast.cast(MediaCode.CHUNK_FILE_UPLOAD_FAIL);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);&#125;</code></pre></div><h4 id="5、合并分块"><a href="#5、合并分块" class="headerlink" title="5、合并分块"></a>5、合并分块</h4><p>在 <code>Service</code> 中定义分块合并分块方法，功能如下：</p><p>1）将块文件合并</p><p>2）校验文件 <code>md5</code> 是否正确</p><p>3）向 <code>Mongodb</code> 写入文件信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 合并文件块信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 文件名称</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileSize 文件大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mimetype 文件类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件拓展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ResponseResult</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">mergeChunks</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;    <span class="hljs-comment">//获取文件块路径</span>    String chunkFloderPath = getChunkFloderPath(fileMd5);    <span class="hljs-comment">//合并文件路径</span>    String fileFullPath = <span class="hljs-keyword">this</span>.getFileFullPath(fileMd5, fileExt);    File mergeFile = <span class="hljs-keyword">new</span> File(fileFullPath);    <span class="hljs-comment">//创建合并文件,如果存在则先删除再创建</span>    <span class="hljs-keyword">if</span>(mergeFile.exists())&#123;        mergeFile.delete();    &#125;    <span class="hljs-keyword">boolean</span> newFile = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;        newFile = mergeFile.createNewFile();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();        LOGGER.error(<span class="hljs-string">"mergechunks..create mergeFile fail:&#123;&#125;"</span>,e.getMessage());    &#125;    <span class="hljs-keyword">if</span>(!newFile)&#123;        <span class="hljs-comment">//文件创建失败</span>        ExceptionCast.cast(MediaCode.MERGE_FILE_CREATEFAIL);    &#125;    <span class="hljs-comment">//获取块文件列表,此列表是已经排序好的</span>    List&lt;File&gt; chunkFiles = <span class="hljs-keyword">this</span>.getChunkFiles(chunkFloderPath);    <span class="hljs-comment">//合并文件</span>    mergeFile = <span class="hljs-keyword">this</span>.mergeFile(mergeFile, chunkFiles);    <span class="hljs-keyword">if</span>(mergeFile == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(MediaCode.MERGE_FILE_FAIL);    &#125;    <span class="hljs-comment">//校验文件</span>    <span class="hljs-keyword">boolean</span> checkResult = <span class="hljs-keyword">this</span>.checkFileMd5(mergeFile, fileMd5);    <span class="hljs-keyword">if</span>(!checkResult)&#123;        ExceptionCast.cast(MediaCode.MERGE_FILE_CHECKFAIL);    &#125;    <span class="hljs-comment">//将文件信息保存到数据库</span>    MediaFile mediaFile = <span class="hljs-keyword">new</span> MediaFile();    mediaFile.setFileId(fileMd5);    mediaFile.setFileName(fileMd5+<span class="hljs-string">"."</span>+fileExt);    mediaFile.setFileOriginalName(fileName);    <span class="hljs-comment">//文件路径保存相对路径</span>    String filePath = <span class="hljs-keyword">this</span>.getFilePath(fileMd5,fileExt);    mediaFile.setFilePath(<span class="hljs-keyword">this</span>.getFilePath(fileMd5,fileExt));    mediaFile.setFileUrl(filePath + fileName + <span class="hljs-string">"."</span> + fileExt);    mediaFile.setFileSize(fileSize);    mediaFile.setUploadTime(<span class="hljs-keyword">new</span> Date());    mediaFile.setMimeType(mimetype);    mediaFile.setFileType(fileExt);    <span class="hljs-comment">//状态为上传成功</span>    mediaFile.setFileStatus(<span class="hljs-string">"301002"</span>);    MediaFile save = mediaFileRepository.save(mediaFile);    <span class="hljs-comment">//向MQ发送视频处理消息</span>    <span class="hljs-keyword">this</span>.sendProcessVideoMsg(fileMd5);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);&#125;<span class="hljs-comment">//校验文件MD5</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkFileMd5</span><span class="hljs-params">(File mergeFile, String fileMd5)</span> </span>&#123;    <span class="hljs-keyword">if</span>(mergeFile == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(fileMd5))&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//进行md5校验</span>    <span class="hljs-keyword">try</span> &#123;        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(mergeFile);        <span class="hljs-comment">//得到文件的MD5</span>        String md5Hex = DigestUtils.md5Hex(fileInputStream);        <span class="hljs-comment">//比较两个MD5值</span>        <span class="hljs-keyword">if</span>(md5Hex.equalsIgnoreCase(fileMd5))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;        e.printStackTrace();        LOGGER.error(<span class="hljs-string">"未找到该文件 &#123;&#125;"</span>,e.getMessage());    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">//合并文件</span><span class="hljs-function"><span class="hljs-keyword">private</span> File <span class="hljs-title">mergeFile</span><span class="hljs-params">(File mergeFile, List&lt;File&gt; chunkFiles)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//创建写文件对象</span>        RandomAccessFile raf_write = <span class="hljs-keyword">new</span> RandomAccessFile(mergeFile,<span class="hljs-string">"rw"</span>);        <span class="hljs-comment">//遍历分块文件开始合并</span>        <span class="hljs-comment">//读取文件缓冲区</span>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-keyword">for</span>(File chunkFile:chunkFiles)&#123;            RandomAccessFile raf_read = <span class="hljs-keyword">new</span> RandomAccessFile(chunkFile,<span class="hljs-string">"r"</span>);            <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;            <span class="hljs-comment">//读取分块文件</span>            <span class="hljs-keyword">while</span>((len = raf_read.read(b))!= -<span class="hljs-number">1</span>)&#123;                <span class="hljs-comment">//向合并文件中写数据</span>                raf_write.write(b,<span class="hljs-number">0</span>,len);            &#125;             raf_read.close();        &#125;         raf_write.close();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();        LOGGER.error(<span class="hljs-string">"merge file error:&#123;&#125;"</span>,e.getMessage());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;     <span class="hljs-keyword">return</span> mergeFile;&#125;<span class="hljs-comment">//获取块文件列表</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;File&gt; <span class="hljs-title">getChunkFiles</span><span class="hljs-params">(String chunkFloderPath)</span> </span>&#123;    <span class="hljs-comment">//块文件目录</span>    File chunkFolder = <span class="hljs-keyword">new</span> File(chunkFloderPath);    <span class="hljs-comment">//分块文件列表</span>    File[] fileArray = chunkFolder.listFiles();    <span class="hljs-comment">//将分块列表转为集合,便于排序</span>    ArrayList&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(fileArray));    <span class="hljs-comment">//从小到大排序,按名称升序</span>    Collections.sort(fileList, <span class="hljs-keyword">new</span> Comparator&lt;File&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(File o1, File o2)</span> </span>&#123;            <span class="hljs-comment">//比较两个文件的名称</span>            <span class="hljs-keyword">if</span> (Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName())) &#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;);    <span class="hljs-keyword">return</span> fileList;&#125;</code></pre></div><h4 id="6、Controller"><a href="#6、Controller" class="headerlink" title="6、Controller"></a>6、Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.media.MediaUploadControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.CheckChunkResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.service.MediaUploadService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/media/upload"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaUploadController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaUploadControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    MediaUploadService mediaUploadService;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/register"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">register</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-keyword">return</span> mediaUploadService.register(fileMd5,fileName,fileSize,mimetype,fileExt);    &#125;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/checkchunk"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CheckChunkResult <span class="hljs-title">checkChunk</span><span class="hljs-params">(String fileMd5, Integer chunk, Integer chunkSize)</span> </span>&#123;        <span class="hljs-keyword">return</span> mediaUploadService.checkChunk(fileMd5,chunk,chunkSize);    &#125;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/uploadchunk"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">uploadChunk</span><span class="hljs-params">(MultipartFile file, Integer chunk, String fileMd5)</span> </span>&#123;            <span class="hljs-keyword">return</span> mediaUploadService.uploadChunk(file, chunk, fileMd5);    &#125;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/mergechunks"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">mergeChunks</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-keyword">return</span> mediaUploadService.mergeChunks(fileMd5,fileName,fileSize,mimetype,fileExt);    &#125;&#125;</code></pre></div><h4 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h4><p>建议第一次测试时使用调试模式，在每个模块下都打一个断点进行单步调试，逐步的执行代码，以便检查代码的逻辑。</p><p><a href="https://qnoss.codeyee.com/20200704_13/image28" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image28.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们在前端工程选择一个文件进行上传，点击开始上传</p><p><a href="https://qnoss.codeyee.com/20200704_13/image29" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image29.png" srcset="/img/loading.gif" alt="img"></a></p><p>开始上传后，我们可以看到文件所属的 <code>chunk</code> 目录下在不断的生成块文件</p><p><a href="https://qnoss.codeyee.com/20200704_13/image30" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image30.png" srcset="/img/loading.gif" alt="img"></a></p><p>块文件全部生成后，会自动调用合并的接口，将所有块文件合并成单个文件</p><p><a href="https://qnoss.codeyee.com/20200704_13/image31" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image31.png" srcset="/img/loading.gif" alt="img"></a></p><p>上传成功页面提示</p><p><a href="https://qnoss.codeyee.com/20200704_13/image32" target="_blank" rel="noopener"><img src="/2020/08/21/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday13/image32.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-完整的代码"><a href="#4-完整的代码" class="headerlink" title="4. 完整的代码"></a>4. 完整的代码</h2><h3 id="MediaUploadService"><a href="#MediaUploadService" class="headerlink" title="MediaUploadService"></a>MediaUploadService</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.service;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.CheckChunkResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 媒体文件上传服务</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MediaUploadService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件信息校验并注册</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 文件名称</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileSize 文件大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mimetype 文件类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件扩展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 通用的响应信息</span><span class="hljs-comment">     */</span>    <span class="hljs-function">ResponseResult <span class="hljs-title">register</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查文件块是否存在</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 块编号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunkSize 块大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 检查文件块信息的响应</span><span class="hljs-comment">     */</span>    <span class="hljs-function">CheckChunkResult <span class="hljs-title">checkChunk</span><span class="hljs-params">(String fileMd5,Integer chunk,Integer chunkSize)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 上传分块文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file 上传的文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 分块号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ResponseResult</span><span class="hljs-comment">     */</span>    <span class="hljs-function">ResponseResult <span class="hljs-title">uploadChunk</span><span class="hljs-params">(MultipartFile file,Integer chunk,String fileMd5)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 合并文件块</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 文件名称</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileSize 文件大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mimetype 文件类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件拓展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ResponseResult</span><span class="hljs-comment">     */</span>    <span class="hljs-function">ResponseResult <span class="hljs-title">mergeChunks</span><span class="hljs-params">(String fileMd5,String fileName,Long fileSize,String mimetype,String fileExt)</span></span>;&#125;</code></pre></div><h3 id="MediaUploadServiceImpl"><a href="#MediaUploadServiceImpl" class="headerlink" title="MediaUploadServiceImpl"></a>MediaUploadServiceImpl</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_media.service.impl;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.netflix.discovery.converters.Auto;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.MediaFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.CheckChunkResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.media.response.MediaCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.config.RabbitMQConfig;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.controller.MediaUploadController;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.dao.MediaFileRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_media.service.MediaUploadService;<span class="hljs-keyword">import</span> org.apache.commons.codec.digest.DigestUtils;<span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-keyword">import</span> javax.jws.Oneway;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-meta">@Service</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaUploadServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MediaUploadService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(MediaUploadController<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    MediaFileRepository mediaFileRepository;    <span class="hljs-comment">//上传文件根目录</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.upload-location&#125;"</span>)    String uploadPath;   <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查文件信息是否已经存在本地以及mongodb内,其中一者不存在则重新注册</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件扩展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 文件路径</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">register</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-comment">//1.检查文件在磁盘上是否存在</span>        <span class="hljs-comment">//2.检查文件信息在mongodb上是否存在</span>        <span class="hljs-comment">//获取文件所属目录以及文件路径</span>        String fileFloderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String filePath = <span class="hljs-keyword">this</span>.getFileFullPath(fileMd5, fileExt);        File file = <span class="hljs-keyword">new</span> File(filePath);        <span class="hljs-keyword">boolean</span> exists = file.exists();        <span class="hljs-comment">//查询mongodb上的文件信息</span>        Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5);        <span class="hljs-keyword">if</span>(exists &amp;&amp; optional.isPresent())&#123;            ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST);        &#125;        <span class="hljs-comment">//其中一者不存在则重新注册文件信息</span>        File fileFloder = <span class="hljs-keyword">new</span> File(fileFloderPath);        <span class="hljs-keyword">if</span>(!fileFloder.exists())&#123;            <span class="hljs-comment">//创建文件目录</span>            fileFloder.mkdirs();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 检查文件块是否存在</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件md5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 块编号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunkSize 块大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CheckChunkResult</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CheckChunkResult <span class="hljs-title">checkChunk</span><span class="hljs-params">(String fileMd5, Integer chunk, Integer chunkSize)</span> </span>&#123;        <span class="hljs-comment">//获取文件块路径</span>        String chunkFloder = <span class="hljs-keyword">this</span>.getChunkFloderPath(fileMd5);        File chunkFile = <span class="hljs-keyword">new</span> File(chunkFloder + chunk);        <span class="hljs-keyword">if</span>(chunkFile.exists())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CheckChunkResult(CommonCode.SUCCESS, <span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CheckChunkResult(CommonCode.SUCCESS, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 上传分块文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file 上传的文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chunk 分块号</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">uploadChunk</span><span class="hljs-params">(MultipartFile file, Integer chunk, String fileMd5)</span> </span>&#123;        <span class="hljs-comment">//获取分块文件所属目录</span>        String chunkFloder = <span class="hljs-keyword">this</span>.getChunkFloderPath(fileMd5);        InputStream inputStream = <span class="hljs-keyword">null</span>;        FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            inputStream = file.getInputStream();            fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(chunkFloder + chunk);            IOUtils.copy(inputStream,fileOutputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-comment">//文件保存失败</span>            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"upload chunk file fail:&#123;&#125;"</span>,e.getMessage());            ExceptionCast.cast(MediaCode.CHUNK_FILE_UPLOAD_FAIL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 合并文件块信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileMd5 文件MD5</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileName 文件名称</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileSize 文件大小</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mimetype 文件类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileExt 文件拓展名</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ResponseResult</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">mergeChunks</span><span class="hljs-params">(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt)</span> </span>&#123;        <span class="hljs-comment">//获取文件块路径</span>        String chunkFloderPath = getChunkFloderPath(fileMd5);        <span class="hljs-comment">//合并文件路径</span>        String fileFullPath = <span class="hljs-keyword">this</span>.getFileFullPath(fileMd5, fileExt);        File mergeFile = <span class="hljs-keyword">new</span> File(fileFullPath);        <span class="hljs-comment">//创建合并文件,如果存在则先删除再创建</span>        <span class="hljs-keyword">if</span>(mergeFile.exists())&#123;            mergeFile.delete();        &#125;        <span class="hljs-keyword">boolean</span> newFile = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            newFile = mergeFile.createNewFile();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"mergechunks..create mergeFile fail:&#123;&#125;"</span>,e.getMessage());        &#125;        <span class="hljs-keyword">if</span>(!newFile)&#123;            <span class="hljs-comment">//文件创建失败</span>            ExceptionCast.cast(MediaCode.MERGE_FILE_CREATEFAIL);        &#125;        <span class="hljs-comment">//获取块文件列表,此列表是已经排序好的</span>        List&lt;File&gt; chunkFiles = <span class="hljs-keyword">this</span>.getChunkFiles(chunkFloderPath);        <span class="hljs-comment">//合并文件</span>        mergeFile = <span class="hljs-keyword">this</span>.mergeFile(mergeFile, chunkFiles);        <span class="hljs-keyword">if</span>(mergeFile == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(MediaCode.MERGE_FILE_FAIL);        &#125;        <span class="hljs-comment">//校验文件</span>        <span class="hljs-keyword">boolean</span> checkResult = <span class="hljs-keyword">this</span>.checkFileMd5(mergeFile, fileMd5);        <span class="hljs-keyword">if</span>(!checkResult)&#123;            ExceptionCast.cast(MediaCode.MERGE_FILE_CHECKFAIL);        &#125;        <span class="hljs-comment">//将文件信息保存到数据库</span>        MediaFile mediaFile = <span class="hljs-keyword">new</span> MediaFile();        mediaFile.setFileId(fileMd5);        mediaFile.setFileName(fileMd5+<span class="hljs-string">"."</span>+fileExt);        mediaFile.setFileOriginalName(fileName);        <span class="hljs-comment">//文件路径保存相对路径</span>        String filePath = <span class="hljs-keyword">this</span>.getFilePath(fileMd5,fileExt);        mediaFile.setFilePath(<span class="hljs-keyword">this</span>.getFilePath(fileMd5,fileExt));        mediaFile.setFileUrl(filePath + fileName + <span class="hljs-string">"."</span> + fileExt);        mediaFile.setFileSize(fileSize);        mediaFile.setUploadTime(<span class="hljs-keyword">new</span> Date());        mediaFile.setMimeType(mimetype);        mediaFile.setFileType(fileExt);        <span class="hljs-comment">//状态为上传成功</span>        mediaFile.setFileStatus(<span class="hljs-string">"301002"</span>);        MediaFile save = mediaFileRepository.save(mediaFile);        <span class="hljs-comment">//向MQ发送视频处理消息</span>        <span class="hljs-keyword">this</span>.sendProcessVideoMsg(fileMd5);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">//视频处理路由</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xc-service-manage-media.mq.routingkey-media-video&#125;"</span>)    <span class="hljs-keyword">public</span> String routingkey_media_video;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-comment">//向MQ发送视频处理消息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> ResponseResult <span class="hljs-title">sendProcessVideoMsg</span><span class="hljs-params">(String mediaId)</span></span>&#123;        Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(mediaId);        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);        &#125;        MediaFile mediaFile = optional.get();        <span class="hljs-comment">//发送视频处理消息</span>        Map&lt;String,String&gt; msgMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        msgMap.put(<span class="hljs-string">"mediaId"</span>,mediaId);        <span class="hljs-comment">//发送的消息</span>        String msg = JSON.toJSONString(msgMap);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.rabbitTemplate.convertAndSend(RabbitMQConfig.EX_MEDIA_PROCESSTASK,routingkey_media_video,msg);            LOGGER.info(<span class="hljs-string">"send media process task msg:&#123;&#125;"</span>,msg);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();            LOGGER.info(<span class="hljs-string">"send media process task error,msg is:&#123;&#125;,error:&#123;&#125;"</span>,msg,e.getMessage());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">//校验文件MD5</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkFileMd5</span><span class="hljs-params">(File mergeFile, String fileMd5)</span> </span>&#123;        <span class="hljs-keyword">if</span>(mergeFile == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(fileMd5))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//进行md5校验</span>        <span class="hljs-keyword">try</span> &#123;            FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(mergeFile);            <span class="hljs-comment">//得到文件的MD5</span>            String md5Hex = DigestUtils.md5Hex(fileInputStream);            <span class="hljs-comment">//比较两个MD5值</span>            <span class="hljs-keyword">if</span>(md5Hex.equalsIgnoreCase(fileMd5))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"未找到该文件 &#123;&#125;"</span>,e.getMessage());        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//合并文件</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> File <span class="hljs-title">mergeFile</span><span class="hljs-params">(File mergeFile, List&lt;File&gt; chunkFiles)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建写文件对象</span>            RandomAccessFile raf_write = <span class="hljs-keyword">new</span> RandomAccessFile(mergeFile,<span class="hljs-string">"rw"</span>);            <span class="hljs-comment">//遍历分块文件开始合并</span>            <span class="hljs-comment">//读取文件缓冲区</span>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">for</span>(File chunkFile:chunkFiles)&#123;                RandomAccessFile raf_read = <span class="hljs-keyword">new</span> RandomAccessFile(chunkFile,<span class="hljs-string">"r"</span>);                <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;                <span class="hljs-comment">//读取分块文件</span>                <span class="hljs-keyword">while</span>((len = raf_read.read(b))!= -<span class="hljs-number">1</span>)&#123;                    <span class="hljs-comment">//向合并文件中写数据</span>                    raf_write.write(b,<span class="hljs-number">0</span>,len);                &#125;                 raf_read.close();            &#125;             raf_write.close();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"merge file error:&#123;&#125;"</span>,e.getMessage());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-keyword">return</span> mergeFile;    &#125;    <span class="hljs-comment">//获取块文件列表</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;File&gt; <span class="hljs-title">getChunkFiles</span><span class="hljs-params">(String chunkFloderPath)</span> </span>&#123;        <span class="hljs-comment">//块文件目录</span>        File chunkFolder = <span class="hljs-keyword">new</span> File(chunkFloderPath);        <span class="hljs-comment">//分块文件列表</span>        File[] fileArray = chunkFolder.listFiles();        <span class="hljs-comment">//将分块列表转为集合,便于排序</span>        ArrayList&lt;File&gt; fileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(fileArray));        <span class="hljs-comment">//从小到大排序,按名称升序</span>        Collections.sort(fileList, <span class="hljs-keyword">new</span> Comparator&lt;File&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(File o1, File o2)</span> </span>&#123;                <span class="hljs-comment">//比较两个文件的名称</span>                <span class="hljs-keyword">if</span> (Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName())) &#123;                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;        &#125;);        <span class="hljs-keyword">return</span> fileList;    &#125;    <span class="hljs-comment">//获取文件块路径</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getChunkFloderPath</span><span class="hljs-params">(String fileMd5)</span> </span>&#123;        <span class="hljs-comment">//获取分块文件所属目录</span>        String fileFloderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String chunkFloder = fileFloderPath + <span class="hljs-string">"chunk/"</span>;        File fileChunkFloder = <span class="hljs-keyword">new</span> File(chunkFloder);        <span class="hljs-comment">//如果分块所属目录不存在则创建</span>        <span class="hljs-keyword">if</span>(!fileChunkFloder.exists())&#123;            fileChunkFloder.mkdirs();        &#125;        <span class="hljs-keyword">return</span> chunkFloder;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据文件md5得到文件的所属目录</span><span class="hljs-comment">     * 规则：</span><span class="hljs-comment">     * 一级目录：md5的第一个字符</span><span class="hljs-comment">     * 二级目录：md5的第二个字符</span><span class="hljs-comment">     * 三级目录：md5</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileFloderPath</span><span class="hljs-params">(String fileMd5)</span></span>&#123;            String floderPath = uploadPath + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) + <span class="hljs-string">"/"</span> +fileMd5  + <span class="hljs-string">"/"</span>;            <span class="hljs-keyword">return</span> floderPath;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取全文件路径</span><span class="hljs-comment">     * 文件名：md5+文件扩展名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileFullPath</span><span class="hljs-params">(String fileMd5, String fileExt)</span></span>&#123;        String floderPath = <span class="hljs-keyword">this</span>.getFileFloderPath(fileMd5);        String filePath = floderPath + fileMd5 + <span class="hljs-string">"."</span> + fileExt;        <span class="hljs-keyword">return</span> filePath;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取文件路径</span><span class="hljs-comment">     * 文件名：md5+文件扩展名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFilePath</span><span class="hljs-params">(String fileMd5, String fileExt)</span></span>&#123;        String filePath = <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + fileMd5.substring(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) + <span class="hljs-string">"/"</span> + fileMd5 + <span class="hljs-string">"/"</span>;        <span class="hljs-keyword">return</span> filePath;    &#125;&#125;</code></pre></div><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FFmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day12：基于 Nuxt.js 构建搜索前端工程</title>
    <link href="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/"/>
    <url>/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day12</code> 的内容</p><ul><li>Nuxt.js 的基本使用</li><li>基于 Nuxt.js 开发搜索门户前端</li></ul><h1 id="一、搜索前端技术需求"><a href="#一、搜索前端技术需求" class="headerlink" title="一、搜索前端技术需求"></a>一、搜索前端技术需求</h1><p>采用 <code>vue.js</code> 开发搜索界面则 <code>SEO</code> 不友好，需要解决 <code>SEO</code> 的问题。</p><h2 id="1-什么是SEO"><a href="#1-什么是SEO" class="headerlink" title="1. 什么是SEO?"></a>1. 什么是SEO?</h2><p>我们先开一下百度百科是如何描述的</p><p><a href="https://qnoss.codeyee.com/20200704_12/image1" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p>总结：<code>seo</code> 是网站为了提高自已的网站排名，获得更多的流量，对网站的结构及内容进行调整优化，以便搜索引擎（百度，google等）更好抓取到更优质的网站的内容。</p><p>下图是搜索引擎爬取网站页面的大概流程图：</p><blockquote><p>搜索引擎的工作流程很复杂，下图只是简单概括</p></blockquote><p><a href="https://qnoss.codeyee.com/20200704_12/image2" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>从上图可以看到 <code>SEO</code> 是网站自己为了方便 <code>spider</code> (爬虫) 抓取网页而作出的网页内容优化，常见的 <code>SEO</code> 方法比如：</p><ul><li>对 <code>url</code> 链接的规范化，多用 <code>restful</code> 风格的 <code>url</code>，多用静态资源 <code>url</code>；</li><li>注意 <code>title</code>、<code>keywords</code> 的设置。</li><li>由于 <code>spider</code> 对 <code>javascript</code> 支持不好，对于网页跳转用 <code>href</code> 标签。</li></ul><h2 id="2-服务端渲染和客户端渲染"><a href="#2-服务端渲染和客户端渲染" class="headerlink" title="2. 服务端渲染和客户端渲染"></a>2. 服务端渲染和客户端渲染</h2><p>采用什么技术有利于 <code>SEO</code>？要解答这个问题需要理解服务端渲染和客户端渲染。</p><p>那么什么是服务端渲染?</p><p>我们用传统的 <code>servlet</code> 开发来举例：浏览器请求 <code>servlet</code>，<code>servlet</code> 在服务端生成 <code>html</code> 响应给浏览器，浏览器展示<code>html</code> 的内容，这个过程就是服务端渲染，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image3" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>服务端渲染的特点：</p><p>1）在服务端生成 <code>html</code> 网页的 <code>dom</code> 元素。</p><p>2）客户端（浏览器）只负责显示 <code>dom</code> 元素内容。</p><p>当初随着 <code>web2.0</code> 的到来，<code>AJAX</code> 技术兴起，出现了客户端渲染：客户端（浏览器） 使用 <code>AJAX</code> 向服务端发起<code>http</code> 请求，获取到了想要的数据，客户端拿着数据开始渲染 <code>html</code> 网页，生成 <code>Dom</code> 元素，并最终将网页内容展示给用户</p><p>客户端渲染如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image4" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>客户端渲染的特点：</p><p>1）在服务端只是给客户端响应的了数据，而不是 <code>html</code> 网页</p><p>2）客户端（浏览器）负责获取服务端的数据生成 <code>Dom</code> 元素。</p><p>两种方式各有什么优缺点？</p><p><strong>客户端渲染：</strong></p><ol><li>缺点</li></ol><p>不利于网站进行 <code>SEO</code>，因为网站大量使用 <code>javascript</code> 技术，不利于 <code>spider</code> 抓取网页。</p><ol><li>优点</li></ol><p>客户端负责渲染，用户体验性好，服务端只提供数据不用关心用户界面的内容，有利于提高服务端的开发效率。</p><p>3）适用场景</p><p>对SEO没有要求的系统，比如后台管理类的系统，如电商后台管理，用户管理等。</p><p><strong>服务端渲染：</strong></p><ol><li>优点</li></ol><p>有利于SEO，网站通过 <code>href</code> 的 <code>url</code> 将 <code>spider</code>直接引到服务端，服务端提供优质的网页内容给 <code>spider</code>。</p><ol><li>缺点</li></ol><p>服务端完成一部分客户端的工作，通常完成一个需求需要修改客户端和服务端的代码，开发效率低，不利于系统的<br>稳定性。</p><p>3）适用场景</p><p>对 <code>SEO</code> 有要求的系统，比如：门户首页、商品详情页面等。</p><h1 id="二、Nuxt-js-介绍"><a href="#二、Nuxt-js-介绍" class="headerlink" title="二、Nuxt.js 介绍"></a>二、Nuxt.js 介绍</h1><h2 id="0x01-简单的了解一下"><a href="#0x01-简单的了解一下" class="headerlink" title="0x01 简单的了解一下"></a>0x01 简单的了解一下</h2><p>移动互联网的兴起促进了 <code>web</code> 前后端分离开发模式的发展，服务端只专注业务，前端只专注用户体验，前端大量运用的前端渲染技术，比如流行的 <code>vue.js</code>、<code>react</code> 框架都实现了功能强大的前端渲染。</p><p>但是，对于有 <code>SEO</code> 需求的网页如果使用前端渲染技术去开发就不利于 <code>SEO</code> 了，有没有一种即使用 <code>vue.js</code>、<code>react</code> 的前端技术也实现服务端渲染的技术呢？其实，对于服务端渲染的需求，<code>vue.js</code>、<code>react</code> 这样流行的前端框架提供了服务端渲染的解决方案。</p><p><a href="https://qnoss.codeyee.com/20200704_12/image5" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>从上图可以看到：</p><p><code>react</code> 框架提供 <code>next.js</code> 实现服务端渲染。</p><p><code>vue.js</code> 框架提供 <code>Nuxt.js</code> 实现服务端渲染。</p><p>基本原理</p><h2 id="0x02-工作原理"><a href="#0x02-工作原理" class="headerlink" title="0x02 工作原理"></a>0x02 工作原理</h2><p>下图展示了从客户端请求到 <code>Nuxt.js</code> 进行服务端渲染的整体的工作流程：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image6" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、用户打开浏览器，输入网址请求到 <code>Node.js</code></p><p>2、部署在 <code>Node.js</code> 的应用 <code>Nuxt.js</code> 接收浏览器请求，并请求服务端获取数据</p><p>3、<strong>Nuxt.js</strong> 获取到数据后进行服务端渲染</p><p>4、<strong>Nuxt.js</strong> 将 <code>html</code> 网页响应给浏览器</p><p><strong>Nuxt.js</strong> 使用了哪些技术？</p><p><strong>Nuxt.js</strong> 使用 <code>Vue.js</code> + <code>webpack</code> + <code>Babel</code> 三大技术框架/组件，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image7" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image7.png" srcset="/img/loading.gif" alt="img"></a></p><p><code>Babel</code> 是一个 <code>js</code> 的转码器，负责将 <code>ES6</code> 的代码转成浏览器识别的 <code>ES5</code> 代码。</p><p><code>Webpack</code> 是一个前端工程打包工具。</p><p><code>Vue.js</code> 是一个优秀的前端框架。</p><p>那么 <strong>Nuxt.js</strong> 的特性有哪些？</p><ul><li>基于 <code>Vue.js</code></li><li>自动代码分层</li><li>服务端渲染</li><li>强大的路由功能，支持异步数据</li><li>静态文件服务</li><li>ES6/ES7 语法支持</li><li>打包和压缩 <code>JS</code> 和 <code>CSS</code></li><li><code>HTML</code> 头部标签管理</li><li>本地开发支持热加载</li><li>集成 <code>ESLint</code></li><li>支持各种样式预处理器： <code>SASS</code>、<code>LESS</code>、 <code>Stylus</code> 等等</li></ul><h1 id="三、Nuxt-js-基本使用"><a href="#三、Nuxt-js-基本使用" class="headerlink" title="三、Nuxt.js 基本使用"></a>三、Nuxt.js 基本使用</h1><h2 id="1-创建-Nuxt-工程"><a href="#1-创建-Nuxt-工程" class="headerlink" title="1. 创建 Nuxt 工程"></a>1. 创建 Nuxt 工程</h2><p><code>nuxt.js</code> 有标准的目录结构，官方提供了模板工程，可以模板工程快速创建 <code>nuxt</code> 项目。</p><p>模板工程地址：<a href="https://github.com/nuxt-community/starter-template/archive/master.zip" target="_blank" rel="noopener">https://github.com/nuxt-community/starter-template/archive/master.zip</a></p><p>本项目提供基于 <code>Nuxt.js</code> 的封装工程，基于此封装工程开发搜索前端，见 <code>资料/xc-ui-pc-portal.zip</code>，解压 <code>xc-ui-pc-portal.zip</code> 到本项目前端工程目录下。</p><p>本前端工程属于门户的一部分，将承载一部分考虑 <code>SEO</code> 的非静态化页面。</p><p>本工程基于 <code>Nuxt.js</code> 模板工程构建，<code>Nuxt.js</code> 使用 <code>1.3</code> 版本，并加入了今后开发中所使用的依赖包，直接解压本工程即可使用。</p><h2 id="2-目录结构"><a href="#2-目录结构" class="headerlink" title="2. 目录结构"></a>2. 目录结构</h2><p>目录结构如下</p><p><a href="https://qnoss.codeyee.com/20200704_12/image8" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image8.png" srcset="/img/loading.gif" alt="img"></a></p><table><thead><tr><th>名称</th><th>描述信息</th></tr></thead><tbody><tr><td>assets</td><td>资源目录 <code>assets</code> 用于组织未编译的静态资源如 <code>LESS</code>、<code>SASS</code> 或 <code>JavaScript</code></td></tr><tr><td>components</td><td>组件目录 <code>components</code> 用于组织应用的 <code>Vue.js</code> 组件。<code>Nuxt.js</code> 不会扩展增强该目录下 <code>Vue.js</code> 组件，即这些组件不会像页面组件那样有 <code>asyncData</code> 方法的特性。</td></tr><tr><td>layouts</td><td>布局目录 <code>layouts</code> 用于组织应用的布局组件。该目录名为 <code>Nuxt.js</code> 保留的，不可更改。</td></tr><tr><td>middleware</td><td><code>middleware</code> 目录用于存放应用的中间件</td></tr><tr><td>pages</td><td>页面目录 <code>pages</code> 用于组织应用的路由及视图。<code>Nuxt.js</code> 框架读取该目录下所有的 <code>.vue</code> 文件并自动生成对应的路由配置。该目录名为 <code>Nuxt.js</code> 保留的，不可更改。</td></tr><tr><td>plugins</td><td>插件目录 <code>plugins</code> 用于组织那些需要在 根<code>vue.js</code>应用 实例化之前需要运行的 <code>Javascript</code> 插件</td></tr><tr><td>static</td><td>静态文件目录 <code>static</code> 用于存放应用的静态文件，此类文件不会被 <code>Nuxt.js</code> 调用 <code>Webpack</code> 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。例如: <code>/static/logo.png</code> 映射至 <code>/logo.png</code> ，该目录名为<code>Nuxt.js</code>保留的，不可更改。</td></tr><tr><td>Store</td><td><code>store</code> 目录用于组织应用的 <code>Vuex</code> 状态树 文件。 <code>Nuxt.js</code> 框架集成了 <code>Vuex</code> 状态树 的相关功能配置，在 <code>store</code> 目录下创建一个 <code>index.js</code> 文件可激活这些配置。</td></tr><tr><td>nuxt.config.js</td><td>nuxt.config.js 文件用于组织 <code>Nuxt.js</code> 应用的个性化配置，以便覆盖默认配置。该文件名为<code>Nuxt.js</code> 保留的，不可更改。</td></tr><tr><td>package.json</td><td>文件用于描述应用的依赖关系和对外暴露的脚本接口。该文件名为 <code>Nuxt.js</code> 保留的，不可更改。</td></tr></tbody></table><p>nuxt.js 提供了目录的别名，方便在程序中引用：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image9" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>官方文档： <a href="https://zh.nuxtjs.org/guide/installation" target="_blank" rel="noopener">https://zh.nuxtjs.org/guide/installation</a></p><h2 id="3-页面布局"><a href="#3-页面布局" class="headerlink" title="3. 页面布局"></a>3. 页面布局</h2><p>页面布局就是页面内容的整体结构，通过在 <code>layouts</code> 目录下添加布局文件来实现。在 <code>layouts</code> 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 <code>layout</code> 属性来引用。</p><p>一个例子：</p><p>1、定义：<code>layouts/test.vue</code> 布局文件，如下：</p><p>注意：布局文件中一定要加 <code>&lt;nuxt/&gt;</code> 组件用于显示页面内容。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是头<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">nuxt</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是尾<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>2、在 <code>pages</code> 目录创建 <code>user</code> 目录，并创建 <code>index.vue</code> 页面</p><p>在 <code>pages/user/index.vue</code> 页面里， 可以指定页面组件使用 <code>test</code> 布局，代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    测试页面    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><span class="actionscript">layout:<span class="hljs-string">'test'</span></span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>3、测试</p><p>请求：<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:10000/user，效果如下:</p><p><a href="https://qnoss.codeyee.com/20200704_12/image10" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image10.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h2><h3 id="1、基础路由"><a href="#1、基础路由" class="headerlink" title="1、基础路由"></a>1、基础路由</h3><p><strong>Nuxt.js</strong> 依据 <code>pages</code> 目录结构自动生成 <code>vue-router</code> 模块的路由配置。</p><p><strong>Nuxt.js</strong> 根据 <code>pages</code> 的目录结构及页面名称定义规范来生成路由，下边是一个基础路由的例子</p><p>假设 <code>pages</code> 的目录结构如下：</p><div class="hljs"><pre><code class="hljs haml">pages/-<span class="ruby">-<span class="hljs-params">| user/</span></span><span class="ruby">-----<span class="hljs-params">| index.vue</span></span><span class="ruby">-----<span class="hljs-params">| one.vue</span></span></code></pre></div><p>那么，<code>Nuxt.js</code> 自动生成的路由配置如下：</p><div class="hljs"><pre><code class="hljs js">router: &#123;routes: [        &#123;            name: <span class="hljs-string">'user'</span>,            path: <span class="hljs-string">'/user'</span>,            component: <span class="hljs-string">'pages/user/index.vue'</span>        &#125;,        &#123;            name: <span class="hljs-string">'user-one'</span>,            path: <span class="hljs-string">'/user/one'</span>,            component: <span class="hljs-string">'pages/user/one.vue'</span>        &#125;    ]&#125;</code></pre></div><p><strong>index.vue</strong> 代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    用户管理首页    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><span class="actionscript">layout:<span class="hljs-string">"test"</span></span>&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p><strong>one.vue</strong> 代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        one页面    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><span class="actionscript">        layout:<span class="hljs-string">"test"</span></span>    &#125; <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>分别访问如下链接进行测试：</p><p><a href="http://localhost:10000/user" target="_blank" rel="noopener">http://localhost:10000/user</a></p><p><a href="http://localhost:10000/user/one" target="_blank" rel="noopener">http://localhost:10000/user/one</a></p><h3 id="2、嵌套路由"><a href="#2、嵌套路由" class="headerlink" title="2、嵌套路由"></a>2、嵌套路由</h3><p>你可以通过 <code>vue-router</code> 的子路由创建 <code>Nuxt.js</code> 应用的嵌套路由。</p><p>创建内嵌子路由，你需要添加一个 <code>Vue</code> 文件，同时添加一个<strong>与该文件同名</strong>的目录用来存放子视图组件。</p><p>别忘了在父级 <code>Vue</code> 文件内增加 <code>&lt;nuxt-child/&gt;</code> 用于显示子视图内容。</p><p>假设文件结构如：</p><div class="hljs"><pre><code class="hljs html">pages/--| user/-----| _id.vue-----| index.vue--| user.vue</code></pre></div><p>Nuxt.js 自动生成的路由配置如下：</p><div class="hljs"><pre><code class="hljs js">router: &#123;    routes: [        &#123;            path: <span class="hljs-string">'/user'</span>,            component: <span class="hljs-string">'pages/user.vue'</span>,            children: [                &#123;                    path: <span class="hljs-string">''</span>,                    component: <span class="hljs-string">'pages/user/index.vue'</span>,                    name: <span class="hljs-string">'user'</span>                &#125;,                &#123;                    path: <span class="hljs-string">':id'</span>,                    component: <span class="hljs-string">'pages/user/_id.vue'</span>,                    name: <span class="hljs-string">'user-id'</span>                &#125;            ]        &#125;    ]&#125;</code></pre></div><p>将 <code>user.vue</code> 文件创建到与 <code>user</code> 目录的父目录下，即和 <code>user</code> 目录保持平级 。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        用户管理导航        <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/user/101'"</span>&gt;</span>点击修改ID<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-child</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><span class="actionscript">    layout:<span class="hljs-string">"test"</span></span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p><code>_id.vue</code> 页面实现了向页面传入 <code>id</code> 参数，页面内容如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        修改用户信息&#123;&#123;id&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="actionscript">    layout:<span class="hljs-string">"test"</span>,</span>    data()&#123;<span class="actionscript">        <span class="hljs-keyword">return</span>&#123;</span><span class="actionscript">            id:<span class="hljs-string">""</span></span>        &#125;    &#125;,    mounted()&#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.id = <span class="hljs-keyword">this</span>.$route.params.id;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.id)</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>测试：<a href="http://localhost:10000/user" target="_blank" rel="noopener">http://localhost:10000/user</a></p><p><a href="https://qnoss.codeyee.com/20200704_12/image11" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击修改</p><p><a href="https://qnoss.codeyee.com/20200704_12/image12" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image12.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="5-获取数据"><a href="#5-获取数据" class="headerlink" title="5. 获取数据"></a>5. 获取数据</h2><h3 id="1、asyncData"><a href="#1、asyncData" class="headerlink" title="1、asyncData"></a>1、asyncData</h3><p>Nuxt.js 扩展了 <code>Vue.js</code>，增加了一个叫 <code>asyncData</code> 的方法， <code>asyncData</code> 方法会在组件（<strong>限于页面组件</strong>）每次加载之前被调用。</p><p>它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 <code>asyncData</code> 方法来获取数据，<code>Nuxt.js</code> 会将 <code>asyncData</code> 返回的数据融合组件 <code>data</code> 方法返回的数据一并返回给当前组件，从而实现服务端渲染页面的效果。</p><p>注意：由于 <code>asyncData</code> 方法是在组件 <strong>初始化</strong> 前被调用的，所以在方法内是没有办法通过 <code>this</code> 来引用组件的实例对象。</p><p>例子：在上边例子中的 <code>user/_id.vue</code> 中添加，页面代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    修改用户信息&#123;&#123;id&#125;&#125;,名称：&#123;&#123;name&#125;&#125;,课程名称：&#123;&#123;course&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><span class="actionscript">    layout:<span class="hljs-string">'test'</span>,</span><span class="actionscript">    <span class="hljs-comment">//根据id查询用户信息</span></span>    asyncData()&#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async方法"</span>)</span><span class="actionscript">        <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            name:<span class="hljs-string">'黑马程序员'</span></span>        &#125;    &#125;,    data()&#123;<span class="actionscript">        <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            id:<span class="hljs-string">''</span>,</span><span class="actionscript">            course: <span class="hljs-string">""</span></span>        &#125;    &#125;,   methods:&#123;<span class="actionscript">      getCourse:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript">          <span class="hljs-keyword">this</span>.course = <span class="hljs-string">"spring实战666"</span></span>      &#125;      &#125;,    mounted()&#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.id = <span class="hljs-keyword">this</span>.$route.params.id;</span><span class="actionscript">        <span class="hljs-keyword">this</span>.getCourse();</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>此方法在服务端被执行，观察服务端控制台打印输出 <strong>“async方法”</strong>。</p><p>此方法返回 <code>data</code> 模型数据，在服务端被渲染，最后响应给前端，刷新此页面查看页面源代码可以看到 <code>name</code>模型数据已在页面源代码中显示，而 <code>course</code> 变量是在 <code>mounted</code> 钩子函数中调用了 <code>getCourse</code> 方法对 <code>course</code> 进行赋值，属于客户端使用 <code>JS</code>进行渲染，所以在页面源代码中没有看到 <code>course</code> 变量的值，如下图所示</p><p><a href="https://qnoss.codeyee.com/20200704_12/image13" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image13.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="2、async-await-方法"><a href="#2、async-await-方法" class="headerlink" title="2、async/await 方法"></a>2、async/await 方法</h3><p>使用 <code>async</code> 和 <code>await</code> 配合 <code>promise</code> 也可以实现同步调用，<code>nuxt.js</code> 中使用 <code>async/await</code> 实现同步调用效果。</p><p>1、先测试异步调用，增加a、b两个方法，并在 <code>mounted</code> 中调用</p><div class="hljs"><pre><code class="hljs js">methods:&#123;    a()&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                resolve(<span class="hljs-number">1</span>)            &#125;,<span class="hljs-number">2000</span>)        &#125;)    &#125;,        b()&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;                setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                    resolve(<span class="hljs-number">2</span>)                &#125;,<span class="hljs-number">1000</span>)            &#125;)        &#125;&#125;,    mounted()&#123;        <span class="hljs-keyword">this</span>.a().then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;            alert(res)            <span class="hljs-built_in">console</span>.log(res)        &#125;)        <span class="hljs-keyword">this</span>.b().then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;            alert(res)            <span class="hljs-built_in">console</span>.log(res)        &#125;)    &#125;</code></pre></div><p>从上述代码中，<code>a</code> 方法使用 <code>setTimeout</code> 延迟了2秒执行，<code>b</code> 方法延迟了1秒，如果按同步顺序进行执行，应该还是先输出 <code>a</code> 方法的内容再输出 <code>b</code> 方法。</p><p>观察客户端，并没有按照方法执行的顺序输出，使用 <code>Promise</code> 实现了异步调用，执行结果如下图</p><p><a href="https://qnoss.codeyee.com/20200704_12/image14" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image14.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、使用 <code>async/await</code> 完成同步调用</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> asyncData(&#123; store, route &#125;) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async方法"</span>)    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"1"</span>)            resolve(<span class="hljs-number">1</span>)        &#125;,<span class="hljs-number">2000</span>)    &#125;);    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2"</span>)            resolve(<span class="hljs-number">2</span>)        &#125;,<span class="hljs-number">1000</span>)    &#125;);    <span class="hljs-keyword">return</span> &#123;        name:<span class="hljs-string">'黑马程序员'</span>    &#125;&#125;,</code></pre></div><p>这里我们在 <code>asyncData</code> 方法前面增加了 <code>async</code> 关键字，在调用 <code>Promise</code> 前也增加了 <code>await</code> , 观察服务端控制台发现是按照 <code>a、b</code> 方法的调用顺序输出 1、2，实现了使用 <code>async/await</code> 完成同步调用。</p><p><a href="https://qnoss.codeyee.com/20200704_12/image15" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="四、搜索服务前端开发"><a href="#四、搜索服务前端开发" class="headerlink" title="四、搜索服务前端开发"></a>四、搜索服务前端开发</h1><h2 id="1-搜索页面"><a href="#1-搜索页面" class="headerlink" title="1. 搜索页面"></a>1. 搜索页面</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p><a href="https://qnoss.codeyee.com/20200704_12/image16" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image16.png" srcset="/img/loading.gif" alt="img"></a></p><p>上图是课程搜索前端的界面，用户通过前端向服务端发起搜索请求，搜索功能包括：</p><p>1、界面默认查询所有课程，并分页显示</p><p>2、通过一级分类和二分类搜索课程，选择一级分类后将显示下属的二级分类</p><p>3、通过关键字搜索课程</p><p>4、通过课程等级搜索课程</p><h3 id="2、页面布局"><a href="#2、页面布局" class="headerlink" title="2、页面布局"></a>2、页面布局</h3><p><code>nuxt.js</code> 将 <code>/layout/default.vue</code> 作为所有页面的默认布局，通常布局包括：页头、内容区、页尾</p><p><code>default.vue</code> 内容如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">nuxt</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">import</span> Footer <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/Footer.vue'</span></span><span class="javascript">    <span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/Header.vue'</span></span><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>        components: &#123;            Header,            Footer        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h3 id="3、Nginx代理配置"><a href="#3、Nginx代理配置" class="headerlink" title="3、Nginx代理配置"></a>3、Nginx代理配置</h3><p>搜索页面中以 <code>/static</code> 开头的静态资源通过 <code>nginx</code> 解析，如下：</p><p><code>/static/plugins</code>：指向门户目录下的 <code>plugins</code> 目录。</p><p><code>/static/css</code>：指向门户目录下的的 <code>css</code> 目录</p><p>修改 <code>Nginx</code> 中 <a href="http://www.xuecheng.com/" target="_blank" rel="noopener">www.xuecheng.com</a> 虚拟主机的配置：</p><blockquote><p>在之前的章节当中如果已经配置了静态资源虚拟主机，可以忽略这个步骤</p></blockquote><div class="hljs"><pre><code class="hljs c">#静态资源，包括系统所需要的图片，js、css等静态资源location /<span class="hljs-keyword">static</span>/img/ &#123;    alias F:/develop/xc_portal_static/img/;    #静态资源，包括系统所需要的图片，js、css等静态资源    location /<span class="hljs-keyword">static</span>/img/ &#123;    alias F:/develop/xc_portal_static/img/;&#125; location /<span class="hljs-keyword">static</span>/css/ &#123;    alias F:/develop/xc_portal_static/css/;&#125; location /<span class="hljs-keyword">static</span>/js/ &#123;    alias F:/develop/xc_portal_static/js/;&#125; location /<span class="hljs-keyword">static</span>/plugins/ &#123;    alias F:/develop/xc_portal_static/plugins/;    add_header Access-Control-Allow-Origin http:<span class="hljs-comment">//ucenter.xuecheng.com;</span>    add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;    add_header Access-Control-Allow-Methods GET;&#125;</code></pre></div><p>配置搜索 <code>Url</code>，下图是 <code>Nginx</code> 搜索转发流程图：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image17" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_12/image17" srcset="/img/loading.gif" alt="img"></a></p><p>用户请求 <code>/course/search</code>时 <code>Nginx</code> 将请求转发到 <code>nuxt.js</code> 服务，<code>nginx</code> 在转发时根据每台 <code>nuxt</code> 服务的负载情况进行转发，实现负载均衡。</p><p>本教程开发环境 <code>Nuxt.js</code> 服务和 <a href="http://www.xuecheng.com/" target="_blank" rel="noopener">www.xuecheng.com</a> 虚拟机主在同一台计算机，使用同一个 <code>nginx</code>，配置如下：</p><div class="hljs"><pre><code class="hljs json">#前端门户课程搜索location ^~ /course/search &#123;    proxy_pass http://dynamic_portal_server_pool;&#125; #后端搜索服务location /openapi/search/ &#123;    proxy_pass http://search_server_pool/search/;&#125;</code></pre></div><p><code>dynamic_portal_server_pool</code> 配置如下 ：</p><div class="hljs"><pre><code class="hljs json">#前端动态门户upstream dynamic_portal_server_pool&#123;    server 127.0.0.1:10000 weight=10;&#125;#后台搜索服务（公开api）upstream search_server_pool&#123;    server 127.0.0.1:40100 weight=10;&#125;</code></pre></div><p>其它配置：</p><blockquote><p>nuxt.js 会自动请求这些一些内置的api，如果不配置的话前端会报错，所以还是给它整上，暂时不需要去追究这些接口是何作用</p></blockquote><div class="hljs"><pre><code class="hljs json">#开发环境webpack定时加载此文件location ^~ /__webpack_hmr &#123;proxy_pass http://dynamic_portal_server_pool/__webpack_hmr;&#125;#开发环境 nuxt 访问 _nuxtlocation ^~ /_nuxt/ &#123;proxy_pass http://dynamic_portal_server_pool/_nuxt/;&#125;</code></pre></div><p>在静态虚拟主机中添加：</p><div class="hljs"><pre><code class="hljs json">#分类信息location /static/category/ &#123;    alias E:/Project/XueChengOnline/xcEduUI01/xuecheng/static/category/;&#125;</code></pre></div><h3 id="4、搜索页面"><a href="#4、搜索页面" class="headerlink" title="4、搜索页面"></a>4、搜索页面</h3><p>创建搜索页面如下：</p><p><a href="https://qnoss.codeyee.com/20200704_12/image18" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p>页面文件参考：<code>资料/search/index_1.vue</code>，重要代码如下：<br><code>nuxt.js</code> 支持定义 <code>header</code>，本页面我们在 <code>header</code> 中引入 <code>css</code> 样式并定义头部信息。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//配置文件</span><span class="hljs-keyword">let</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'~/config/sysConfig'</span>)<span class="hljs-keyword">import</span> querystring <span class="hljs-keyword">from</span> <span class="hljs-string">'querystring'</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'~/api/course'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    head() &#123;        <span class="hljs-keyword">return</span> &#123;            title: <span class="hljs-string">'传智播客-一样的教育,不一样的品质'</span>,            meta: [                &#123;<span class="hljs-attr">charset</span>: <span class="hljs-string">'utf-8'</span>&#125;,                &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'description'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'传智播客专注IT培训,Java培训,Android培训,安卓培训,PHP培训,C++培训,网页设计培训,平面设计培训,UI设计培训,移动开发培训,网络营销培训,web前端培训,云计算大数据培训,全栈工程师培训,产品经理培训。'</span>&#125;,                &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'keywords'</span>, <span class="hljs-attr">content</span>: <span class="hljs-keyword">this</span>.keywords&#125;            ],            link: [                &#123;<span class="hljs-attr">rel</span>: <span class="hljs-string">'stylesheet'</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">'/static/plugins/normalize-css/normalize.css'</span>&#125;,                &#123;<span class="hljs-attr">rel</span>: <span class="hljs-string">'stylesheet'</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">'/static/plugins/bootstrap/dist/css/bootstrap.css'</span>&#125;,                &#123;<span class="hljs-attr">rel</span>: <span class="hljs-string">'stylesheet'</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">'/static/css/page-learing-list.css'</span>&#125;            ]        &#125;    &#125;,</code></pre></div><p>其它数据模型及方法：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-comment">//配置文件</span></span><span class="javascript">    <span class="hljs-keyword">let</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'~/config/sysConfig'</span>)</span><span class="javascript">    <span class="hljs-keyword">import</span> querystring <span class="hljs-keyword">from</span> <span class="hljs-string">'querystring'</span></span><span class="javascript">    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'~/api/course'</span></span><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>        head() &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">                title: <span class="hljs-string">'传智播客-一样的教育,不一样的品质'</span>,</span>                meta: [<span class="actionscript">                    &#123;charset: <span class="hljs-string">'utf-8'</span>&#125;,</span><span class="actionscript">                    &#123;name: <span class="hljs-string">'description'</span>, content: <span class="hljs-string">'传智播客专注IT培训,Java培训,Android培训,安卓培训,PHP培</span></span>                     训,C++培训,网页设计培训,平面设计培训,UI设计培训,移动开发培训,网络营销培训,web前端培训,云计算大数据培训,                     全栈工程师培训,产品经理培训。'&#125;,<span class="actionscript">                     &#123;name: <span class="hljs-string">'keywords'</span>, content: <span class="hljs-keyword">this</span>.keywords&#125;</span>                ],                link: [<span class="actionscript">                    &#123;rel: <span class="hljs-string">'stylesheet'</span>, href: <span class="hljs-string">'/static/plugins/normalize-css/normalize.css'</span>&#125;,</span><span class="actionscript">                    &#123;rel: <span class="hljs-string">'stylesheet'</span>, href: <span class="hljs-string">'/static/plugins/bootstrap/dist/css/bootstrap.css'</span>&#125;,</span><span class="actionscript">                    &#123;rel: <span class="hljs-string">'stylesheet'</span>, href: <span class="hljs-string">'/static/css/page-learing-list.css'</span>&#125;</span>                ]            &#125;        &#125;,<span class="javascript">        <span class="hljs-keyword">async</span> asyncData(&#123; store, route &#125;) &#123;</span><span class="actionscript">            <span class="hljs-keyword">return</span> &#123;</span>                courselist: &#123;&#125;,                first_category:&#123;&#125;,                second_category:&#123;&#125;,<span class="actionscript">                mt:<span class="hljs-string">''</span>,</span><span class="actionscript">                st:<span class="hljs-string">''</span>,</span><span class="actionscript">                grade:<span class="hljs-string">''</span>,</span><span class="actionscript">                keyword:<span class="hljs-string">''</span>,</span>                total:0,                imgUrl:config.imgUrl            &#125;        &#125;,        data() &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> &#123;</span>                courselist: &#123;&#125;,                first_category:&#123;&#125;,                second_category:&#123;&#125;,<span class="actionscript">                mt:<span class="hljs-string">''</span>,</span><span class="actionscript">                st:<span class="hljs-string">''</span>,</span><span class="actionscript">                grade:<span class="hljs-string">''</span>,</span><span class="actionscript">                keyword:<span class="hljs-string">''</span>,</span>                imgUrl:config.imgUrl,<span class="actionscript">                total:<span class="hljs-number">0</span>,<span class="hljs-comment">//总记录数</span></span><span class="actionscript">                page:<span class="hljs-number">1</span>,<span class="hljs-comment">//页码</span></span><span class="actionscript">                page_size:<span class="hljs-number">12</span><span class="hljs-comment">//每页显示个数</span></span>            &#125;        &#125;,<span class="actionscript">        watch:&#123;<span class="hljs-comment">//路由发生变化立即搜索search表示search方法</span></span><span class="actionscript">            <span class="hljs-string">'$route'</span>:<span class="hljs-string">'search'</span></span>        &#125;,        methods: &#123;<span class="actionscript">            <span class="hljs-comment">//分页触发</span></span>            handleCurrentChange(page) &#123;            &#125;,<span class="actionscript">            <span class="hljs-comment">//搜索方法</span></span>            search()&#123;<span class="actionscript">                <span class="hljs-comment">//刷新当前页面</span></span><span class="javascript">                <span class="hljs-built_in">window</span>.location.reload();</span>            &#125;        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p>重启Nginx，请求：<a href="http://www.xuecheng.com/course/search%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A" target="_blank" rel="noopener">http://www.xuecheng.com/course/search，页面效果如下：</a></p><p><a href="https://qnoss.codeyee.com/20200704_12/image19" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image19.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-查看全部"><a href="#2-查看全部" class="headerlink" title="2. 查看全部"></a>2. 查看全部</h2><h3 id="1、需求分析-1"><a href="#1、需求分析-1" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>初次进入页面，没有输入任何查询条件，默认查询全部课程，分页显示</p><h3 id="2、api方法"><a href="#2、api方法" class="headerlink" title="2、api方法"></a>2、api方法</h3><p>在api目录创建本工程所用的api方法类，api方法类使用了public.js等一些抽取类：</p><p>/api/public.js————-抽取axios 的基础方法</p><p>/api/util.js—————–工具类</p><p>/config/sysConfig.js—-系统配置类，配置了系统参数变量</p><p>创建 <code>course.js</code>，作为课程相关业务模块的 <code>api</code> 方法类。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./public'</span><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span><span class="hljs-keyword">let</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'~/config/sysConfig'</span>)<span class="hljs-keyword">let</span> apiURL = config.apiURL<span class="hljs-keyword">let</span> staticURL = config.staticURL<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">'undefined'</span>) &#123;    apiURL = config.backApiURL    staticURL = config.backStaticURL&#125; <span class="hljs-comment">/*搜索*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> search_course = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> querys = qs.stringify(params);    <span class="hljs-keyword">return</span> http.requestQuickGet(apiURL+<span class="hljs-string">"/search/course/list/"</span>+page+<span class="hljs-string">"/"</span>+size+<span class="hljs-string">"?"</span>+querys);&#125;</code></pre></div><h3 id="3、搜索方法"><a href="#3、搜索方法" class="headerlink" title="3、搜索方法"></a>3、搜索方法</h3><p>实现思路如下：</p><p>1、用户请求本页面到达 <code>node.js</code></p><p>2、在 <code>asyncData</code> 方法中向服务端请求查询课程</p><p>3、<code>asyncData</code> 方法执行完成开始服务端渲染在 <code>asyncData</code> 中执行搜索，代码如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> asyncData(&#123; store, route &#125;) &#123;<span class="hljs-comment">//服务端调用方法</span>    <span class="hljs-comment">//搜索课程</span>    <span class="hljs-keyword">let</span> page = route.query.page;    <span class="hljs-keyword">if</span>(!page)&#123;        page = <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        page = <span class="hljs-built_in">Number</span>.parseInt(page)    &#125;     <span class="hljs-built_in">console</span>.log(page);    <span class="hljs-comment">//请求搜索服务，搜索服务</span>    <span class="hljs-keyword">let</span> course_data = <span class="hljs-keyword">await</span> courseApi.search_course(page,<span class="hljs-number">2</span>,route.query);    <span class="hljs-built_in">console</span>.log(course_data)    <span class="hljs-comment">//拿到数据</span>    <span class="hljs-keyword">if</span> (course_data &amp;&amp; course_data.queryResult ) &#123;        <span class="hljs-keyword">let</span> keywords = <span class="hljs-string">''</span>        <span class="hljs-keyword">let</span> mt=<span class="hljs-string">''</span>        <span class="hljs-keyword">let</span> st=<span class="hljs-string">''</span>        <span class="hljs-keyword">let</span> grade=<span class="hljs-string">''</span>        <span class="hljs-keyword">let</span> keyword=<span class="hljs-string">''</span>        <span class="hljs-keyword">let</span> total = course_data.queryResult.total        <span class="hljs-keyword">if</span>( route.query.mt)&#123;            mt = route.query.mt        &#125;         <span class="hljs-keyword">if</span>( route.query.st)&#123;            st = route.query.st        &#125;         <span class="hljs-keyword">if</span>( route.query.grade)&#123;            grade = route.query.grade        &#125;         <span class="hljs-keyword">if</span>( route.query.keyword)&#123;            keyword = route.query.keyword        &#125;         <span class="hljs-keyword">return</span> &#123;            courselist: course_data.queryResult.list,<span class="hljs-comment">//课程列表</span>            keywords:keywords,            mt:mt,            st:st,            grade:grade,            keyword:keyword,            page:page,            total:total,            imgUrl:config.imgUrl        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//未拿到数据，返回空值对象到前端</span>        <span class="hljs-keyword">return</span> &#123;            courselist: &#123;&#125;,            first_category:&#123;&#125;,            second_category:&#123;&#125;,            mt:<span class="hljs-string">''</span>,            st:<span class="hljs-string">''</span>,            grade:<span class="hljs-string">''</span>,            keyword:<span class="hljs-string">''</span>,            page:page,            total:<span class="hljs-number">0</span>,            imgUrl:config.imgUrl        &#125;    &#125;&#125;</code></pre></div><h3 id="4、页面"><a href="#4、页面" class="headerlink" title="4、页面"></a>4、页面</h3><p>在页面中展示课程列表。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 渲染课程信息 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"recom-item"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(course, index) in courselist"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/detail/'+course.id+'.html'"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"course.pic"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"imgUrl+'/'+course.pic"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">alt</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/img/widget-demo1.png"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">alt</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"course_title"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"course.name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"float: left"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"course.charge == '203001'"</span>&gt;</span>免费<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"course.charge == '203002'"</span>&gt;</span>￥&#123;&#123;course.price | money&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-comment">&lt;!-- &lt;em&gt; · &lt;/em&gt;--&gt;</span>                <span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>                <span class="hljs-comment">&lt;!--&lt;em&gt;1125人在学习&lt;/em&gt;--&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>添加在 <code>index.vue</code> 页面的 <code>content-list</code> 节点下，具体代码参考 <code>资料/index_2.vue</code> 文件</p><p>访问搜索页面，<code>nuxt.js</code> 会在页面渲染之前请求查询接口拿到数据，并在 node.js 上完成页面的渲染</p><p><a href="https://qnoss.codeyee.com/20200704_12/image20" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image20.png" srcset="/img/loading.gif" alt="img"></a></p><p>效果预览</p><p><a href="https://qnoss.codeyee.com/20200704_12/image21" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-分页查询"><a href="#3-分页查询" class="headerlink" title="3. 分页查询"></a>3. 分页查询</h2><h3 id="1、服务端代码"><a href="#1、服务端代码" class="headerlink" title="1、服务端代码"></a>1、服务端代码</h3><p>服务端实现代码已在 <code>day11</code> 的内容中完成，搜索服务核心代码如下</p><div class="hljs"><pre><code class="hljs java">...<span class="hljs-comment">//分页</span><span class="hljs-comment">//当前页码</span><span class="hljs-keyword">if</span>(page&lt;=<span class="hljs-number">0</span>)&#123;page = <span class="hljs-number">1</span>;&#125; //起始记录下标<span class="hljs-keyword">int</span> from = (page -<span class="hljs-number">1</span>) * size;searchSourceBuilder.from(from);searchSourceBuilder.size(size);...</code></pre></div><h3 id="2、前端代码"><a href="#2、前端代码" class="headerlink" title="2、前端代码"></a>2、前端代码</h3><p>使用 <code>Element ui</code> 的 <code>el-pagination</code> 分页插件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span></span><span class="hljs-tag">                   <span class="hljs-attr">background</span></span><span class="hljs-tag">                   <span class="hljs-attr">layout</span>=<span class="hljs-string">"prev, pager, next"</span></span><span class="hljs-tag">                   @<span class="hljs-attr">current-change</span>=<span class="hljs-string">"handleCurrentChange"</span></span><span class="hljs-tag">                   <span class="hljs-attr">:total</span>=<span class="hljs-string">"total"</span></span><span class="hljs-tag">                   <span class="hljs-attr">:page-size</span>=<span class="hljs-string">"page_size"</span></span><span class="hljs-tag">                   <span class="hljs-attr">:current-page</span>=<span class="hljs-string">"page"</span></span><span class="hljs-tag">                   <span class="hljs-attr">prev-text</span>=<span class="hljs-string">"上一页"</span></span><span class="hljs-tag">                   <span class="hljs-attr">next-text</span>=<span class="hljs-string">"下一页"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>定义分页触发方法：</p><div class="hljs"><pre><code class="hljs js">methods:&#123;    <span class="hljs-comment">//分页触发</span>    handleCurrentChange(page) &#123;        <span class="hljs-keyword">this</span>.page = page        <span class="hljs-keyword">this</span>.$route.query.page = page        <span class="hljs-keyword">let</span> querys = querystring.stringify(<span class="hljs-keyword">this</span>.$route.query)        <span class="hljs-built_in">window</span>.location = <span class="hljs-string">'/course/search?'</span>+querys;    &#125; .        ..</code></pre></div><h2 id="4-按分类搜索"><a href="#4-按分类搜索" class="headerlink" title="4. 按分类搜索"></a>4. 按分类搜索</h2><h3 id="1、需求分析-2"><a href="#1、需求分析-2" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>1）通过一级分类搜索</p><p>2）选择一级分类后将显示下属的二级分类</p><p>3）选择二分类进行搜索</p><p>4）选择一级分类的全部则表示没有按照分类搜索</p><p>5）选择一级分类的全部时二级分类不显示</p><h3 id="2、api-方法"><a href="#2、api-方法" class="headerlink" title="2、api 方法"></a>2、api 方法</h3><p>课程分类将通过页面静态化的方式写入静态资源下，通过 <code>/category/category.json</code> 可访问，</p><p>通过 <a href="http://www.xuecheng.com/static/category/category.json" target="_blank" rel="noopener">www.xuecheng.com/static/category/category.json</a> 即可访问。</p><p><code>category.json</code> 的内容如下</p><p><a href="https://qnoss.codeyee.com/20200704_12/image22" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们需要定义 <code>api</code> 方法获取所有的分类</p><p>在 <code>/api/course.js</code> 中添加：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*获取分类*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sysres_category = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> http.requestQuickGet(staticURL+<span class="hljs-string">"/static/category/category.json"</span>);&#125;</code></pre></div><h3 id="3、在-asncData-中查询分类"><a href="#3、在-asncData-中查询分类" class="headerlink" title="3、在 asncData 中查询分类"></a>3、在 asncData 中查询分类</h3><p>进入搜索页面将默认显示所有一级分类，当前如果已选择一级分类则要显示所有一级分类及该一级分类下属的二级<br>分类。在 <code>asyncData</code> 方法中实现上边的需求，代码如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> asyncData(&#123; store, route &#125;) &#123;    <span class="hljs-comment">//服务端调用方法</span>    <span class="hljs-comment">//搜索课程</span>    <span class="hljs-keyword">let</span> page = route.query.page;    <span class="hljs-keyword">if</span> (!page) &#123;        page = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        page = <span class="hljs-built_in">Number</span>.parseInt(page);    &#125;    <span class="hljs-built_in">console</span>.log(page);    <span class="hljs-comment">//请求搜索服务，搜索服务</span>    <span class="hljs-keyword">let</span> course_data = <span class="hljs-keyword">await</span> courseApi.search_course(page, <span class="hljs-number">2</span>, route.query);    <span class="hljs-built_in">console</span>.log(course_data);    <span class="hljs-keyword">let</span> category_data = <span class="hljs-keyword">await</span> courseApi.sysres_category();    <span class="hljs-built_in">console</span>.log(category_data)    <span class="hljs-keyword">if</span> (course_data &amp;&amp; course_data.queryResult) &#123;        <span class="hljs-keyword">let</span> keywords = <span class="hljs-string">""</span>;        <span class="hljs-keyword">let</span> mt = <span class="hljs-string">""</span>;        <span class="hljs-keyword">let</span> st = <span class="hljs-string">""</span>;        <span class="hljs-keyword">let</span> grade = <span class="hljs-string">""</span>;        <span class="hljs-keyword">let</span> keyword = <span class="hljs-string">""</span>;        <span class="hljs-keyword">let</span> total = course_data.queryResult.total;        <span class="hljs-keyword">if</span> (route.query.mt) &#123;            mt = route.query.mt;        &#125;        <span class="hljs-keyword">if</span> (route.query.st) &#123;            st = route.query.st;        &#125;        <span class="hljs-keyword">if</span> (route.query.grade) &#123;            grade = route.query.grade;        &#125;        <span class="hljs-keyword">if</span> (route.query.keyword) &#123;            keyword = route.query.keyword;        &#125;        <span class="hljs-comment">//全部分类</span>        <span class="hljs-keyword">let</span> category = category_data.category; <span class="hljs-comment">//分部分类</span>        <span class="hljs-keyword">let</span> first_category = category[<span class="hljs-number">0</span>].children; <span class="hljs-comment">//一级分类</span>        <span class="hljs-keyword">let</span> second_category = []; <span class="hljs-comment">//二级分类</span>        <span class="hljs-comment">//遍历一级分类</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> first_category) &#123;            keywords += first_category[i].name + <span class="hljs-string">" "</span>;            <span class="hljs-keyword">if</span> (mt != <span class="hljs-string">""</span> &amp;&amp; mt == first_category[i].id) &#123;                <span class="hljs-comment">//取出二级分类</span>                second_category = first_category[i].children;                <span class="hljs-comment">// console.log(second_category)</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> &#123;            courselist: course_data.queryResult.list, <span class="hljs-comment">//课程列表</span>            keywords: keywords,            first_category: first_category,            second_category: second_category,            mt: mt,            st: st,            grade: grade,            keyword: keyword,            page: page,            total: total,            imgUrl: config.imgUrl        &#125;;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> &#123;            courselist: &#123;&#125;,            first_category: &#123;&#125;,            second_category: &#123;&#125;,            mt: <span class="hljs-string">""</span>,            st: <span class="hljs-string">""</span>,            grade: <span class="hljs-string">""</span>,            keyword: <span class="hljs-string">""</span>,            page: page,            total: <span class="hljs-number">0</span>,            imgUrl: config.imgUrl        &#125;;    &#125;&#125;,</code></pre></div><h3 id="4、页面-1"><a href="#4、页面-1" class="headerlink" title="4、页面"></a>4、页面</h3><p>在页面显示一级分类及二级分类，需要根据当前是否选择一级分类、是否选择二分类显示页面内容。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>一级分类：<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"mt!=''"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?</span></span><span class="hljs-tag"><span class="hljs-string">        keyword='+keyword+'&amp;grade='+grade"</span>&gt;</span>全部<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"all"</span> <span class="hljs-attr">v-else</span>&gt;</span>全部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"category_v in first_category"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link all"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt=' +</span></span><span class="hljs-tag"><span class="hljs-string">                                                   category_v.id"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"category_v.id == mt"</span>&gt;</span>&#123;&#123;category_v.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt=' +</span></span><span class="hljs-tag"><span class="hljs-string">                                               category_v.id"</span> <span class="hljs-attr">v-else</span>&gt;</span>&#123;&#123;category_v.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-comment">&lt;!--&lt;ol&gt;</span><span class="hljs-comment">    &lt;li&gt;数据分析&lt;/li&gt;</span><span class="hljs-comment">    &lt;li&gt;机器学习工程&lt;/li&gt;</span><span class="hljs-comment">    &lt;li&gt;前端开发工程&lt;/li&gt;</span><span class="hljs-comment">    &lt;/ol&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>二级分类：<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"st!=''"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?</span></span><span class="hljs-tag"><span class="hljs-string">        keyword='+keyword+'&amp;mt='+mt+'&amp;grade='+grade"</span>&gt;</span>全部<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"all"</span> <span class="hljs-attr">v-else</span>&gt;</span>全部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"second_category.length&gt;0"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"category_v in second_category"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link all"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt='+mt+'&amp;st='</span></span><span class="hljs-tag"><span class="hljs-string">                                                   + category_v.id"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"category_v.id == st"</span>&gt;</span>&#123;&#123;category_v.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt='+mt+'&amp;st=' +</span></span><span class="hljs-tag"><span class="hljs-string">                                               category_v.id"</span> <span class="hljs-attr">v-else</span>&gt;</span>&#123;&#123;category_v.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;li&gt;大数据&lt;/li&gt;</span><span class="hljs-comment">        &lt;li&gt;云计算&lt;/li&gt;--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-comment">&lt;!--&lt;a href="#" class="more"&gt;更多 ∨&lt;/a&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><h3 id="5、立即搜索"><a href="#5、立即搜索" class="headerlink" title="5、立即搜索"></a>5、立即搜索</h3><p>当用户点击分类时立即执行搜索，实现思路如下：</p><ul><li>点击分类立即更改路由。</li><li>通过监听路由，路由更改则刷新页面。</li></ul><p>1）创建搜索方法</p><div class="hljs"><pre><code class="hljs js">search()&#123;<span class="hljs-comment">//刷新当前页面</span><span class="hljs-built_in">window</span>.location.reload();&#125;</code></pre></div><p>2）定义watch</p><p>通过 <code>vue.js</code> 的 <code>watch</code> 可以实现监视某个变量，当变量值出现变化时执行某个方法。</p><p>实现思路是：</p><p>1、点击分类页面路由更改</p><p>2、通过 <code>watch</code> 监视路由，路由更改触发 <code>search</code> 方法与 <code>methods</code> 并行定义 <code>watch</code>：</p><div class="hljs"><pre><code class="hljs js">watch: &#123;    <span class="hljs-comment">//路由发生变化立即搜索search表示search方法</span>    $route: <span class="hljs-string">"search"</span>&#125;,</code></pre></div><h2 id="5-按难度等级搜索"><a href="#5-按难度等级搜索" class="headerlink" title="5. 按难度等级搜索"></a>5. 按难度等级搜索</h2><h3 id="1、需求分析-3"><a href="#1、需求分析-3" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>用户选择不同的课程难度等级去搜索课程。</p><p><a href="https://qnoss.codeyee.com/20200704_12/image23" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_12/image23" srcset="/img/loading.gif" alt="img"></a></p><h3 id="2、api方法-1"><a href="#2、api方法-1" class="headerlink" title="2、api方法"></a>2、api方法</h3><p>使用 <code>search_course</code> 方法完成搜索。</p><h3 id="3、页面"><a href="#3、页面" class="headerlink" title="3、页面"></a>3、页面</h3><p>按难度等级搜索思路如下：</p><p>1）点击难度等级立即更改路由。</p><p>2）通过监听路由，路由更改则立即执行 <code>search</code> 搜索方法</p><p>按难度等级搜索页面代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>难度等级：<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"grade!=''"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt=' +</span></span><span class="hljs-tag"><span class="hljs-string">                                           mt+'&amp;st='+st+'&amp;grade='"</span>&gt;</span>全部            <span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"all"</span> <span class="hljs-attr">v-else</span>&gt;</span>全部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"grade=='200001'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"all"</span>&gt;</span>初级<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt=' +</span></span><span class="hljs-tag"><span class="hljs-string">            mt+'&amp;st='+st+'&amp;grade=200001'"</span>&gt;</span>初级<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"grade=='200002'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"all"</span>&gt;</span>中级<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt=' +</span></span><span class="hljs-tag"><span class="hljs-string">            mt+'&amp;st='+st+'&amp;grade=200002'"</span>&gt;</span>中级<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"grade=='200003'"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"all"</span>&gt;</span>高级<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nuxt-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-link"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"'/course/search?keyword='+keyword+'&amp;mt=' +</span></span><span class="hljs-tag"><span class="hljs-string">            mt+'&amp;st='+st+'&amp;grade=200003'"</span>&gt;</span>高级<span class="hljs-tag">&lt;/<span class="hljs-name">nuxt-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><h2 id="6-高亮显示"><a href="#6-高亮显示" class="headerlink" title="6. 高亮显示"></a>6. 高亮显示</h2><h3 id="1、服务端代码-1"><a href="#1、服务端代码-1" class="headerlink" title="1、服务端代码"></a>1、服务端代码</h3><p>高亮的核心代码</p><div class="hljs"><pre><code class="hljs java">...   <span class="hljs-comment">//定义高亮</span>   HighlightBuilder highlightBuilder = <span class="hljs-keyword">new</span> HighlightBuilder();   highlightBuilder.preTags(<span class="hljs-string">"&lt;font class='eslight'&gt;"</span>);   highlightBuilder.postTags(<span class="hljs-string">"&lt;/font&gt;"</span>);   highlightBuilder.fields().add(<span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">"name"</span>));   searchSourceBuilder.highlighter(highlightBuilder);...   <span class="hljs-comment">//添加数据</span>   <span class="hljs-keyword">for</span>(SearchHit hit:searchHits)&#123;       CoursePub coursePub = <span class="hljs-keyword">new</span> CoursePub();       <span class="hljs-comment">//源文档</span>       Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();       <span class="hljs-comment">//课程id</span>       String id = (String) sourceAsMap.get(<span class="hljs-string">"id"</span>);       coursePub.setId(id);       <span class="hljs-comment">//取出name</span>       String name = (String) sourceAsMap.get(<span class="hljs-string">"name"</span>);       <span class="hljs-comment">//取出高亮字段</span>       Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();       <span class="hljs-keyword">if</span>(highlightFields.get(<span class="hljs-string">"name"</span>)!=<span class="hljs-keyword">null</span>)&#123;           HighlightField highlightField = highlightFields.get(<span class="hljs-string">"name"</span>);           Text[] fragments = highlightField.fragments();           StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();           <span class="hljs-keyword">for</span>(Text text:fragments)&#123;               stringBuffer.append(text);           &#125;            name = stringBuffer.toString();       &#125;        coursePub.setName(name);       ....   &#125;</code></pre></div><p>核心的代码主要是设置 <code>HighlightBuilder</code> 对象的高亮属性，然后在遍历添加数据的循环中，在map中取出<code>name</code> 属性后，再取出高亮字段，并且设置到 <code>name</code> 属性中。</p><p>以下是搜索服务的全部代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.search.service;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CoursePub;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.search.CourseSearchParam;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResult;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.elasticsearch.action.search.SearchRequest;<span class="hljs-keyword">import</span> org.elasticsearch.action.search.SearchResponse;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;<span class="hljs-keyword">import</span> org.elasticsearch.common.text.Text;<span class="hljs-keyword">import</span> org.elasticsearch.index.query.BoolQueryBuilder;<span class="hljs-keyword">import</span> org.elasticsearch.index.query.MultiMatchQueryBuilder;<span class="hljs-keyword">import</span> org.elasticsearch.index.query.QueryBuilders;<span class="hljs-keyword">import</span> org.elasticsearch.search.SearchHit;<span class="hljs-keyword">import</span> org.elasticsearch.search.SearchHits;<span class="hljs-keyword">import</span> org.elasticsearch.search.builder.SearchSourceBuilder;<span class="hljs-keyword">import</span> org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;<span class="hljs-keyword">import</span> org.elasticsearch.search.fetch.subphase.highlight.HighlightField;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> javax.naming.directory.SearchResult;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsCourseService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(EsCourseService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.elasticsearch.course.index&#125;"</span>)    <span class="hljs-keyword">private</span> String es_index;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.elasticsearch.course.type&#125;"</span>)    <span class="hljs-keyword">private</span> String es_type;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.elasticsearch.course.source_field&#125;"</span>)    <span class="hljs-keyword">private</span> String source_field;    <span class="hljs-meta">@Autowired</span>    RestHighLevelClient restHighLevelClient;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 课程列表搜索</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 每页数量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseSearchParam 搜索参数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;CoursePub&gt; <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, CourseSearchParam courseSearchParam)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        <span class="hljs-comment">//设置索引</span>        SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(es_index);        <span class="hljs-comment">//设置类型</span>        searchRequest.types(es_type);        <span class="hljs-comment">//创建搜索源对象</span>        SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();        <span class="hljs-comment">//创建布尔查询对象</span>        BoolQueryBuilder boolQueryBuilder = <span class="hljs-keyword">new</span> BoolQueryBuilder();        <span class="hljs-comment">//源字段过滤</span>        String[] fieldArr = source_field.split(<span class="hljs-string">","</span>);        searchSourceBuilder.fetchSource(fieldArr,<span class="hljs-keyword">new</span> String[]&#123;&#125;);        <span class="hljs-comment">//根据关键字进行查询</span>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getKeyword()))&#123;            <span class="hljs-comment">//匹配关键词</span>            MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), <span class="hljs-string">"name"</span>, <span class="hljs-string">"teachplan"</span>, <span class="hljs-string">"description"</span>);            <span class="hljs-comment">//设置匹配占比</span>            multiMatchQueryBuilder.minimumShouldMatch(<span class="hljs-string">"70%"</span>);            <span class="hljs-comment">//提升字段的权重值</span>            multiMatchQueryBuilder.field(<span class="hljs-string">"name"</span>,<span class="hljs-number">10</span>);            boolQueryBuilder.must(multiMatchQueryBuilder);        &#125;        <span class="hljs-comment">//根据难度进行过滤</span>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123;            boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"mt"</span>,courseSearchParam.getMt()));        &#125;        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123;            boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"st"</span>,courseSearchParam.getSt()));        &#125;        <span class="hljs-comment">//根据等级进行过滤</span>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123;            boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"grade"</span>,courseSearchParam.getGrade()));        &#125;        <span class="hljs-comment">//设置分页参数</span>        <span class="hljs-keyword">if</span>(page&lt;=<span class="hljs-number">0</span>)&#123;            page = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">0</span>)&#123;            size = <span class="hljs-number">20</span>;        &#125;        <span class="hljs-comment">//计算搜索起始位置</span>        <span class="hljs-keyword">int</span> start = (page-<span class="hljs-number">1</span>) * size;        searchSourceBuilder.from(start);        searchSourceBuilder.size(size);        <span class="hljs-comment">//将布尔查询对象添加到搜索源内</span>        searchSourceBuilder.query(boolQueryBuilder);        <span class="hljs-comment">//配置高亮信息</span>        HighlightBuilder highlightBuilder = <span class="hljs-keyword">new</span> HighlightBuilder();        highlightBuilder.preTags(<span class="hljs-string">"&lt;font class='eslight'&gt;"</span>);        highlightBuilder.postTags(<span class="hljs-string">"&lt;/font&gt;"</span>);        <span class="hljs-comment">//设置高亮字段</span>        highlightBuilder.fields().add(<span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">"name"</span>));        searchSourceBuilder.highlighter(highlightBuilder);        <span class="hljs-comment">//请求搜索</span>        searchRequest.source(searchSourceBuilder);        SearchResponse searchResponse = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span>&#123;            searchResponse = restHighLevelClient.search(searchRequest);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            <span class="hljs-comment">//搜索异常</span>            e.printStackTrace();            LOGGER.error(<span class="hljs-string">"search error ...&#123;&#125;"</span>,e.getMessage());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult&lt;&gt;(CommonCode.FAIL,<span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-comment">//结果收集处理</span>        SearchHits hits = searchResponse.getHits();        <span class="hljs-comment">//获取匹配度高的结果</span>        SearchHit[] searchHits = hits.getHits();        <span class="hljs-comment">//总记录数</span>        <span class="hljs-keyword">long</span> totalHits = hits.getTotalHits();        <span class="hljs-comment">//数据列表</span>        ArrayList&lt;CoursePub&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">//添加数据</span>        <span class="hljs-keyword">for</span> (SearchHit hit: searchHits)&#123;            CoursePub coursePub = <span class="hljs-keyword">new</span> CoursePub();            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();            <span class="hljs-comment">//取出id</span>            String id = (String) sourceAsMap.get(<span class="hljs-string">"id"</span>);            coursePub.setId(id);            <span class="hljs-comment">//取出名称</span>            String name = (String) sourceAsMap.get(<span class="hljs-string">"name"</span>);            <span class="hljs-comment">//取出高亮字段</span>            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();            <span class="hljs-keyword">if</span>(highlightFields.get(<span class="hljs-string">"name"</span>)!=<span class="hljs-keyword">null</span>)&#123;                HighlightField highlightField = highlightFields.get(<span class="hljs-string">"name"</span>);                Text[] fragments = highlightField.fragments();                StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();                <span class="hljs-keyword">for</span>(Text text:fragments)&#123;                    stringBuffer.append(text);                &#125;                name = stringBuffer.toString();            &#125;            coursePub.setName(name);            <span class="hljs-comment">//图片</span>            String pic = (String) sourceAsMap.get(<span class="hljs-string">"pic"</span>);            coursePub.setPic(pic);            <span class="hljs-comment">//优惠后的价格</span>            Float price = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span>(sourceAsMap.get(<span class="hljs-string">"price"</span>) !=<span class="hljs-keyword">null</span>)&#123;                    price = Float.parseFloat(String.format(<span class="hljs-string">"%.3f"</span>,sourceAsMap.get(<span class="hljs-string">"price"</span>)));                &#125;            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                e.printStackTrace();            &#125;            coursePub.setPrice(price);            <span class="hljs-comment">//优惠前的价格</span>            Float priceOld = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span>(sourceAsMap.get(<span class="hljs-string">"price_old"</span>) !=<span class="hljs-keyword">null</span>)&#123;                    priceOld = Float.parseFloat(String.format(<span class="hljs-string">"%.3f"</span>,sourceAsMap.get(<span class="hljs-string">"price_old"</span>)));                &#125;            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                e.printStackTrace();            &#125;            coursePub.setPrice_old(priceOld);            list.add(coursePub);        &#125;        <span class="hljs-comment">//返回响应结果</span>        QueryResult&lt;CoursePub&gt; queryResult = <span class="hljs-keyword">new</span> QueryResult&lt;&gt;();        queryResult.setList(list);        queryResult.setTotal(totalHits);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult&lt;&gt;(CommonCode.SUCCESS,queryResult);    &#125;&#125;</code></pre></div><h3 id="2、前端代码-1"><a href="#2、前端代码-1" class="headerlink" title="2、前端代码"></a>2、前端代码</h3><p>在后端的代码中，我们在添加高亮标签时候引用了 <code>eslight</code> 的样式，代码如下</p><div class="hljs"><pre><code class="hljs html">highlightBuilder.preTags("<span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'eslight'</span>&gt;</span>");</code></pre></div><p>所以我们在 <code>search/index.vue</code> 中定义 <code>eslight</code> 样式，实现多高亮字段的样式控制。</p><div class="hljs"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;<span class="hljs-selector-class">.eslight</span>&#123;<span class="hljs-attribute">color</span>: red;&#125; ...</code></pre></div><p>我们来测试一下，在搜索门户前端下搜索关键词 <code>spring cloud</code></p><p><a href="https://qnoss.codeyee.com/20200704_12/image24" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image24.png" srcset="/img/loading.gif" alt="img"></a></p><p>从测试的结果中可以看到，我们搜索的关键词成功的被高亮。</p><h1 id="五、集成测试"><a href="#五、集成测试" class="headerlink" title="五、集成测试"></a>五、集成测试</h1><h2 id="1、需求分析-4"><a href="#1、需求分析-4" class="headerlink" title="1、需求分析"></a>1、需求分析</h2><p>本次集成测试的目的如下：</p><p>1、测试课程发布与CMS接口是否正常。</p><p>2、测试课程发布与ES接口是否正常。</p><p>3、测试课程从创建到发布的整个过程。</p><h2 id="2、准备环境"><a href="#2、准备环境" class="headerlink" title="2、准备环境"></a>2、准备环境</h2><p>1、启动 MySQL、MongoDB</p><p>2、启动 ElasticSearch、RabbitMQ</p><p>3、启动 Eureka Server</p><p>4、启动 CMS、课程管理服务、搜索服务。</p><p>5、启动 Nginx、系统管理前端、教学管理前端、Nuxt.js。</p><h2 id="3、开始测试"><a href="#3、开始测试" class="headerlink" title="3、开始测试"></a>3、开始测试</h2><p>这里我们发布一个大数据的测试课程</p><blockquote><p>这里要注意的是，发布课程前需要添加课程营销和课程计划，否则将发布失败。</p></blockquote><p><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image25.png" srcset="/img/loading.gif" alt="img"></p><p>点击课程发布</p><p><a href="https://qnoss.codeyee.com/20200704_12/image26" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image26.png" srcset="/img/loading.gif" alt="img"></a></p><p>发布成功，我们到 <code>coursePub</code> 表上看一下我们发布的课程信息</p><p><a href="https://i.loli.net/2020/05/09/erXkFpA6giHxLPE.png" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/erXkFpA6giHxLPE.png" srcset="/img/loading.gif" alt="img"></a></p><p>从上图中我们可以看到，我们发布的信息已经成功添加到了 coursePub 表内，这个时候等待 <code>LogStash</code> 自动采集我们课程发布的信息，并添加到 <code>Elastic Search</code> 的索引内。</p><p>等待一段时间后，我们从 <code>LogStash</code> 的控制台信息内可以看到，已经采集了我们发布的课程信息，并成功索引到了 Elastic Search</p><p><a href="https://qnoss.codeyee.com/20200704_12/image27" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image27.png" srcset="/img/loading.gif" alt="LogStash控制台"></a></p><p><a href="https://qnoss.codeyee.com/20200704_12/image27" target="_blank" rel="noopener">LogStash控制台</a></p><p><a href="https://qnoss.codeyee.com/20200704_12/image28" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image28.png" srcset="/img/loading.gif" alt="ES索引数据"></a></p><p><a href="https://qnoss.codeyee.com/20200704_12/image28" target="_blank" rel="noopener">ES索引数据</a></p><p>这个时候我们到搜索的前端门户上搜索我们最新发布的课程</p><p><a href="https://qnoss.codeyee.com/20200704_12/image29" target="_blank" rel="noopener"><img src="/2020/08/19/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday12/image29.png" srcset="/img/loading.gif" alt="img"></a></p><p>成功的搜索到了刚才发布的大数据课程，并且将 “大数据” 这个关键词进行高亮处理。</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nuxt.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day11：基于 ElasticSearch 构建搜索服务</title>
    <link href="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/"/>
    <url>/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day11</code> 的内容</p><ul><li>基于 <code>Java</code> 客户端实现 DSL 搜索</li><li>搭建 <code>ElasticSearch</code> 集群环境</li><li>使用 <code>Logstash</code> 自动创建 <code>ElasticSearch</code> 的索引、数据文档</li><li>基于 <code>ElasticSearch</code> 开发搜索服务接口</li></ul><h1 id="一、搜索管理"><a href="#一、搜索管理" class="headerlink" title="一、搜索管理"></a>一、搜索管理</h1><h2 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h2><h3 id="1、创建映射"><a href="#1、创建映射" class="headerlink" title="1、创建映射"></a>1、创建映射</h3><p>创建 <code>xc_course</code> 索引库，方式如下</p><p>post：<a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"description"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>        &#125;,        <span class="hljs-attr">"name"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>        &#125;,        <span class="hljs-attr">"pic"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"index"</span>: <span class="hljs-literal">false</span>        &#125;,        <span class="hljs-attr">"price"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"timestamp"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span>        &#125;    &#125;&#125;</code></pre></div><h3 id="2、插入原始数据"><a href="#2、插入原始数据" class="headerlink" title="2、插入原始数据"></a>2、插入原始数据</h3><p>向 <code>xc_course/doc</code> 中插入以下三个文档数据：</p><p>PUT：<a href="http://localhost:9200/xc_course/doc/1" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/1</a></p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Bootstrap开发"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Bootstrap是由Twitter推出的一个前台页面开发框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松的实现一个不受浏览器限制的精美界面效果。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201002"</span>,    <span class="hljs-attr">"price"</span>:<span class="hljs-number">38.6</span>,    <span class="hljs-attr">"timestamp"</span>:<span class="hljs-string">"2018-04-25 19:11:35"</span>, <span class="hljs-attr">"pic"</span>:<span class="hljs-string">"group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg"</span>&#125;</code></pre></div><p>PUT：<a href="http://localhost:9200/xc_course/doc/2" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/2</a></p><div class="hljs"><pre><code class="hljs json">&#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"java编程基础"</span>,<span class="hljs-attr">"description"</span>: <span class="hljs-string">"java语言是世界第一编程语言，在软件开发领域使用人数最多。"</span>,<span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">68.6</span>,<span class="hljs-attr">"timestamp"</span>:<span class="hljs-string">"2018-03-25 19:11:35"</span>,<span class="hljs-attr">"pic"</span>:<span class="hljs-string">"group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg"</span>&#125;</code></pre></div><p>PUT：<a href="http://localhost:9200/xc_course/doc/3" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/3</a></p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"spring 在java领域非常流行，java程序员都在用。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,    <span class="hljs-attr">"price"</span>:<span class="hljs-number">88.6</span>,    <span class="hljs-attr">"timestamp"</span>:<span class="hljs-string">"2018-02-24 19:11:35"</span>,  <span class="hljs-attr">"pic"</span>:<span class="hljs-string">"group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg"</span>&#125;</code></pre></div><h3 id="3、简单的搜索一下"><a href="#3、简单的搜索一下" class="headerlink" title="3、简单的搜索一下"></a>3、简单的搜索一下</h3><p>简单搜索就是通过 <code>url</code> 进行查询，以 <code>get</code> 方式请求 <code>ES</code>。</p><p>格式：GET ../_search?q=…..</p><blockquote><p>q：搜索字符串。</p></blockquote><p>例子：?q=name:spring</p><blockquote><p>搜索name中包括spring的文档。</p></blockquote><h2 id="2-DSL-搜索"><a href="#2-DSL-搜索" class="headerlink" title="2. DSL 搜索"></a>2. DSL 搜索</h2><p>DSL(Domain Specific Language) 是 <code>ES</code> 提出的基于 <code>json</code> 的搜索方式，在搜索时传入特定的 <code>json</code> 格式的数据来完成不同的搜索需求。</p><p><code>DSL</code> 比 <code>URI</code> (在url传递搜索参数) 搜索方式功能强大，在项目中建议使用 <code>DSL</code> 方式来完成搜索。</p><h3 id="1、查询所有文档"><a href="#1、查询所有文档" class="headerlink" title="1、查询所有文档"></a>1、查询所有文档</h3><p>查询所有索引库的文档。</p><p>发送：post <a href="http://localhost:9200/_search" target="_blank" rel="noopener">http://localhost:9200/_search</a></p><p>查询指定索引库 <strong>指定类型</strong> 下的文档。（通过使用此方法）</p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;    <span class="hljs-attr">"match_all"</span>: &#123;&#125;    &#125;,    <span class="hljs-attr">"_source"</span> : [<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>]&#125;</code></pre></div><blockquote><p>_source：<code>source</code> 源过虑设置，指定结果中所包括的字段有哪些。</p></blockquote><p>搜索结果：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"took"</span>: <span class="hljs-number">9</span>,    <span class="hljs-attr">"timed_out"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"_shards"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"successful"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"skipped"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"failed"</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">"hits"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">3</span>,        <span class="hljs-attr">"max_score"</span>: <span class="hljs-number">1.0</span>,        <span class="hljs-attr">"hits"</span>: [            &#123;                <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,                <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,                <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"1"</span>,                <span class="hljs-attr">"_score"</span>: <span class="hljs-number">1.0</span>,                <span class="hljs-attr">"_source"</span>: &#123;                    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201002"</span>,                    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Bootstrap开发"</span>                &#125;            &#125;,            &#123;                <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,                <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,                <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"2"</span>,                <span class="hljs-attr">"_score"</span>: <span class="hljs-number">1.0</span>,                <span class="hljs-attr">"_source"</span>: &#123;                    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,                    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"java编程基础"</span>                &#125;            &#125;,            &#123;                <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,                <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,                <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"3"</span>,                <span class="hljs-attr">"_score"</span>: <span class="hljs-number">1.0</span>,                <span class="hljs-attr">"_source"</span>: &#123;                    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,                    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>                &#125;            &#125;        ]    &#125;&#125;</code></pre></div><p>结果说明：</p><table><thead><tr><th>字段名称</th><th>描述</th></tr></thead><tbody><tr><td>took</td><td>本次操作花费的时间，单位为毫秒。</td></tr><tr><td>timed_out</td><td>请求是否超时</td></tr><tr><td>_shards</td><td>说明本次操作共搜索了哪些分片</td></tr><tr><td>hits</td><td>搜索命中的记录</td></tr><tr><td>hits.total</td><td>符合条件的文档总数 hits.hits ：匹配度较高的前N个文档</td></tr><tr><td>hits.max_score</td><td>文档匹配得分，这里为最高分</td></tr><tr><td>_score</td><td>每个文档都有一个匹配度得分，按照降序排列。</td></tr><tr><td>_source</td><td>显示了文档的原始内容。</td></tr></tbody></table><p><strong>使用JAVA 客户端实现：</strong></p><ul><li>创建搜索请求对象</li><li>指定类型（部分版本不需要指定类型，这里以 <code>6.2.1</code> 为例）</li><li>构建搜索源对象</li><li>配置搜索方式，设置需要过滤字段</li><li>向搜索请求中设置搜索源</li><li>执行搜索，向ES发起 <code>http</code> 请求</li><li>搜索结果 <code>asd as</code></li><li>匹配到的总记录数</li><li>得到匹配度高的文档</li><li>遍历结果，获取 <code>SearchHit</code> 对象中的属性，输出或者存档。</li></ul><p>具体代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestSearch</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RestHighLevelClient client;    <span class="hljs-comment">//搜索type下的全部记录</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSearchAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//获取搜索请求对象，并且设置类型</span>        SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);        searchRequest.types(<span class="hljs-string">"doc"</span>);        SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();        <span class="hljs-comment">//设置搜索方式</span>        searchSourceBuilder.query(QueryBuilders.matchAllQuery());        <span class="hljs-comment">//配置source源字段过虑，1显示的，2排除的</span>        searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>&#125;, <span class="hljs-keyword">new</span> String[]&#123;&#125;);        <span class="hljs-comment">//将搜索源配置到搜索请求中，执行搜索，获取搜索响应结果</span>        searchRequest.source(searchSourceBuilder);        SearchResponse searchResponse = client.search(searchRequest);        <span class="hljs-comment">//获取所有搜索结果、总匹配数量</span>        SearchHits hits = searchResponse.getHits();        <span class="hljs-keyword">long</span> totalHits = hits.getTotalHits();        <span class="hljs-comment">//筛选出匹配度高的文档记录</span>        SearchHit[] searchHits = hits.getHits();        <span class="hljs-comment">//遍历结果</span>        <span class="hljs-keyword">for</span> (SearchHit hit : searchHits) &#123;            String index = hit.getIndex();            String type = hit.getType();            String id = hit.getId();            <span class="hljs-keyword">float</span> score = hit.getScore();            String sourceAsString = hit.getSourceAsString();            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();            String name = (String) sourceAsMap.get(<span class="hljs-string">"name"</span>);            String studymodel = (String) sourceAsMap.get(<span class="hljs-string">"studymodel"</span>);            String description = (String) sourceAsMap.get(<span class="hljs-string">"description"</span>);            System.out.println(name);            System.out.println(studymodel);            System.out.println(description);        &#125;    &#125;&#125;</code></pre></div><h3 id="2、分页查询"><a href="#2、分页查询" class="headerlink" title="2、分页查询"></a>2、分页查询</h3><p><code>ES</code> 支持分页查询，传入两个参数：<code>from</code> 和 <code>size</code>。</p><ul><li>form：表示起始文档的下标，从0开始。</li><li>size：查询的文档数量。</li></ul><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"from"</span> : <span class="hljs-number">0</span>,     <span class="hljs-attr">"size"</span> : <span class="hljs-number">1</span>,    <span class="hljs-attr">"query"</span>: &#123;    <span class="hljs-attr">"match_all"</span>: &#123;&#125;    &#125;,    <span class="hljs-attr">"_source"</span> : [<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>]&#125;</code></pre></div><p><strong>使用JAVA 客户端实现：</strong></p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-comment">//分页查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSearchPage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//获取搜索请求对象，并且设置类型</span>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//设置搜索方式</span>    searchSourceBuilder.query(QueryBuilders.matchAllQuery());    <span class="hljs-comment">//ES这里是按起始坐标来实现分页查询,所以我们要指定一个页码</span>    <span class="hljs-keyword">int</span> pageNum = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> size = <span class="hljs-number">2</span>;    <span class="hljs-comment">//通过页码和查询数量得出起始位置</span>    <span class="hljs-keyword">int</span> fromNum = (pageNum - <span class="hljs-number">1</span>) * size;    <span class="hljs-comment">//分页查询，设置起始下标，从0开始</span>    searchSourceBuilder.from(<span class="hljs-number">0</span>);    <span class="hljs-comment">//每页显示个数</span>    searchSourceBuilder.size(size);    <span class="hljs-comment">//配置source源字段过虑，1显示的，2排除的</span>    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>&#125;, <span class="hljs-keyword">new</span> String[]&#123;&#125;);    <span class="hljs-comment">//将搜索源配置到搜索请求中，执行搜索，获取搜索响应结果</span>    searchRequest.source(searchSourceBuilder);    SearchResponse searchResponse = restHighLevelClient.search(searchRequest);    <span class="hljs-comment">//获取所有搜索结果、总匹配数量</span>    SearchHits hits = searchResponse.getHits();    <span class="hljs-keyword">long</span> totalHits = hits.getTotalHits();    <span class="hljs-comment">//筛选出匹配度高的文档记录</span>    SearchHit[] searchHits = hits.getHits();    <span class="hljs-comment">//遍历结果</span>    <span class="hljs-keyword">for</span>(SearchHit hit : searchHits)&#123;        System.out.println(hit.toString());    &#125;&#125;</code></pre></div><h3 id="3、Term-Query"><a href="#3、Term-Query" class="headerlink" title="3、Term Query"></a>3、Term Query</h3><p><code>Term Query</code> 为精确查询，在搜索时会整体匹配关键字，不再将关键字分词。</p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"term"</span> : &#123;            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring"</span>        &#125;    &#125;,    <span class="hljs-attr">"_source"</span> : [<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>]&#125;</code></pre></div><p>上边的搜索会查询 <code>name</code> 包括 <code>spring</code> 这个词的文档。</p><p><strong>JAVA客户端实现：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Term Query 精确查询</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestSearchTermQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//设置查询类型为termQuery,精确匹配name中包含spring的文档</span>    searchSourceBuilder.query(QueryBuilders.termQuery(<span class="hljs-string">"name"</span>,<span class="hljs-string">"spring"</span>));<span class="hljs-comment">//source源字段过虑</span>    <span class="hljs-comment">//不指定过滤条件则默认显示查询到的文档的所有字段</span>    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;&#125;, <span class="hljs-keyword">new</span> String[]&#123;&#125;);    <span class="hljs-comment">//设置搜索源并获取搜索结果</span>    searchRequest.source(searchSourceBuilder);    SearchResponse searchResponse = restHighLevelClient.search(searchRequest);    <span class="hljs-comment">//获取搜索结果</span>    <span class="hljs-comment">//  .getHits() 取本次所有匹配结果</span>    <span class="hljs-comment">//  .getHits().getHits() 筛选出匹配度高的文档记录</span>    SearchHits hits = searchResponse.getHits();    <span class="hljs-keyword">long</span> totalHits = hits.getTotalHits();    <span class="hljs-comment">//筛选匹配度最高的结果</span>    SearchHit[] searchHits = hits.getHits();    System.out.println(<span class="hljs-string">"结果数量为: "</span> + totalHits);    <span class="hljs-comment">//输出搜索结果</span>    <span class="hljs-keyword">for</span>(SearchHit hit : searchHits)&#123;        System.out.println(hit.getSourceAsMap());    &#125;&#125;</code></pre></div><h3 id="4、根据id精确匹配"><a href="#4、根据id精确匹配" class="headerlink" title="4、根据id精确匹配"></a>4、根据id精确匹配</h3><p>ES提供根据多个id值匹配的方法：</p><p>post： <a href="http://127.0.0.1:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://127.0.0.1:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"ids"</span> : &#123;            <span class="hljs-attr">"type"</span> : <span class="hljs-string">"doc"</span>,            <span class="hljs-attr">"values"</span> : [<span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"100"</span>]        &#125;    &#125;&#125;</code></pre></div><p><strong>JAVA客户端实现：</strong></p><div class="hljs"><pre><code class="hljs java">String[] split = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"1"</span>,<span class="hljs-string">"2"</span>&#125;;List&lt;String&gt; idList = Arrays.asList(split);searchSourceBuilder.query(QueryBuilders.termsQuery(<span class="hljs-string">"_id"</span>, idList));</code></pre></div><h3 id="5、match-query-匹配单个字段"><a href="#5、match-query-匹配单个字段" class="headerlink" title="5、match query (匹配单个字段)"></a>5、match query (匹配单个字段)</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1) 基本使用"></a>(1) 基本使用</h4><p><code>match query</code> 即全文检索，它的搜索方式是先将搜索字符串分词，再使用各各词条从索引中搜索。</p><p><code>match query</code> 与 <code>Term query</code> 区别是 <code>match query</code> 在搜索前先将搜索关键字分词，再拿各各词语去索引中搜索。</p><p>需求：检索 <code>name</code> 字段中包含 spring开发 的文档，并且结果只显示该文档的 name 字段</p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"match"</span>: &#123;            <span class="hljs-attr">"name"</span>: &#123;                <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring开发"</span>,                <span class="hljs-attr">"operator"</span>: <span class="hljs-string">"or"</span>            &#125;        &#125;    &#125;,<span class="hljs-attr">"_source"</span> : [<span class="hljs-string">"name"</span>]&#125;</code></pre></div><ul><li>query：搜索的关键字，对于英文关键字如果有多个单词则中间要用半角逗号分隔，而对于中文关键字中间可以用逗号分隔也可以不用。</li><li>operator：<code>or</code> 表示 只要有一个词在文档中出现则就符合条件, <code>and</code> 表示每个词都在文档中出现则才符合条件</li></ul><p><strong>operator</strong>：<code>or</code> 表示 只要有一个词在文档中出现则就符合条件, <code>and</code> 表示每个词都在文档中出现则才符合条件</p><p>搜索结果：</p><div class="hljs"><pre><code class="hljs json">"hits": [    &#123;        <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,        <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,        <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"3"</span>,        <span class="hljs-attr">"_score"</span>: <span class="hljs-number">1.3802519</span>,        <span class="hljs-attr">"_source"</span>: &#123;            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>        &#125;    &#125;,    &#123;        <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,        <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,        <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"1"</span>,        <span class="hljs-attr">"_score"</span>: <span class="hljs-number">0.52354836</span>,        <span class="hljs-attr">"_source"</span>: &#123;            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Bootstrap开发"</span>        &#125;    &#125;]</code></pre></div><p>上边的搜索的执行过程是：</p><p>1、将 <code>spring开发</code> 分词，分为 <code>spring</code>、<code>开发</code> 两个词</p><p>2、再使用 <code>spring</code> 和开发两个词去匹配索引中搜索。</p><p>3、由于设置了 <code>operator</code> 为 <code>or</code>，只要有一个词匹配成功则就返回该文档。</p><p>我们将 operator 设置为 <code>and</code> 再次进行搜索</p><div class="hljs"><pre><code class="hljs json">"hits": [    &#123;        <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,        <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,        <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"3"</span>,        <span class="hljs-attr">"_score"</span>: <span class="hljs-number">1.3802519</span>,        <span class="hljs-attr">"_source"</span>: &#123;            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>        &#125;    &#125;]</code></pre></div><p>从结果中我们可以看到，使用 <code>and</code> 进行搜索后，ES会匹配指定的字段包含 <code>spring</code>、<code>开发</code> 两个词的结果。</p><p><strong>JAVA客户端实现：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据关键字搜索</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMatchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//source源字段过虑</span>    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>&#125;, <span class="hljs-keyword">new</span> String[]&#123;&#125;);    <span class="hljs-comment">//设置过滤器，匹配关键字</span>    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="hljs-string">"description"</span>, <span class="hljs-string">"spring开发"</span>).operator(Operator.OR));    searchRequest.source(searchSourceBuilder);    <span class="hljs-comment">//执行搜索请求</span>    SearchResponse searchResponse = client.search(searchRequest);    SearchHits hits = searchResponse.getHits();    SearchHit[] searchHits = hits.getHits();    <span class="hljs-comment">//输出搜索结果</span>    <span class="hljs-keyword">for</span>(SearchHit hit : searchHits)&#123;        System.out.println(hit.getSourceAsMap());    &#125;&#125;</code></pre></div><h4 id="2-minimum-should-match"><a href="#2-minimum-should-match" class="headerlink" title="(2) minimum_should_match"></a>(2) minimum_should_match</h4><p>上边使用的 <code>operator = or</code> 表示只要有一个词匹配上就得分，如果实现三个词至少有两个词匹配如何实现？使用 <code>minimum_should_match</code> 可以指定文档匹配词的占比：</p><p>比如搜索语句如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"match"</span>: &#123;            <span class="hljs-attr">"description"</span>: &#123;                <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring开发框架"</span>,                <span class="hljs-attr">"minimum_should_match"</span>: <span class="hljs-string">"80%"</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><p><code>spring开发框架</code> 会被分为三个词：<code>spring</code>、<code>开发</code>、<code>框架</code></p><p>设置 <code>minimum_should_match:80%</code> 表示，三个词在文档的匹配占比为 <strong>80%</strong>，即 3<em>0.8=2.4，向上取整得2，表示至少有 *</em>两个词** 在文档中要匹配成功。</p><p>对应的 <code>RestClient</code> 如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//匹配关键字</span>MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(<span class="hljs-string">"description"</span>, <span class="hljs-string">"前台页面开发框架 架构"</span>).minimumShouldMatch(<span class="hljs-string">"80%"</span>);<span class="hljs-comment">//设置匹配占比</span>searchSourceBuilder.query(matchQueryBuilder);</code></pre></div><h3 id="6、multi-query-匹配多个字段"><a href="#6、multi-query-匹配多个字段" class="headerlink" title="6、multi query (匹配多个字段)"></a>6、multi query (匹配多个字段)</h3><p>上边学习的 <code>termQuery</code> 和 <code>matchQuery</code> 一次只能匹配一个 <code>Field</code>，本节学习 <code>multiQuery</code>，一次可以匹配多个字段。</p><h4 id="1-基本使用-1"><a href="#1-基本使用-1" class="headerlink" title="(1) 基本使用"></a>(1) 基本使用</h4><p>单项匹配是在一个 <code>field</code> 中去匹配，多项匹配是拿关键字去多个 <code>Field</code> 中匹配，例子如下：</p><p>发送：post <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><p>拿关键字 <code>spring css</code>去匹配 <code>name</code> 和 <code>description</code> 字段。</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"multi_match"</span>: &#123;            <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring css"</span>,            <span class="hljs-attr">"minimum_should_match"</span>: <span class="hljs-string">"50%"</span>,            <span class="hljs-attr">"fields"</span>: [                <span class="hljs-string">"name"</span>,                <span class="hljs-string">"description"</span>            ]        &#125;    &#125;&#125;</code></pre></div><h4 id="2-提升-boost-权重"><a href="#2-提升-boost-权重" class="headerlink" title="(2) 提升 boost (权重)"></a>(2) 提升 boost (权重)</h4><p>匹配多个字段时可以提升字段的 <code>boost</code>（权重）来提高得分</p><p>例子：提升 <code>boost</code>之前，执行下边的查询：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"multi_match"</span>: &#123;            <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring框架"</span>,            <span class="hljs-attr">"minimum_should_match"</span>: <span class="hljs-string">"50%"</span>,            <span class="hljs-attr">"fields"</span>: [                <span class="hljs-string">"name"</span>,                <span class="hljs-string">"description"</span>            ]        &#125;    &#125;&#125;</code></pre></div><p>通过查询发现 <code>Bootstrap</code> 排在前边。</p><p>提升 <code>boost</code>，通常关键字匹配上 <code>name</code> 的权重要比匹配上 <code>description</code> 的权重高，这里可以对<code>name</code> 的权重提升。</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"multi_match"</span>: &#123;            <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring框架"</span>,            <span class="hljs-attr">"minimum_should_match"</span>: <span class="hljs-string">"50%"</span>,            <span class="hljs-attr">"fields"</span>: [                <span class="hljs-string">"name^10"</span>,                <span class="hljs-string">"description"</span>            ]        &#125;    &#125;&#125;</code></pre></div><p><code>name^10</code> 表示权重提升 <code>10</code> 倍，执行上边的查询，发现 <code>name</code> 中包括 <code>spring</code> 关键字的文档排在前边。</p><p><strong>JAVA 客户端：</strong></p><div class="hljs"><pre><code class="hljs java">MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="hljs-string">"spring框架"</span>,<span class="hljs-string">"name"</span>, <span class="hljs-string">"description"</span>).minimumShouldMatch(<span class="hljs-string">"50%"</span>);multiMatchQueryBuilder.field(<span class="hljs-string">"name"</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//提升boost</span></code></pre></div><h3 id="7、布尔查询"><a href="#7、布尔查询" class="headerlink" title="7、布尔查询"></a>7、布尔查询</h3><p>布尔查询对应于 <code>Lucene</code> 的 <code>BooleanQuery</code> 查询，实现将多个查询组合起来。</p><p>三个参数：</p><p><code>must</code>：文档必须匹配 <code>must</code> 所包括的查询条件，相当于 <code>AND</code></p><p><code>should</code>：文档应该匹配 <code>should</code> 所包括的查询条件其中的一个或多个，相当于 <code>OR</code></p><p><code>must_not</code>：文档不能匹配 <code>must_not</code> 所包括的该查询条件，相当于 <code>NOT</code></p><p>分别使用 <code>must</code>、<code>should</code>、<code>must_not</code> 测试下边的查询：</p><p>发送：POST <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"_source"</span>: [        <span class="hljs-string">"name"</span>,        <span class="hljs-string">"studymodel"</span>,        <span class="hljs-string">"description"</span>    ],    <span class="hljs-attr">"from"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"size"</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"bool"</span>: &#123;            <span class="hljs-attr">"must"</span>: [                &#123;                    <span class="hljs-attr">"multi_match"</span>: &#123;                        <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring框架"</span>,                        <span class="hljs-attr">"minimum_should_match"</span>: <span class="hljs-string">"50%"</span>,                        <span class="hljs-attr">"fields"</span>: [                            <span class="hljs-string">"name^10"</span>,                            <span class="hljs-string">"description"</span>                        ]                    &#125;                &#125;,                &#123;                    <span class="hljs-attr">"term"</span>: &#123;                        <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>                    &#125;                &#125;            ]        &#125;    &#125;&#125;</code></pre></div><p><code>must</code>：表示必须，多个查询条件必须都满足。（通常使用<code>must</code>）</p><p><code>should</code>：表示或者，多个查询条件只要有一个满足即可。</p><p><code>must_not</code>：表示非。</p><p><strong>JAVA客户端实现：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//BoolQuery，将搜索关键字分词，拿分词去索引库搜索</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBoolQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//创建搜索请求对象</span>    SearchRequest searchRequest= <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    <span class="hljs-comment">//创建搜索源配置对象</span>    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>,<span class="hljs-string">"pic"</span>,<span class="hljs-string">"studymodel"</span>&#125;,<span class="hljs-keyword">new</span> String[]&#123;&#125;);    <span class="hljs-comment">//multiQuery</span>    String keyword = <span class="hljs-string">"spring开发框架"</span>;    MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="hljs-string">"spring框架"</span>,    <span class="hljs-string">"name"</span>, <span class="hljs-string">"description"</span>)    .minimumShouldMatch(<span class="hljs-string">"50%"</span>);    multiMatchQueryBuilder.field(<span class="hljs-string">"name"</span>,<span class="hljs-number">10</span>);    <span class="hljs-comment">//TermQuery</span>    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="hljs-string">"studymodel"</span>, <span class="hljs-string">"201001"</span>);    <span class="hljs-comment">//布尔查询</span>    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();    boolQueryBuilder.must(multiMatchQueryBuilder);    boolQueryBuilder.must(termQueryBuilder);    <span class="hljs-comment">//设置布尔查询对象</span>    searchSourceBuilder.query(boolQueryBuilder);    searchRequest.source(searchSourceBuilder);<span class="hljs-comment">//设置搜索源配置</span>    SearchResponse searchResponse = client.search(searchRequest);    SearchHits hits = searchResponse.getHits();    SearchHit[] searchHits = hits.getHits();    <span class="hljs-keyword">for</span>(SearchHit hit:searchHits)&#123;        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        System.out.println(sourceAsMap);    &#125;&#125;</code></pre></div><h3 id="8、过滤器"><a href="#8、过滤器" class="headerlink" title="8、过滤器"></a>8、过滤器</h3><p>过虑是针对 <strong>搜索的结果</strong> 进行过虑，过虑器主要判断的是文档是否匹配，不去 <strong>计算和判断文档的匹配度得分</strong>，所以过虑器的 <strong>性能</strong> 比查询要高，且方便缓存，推荐尽量使用过虑器去实现查询或者 <strong>过虑器</strong> 和 <strong>查询</strong> 共同使用。</p><p>过虑器在布尔查询中使用，下边是在搜索结果的基础上进行过滤</p><p>发送：POST <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"_source"</span>: [        <span class="hljs-string">"name"</span>,        <span class="hljs-string">"studymodel"</span>,        <span class="hljs-string">"description"</span>,        <span class="hljs-string">"price"</span>    ],    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"bool"</span>: &#123;            <span class="hljs-attr">"must"</span>: [                &#123;                    <span class="hljs-attr">"multi_match"</span>: &#123;                        <span class="hljs-attr">"query"</span>: <span class="hljs-string">"spring框架"</span>,                        <span class="hljs-attr">"minimum_should_match"</span>: <span class="hljs-string">"50%"</span>,                        <span class="hljs-attr">"fields"</span>: [                            <span class="hljs-string">"name^10"</span>,                            <span class="hljs-string">"description"</span>                        ]                    &#125;                &#125;            ],            <span class="hljs-attr">"filter"</span>: [                &#123;                    <span class="hljs-attr">"term"</span>: &#123;                        <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>                    &#125;                &#125;,                &#123;                    <span class="hljs-attr">"range"</span>: &#123;                        <span class="hljs-attr">"price"</span>: &#123;                            <span class="hljs-attr">"gte"</span>: <span class="hljs-number">60</span>,                            <span class="hljs-attr">"lte"</span>: <span class="hljs-number">100</span>                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;&#125;</code></pre></div><p>range：范围过虑，保留大于等于 <code>60</code> 并且小于等于 <code>100</code> 的记录。</p><p>term：项匹配过虑，保留 <code>studymodel</code> 等于 <code>201001</code> 的记录。</p><p>注意：<code>range</code> 和 <code>term</code> 一次只能对一个 <code>Field</code> 设置范围过虑。</p><p><strong>JAVA 客户端实现：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//布尔查询使用过虑器</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//source源字段过虑</span>    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>,<span class="hljs-string">"price"</span>,<span class="hljs-string">"description"</span>&#125;,    <span class="hljs-keyword">new</span> String[]&#123;&#125;);    searchRequest.source(searchSourceBuilder);    <span class="hljs-comment">//匹配关键字</span>    MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="hljs-string">"spring框</span><span class="hljs-string">    架"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"description"</span>);    <span class="hljs-comment">//设置匹配占比</span>    multiMatchQueryBuilder.minimumShouldMatch(<span class="hljs-string">"50%"</span>);    <span class="hljs-comment">//提升另个字段的Boost值</span>    multiMatchQueryBuilder.field(<span class="hljs-string">"name"</span>,<span class="hljs-number">10</span>);    searchSourceBuilder.query(multiMatchQueryBuilder);    <span class="hljs-comment">//布尔查询</span>    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();    boolQueryBuilder.must(searchSourceBuilder.query());    <span class="hljs-comment">//过虑条件</span>    boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"studymodel"</span>, <span class="hljs-string">"201001"</span>));    boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="hljs-string">"price"</span>).gte(<span class="hljs-number">60</span>).lte(<span class="hljs-number">100</span>));    <span class="hljs-comment">//执行搜索</span>SearchResponse searchResponse = client.search(searchRequest);    SearchHits hits = searchResponse.getHits();    SearchHit[] searchHits = hits.getHits();    <span class="hljs-keyword">for</span>(SearchHit hit:searchHits)&#123;        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        System.out.println(sourceAsMap);    &#125;&#125;</code></pre></div><h3 id="9、排序"><a href="#9、排序" class="headerlink" title="9、排序"></a>9、排序</h3><p>可以在字段上添加一个或多个排序，支持在 <code>keyword</code>、<code>date</code>、<code>float</code> 等类型上添加，<code>text</code> 类型的字段上不允许添加排序。</p><p>需求：过虑 <code>0--10</code> 元价格范围的文档，并且对结果进行排序，先按 <code>studymodel</code> 降序，再按价格升序</p><p>发送 POST <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"_source"</span>: [        <span class="hljs-string">"name"</span>,        <span class="hljs-string">"studymodel"</span>,        <span class="hljs-string">"description"</span>,        <span class="hljs-string">"price"</span>    ],    <span class="hljs-attr">"query"</span>: &#123;        <span class="hljs-attr">"bool"</span>: &#123;            <span class="hljs-attr">"filter"</span>: [                &#123;                    <span class="hljs-attr">"range"</span>: &#123;                        <span class="hljs-attr">"price"</span>: &#123;                            <span class="hljs-attr">"gte"</span>: <span class="hljs-number">0</span>,                            <span class="hljs-attr">"lte"</span>: <span class="hljs-number">100</span>                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;,    <span class="hljs-attr">"sort"</span>: [        &#123;            <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"desc"</span>        &#125;,        &#123;            <span class="hljs-attr">"price"</span>: <span class="hljs-string">"asc"</span>        &#125;    ]&#125;</code></pre></div><blockquote><p>dest 表示降序，从大到小，asc 表示升序，从小到大</p></blockquote><p><strong>JAVA客户端实现</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//source源字段过虑</span>    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>,<span class="hljs-string">"price"</span>,<span class="hljs-string">"description"</span>&#125;,    <span class="hljs-keyword">new</span> String[]&#123;&#125;);    searchRequest.source(searchSourceBuilder);    <span class="hljs-comment">//布尔查询</span>    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();    <span class="hljs-comment">//过虑</span>  boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="hljs-string">"price"</span>).gte(<span class="hljs-number">0</span>).lte(<span class="hljs-number">100</span>));    <span class="hljs-comment">//排序</span>    searchSourceBuilder.sort(<span class="hljs-keyword">new</span> FieldSortBuilder(<span class="hljs-string">"studymodel"</span>).order(SortOrder.DESC));    searchSourceBuilder.sort(<span class="hljs-keyword">new</span> FieldSortBuilder(<span class="hljs-string">"price"</span>).order(SortOrder.ASC));    SearchResponse searchResponse = client.search(searchRequest);    SearchHits hits = searchResponse.getHits();    SearchHit[] searchHits = hits.getHits();    <span class="hljs-keyword">for</span>(SearchHit hit:searchHits)&#123;        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        System.out.println(sourceAsMap);    &#125;&#125;</code></pre></div><h3 id="10、高亮显示"><a href="#10、高亮显示" class="headerlink" title="10、高亮显示"></a>10、高亮显示</h3><p><strong>JAVA客户端实现</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">"xc_course"</span>);    searchRequest.types(<span class="hljs-string">"doc"</span>);    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//source源字段过虑</span>    searchSourceBuilder.fetchSource(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"name"</span>,<span class="hljs-string">"studymodel"</span>,<span class="hljs-string">"price"</span>,<span class="hljs-string">"description"</span>&#125;,    <span class="hljs-keyword">new</span> String[]&#123;&#125;);    searchRequest.source(searchSourceBuilder);    <span class="hljs-comment">//匹配关键字</span>    MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(<span class="hljs-string">"开发"</span>,    <span class="hljs-string">"name"</span>, <span class="hljs-string">"description"</span>);    searchSourceBuilder.query(multiMatchQueryBuilder);    <span class="hljs-comment">//布尔查询</span>    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();    boolQueryBuilder.must(searchSourceBuilder.query());    <span class="hljs-comment">//过虑</span>    boolQueryBuilder.filter(QueryBuilders.rangeQuery(<span class="hljs-string">"price"</span>).gte(<span class="hljs-number">0</span>).lte(<span class="hljs-number">100</span>));    <span class="hljs-comment">//排序</span>    searchSourceBuilder.sort(<span class="hljs-keyword">new</span> FieldSortBuilder(<span class="hljs-string">"studymodel"</span>).order(SortOrder.DESC));    searchSourceBuilder.sort(<span class="hljs-keyword">new</span> FieldSortBuilder(<span class="hljs-string">"price"</span>).order(SortOrder.ASC));    <span class="hljs-comment">//高亮设置</span>    HighlightBuilder highlightBuilder = <span class="hljs-keyword">new</span> HighlightBuilder();    highlightBuilder.preTags(<span class="hljs-string">"&lt;tag&gt;"</span>);<span class="hljs-comment">//设置前缀</span>    highlightBuilder.postTags(<span class="hljs-string">"&lt;/tag&gt;"</span>);<span class="hljs-comment">//设置后缀</span>    <span class="hljs-comment">// 设置高亮字段</span>    highlightBuilder.fields().add(<span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">"name"</span>));    <span class="hljs-comment">// highlightBuilder.fields().add(new HighlightBuilder.Field("description"));</span>    searchSourceBuilder.highlighter(highlightBuilder);    SearchResponse searchResponse = client.search(searchRequest);    SearchHits hits = searchResponse.getHits();    SearchHit[] searchHits = hits.getHits();    <span class="hljs-keyword">for</span> (SearchHit hit : searchHits) &#123;        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        <span class="hljs-comment">//名称</span>        String name = (String) sourceAsMap.get(<span class="hljs-string">"name"</span>);        <span class="hljs-comment">//取出高亮字段内容</span>        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();        <span class="hljs-keyword">if</span>(highlightFields!=<span class="hljs-keyword">null</span>)&#123;            HighlightField nameField = highlightFields.get(<span class="hljs-string">"name"</span>);            <span class="hljs-keyword">if</span>(nameField!=<span class="hljs-keyword">null</span>)&#123;                Text[] fragments = nameField.getFragments();                StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();                <span class="hljs-keyword">for</span> (Text str : fragments) &#123;                    stringBuffer.append(str.string());                &#125;                 name = stringBuffer.toString();            &#125;        &#125;        <span class="hljs-comment">//取出所有结果</span>        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        System.out.println(sourceAsMap);    &#125;&#125;</code></pre></div><h1 id="二、集群管理"><a href="#二、集群管理" class="headerlink" title="二、集群管理"></a>二、集群管理</h1><p><code>ES</code> 通常以集群方式工作，这样做不仅能够提高 <code>ES</code> 的搜索能力还可以处理大数据搜索的能力，同时也增加了系统的容错能力及高可用，<code>ES</code> 可以实现 <code>PB</code> 级数据的搜索。</p><h2 id="1-集群结构"><a href="#1-集群结构" class="headerlink" title="1. 集群结构"></a>1. 集群结构</h2><p>下图是 <code>ES</code> 集群结构的示意图：</p><p><a href="https://qnoss.codeyee.com/20200704_11/image1" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image1.png" srcset="/img/loading.gif" alt="image-20200423073305474.png"></a></p><p><a href="https://qnoss.codeyee.com/20200704_11/image1" target="_blank" rel="noopener">image-20200423073305474.png</a></p><p>从上图总结以下概念：</p><p><strong>1、结点</strong></p><p><code>ES</code> 集群由多个服务器组成，每个服务器即为一个 <code>Node</code> 结点(如果该服务器只部署了一个 <code>ES</code> 进程)。</p><p><strong>2、分片</strong></p><p>当我们的文档量很大时，由于内存和硬盘的限制，同时也为了提高 <code>ES</code> 的处理能力、容错能力及高可用能力，我们将索引分成若干分片，每个分片可以放在不同的服务器，这样就实现了多个服务器共同对外提供索引及搜索服务。<br>一个搜索请求过来，会分别从各各分片去查询，最后将查询到的数据合并返回给用户。</p><p><strong>3、副本</strong></p><p>为了提高 <code>ES</code> 的高可用同时也为了提高搜索的吞吐量，我们将分片复制一份或多份存储在其它的服务器，这样即使当前的服务器挂掉了，拥有副本的服务器照常可以提供服务。</p><p><strong>4、主结点</strong></p><p>一个集群中会有一个或多个主结点，主结点的作用是集群管理，比如增加节点，移除节点等，主结点挂掉后ES会重新选一个主结点。</p><p><strong>5、结点转发</strong></p><p>每个结点都知道其它结点的信息，我们可以对任意一个结点发起请求，接收请求的结点会转发给其它结点查询数据</p><h2 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2. 搭建集群"></a>2. 搭建集群</h2><h3 id="1、节点的三个角色"><a href="#1、节点的三个角色" class="headerlink" title="1、节点的三个角色"></a>1、节点的三个角色</h3><p>下边的例子实现创建一个 2结点的集群，并且索引的分片我们设置 2片，每片一个副本。</p><p>主结点：<code>master</code> 节点主要用于集群的管理及索引，比如新增结点、分片分配、索引的新增和删除等。</p><p>数据结点：<code>data</code> 节点上保存了数据分片，它负责索引和搜索操作。 客户端结点：<code>client</code> 节点仅作为请求客户端存在，<code>client</code> 的作用也作为负载均衡器，<code>client</code> 节点不存数据，只是将请求均衡转发到其它结点。</p><p>通过下边两项参数来配置结点的功能：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">node.master:</span> <span class="hljs-comment">#是否允许为主结点</span><span class="hljs-attr">node.data:</span> <span class="hljs-comment">#允许存储数据作为数据结点</span><span class="hljs-attr">node.ingest:</span> <span class="hljs-comment">#是否允许成为协调节点，</span></code></pre></div><p>四种组合方式：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">master=true,</span> <span class="hljs-string">data=true：即是主结点又是数据结点</span><span class="hljs-string">master=false,</span> <span class="hljs-string">data=true：仅是数据结点</span><span class="hljs-string">master=true,</span> <span class="hljs-string">data=false：仅是主结点，不存储数据</span><span class="hljs-string">master=false,</span> <span class="hljs-string">data=false：即不是主结点也不是数据结点，此时可设置ingest为true表示它是一个客户端</span></code></pre></div><h3 id="2、创建节点"><a href="#2、创建节点" class="headerlink" title="2、创建节点"></a>2、创建节点</h3><h4 id="1-配置节点1"><a href="#1-配置节点1" class="headerlink" title="(1) 配置节点1"></a>(1) 配置节点1</h4><p>结点1 对外服务的 <code>http</code> 端口是 <code>9200</code>，集群管理端口是 <code>9300</code></p><p>配置 elasticsearch.yml</p><p>结点名：<code>xc_node_1</code></p><p><code>elasticsearch.yml</code> 内容如下</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">xuecheng</span><span class="hljs-attr">node.name:</span> <span class="hljs-string">xc_node_1</span><span class="hljs-comment"># 主机绑定IP、端口等信息</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-attr">http.port:</span> <span class="hljs-number">9200</span><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9300</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 配置master节点列表</span><span class="hljs-attr">discovery.zen.ping.unicast.hosts:</span> <span class="hljs-string">["0.0.0.0:9300",</span> <span class="hljs-string">"0.0.0.0:9301"</span><span class="hljs-string">]</span><span class="hljs-comment"># 最小的主节点数量</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-attr">node.ingest:</span> <span class="hljs-literal">true</span><span class="hljs-attr">bootstrap.memory_lock:</span> <span class="hljs-literal">false</span><span class="hljs-attr">node.max_local_storage_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># 数据与日志目录</span><span class="hljs-attr">path.data:</span> <span class="hljs-string">D:\soft\elasticsearch\elasticsearch-6.8.8_1\data</span><span class="hljs-attr">path.logs:</span> <span class="hljs-string">D:\soft\elasticsearch\elasticsearch-6.8.8_1\logs</span><span class="hljs-comment"># 跨域配置</span><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">/.*/</span></code></pre></div><p>启动节点1</p><h4 id="2-配置节点2"><a href="#2-配置节点2" class="headerlink" title="(2) 配置节点2"></a>(2) 配置节点2</h4><p>我们测试环境就在同一台机器上部署两个节点，所以需要将 <code>ES</code> 的安装包再解压一份，并复制节点1的ik插件和一些日志配置文件到 <strong>节点2</strong> 的目录下</p><p>结点 <code>2</code>对外服务的 <code>http</code> 端口是 <code>9201</code>，集群管理端口是<code>9302</code></p><p>结点名：<code>xc_node_2</code></p><p><code>elasticsearch.yml</code> 内容如下 ：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">xuecheng</span><span class="hljs-attr">node.name:</span> <span class="hljs-string">xc_node_2</span><span class="hljs-comment"># 主机绑定IP、端口等信息</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-attr">http.port:</span> <span class="hljs-number">9201</span><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9301</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 配置master节点列表</span><span class="hljs-attr">discovery.zen.ping.unicast.hosts:</span> <span class="hljs-string">["0.0.0.0:9300",</span> <span class="hljs-string">"0.0.0.0:9301"</span><span class="hljs-string">]</span><span class="hljs-comment"># 最小的主节点数量</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-attr">node.ingest:</span> <span class="hljs-literal">true</span><span class="hljs-attr">bootstrap.memory_lock:</span> <span class="hljs-literal">false</span><span class="hljs-attr">node.max_local_storage_nodes:</span> <span class="hljs-number">1</span><span class="hljs-comment"># 数据与日志目录</span><span class="hljs-attr">path.data:</span> <span class="hljs-string">D:\soft\elasticsearch\elasticsearch-6.8.8_1\data</span><span class="hljs-attr">path.logs:</span> <span class="hljs-string">D:\soft\elasticsearch\elasticsearch-6.8.8_2\logs</span><span class="hljs-comment"># 跨域配置</span><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">/.*/</span></code></pre></div><p>启动结点2</p><h3 id="3、创建索引库"><a href="#3、创建索引库" class="headerlink" title="3、创建索引库"></a>3、创建索引库</h3><p>1）使用head连上其中一个结点</p><p><a href="https://qnoss.codeyee.com/20200704_11/image2" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>上图表示两个结点已经创建成功。</p><p>2）下边创建索引库，共 <code>2</code> 个分片，每个分片一个副本。</p><p><a href="https://qnoss.codeyee.com/20200704_11/image3" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>创建成功，刷新 head</p><p><a href="https://qnoss.codeyee.com/20200704_11/image4" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>上图可以看到共有4个分片，其中两个分片是副本。</p><h3 id="4、集群的健康状态"><a href="#4、集群的健康状态" class="headerlink" title="4、集群的健康状态"></a>4、集群的健康状态</h3><p>通过访问 GET <code>/_cluster/health</code> 来查看 <code>Elasticsearch</code> 的集群健康情况。</p><p>用三种颜色来展示健康状态： <code>green</code> 、 <code>yellow</code> 或者 <code>red</code> 。</p><ul><li>green：所有的主分片和副本分片都正常运行。</li><li>yellow：所有的主分片都正常运行，但有些副本分片运行不正常。</li><li>ed：存在主分片运行不正常。</li></ul><p>GET 请求：<a href="http://localhost:9200/_cluster/health" target="_blank" rel="noopener">http://localhost:9200/_cluster/health</a></p><p>响应结果：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"cluster_name"</span>: <span class="hljs-string">"xuecheng"</span>,    <span class="hljs-attr">"status"</span>: <span class="hljs-string">"green"</span>,    <span class="hljs-attr">"timed_out"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"number_of_nodes"</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">"number_of_data_nodes"</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">"active_primary_shards"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"active_shards"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"relocating_shards"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"initializing_shards"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"unassigned_shards"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"delayed_unassigned_shards"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"number_of_pending_tasks"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"number_of_in_flight_fetch"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"task_max_waiting_in_queue_millis"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"active_shards_percent_as_number"</span>: <span class="hljs-number">100.0</span>&#125;</code></pre></div><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>1）创建映射并写入文档</p><p>连接 其中任意一台结点，创建映射写入文档。</p><p>POST <a href="http://localhost:9200/xc_course/doc/3" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/3</a></p><div class="hljs"><pre><code class="hljs json">&#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"spring 在java领域非常流行，java软件开发人员都在用。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,    <span class="hljs-attr">"price"</span>:<span class="hljs-number">66.6</span>&#125;</code></pre></div><p>响应结果：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,    <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,    <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"3"</span>,    <span class="hljs-attr">"_version"</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">"result"</span>: <span class="hljs-string">"created"</span>,    <span class="hljs-attr">"_shards"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">2</span>,        <span class="hljs-attr">"successful"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"failed"</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">"_seq_no"</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">"_primary_term"</span>: <span class="hljs-number">1</span>&#125;</code></pre></div><p>从上边的提示可看出，两个分片都保存成功。</p><p>2）搜索</p><p>向其它一个结点发起搜索请求，查询全部数据。</p><p>3）关闭一个结点</p><p>ES会重新选中一个主结点（前提在配置结点时允许它可以为主结点）</p><p><a href="https://qnoss.codeyee.com/20200704_11/image5" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>此时向活的结点发起搜索请求，仍然正常。</p><p>4）添加一个结点</p><p>添加结点 <code>3</code>，端口设置为：</p><p><code>http</code> 端口是：<code>9202</code></p><p>集群管理端口是 <code>9302</code></p><p>结点名：<code>xc_node_3</code></p><p>此结点的配置：</p><div class="hljs"><pre><code class="hljs json">node.master: falsenode.data: true</code></pre></div><p>启动结点3，刷新 <code>head</code>，下图显示 <code>ES</code> 将分片分在了 <code>3</code> 个结点</p><p><a href="https://qnoss.codeyee.com/20200704_11/image6" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>向结点3发起搜索请求：</p><p>GET： <a href="http://127.0.0.1:9202/xc_course/doc/_search" target="_blank" rel="noopener">http://127.0.0.1:9202/xc_course/doc/_search</a></p><p>全部数据可被正常搜索到。</p><h1 id="三、搜索服务开发"><a href="#三、搜索服务开发" class="headerlink" title="三、搜索服务开发"></a>三、搜索服务开发</h1><h2 id="1-课程搜索服务需求分析"><a href="#1-课程搜索服务需求分析" class="headerlink" title="1. 课程搜索服务需求分析"></a>1. 课程搜索服务需求分析</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p><a href="https://qnoss.codeyee.com/20200704_11/image7" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image7.png" srcset="/img/loading.gif" alt="img"></a></p><ol><li>根据分类搜索课程信息。</li><li>根据关键字搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。</li><li>根据难度等级搜索课程。</li><li>搜索结点分页显示。</li></ol><h3 id="2、搜索流程"><a href="#2、搜索流程" class="headerlink" title="2、搜索流程"></a>2、搜索流程</h3><p><a href="https://qnoss.codeyee.com/20200704_11/image8" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、课程管理服务将数据写到 <code>MySQL</code> 数据库</p><p>2、使用 <code>Logstash</code> 将 <code>MySQL</code> 数据库中的数据写到 <code>ES</code> 的索引库。</p><p>3、用户在前端搜索课程信息，请求到搜索服务。</p><p>4、搜索服务请求 <code>ES</code> 搜索课程信息。</p><h2 id="2-课程索引"><a href="#2-课程索引" class="headerlink" title="2. 课程索引"></a>2. 课程索引</h2><h3 id="1、技术方案"><a href="#1、技术方案" class="headerlink" title="1、技术方案"></a>1、技术方案</h3><p>如何维护课程索引信息？</p><p>1、当课程向 <code>MySQL</code> 添加后同时将课程信息添加到索引库。采用 <code>Logstach</code> 实现，<code>Logstach</code>会从 <code>MySQL</code> 中 将数据采集到 <code>ES</code> 索引库。</p><p>2、当课程在 <code>MySQL</code> 更新信息后同时更新该课程在索引库的信息。</p><p>采用 <code>Logstach</code> 实现。</p><p>3、当课程在 <code>MySQL</code> 删除后同时将该课程从索引库删除。</p><p>手工写程序实现，在删除课程后将索引库中该课程信息删除。</p><h3 id="2、准备课程索引信息"><a href="#2、准备课程索引信息" class="headerlink" title="2、准备课程索引信息"></a>2、准备课程索引信息</h3><p>课程发布成功在 <code>MySQL</code> 数据库存储课程发布信息，此信息作为课程索引信息。</p><h4 id="创建课程发布表"><a href="#创建课程发布表" class="headerlink" title="创建课程发布表"></a>创建课程发布表</h4><p>课程信息分布在 <code>course_base</code>、<code>course_pic</code> 等不同的表中。</p><p>课程发布成功为了方便进行索引将这几张表的数据合并在一张表中，作为课程发布信息。</p><p>创建 <code>course_pub</code> 表</p><p><a href="https://qnoss.codeyee.com/20200704_11/image9" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image9.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="创建表模型"><a href="#创建表模型" class="headerlink" title="创建表模型"></a>创建表模型</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"course_pub"</span>)<span class="hljs-meta">@GenericGenerator</span>(name = <span class="hljs-string">"jpa-assigned"</span>, strategy = <span class="hljs-string">"assigned"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoursePub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">916357110051689487L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(generator = <span class="hljs-string">"jpa-assigned"</span>)    <span class="hljs-meta">@Column</span>(length = <span class="hljs-number">32</span>)    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String users;    <span class="hljs-keyword">private</span> String mt;    <span class="hljs-keyword">private</span> String st;    <span class="hljs-keyword">private</span> String grade;    <span class="hljs-keyword">private</span> String studymodel;    <span class="hljs-keyword">private</span> String teachmode;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-keyword">private</span> String pic;<span class="hljs-comment">//图片</span>    <span class="hljs-keyword">private</span> Date timestamp;<span class="hljs-comment">//时间戳</span>    <span class="hljs-keyword">private</span> String charge;+    <span class="hljs-keyword">private</span> String valid;    <span class="hljs-keyword">private</span> String qq;    <span class="hljs-keyword">private</span> Float price;    <span class="hljs-keyword">private</span> Float price_old;    <span class="hljs-keyword">private</span> String expires;    <span class="hljs-keyword">private</span> String teachplan;<span class="hljs-comment">//课程计划</span>    <span class="hljs-meta">@Column</span>(name=<span class="hljs-string">"pub_time"</span>)    <span class="hljs-keyword">private</span> String pubTime;<span class="hljs-comment">//课程发布时间</span>&#125;</code></pre></div><h4 id="添加课程索引"><a href="#添加课程索引" class="headerlink" title="添加课程索引"></a>添加课程索引</h4><p>我们需要在课程发成功后执行添加课程索引的操作</p><p>1）创建 <code>course_pub</code> 表的 <code>dao</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoursePubRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">CoursePub</span>, <span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><ol><li>修改课程发布</li></ol><p>我们先将添加索引拆分为两个方法：createCoursePub、saveCoursePub</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//保存CoursePub</span><span class="hljs-function"><span class="hljs-keyword">private</span> CoursePub <span class="hljs-title">saveCoursePub</span><span class="hljs-params">(String id, CoursePub coursePub)</span></span>&#123;    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(id))&#123;    ExceptionCast.cast(CourseCode.COURSE_PUBLISH_COURSEIDISNULL);    &#125;     CoursePub coursePubNew = <span class="hljs-keyword">null</span>;    Optional&lt;CoursePub&gt; coursePubOptional = coursePubRepository.findById(id);    <span class="hljs-keyword">if</span>(coursePubOptional.isPresent())&#123;    coursePubNew = coursePubOptional.get();    &#125;     <span class="hljs-keyword">if</span>(coursePubNew == <span class="hljs-keyword">null</span>)&#123;    coursePubNew = <span class="hljs-keyword">new</span> CoursePub();    &#125;     BeanUtils.copyProperties(coursePub,coursePubNew);    <span class="hljs-comment">//设置主键</span>    coursePubNew.setId(id);    <span class="hljs-comment">//更新时间戳为最新时间</span>    coursePub.setTimestamp(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">//发布时间</span>    SimpleDateFormat simpleDateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"YYYY-MM-dd HH:mm:ss"</span>);    String date = simpleDateFormat.format(<span class="hljs-keyword">new</span> Date());    coursePub.setPubTime(date);    coursePubRepository.save(coursePub);    <span class="hljs-keyword">return</span> coursePub;&#125;<span class="hljs-comment">//创建coursePub对象</span><span class="hljs-function"><span class="hljs-keyword">private</span> CoursePub <span class="hljs-title">createCoursePub</span><span class="hljs-params">(String id)</span></span>&#123;    CoursePub coursePub = <span class="hljs-keyword">new</span> CoursePub();    coursePub.setId(id);    <span class="hljs-comment">//基础信息</span>    Optional&lt;CourseBase&gt; courseBaseOptional = courseBaseRepository.findById(id);    <span class="hljs-keyword">if</span>(courseBaseOptional == <span class="hljs-keyword">null</span>)&#123;        CourseBase courseBase = courseBaseOptional.get();        BeanUtils.copyProperties(courseBase, coursePub);    &#125;     <span class="hljs-comment">//查询课程图片</span>    Optional&lt;CoursePic&gt; picOptional = coursePicRepository.findById(id);    <span class="hljs-keyword">if</span>(picOptional.isPresent())&#123;        CoursePic coursePic = picOptional.get();        BeanUtils.copyProperties(coursePic, coursePub);    &#125;     <span class="hljs-comment">//课程营销信息</span>    Optional&lt;CourseMarket&gt; marketOptional = courseMarketRepository.findById(id);    <span class="hljs-keyword">if</span>(marketOptional.isPresent())&#123;        CourseMarket courseMarket = marketOptional.get();        BeanUtils.copyProperties(courseMarket, coursePub);    &#125;     <span class="hljs-comment">//课程计划</span>    TeachplanNode teachplanNode = teachplanMapper.selectList(id);    <span class="hljs-comment">//将课程计划转成json</span>    String teachplanString = JSON.toJSONString(teachplanNode);    coursePub.setTeachplan(teachplanString);    <span class="hljs-keyword">return</span> coursePub;&#125;</code></pre></div><p>3）修改课程方法，调用 <code>createCoursePub</code> 和 <code>saveCoursePub</code> 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//课程发布</span><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> CoursePublishResult <span class="hljs-title">publish</span><span class="hljs-params">(String courseId)</span></span>&#123;    ....    <span class="hljs-comment">//创建课程索引</span>    <span class="hljs-comment">//创建课程索引信息</span>    CoursePub coursePub = createCoursePub(courseId);    <span class="hljs-comment">//向数据库保存课程索引信息</span>    CoursePub newCoursePub = saveCoursePub(courseId, coursePub);    <span class="hljs-keyword">if</span>(newCoursePub==<span class="hljs-keyword">null</span>)&#123;    <span class="hljs-comment">//创建课程索引信息失败</span>ExceptionCast.cast(CourseCode.COURSE_PUBLISH_CREATE_INDEX_ERROR);    &#125;    ....&#125;</code></pre></div><h3 id="3、搭建ES环境"><a href="#3、搭建ES环境" class="headerlink" title="3、搭建ES环境"></a>3、搭建ES环境</h3><p>创建索引库 ， 创建 <code>xc_course</code> 索引库，1分片，0个副本。</p><p><a href="https://qnoss.codeyee.com/20200704_11/image10" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>创建映射</p><p>POST: <a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"description"</span>: &#123;            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"grade"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"id"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"mt"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"name"</span>: &#123;            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"users"</span>: &#123;            <span class="hljs-attr">"index"</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"charge"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"valid"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"pic"</span>: &#123;            <span class="hljs-attr">"index"</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"qq"</span>: &#123;            <span class="hljs-attr">"index"</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"price"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>        &#125;,        <span class="hljs-attr">"price_old"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>        &#125;,        <span class="hljs-attr">"st"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"status"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"teachmode"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"teachplan"</span>: &#123;            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"expires"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>        &#125;,        <span class="hljs-attr">"pub_time"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>        &#125;,        <span class="hljs-attr">"start_time"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>        &#125;,        <span class="hljs-attr">"end_time"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>        &#125;    &#125;&#125;</code></pre></div><h3 id="4、Logstash创建索引"><a href="#4、Logstash创建索引" class="headerlink" title="4、Logstash创建索引"></a>4、Logstash创建索引</h3><p>Logstash是ES下的一款开源软件，它能够同时 从多个来源采集数据、转换数据，然后将数据发送 <code>Eleasticsearch</code> 中创建索引。</p><p>本项目使用 <code>Logstash</code> 将 <code>MySQL</code> 中的数据采用到ES索引中。</p><h4 id="下载-Logstash"><a href="#下载-Logstash" class="headerlink" title="下载 Logstash"></a>下载 Logstash</h4><p>下载的 <code>Logstash</code> 要和ES的版本保持一致，下载地址 <a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a></p><p>下载完成后解压即可</p><h4 id="安装-Logstash"><a href="#安装-Logstash" class="headerlink" title="安装 Logstash"></a>安装 Logstash</h4><p><code>ogstash-input-jdbc</code> 是<code>ruby</code>开发的，先下载 <code>ruby</code> 并安装</p><p>下载地址: <a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">https://rubyinstaller.org/downloads/</a></p><p>安装完成查看是否安装成功 <code>ruby -v</code></p><p><code>6.x</code> 版本本身不带 <code>logstash-input-jdbc</code> 插件，需要手动安装 ，在bin目录下执行以下命令</p><div class="hljs"><pre><code class="hljs shell">.\logstash-plugin.bat install logstash-input-jdbc</code></pre></div><p><a href="https://qnoss.codeyee.com/20200704_11/image11" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p>安装成功后我们可以在 <code>logstash</code> 根目录下的 <code>vendor\bundle\jruby\2.5.0\gems</code> 目录查看对应的插件版本</p><h4 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h4><p><code>Logstash</code> 的工作是从 <code>MySQL</code> 中读取数据，向ES中创建索引，这里需要提前创建 <code>mapping</code> 的模板文件以便 <code>logstash</code> 使用。</p><p>在 <code>logstach</code> 的 <code>config</code> 目录创建 <code>xc_course_template.json</code>，内容如下：</p><div class="hljs"><pre><code class="hljs json">&#123;   <span class="hljs-attr">"mappings"</span> : &#123;      <span class="hljs-attr">"doc"</span> : &#123;         <span class="hljs-attr">"properties"</span> : &#123;            <span class="hljs-attr">"charge"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"description"</span> : &#123;               <span class="hljs-attr">"analyzer"</span> : <span class="hljs-string">"ik_max_word"</span>,               <span class="hljs-attr">"search_analyzer"</span> : <span class="hljs-string">"ik_smart"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>            &#125;,            <span class="hljs-attr">"end_time"</span> : &#123;               <span class="hljs-attr">"format"</span> : <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"date"</span>            &#125;,            <span class="hljs-attr">"expires"</span> : &#123;               <span class="hljs-attr">"format"</span> : <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"date"</span>            &#125;,            <span class="hljs-attr">"grade"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"id"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"mt"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"name"</span> : &#123;               <span class="hljs-attr">"analyzer"</span> : <span class="hljs-string">"ik_max_word"</span>,               <span class="hljs-attr">"search_analyzer"</span> : <span class="hljs-string">"ik_smart"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>            &#125;,            <span class="hljs-attr">"pic"</span> : &#123;               <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"price"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"float"</span>            &#125;,            <span class="hljs-attr">"price_old"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"float"</span>            &#125;,            <span class="hljs-attr">"pub_time"</span> : &#123;               <span class="hljs-attr">"format"</span> : <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"date"</span>            &#125;,            <span class="hljs-attr">"qq"</span> : &#123;               <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"st"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"start_time"</span> : &#123;               <span class="hljs-attr">"format"</span> : <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"date"</span>            &#125;,            <span class="hljs-attr">"status"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"studymodel"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"teachmode"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;,            <span class="hljs-attr">"teachplan"</span> : &#123;               <span class="hljs-attr">"analyzer"</span> : <span class="hljs-string">"ik_max_word"</span>,               <span class="hljs-attr">"search_analyzer"</span> : <span class="hljs-string">"ik_smart"</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>            &#125;,            <span class="hljs-attr">"users"</span> : &#123;               <span class="hljs-attr">"index"</span> : <span class="hljs-literal">false</span>,               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"text"</span>            &#125;,            <span class="hljs-attr">"valid"</span> : &#123;               <span class="hljs-attr">"type"</span> : <span class="hljs-string">"keyword"</span>            &#125;         &#125;      &#125;   &#125;,   <span class="hljs-attr">"template"</span> : <span class="hljs-string">"xc_course"</span>&#125;</code></pre></div><p>该文件对于的是ES库中的映射</p><h4 id="配置-mysql-conf"><a href="#配置-mysql-conf" class="headerlink" title="配置 mysql.conf"></a>配置 mysql.conf</h4><p>在 <code>logstash</code> 的 <code>config</code> 目录下配置 <code>mysql.conf</code>文件供 <code>logstash</code> 使用，<code>logstash</code> 会根据<code>mysql.conf</code> 文件的配置的地址从 <code>MySQL</code> 中读取数据向 <code>ES</code> 中写入索引。</p><p>参考 <a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html</a></p><p>配置输入数据源和输出数据源。</p><div class="hljs"><pre><code class="hljs conf">input &#123;    stdin &#123;    &#125;     jdbc &#123;        jdbc_connection_string &#x3D;&gt; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;xc_course?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;UTC&quot;        # 数据库信息        jdbc_user &#x3D;&gt; &quot;root&quot;        jdbc_password &#x3D;&gt; 123123        # MYSQL 驱动地址,修改为maven仓库对应的位置        jdbc_driver_library &#x3D;&gt; &quot;D:&#x2F;soft&#x2F;apache-maven-3.5.4&#x2F;repository&#x2F;mysql&#x2F;mysql-connector-java&#x2F;5.1.40&#x2F;mysql-        connector-java-5.1.40.jar&quot;        # the name of the driver class for mysql        jdbc_driver_class &#x3D;&gt; &quot;com.mysql.jdbc.Driver&quot;        jdbc_paging_enabled &#x3D;&gt; &quot;true&quot;        jdbc_page_size &#x3D;&gt; &quot;50000&quot;        #要执行的sql文件        #statement_filepath &#x3D;&gt; &quot;&#x2F;conf&#x2F;course.sql&quot;# 这里我们采用直接sql语句的形式, 因为logstash默认采用的是UTC标准时间,我们这里需要加上8小时        statement &#x3D;&gt; &quot;select * from course_pub where timestamp &gt; date_add(:sql_last_value,INTERVAL 8 HOUR)&quot;        #定时配置        schedule &#x3D;&gt; &quot;* * * * *&quot;        record_last_run &#x3D;&gt; true        last_run_metadata_path &#x3D;&gt; &quot;D:&#x2F;soft&#x2F;elasticsearch&#x2F;logstash-6.8.8&#x2F;config&#x2F;logstash_metadata&quot;        &#125;    &#125;     output &#123;        elasticsearch &#123;        #ES的ip地址和端口        hosts &#x3D;&gt; &quot;localhost:9200&quot;        #hosts &#x3D;&gt; [&quot;localhost:9200&quot;,&quot;localhost:9202&quot;,&quot;localhost:9203&quot;]        #ES索引库名称        index &#x3D;&gt; &quot;xc_course&quot;        document_id &#x3D;&gt; &quot;%&#123;id        document_type &#x3D;&gt; &quot;doc&quot;        template &#x3D;&gt;&quot;D:&#x2F;soft&#x2F;elasticsearch&#x2F;logstash-6.8.8&#x2F;config&#x2F;xc_course_template.json&quot;        template_name &#x3D;&gt; &quot;xc_course&quot;        template_overwrite &#x3D;&gt;&quot;true&quot;    &#125; stdout &#123;    #日志输出    codec &#x3D;&gt; json_lines    &#125;&#125;</code></pre></div><p>说明：</p><p>1、<code>ES</code> 采用 <code>UTC</code> 时区问题</p><p><code>ES</code> 采用 <code>UTC</code> 时区，比北京时间早8小时，所以 <code>ES</code> 读取数据时让最后更新时间加8小时<br><code>where timestamp &gt; date_add(:sql_last_value,INTERVAL 8 HOUR)</code></p><p>2、<code>logstash</code> 每个执行完成会在 <code>config/logstash_metadata</code> 记录执行时间下次以此时间为基准进行增量同步数据到索引库。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动 <code>logstash.bat</code></p><div class="hljs"><pre><code class="hljs c">.\logstash.bat -f ..\<span class="hljs-built_in">config</span>\mysql.conf</code></pre></div><p><a href="https://qnoss.codeyee.com/20200704_11/image12" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>修改 <code>course_pub</code> 中的数据，并且修改 <code>timestamp</code> 为当前时间，观察 <code>Logstash</code> 日志是否读取到要索引的数据。</p><p>最后用 <code>head</code> 登录 <code>ES</code> 查看索引文档内容是否修改。</p><p><a href="https://qnoss.codeyee.com/20200704_11/image13" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image13.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-课程搜索实战"><a href="#3-课程搜索实战" class="headerlink" title="3. 课程搜索实战"></a>3. 课程搜索实战</h2><h3 id="1、需求分析-1"><a href="#1、需求分析-1" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>1、根据 <strong>分类</strong> 搜索课程信息。</p><p>2、根据 <strong>关键字</strong> 搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。</p><p>3、根据 <strong>难度等级</strong> 搜索课程。</p><p>4、搜索结点分页显示。</p><h4 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h4><p>1、根据关键字搜索，采用 <code>MultiMatchQuery</code>，搜索 <code>name</code>、<code>description</code>、<code>teachplan</code></p><p>2、根据分类、课程等级搜索采用过虑器实现。</p><p>3、分页查询。</p><p>4、高亮显示。</p><h3 id="2、创建搜索服务工程"><a href="#2、创建搜索服务工程" class="headerlink" title="2、创建搜索服务工程"></a>2、创建搜索服务工程</h3><p>该工程环境我们在 <code>day10</code> 已经搭建完成，如果你未学习前面的章节，请参考 <code>day10 六、索引管理</code> 的内容。</p><h3 id="3、构建API"><a href="#3、构建API" class="headerlink" title="3、构建API"></a>3、构建API</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.search;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CoursePub;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.search.CourseSearchParam;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"课程搜索"</span>, description = <span class="hljs-string">"基于ES构建的课程搜索API"</span>,tags = &#123;<span class="hljs-string">"课程搜索"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EsCourseConrollerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"课程详细搜索"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;CoursePub&gt; <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, CourseSearchParam courseSearchParam)</span> <span class="hljs-keyword">throws</span> IOException</span>;&#125;</code></pre></div><h3 id="4、Service"><a href="#4、Service" class="headerlink" title="4、Service"></a>4、Service</h3><h4 id="按关键词搜索"><a href="#按关键词搜索" class="headerlink" title="按关键词搜索"></a>按关键词搜索</h4><p>在 <code>appliction.yml</code> 中配置 <code>source_field</code></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">elasticsearch:</span>    <span class="hljs-attr">hostlist:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9200</span> <span class="hljs-comment">#多个结点中间用逗号分隔</span>    <span class="hljs-attr">course:</span>    <span class="hljs-attr">index:</span> <span class="hljs-string">xc_course</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">doc</span>    <span class="hljs-attr">source_field:</span> <span class="hljs-string">id,name,grade,mt,st,charge,valid,pic,qq,price,price_old,status,studymodel,teachmode,expires,pub_time,start_time,end_time</span></code></pre></div><p><code>service</code> 完整代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 课程列表搜索</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> size 每页数量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseSearchParam 搜索参数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;CoursePub&gt; <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, CourseSearchParam courseSearchParam)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;    <span class="hljs-comment">//设置索引</span>    SearchRequest searchRequest = <span class="hljs-keyword">new</span> SearchRequest(es_index);    <span class="hljs-comment">//设置类型</span>    searchRequest.types(es_type);    <span class="hljs-comment">//创建搜索源对象</span>    SearchSourceBuilder searchSourceBuilder = <span class="hljs-keyword">new</span> SearchSourceBuilder();    <span class="hljs-comment">//创建布尔查询对象</span>    BoolQueryBuilder boolQueryBuilder = <span class="hljs-keyword">new</span> BoolQueryBuilder();    <span class="hljs-comment">//源字段过滤</span>    String[] fieldArr = source_field.split(<span class="hljs-string">","</span>);    searchSourceBuilder.fetchSource(fieldArr,<span class="hljs-keyword">new</span> String[]&#123;&#125;);    <span class="hljs-comment">//根据关键字进行查询</span>    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getKeyword()))&#123;        <span class="hljs-comment">//匹配关键词</span>        MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), <span class="hljs-string">"name"</span>, <span class="hljs-string">"teachplan"</span>, <span class="hljs-string">"description"</span>);        <span class="hljs-comment">//设置匹配占比</span>        multiMatchQueryBuilder.minimumShouldMatch(<span class="hljs-string">"70%"</span>);        <span class="hljs-comment">//提升字段的权重值</span>        multiMatchQueryBuilder.field(<span class="hljs-string">"name"</span>,<span class="hljs-number">10</span>);        boolQueryBuilder.must(multiMatchQueryBuilder);    &#125;    <span class="hljs-comment">//根据难度进行过滤</span>    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123;        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"mt"</span>,courseSearchParam.getMt()));    &#125;    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123;        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"st"</span>,courseSearchParam.getSt()));    &#125;    <span class="hljs-comment">//根据等级进行过滤</span>    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123;        boolQueryBuilder.filter(QueryBuilders.termQuery(<span class="hljs-string">"grade"</span>,courseSearchParam.getGrade()));    &#125;    <span class="hljs-comment">//设置分页参数</span>    <span class="hljs-keyword">if</span>(page&lt;=<span class="hljs-number">0</span>)&#123;        page = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">0</span>)&#123;        size = <span class="hljs-number">20</span>;    &#125;    <span class="hljs-comment">//计算搜索起始位置</span>    <span class="hljs-keyword">int</span> start = (page-<span class="hljs-number">1</span>) * size;    searchSourceBuilder.from(start);    searchSourceBuilder.size(size);    <span class="hljs-comment">//将布尔查询对象添加到搜索源内</span>    searchSourceBuilder.query(boolQueryBuilder);    <span class="hljs-comment">//配置高亮信息</span>    HighlightBuilder highlightBuilder = <span class="hljs-keyword">new</span> HighlightBuilder();    highlightBuilder.preTags(<span class="hljs-string">"&lt;font class='eslight'&gt;"</span>);    highlightBuilder.postTags(<span class="hljs-string">"&lt;/font&gt;"</span>);    <span class="hljs-comment">//设置高亮字段</span>    highlightBuilder.fields().add(<span class="hljs-keyword">new</span> HighlightBuilder.Field(<span class="hljs-string">"name"</span>));    searchSourceBuilder.highlighter(highlightBuilder);    <span class="hljs-comment">//请求搜索</span>    searchRequest.source(searchSourceBuilder);    SearchResponse searchResponse = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span>&#123;        searchResponse = restHighLevelClient.search(searchRequest);    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;        <span class="hljs-comment">//搜索异常</span>        e.printStackTrace();        LOGGER.error(<span class="hljs-string">"search error ...&#123;&#125;"</span>,e.getMessage());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult&lt;&gt;(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//结果收集处理</span>    SearchHits hits = searchResponse.getHits();    <span class="hljs-comment">//获取匹配度高的结果</span>    SearchHit[] searchHits = hits.getHits();    <span class="hljs-comment">//总记录数</span>    <span class="hljs-keyword">long</span> totalHits = hits.getTotalHits();    <span class="hljs-comment">//数据列表</span>    ArrayList&lt;CoursePub&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">//添加数据</span>    <span class="hljs-keyword">for</span> (SearchHit hit: searchHits)&#123;        CoursePub coursePub = <span class="hljs-keyword">new</span> CoursePub();        Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();        <span class="hljs-comment">//取出名称</span>        String name = (String) sourceAsMap.get(<span class="hljs-string">"name"</span>);        coursePub.setName(name);        <span class="hljs-comment">//图片</span>        String pic = (String) sourceAsMap.get(<span class="hljs-string">"pic"</span>);        coursePub.setPic(pic);        <span class="hljs-comment">//优惠后的价格</span>        Float price = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(sourceAsMap.get(<span class="hljs-string">"price"</span>) !=<span class="hljs-keyword">null</span>)&#123;                price = Float.parseFloat(String.format(<span class="hljs-string">"%.3f"</span>,sourceAsMap.get(<span class="hljs-string">"price"</span>)));            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;        coursePub.setPrice(price);        <span class="hljs-comment">//优惠前的价格</span>        Float priceOld = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(sourceAsMap.get(<span class="hljs-string">"price_old"</span>) !=<span class="hljs-keyword">null</span>)&#123;                priceOld = Float.parseFloat(String.format(<span class="hljs-string">"%.3f"</span>,sourceAsMap.get(<span class="hljs-string">"price_old"</span>)));            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;        coursePub.setPrice_old(priceOld);        list.add(coursePub);    &#125;    <span class="hljs-comment">//返回响应结果</span>    QueryResult&lt;CoursePub&gt; queryResult = <span class="hljs-keyword">new</span> QueryResult&lt;&gt;();    queryResult.setList(list);    queryResult.setTotal(totalHits);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult&lt;&gt;(CommonCode.SUCCESS,queryResult);&#125;</code></pre></div><p>servcice 的代码中的注释已经写得很详细了，这里我就不再做过多的解释，请详细的阅读上述的代码。</p><h3 id="5、Controller"><a href="#5、Controller" class="headerlink" title="5、Controller"></a>5、Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 课程信息搜索</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page 页码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> size 每页数量</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseSearchParam 搜索参数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list/&#123;page&#125;/&#123;size&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;CoursePub&gt; <span class="hljs-title">findList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page,@<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size, CourseSearchParam courseSearchParam) <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">return</span> esCourseService.findList(page,size,courseSearchParam);&#125;</code></pre></div><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><h4 id="根据关键字搜索"><a href="#根据关键字搜索" class="headerlink" title="根据关键字搜索"></a>根据关键字搜索</h4><p>使用 <code>postman</code> 测试</p><p>GET: <a href="http://localhost:40100/search/course/list/1/20?keyword=java" target="_blank" rel="noopener">http://localhost:40100/search/course/list/1/20?keyword=java</a> 开发</p><p><a href="https://qnoss.codeyee.com/20200704_11/image14" target="_blank" rel="noopener"><img src="/2020/08/18/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday11/image14.gif" srcset="/img/loading.gif" alt="img"></a></p><h4 id="根据价格、等级、难度进行搜索"><a href="#根据价格、等级、难度进行搜索" class="headerlink" title="根据价格、等级、难度进行搜索"></a>根据价格、等级、难度进行搜索</h4><p>待测试</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day10：课程发布、ElasticSearch</title>
    <link href="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/"/>
    <url>/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day10</code> 的内容</p><ul><li>课程发布功能开发</li><li><code>ElasticsSearch</code> 安装部署</li><li><code>ElasticsSearch</code> 快速入门、<code>IK</code> 分词器、映射、索引</li></ul><h1 id="一、课程发布"><a href="#一、课程发布" class="headerlink" title="一、课程发布"></a>一、课程发布</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>课程发布后将生成正式的课程详情页面，课程发布后用户即可浏览课程详情页面，并开始课程的学习。课程发布生成课程详情页面的流程与课程预览业务流程相同，如下：</p><p>1、用户进入教学管理中心，进入某个课程的管理界面</p><p>2、点击课程发布，前端请求到课程管理服务</p><p>3、课程管理服务远程调用 <code>CMS</code> 生成课程发布页面，<code>CMS</code> 将课程详情页面发布到服务器</p><p>4、课程管理服务修改课程发布状态为 “<strong>已发布</strong>”，并向前端返回发布成功</p><p>5、用户在教学管理中心点击 “课程详情页面” 链接，查看课程详情页面内容</p><p>流程图如下</p><p><a href="https://qnoss.codeyee.com/20200704_10/image1" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image1.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-CMS一键发布接口"><a href="#2-CMS一键发布接口" class="headerlink" title="2. CMS一键发布接口"></a>2. CMS一键发布接口</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>根据需求分析内容，需要在 <code>cms</code> 服务增加页面发布接口供课程管理服务调用，此接口的功能如下：</p><p>1、接收课程管理服务发布的页面信息</p><p>2、将页面信息添加到 数据库<strong>（mongodb）</strong></p><p>3、对页面信息进行静态化</p><p>4、将页面信息发布到服务器</p><h3 id="2、接口定义"><a href="#2、接口定义" class="headerlink" title="2、接口定义"></a>2、接口定义</h3><p>1、创建响应结果类型</p><p>页面发布成功cms返回页面的 <code>url</code></p><p>页面 <code>Url</code> = <code>cmsSite.siteDomain</code> + <code>cmsSite.siteWebPath</code> + <code>cmsPage.pageWebPath</code> + <code>cmsPage.pageName</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPostPageResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    String pageUrl;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmsPostPageResult</span><span class="hljs-params">(ResultCode resultCode,String pageUrl)</span></span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.pageUrl = pageUrl;    &#125;&#125;</code></pre></div><p>2、在 <code>api</code> 工程定义页面发布接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 一键发布页面</span><span class="hljs-comment">*/</span><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"一键发布页面"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPostPageResult <span class="hljs-title">postPageQuick</span><span class="hljs-params">(CmsPage cmsPage)</span></span>;</code></pre></div><h3 id="3、Dao"><a href="#3、Dao" class="headerlink" title="3、Dao"></a>3、Dao</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 继承MongoDB自带的一些Repository</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsSiteRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsSite</span>,<span class="hljs-title">String</span></span>&#123;&#125;</code></pre></div><h3 id="4、Service"><a href="#4、Service" class="headerlink" title="4、Service"></a>4、Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 一键发布页面</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cmsPage</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPostPageResult <span class="hljs-title">postPageQuick</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-comment">//添加页面，这里直接调用我们在做预览页面时候开发的保存页面方法</span>    CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.saveCmsPage(cmsPage);    <span class="hljs-keyword">if</span>(!cmsPageResult.isSuccess())&#123;        <span class="hljs-comment">//添加页面失败</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPostPageResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;    CmsPage saveCmsPage = cmsPageResult.getCmsPage();    String pageId = saveCmsPage.getPageId();    <span class="hljs-comment">//发布页面,通知cms client发布页面</span>    ResponseResult responseResult = <span class="hljs-keyword">this</span>.postPage(pageId);    <span class="hljs-keyword">if</span>(!responseResult.isSuccess())&#123;        <span class="hljs-comment">//发布失败</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPostPageResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//得到页面的url，页面url=站点域名+站点webpath+页面webpath+页面名称</span>    <span class="hljs-comment">//所以这里我们需要获取站点信息</span>    String siteId = saveCmsPage.getSiteId();    Optional&lt;CmsSite&gt; cmsSiteOptional = cmsSiteRepository.findById(siteId);    <span class="hljs-keyword">if</span>(!cmsSiteOptional.isPresent())&#123;        <span class="hljs-comment">//获取站点异常</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPostPageResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;    CmsSite cmsSite = cmsSiteOptional.get();    <span class="hljs-comment">//站点和页面的信息</span>    String siteDomain = cmsSite.getSiteDomain();    String siteWebPath = cmsSite.getSiteWebPath();    String pageWebPath = saveCmsPage.getPageWebPath();    String pageName = saveCmsPage.getPageName();    <span class="hljs-comment">//发布页面的访问地址</span>    String pageUrl = siteDomain + siteWebPath + pageWebPath + pageName;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPostPageResult(CommonCode.SUCCESS, pageUrl);&#125;</code></pre></div><p>2、页面发布方法</p><h3 id="5、Controller"><a href="#5、Controller" class="headerlink" title="5、Controller"></a>5、Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 一键发布页面</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cmsPage</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/postPageQuick"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPostPageResult <span class="hljs-title">postPageQuick</span><span class="hljs-params">(@RequestBody CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-keyword">return</span> pageService.postPageQuick(cmsPage);&#125;</code></pre></div><h2 id="3-课程发布接口"><a href="#3-课程发布接口" class="headerlink" title="3. 课程发布接口"></a>3. 课程发布接口</h2><h3 id="1、API接口"><a href="#1、API接口" class="headerlink" title="1、API接口"></a>1、API接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"课程发布"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CoursePublishResult <span class="hljs-title">CoursePublish</span><span class="hljs-params">(String courseId)</span></span>;</code></pre></div><h3 id="2、创建Feign-Client"><a href="#2、创建Feign-Client" class="headerlink" title="2、创建Feign Client"></a>2、创建Feign Client</h3><p>定义一个远程调用的方法，用于远程调用刚才我们在 CMS 服务中定义的一键发布接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"XC-SERVICE-MANAGE-CMS"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageClient</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/cms/page/postPageQuick"</span>)    <span class="hljs-function">CmsPostPageResult <span class="hljs-title">postPageQuick</span><span class="hljs-params">(@RequestBody CmsPage cmsPage)</span></span>;&#125;</code></pre></div><h3 id="3、Service"><a href="#3、Service" class="headerlink" title="3、Service"></a>3、Service</h3><p><strong>1、配置课程发布页面参数</strong></p><p>新增课程详情页面的站点信息，如果已增加课程详情页面的站点则忽略此步骤。</p><p>向 <code>mongodb</code> 的 <code>cms_site</code> 中新增如下信息</p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"5b30b052f58b4411fc6cb1cf"</span>),     <span class="hljs-attr">"_class"</span> : <span class="hljs-string">"com.xuecheng.framework.domain.cms.CmsSite"</span>,     <span class="hljs-attr">"siteName"</span> : <span class="hljs-string">"课程详情站点"</span>,     <span class="hljs-attr">"siteDomain"</span> : <span class="hljs-string">"http://www.xuecheng.com"</span>,     <span class="hljs-attr">"sitePort"</span> : <span class="hljs-string">"80"</span>,     <span class="hljs-attr">"siteWebPath"</span> : <span class="hljs-string">"/"</span>,     <span class="hljs-attr">"siteCreateTime"</span> : ISODate(<span class="hljs-string">"2018-02-03T02:34:19.113+0000"</span>)&#125;</code></pre></div><p>在 <code>application.yml</code> 中配置</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">course-publish:</span>  <span class="hljs-attr">siteId:</span> <span class="hljs-string">5b30b052f58b4411fc6cb1cf</span>  <span class="hljs-attr">templateId:</span> <span class="hljs-string">5e93d2e3d79e7d6ed1009b95</span>  <span class="hljs-attr">previewUrl:</span> <span class="hljs-string">http://www.xuecheng.com/cms/preview/</span>  <span class="hljs-attr">pageWebPath:</span> <span class="hljs-string">/course/detail/</span>  <span class="hljs-attr">pagePhysicalPath:</span> <span class="hljs-string">G:/job/code/Project/XueChengOnline/xcEduUI01/xuecheng/static/course/detail/</span>  <span class="hljs-attr">dataUrlPre:</span> <span class="hljs-string">http://localhost:31200/course/preview/model/</span></code></pre></div><ul><li><code>siteId</code>：站点<code>id</code></li><li><code>templateId</code>：模板<code>id</code></li><li><code>dataurlPre</code>：数据<code>url</code>的前缀</li><li><code>pageWebPath</code>: 页面的 <code>web</code> 访问路径</li><li><code>pagePhysicalPath</code>： 这个指的是页面要发布到 <code>nginx</code> 服务器的物理路径，我们在配置文件中定义，可以动态调整，便于扩展。</li></ul><p><strong>2、service 方法如下</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//拼装页面信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> CmsPage <span class="hljs-title">setPageInfo</span><span class="hljs-params">(String courseId)</span></span>&#123;    <span class="hljs-comment">//获取课程信息</span>    CourseBase courseBaseById = <span class="hljs-keyword">this</span>.findCourseBaseById(courseId);    <span class="hljs-comment">//拼装页面基本信息</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    cmsPage.setDataUrl(publish_dataUrlPre + courseId);    cmsPage.setPagePhysicalPath(publish_page_physicalpath);    cmsPage.setPageWebPath(publish_page_webpath);    cmsPage.setSiteId(publish_siteId);    cmsPage.setTemplateId(publish_templateId);    cmsPage.setPageName(courseId + <span class="hljs-string">".html"</span>);    <span class="hljs-comment">//页面别名</span>    cmsPage.setPageAliase(courseBaseById.getName());    <span class="hljs-keyword">return</span> cmsPage;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 课程详细页面发布</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> CoursePublishResult <span class="hljs-title">coursePublish</span><span class="hljs-params">(String courseId)</span></span>&#123;    <span class="hljs-comment">//拼装页面信息</span>    CmsPage cmsPage = setPageInfo(courseId);    <span class="hljs-comment">//发布课程详细页面</span>    CmsPostPageResult cmsPostPageResult = cmsPageClient.postPageQuick(cmsPage);    <span class="hljs-keyword">if</span>(!cmsPostPageResult.isSuccess())&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoursePublishResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//更新课程状态</span>    CourseBase courseBaseById = <span class="hljs-keyword">this</span>.findCourseBaseById(courseId);    courseBaseById.setStatus(<span class="hljs-string">"202002"</span>);    courseBaseRepository.save(courseBaseById);    <span class="hljs-comment">//课程索引...</span>    <span class="hljs-comment">//课程缓存...</span>    <span class="hljs-comment">//页面url</span>    String pageUrl = cmsPostPageResult.getPageUrl();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoursePublishResult(CommonCode.SUCCESS,pageUrl);&#125;</code></pre></div><h3 id="4、Controller"><a href="#4、Controller" class="headerlink" title="4、Controller"></a>4、Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 课程发布</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/publish/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CoursePublishResult <span class="hljs-title">CoursePublish</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.coursePublish(courseId);&#125;</code></pre></div><p>5、接口测试</p><h2 id="4-测试CMS一键发布接口"><a href="#4-测试CMS一键发布接口" class="headerlink" title="4. 测试CMS一键发布接口"></a>4. 测试CMS一键发布接口</h2><p><strong>测试前准备工作</strong></p><p>1、启动<code>RabbitMQ</code>服务<br>2、启动 <code>cms</code> 、<code>course</code> 服务<br>3、启动 <code>cms_client</code>，注意配置 <code>routingKey</code> 和队列名称，<code>routingKey</code> 为所使用的站点id</p><p>4、这里我们分别在 <code>course</code> 、<code>cms</code>、cms client 三个服务内对应的地方打上断点，观察发布的流程</p><p><code>course</code> 服务断点，我们设置在远程调用 cms 一键发布接口返回结果之后</p><p><a href="https://qnoss.codeyee.com/20200704_10/image2" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>cms 服务断点，在 <strong>一键发布接口</strong> 开始执行的地方我们打上断点</p><p><a href="https://qnoss.codeyee.com/20200704_10/image3" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>当 cms 客户端接收到 cms 通过 rabbitMQ 发送的消息后，会调用该方法将页面保存到 nginx 服务器的物理路径内</p><p><a href="https://qnoss.codeyee.com/20200704_10/image4" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>准备工作做完了，我们在 course 服务生成的 sawgger-ui 进行测试</p><p><a href="https://qnoss.codeyee.com/20200704_10/image5" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>发送请求后，我们在 idea 中可以看到，断点已经跑到了 cms 服务的一键发布接口</p><p><a href="https://qnoss.codeyee.com/20200704_10/image6" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>继续执行的话，<code>cms</code> 服务会调用 <code>this.postPage</code> 方法，获取该页面的 数据模型、以及模板数据，将数据静态化后得到完整的页面数据，并且写入到 <code>GridFS</code> 中；</p><p>写入 <code>GridFS</code>后通过 <code>rabbitMQ</code> 发送消息到 <code>cms client</code> ，消息的内容包含一个页面<code>id</code>，入下图，断点已经走到了 <code>cms client</code> 服务的 <code>savePageToServerPath</code> 方法中</p><p><a href="https://qnoss.codeyee.com/20200704_10/image7" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image7.png" srcset="/img/loading.gif" alt="img"></a></p><p>``cms client<code>接收到</code>pageId<code>后，获取该页面数据的 fileId，通过该id到</code>GridFS` 中找到该页面的数据，并写入到页面的物理路径内，写入完成后，回到 cms 服务内拼装发布后的页面地址，再返回到 course 服务</p><p><a href="https://qnoss.codeyee.com/20200704_10/image8" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>course 服务接收到 cms 的响应，取出 pageUrl 返回到前端，如下图</p><p><a href="https://qnoss.codeyee.com/20200704_10/image9" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>回到 swagger ui，我们可以看到已经返回了一个发布成功的url</p><p><a href="https://qnoss.codeyee.com/20200704_10/image10" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>访问页面看下效果</p><p><a href="https://qnoss.codeyee.com/20200704_10/image11" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image11.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="5-前端页面开发与测试"><a href="#5-前端页面开发与测试" class="headerlink" title="5. 前端页面开发与测试"></a>5. 前端页面开发与测试</h2><p><strong>1、页面开发</strong></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-card</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box-card"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"header"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"clearfix"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>课程发布<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text item"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"course.status == '202001'"</span>&gt;</span>      状态：制作中<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>  @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"publish"</span> &gt;</span>新课程发布<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"course.status == '202003'"</span>&gt;</span>      状态：已下线      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"'http://www.xuecheng.com/course/detail/'+this.courseid+'.html'"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>点我查看课程详情页面 <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"course.status == '202002'"</span>&gt;</span>      状态：已发布<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>  @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"publish"</span> &gt;</span>修改发布<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"'http://www.xuecheng.com/course/detail/'+this.courseid+'.html'"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>点我查看课程详情页面 <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-card</span>&gt;</span></code></pre></div><p><strong>2、获取课程状态</strong></p><div class="hljs"><pre><code class="hljs js">getCourseView()&#123;  courseApi.findCourseView(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(res)&#123;        <span class="hljs-comment">//获取课程状态</span>        <span class="hljs-keyword">this</span>.course.status = res.status;    &#125;  &#125;)&#125;</code></pre></div><p>在页面初始化完成其前执行</p><div class="hljs"><pre><code class="hljs js">mounted()&#123;  <span class="hljs-comment">//课程id</span>  <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid;  <span class="hljs-comment">//查询课程信息</span>  <span class="hljs-keyword">this</span>.getCourseView();&#125;</code></pre></div><p><strong>3、页面发布接口</strong></p><p>api接口定义</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*发布课程*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> publish = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/course/publish/'</span>+id);&#125;</code></pre></div><p>api接口实现</p><div class="hljs"><pre><code class="hljs js">publish()&#123;  <span class="hljs-comment">//课程发布</span>  courseApi.publish(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;      <span class="hljs-keyword">if</span>(res.success)&#123;          <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"发布成功，请点击下边的链接查询课程详情页面"</span>)          <span class="hljs-keyword">this</span>.getCourseView();      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">this</span>.$message.error(res.message)      &#125;  &#125;)&#125;,</code></pre></div><p>测试</p><p><a href="https://qnoss.codeyee.com/20200704_10/image12" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image12.gif" srcset="/img/loading.gif" alt="img"></a></p><h1 id="二、初识-Elastic-Search"><a href="#二、初识-Elastic-Search" class="headerlink" title="二、初识 Elastic Search"></a>二、初识 Elastic Search</h1><h2 id="1-是什么？为什么？"><a href="#1-是什么？为什么？" class="headerlink" title="1. 是什么？为什么？"></a>1. 是什么？为什么？</h2><h3 id="1、简历"><a href="#1、简历" class="headerlink" title="1、简历"></a>1、简历</h3><p>百度百科</p><p><a href="https://qnoss.codeyee.com/20200704_10/image13" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image13.png" srcset="/img/loading.gif" alt="img"></a></p><p>官方网址：<a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/products/elasticsearch</a></p><p>Github ：<a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a></p><p><strong>总结：</strong></p><p>1、<code>elasticsearch</code>是一个基于<code>Lucene</code>的高扩展的分布式搜索服务器，支持开箱即用。<br>2、<code>elasticsearch</code> 隐藏了 <code>Lucene</code> 的复杂性，对外提供 <code>Restful</code> 接口来操作索引、搜索。</p><p><strong>突出优点：</strong></p><ol><li>扩展性好，可部署上百台服务器集群，处理PB级数据。</li><li>近实时的去索引数据、搜索数据。</li></ol><p>市面上的同类型的产品有 <code>solr</code> ，那么 <code>es</code> 和 <code>solr</code> 选择哪个？</p><p>如果你公司现在用的 <code>solr</code> 可以满足需求就不要换了。</p><p>如果你公司准备进行全文检索项目的开发，建议优先考虑 <code>elasticsearch</code>，因为像 <code>Github</code>这样大规模的搜索都在用它。</p><h3 id="2、原理于应用"><a href="#2、原理于应用" class="headerlink" title="2、原理于应用"></a>2、原理于应用</h3><p>索引结构</p><p>下图是 <code>ElasticSearch</code> 的索引结构，下边黑色部分是物理结构，上边黄色部分是逻辑结构，逻辑结构也是为了更好的去描述 <code>ElasticSearch</code> 的工作原理及去使用物理结构中的索引文件。</p><p><a href="https://qnoss.codeyee.com/20200704_10/image14" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image14.png" srcset="/img/loading.gif" alt="img"></a></p><p>逻辑结构部分是一个倒排索引表：</p><p>1、将要搜索的文档内容分词，所有不重复的词组成分词列表。</p><p>2、将搜索的文档最终以 <code>Document</code> 方式存储起来。</p><p>3、每个词和 <code>docment</code> 都有关联。</p><p>如下：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image15" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image15.png" srcset="/img/loading.gif" alt="img"></a></p><p>现在，如果我们想搜索 <code>quick brown</code> ，我们只需要查找包含每个词条的文档：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image16" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image16.png" srcset="/img/loading.gif" alt="img"></a></p><p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p><blockquote><p>正排索引：根据词与文章内容的关系进行索引。</p><p>倒排索引：根据词与文章的关系进行索引，需要提前对词和文章进行关联。</p></blockquote><h3 id="3、如何使用es？"><a href="#3、如何使用es？" class="headerlink" title="3、如何使用es？"></a>3、如何使用es？</h3><p><code>Elasticsearch</code> 提供 <code>RESTful Api</code> 接口进行索引、搜索，并且支持多种客户端。</p><p><a href="https://qnoss.codeyee.com/20200704_10/image17" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image17.png" srcset="/img/loading.gif" alt="img"></a></p><p>下图是es在项目中的应用方式：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image18" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p>1）用户在前端搜索关键字</p><p>2）项目前端通过 <code>http</code> 方式请求项目服务端</p><p>3）项目服务端通过 <code>Http RESTful</code> 方式请求 <code>ES</code> 集群进行搜索</p><p>4）<code>ES</code> 集群从索引库检索数据。</p><h2 id="2-安装-Elastic-Search"><a href="#2-安装-Elastic-Search" class="headerlink" title="2. 安装 Elastic Search"></a>2. 安装 Elastic Search</h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>安装配置：</p><p>1、新版本要求至少 <code>jdk1.8</code> 以上。</p><p>2、支持<code>tar</code>、<code>zip</code>、<code>rpm</code>等多种安装方式。在 <code>windows</code> 下开发建议使用ZIP安装方式。</p><p>3、支持 <code>docker</code> 方式安装</p><p>详细参见：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html</a></p><p>注意视频教程中用的是6.2.1的，为了适应较新的版本这里我这里下载 <code>6.8.8</code> 的版本作为演示</p><blockquote><p>截至现在官方已经更新 到了 7.7.*，从语义化版本规范来看，6和7应该有架构上的重大变化，所以我还是选择6系的最新一个版本避免踩坑，以后有需求再去对比7的差异。</p></blockquote><p><a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.8.8.zip" target="_blank" rel="noopener">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.8.8.zip</a></p><p>其他版本下载：<a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases</a></p><p>下载完成后我们解压 <code>elasticsearch-*.*.*.zip</code></p><p><a href="https://qnoss.codeyee.com/20200704_10/image19" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image19.png" srcset="/img/loading.gif" alt="img"></a></p><p><code>bin</code>：脚本目录，包括：启动、停止等可执行脚本</p><p><code>config</code>：配置文件目录</p><p><code>data</code>：索引目录，存放索引文件的地方</p><p><code>logs</code>：日志目录</p><p><code>modules</code>：模块目录，包括了es的功能模块</p><p><code>plugins</code> :插件目录，es支持插件机制</p><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p>ES的配置文件的地址根据安装形式的不同而不同：</p><p>1、使用 <code>zip</code>、<code>tar</code> 安装，配置文件的地址在安装目录的 <code>config</code> 下。</p><p>2、使用 <code>RPM</code> 安装，配置文件在 <code>/etc/elasticsearch</code> 下。</p><p>3、使用 <code>MSI</code> 安装，配置文件的地址在安装目录的 <code>config</code> 下，并且会自动将 <code>config</code> 目录地址写入环境变量<br><code>ES_PATH_CONF</code>。</p><p>本教程使用的 <code>zip</code> 包安装，配置文件在ES安装目录的<code>config</code>下。</p><p>配置文件如下：</p><ul><li><code>elasticsearch.yml</code> ： 用于配置Elasticsearch运行参数</li><li><code>jvm.options</code> ： 用于配置Elasticsearch JVM设置</li><li><code>log4j2.properties</code>： 用于配置Elasticsearch日志</li></ul><h4 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a><strong>elasticsearch.yml</strong></h4><p>配置格式是 <code>YAML</code>，可以采用如下两种方式：</p><p><strong>方式1：层次方式</strong></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">path:</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">/var/lib/elasticsearch</span>  <span class="hljs-attr">logs:</span> <span class="hljs-string">/var/log/elasticsearch</span></code></pre></div><p><strong>方式2：属性方式</strong></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">path.data:</span> <span class="hljs-string">/var/lib/elasticsearch</span><span class="hljs-attr">path.logs:</span> <span class="hljs-string">/var/log/elasticsearch</span></code></pre></div><p>本项目采用方式2，例子如下：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">xuecheng</span><span class="hljs-attr">node.name:</span> <span class="hljs-string">xc_node_1</span><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-attr">http.port:</span> <span class="hljs-number">9200</span><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9300</span><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-comment">#discovery.zen.ping.unicast.hosts: ["0.0.0.0:9300", "0.0.0.0:9301", "0.0.0.0:9302"]</span><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">1</span><span class="hljs-attr">bootstrap.memory_lock:</span> <span class="hljs-literal">false</span><span class="hljs-attr">node.max_local_storage_nodes:</span> <span class="hljs-number">1</span><span class="hljs-attr">path.data:</span> <span class="hljs-string">D:\ElasticSearch\elasticsearch‐6.2.1\data</span><span class="hljs-attr">path.logs:</span> <span class="hljs-string">D:\ElasticSearch\elasticsearch‐6.2.1\logs</span><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><span class="hljs-string">http.cors.allow‐origin:</span> <span class="hljs-string">/.*/</span></code></pre></div><p>注意 <code>path.data</code> 和 <code>path.logs</code> 路径配置正确。</p><p>常用的配置项如下：</p><table><thead><tr><th>配置字段</th><th>描述</th></tr></thead><tbody><tr><td>cluster.name</td><td>配置 <code>elasticsearch</code> 的集群名称，默认是 <code>elasticsearch</code>。建议修改成一个有意义的名称。</td></tr><tr><td>node.name</td><td>节点名，通常一台物理服务器就是一个节点，<code>es</code> 会默认随机指定一个名字，建议指定一个有意义的名称，方便管理一个或多个节点组成一个 <code>cluster</code> 集群，集群是一个逻辑的概念，节点是物理概念，后边章节会详细介绍。</td></tr><tr><td>path.conf</td><td>设置配置文件的存储路径，tar或zip包安装默认在 <code>es</code> 根目录下的 <code>config</code> 文件夹，<code>rpm</code> 安装默认在 <code>/etc/</code></td></tr><tr><td>path.logs</td><td>设置日志文件的存储路径，默认是es根目录下的 <code>logs</code> 文件夹</td></tr><tr><td>path.plugins</td><td>设置插件的存放路径，默认是 <code>es</code> 根目录下的 <code>plugins</code> 文件夹</td></tr><tr><td>bootstrap.memory_lock</td><td><code>true</code> 设置为 <code>true</code> 可以锁住 <code>ES</code> 使用的内存，避免内存与 <code>swap</code> 分区交换数据。</td></tr><tr><td>elasticsearch path.data</td><td>设置索引数据的存储路径，默认是 <code>es</code> 根目录下的 <code>data</code> 文件夹，可以设置多个存储路径，用逗号隔开。 <code>path.logs</code>: 设置日志文件的存储路径，默认是es根目录下的 <code>logs</code> 文件夹</td></tr><tr><td>network.host</td><td>设置绑定主机的 <code>ip</code> 地址，设置为 <code>0.0.0.0</code> 表示绑定任何 <code>ip</code>，允许外网访问，生产环境建议设置为具体的 <code>ip</code>。</td></tr><tr><td>http.port</td><td><code>9200</code> 设置对外服务的 <code>http</code> 端口，默认为 <code>9200</code>。</td></tr><tr><td>transport.tcp.port</td><td><code>9300</code> 集群结点之间通信端口</td></tr><tr><td>node.master</td><td>指定该节点是否有资格被选举成为 <code>master</code> 结点，默认是true，如果原来的master宕机会重新选举新的master。</td></tr><tr><td>node.data</td><td>指定该节点是否存储索引数据，默认为 <code>true</code>。</td></tr><tr><td>discovery.zen.ping.unicast.hosts</td><td>[“host1:port”, “host2:port”, “…”] 设置集群中 <code>master</code> 节点的初始列表。</td></tr><tr><td>discovery.zen.ping.timeout</td><td><code>3s</code> 设置 <code>ES</code> 自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些。</td></tr><tr><td>discovery.zen.minimum_master_nodes</td><td>主结点数量的最少值 ,此值的公式为：(<code>master_eligible_nodes</code> / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2。</td></tr><tr><td>node.max_local_storage_nodes</td><td>单机允许的最大存储结点数，通常单机启动一个结点建议设置为1，开发环境如果单机启动多个节点可设置大于1.</td></tr></tbody></table><h4 id="jvm-options"><a href="#jvm-options" class="headerlink" title="jvm.options"></a>jvm.options</h4><p>设置最小及最大的JVM堆内存大小：</p><p>在 <code>jvm.options</code> 中设置 <code>-Xms</code> 和 <code>-Xmx</code>：</p><p>1） 两个值设置为相等</p><p>2） 将 <code>Xmx</code> 设置为不超过物理内存的一半。</p><h4 id="log4j2-properties"><a href="#log4j2-properties" class="headerlink" title="log4j2.properties"></a>log4j2.properties</h4><p>日志文件设置，ES使用 <code>log4j</code>，注意日志级别的配置。</p><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p>在<code>linux</code>上根据系统资源情况，可将每个进程最多允许打开的文件数设置大些。</p><p><code>su limit -n</code> 查询当前文件数</p><p>使用命令设置 <code>limit</code>:<br>先切换到 <code>root</code>，设置完成再切回 <code>elasticsearch</code> 用户。</p><div class="hljs"><pre><code class="hljs c">sudo su ulimit ‐n <span class="hljs-number">65536</span>su elasticsearch</code></pre></div><p>也可通过下边的方式修改文件进行持久设置<br><code>/etc/security/limits.conf</code> 将下边的行加入此文件：</p><div class="hljs"><pre><code class="hljs angelscript">elasticsearch  ‐  nofile  <span class="hljs-number">65536</span></code></pre></div><h3 id="3、启动ES"><a href="#3、启动ES" class="headerlink" title="3、启动ES"></a>3、启动ES</h3><p>进入 <code>bin</code> 目录，在 <code>cmd</code> 下运行：<code>elasticsearch.bat</code></p><p><a href="https://qnoss.codeyee.com/20200704_10/image20" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image20.png" srcset="/img/loading.gif" alt="img"></a></p><p>浏览器输入：<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200</a></p><p>显示结果如下（配置不同内容则不同）说明 <code>ES</code> 启动成功：</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"name"</span> : <span class="hljs-string">"xc_node_1"</span>,  <span class="hljs-attr">"cluster_name"</span> : <span class="hljs-string">"xuecheng"</span>,  <span class="hljs-attr">"cluster_uuid"</span> : <span class="hljs-string">"J18wPybJREyx1kjOoH8T‐g"</span>,  <span class="hljs-attr">"version"</span> : &#123;    <span class="hljs-attr">"number"</span> : <span class="hljs-string">"6.2.1"</span>,    <span class="hljs-attr">"build_hash"</span> : <span class="hljs-string">"7299dc3"</span>,    <span class="hljs-attr">"build_date"</span> : <span class="hljs-string">"2018‐02‐07T19:34:26.990113Z"</span>,    <span class="hljs-attr">"build_snapshot"</span> : <span class="hljs-literal">false</span>,     <span class="hljs-attr">"lucene_version"</span> : <span class="hljs-string">"7.2.1"</span>,    <span class="hljs-attr">"minimum_wire_compatibility_version"</span> : <span class="hljs-string">"5.6.0"</span>,    <span class="hljs-attr">"minimum_index_compatibility_version"</span> : <span class="hljs-string">"5.0.0"</span>  &#125;,  <span class="hljs-attr">"tagline"</span> : <span class="hljs-string">"You Know, for Search"</span>&#125;</code></pre></div><h3 id="4、安装-head-插件"><a href="#4、安装-head-插件" class="headerlink" title="4、安装 head 插件"></a>4、安装 head 插件</h3><p><code>head</code> 插件是 <code>ES</code> 的一个可视化管理插件，用来监视ES的状态，并通过 <code>head</code> 客户端和 <code>ES</code> 服务进行交互，比如创建映射、创建索引等，<code>head</code> 的项目地址在 <a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p><p>从ES6.0 开始，<code>head</code> 插件支持使得 <code>node.js</code> 运行。</p><p><strong>1、安装 node.js</strong></p><p><strong>2、下载 head 并运行</strong></p><div class="hljs"><pre><code class="hljs shell">git clone git://github.com/mobz/elasticsearch-head.git cd elasticsearch-head npm install npm run start open</code></pre></div><p>访问 <code>http://本地主机:9100/</code></p><p><strong>3、运行</strong></p><p><a href="https://qnoss.codeyee.com/20200704_10/image21" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image21.png" srcset="/img/loading.gif" alt="img"></a></p><p>打开浏览器调试工具发现报错：</p><p>Origin null is not allowed by Access-Control-Allow-Origin.</p><p>原因是：head插件作为客户端要连接ES服务（localhost:9200），此时存在跨域问题，elasticsearch默认不允许跨域访问。</p><p><strong>解决方案：</strong></p><p>设置 <code>elasticsearch</code> 允许跨域访问</p><div class="hljs"><pre><code class="hljs c"># 跨域配置http.cors.enabled: <span class="hljs-literal">true</span>http.cors.allow-origin: /.*/</code></pre></div><p>跨域访问允许的域名地址，(允许所有域名) 以上使用正则 <code>http.cors.allow-origin: /.*/</code></p><p>注意：将 <code>config/elasticsearch.yml</code> 另存为utf-8编码格式。</p><p>成功连接 <code>ES</code> 。</p><p><a href="https://qnoss.codeyee.com/20200704_10/image22" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image22.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="三、ES-快速入门"><a href="#三、ES-快速入门" class="headerlink" title="三、ES 快速入门"></a>三、ES 快速入门</h1><p><code>ES</code> 作为一个索引及搜索服务，对外提供丰富的 <code>REST</code> 接口，快速入门部分的实例使用 <code>head</code> 插件来测试，目的是对 <code>ES</code> 的使用方法及流程有个初步的认识。</p><h2 id="1-创建索引库"><a href="#1-创建索引库" class="headerlink" title="1. 创建索引库"></a>1. 创建索引库</h2><p><code>ES</code> 的索引库是一个逻辑概念，它包括了分词列表及文档列表，同一个索引库中存储了相同类型的文档。它就相当于 <code>MySQL</code> 中的表，或相当于 <code>Mongodb</code> 中的集合。</p><p>关于索引这个语：</p><p>索引（名词）：<code>ES</code> 是基于 <code>Lucene</code> 构建的一个搜索服务，它要从索引库搜索符合条件索引数据。</p><p>索引（动词）：索引库刚创建起来是空的，将数据添加到索引库的过程称为索引。</p><p>下边介绍两种创建索引库的方法，它们的工作原理是相同的，都是客户端向 <code>ES</code> 服务发送命令。</p><p><strong>1）使用 postman 或 curl 这样的工具创建：</strong></p><p><code>put http://localhost:9200/xc_course</code> 索引库名称</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"settings"</span>:&#123;  <span class="hljs-attr">"index"</span>:&#123;      <span class="hljs-attr">"number_of_shards"</span>:<span class="hljs-number">1</span>,      <span class="hljs-attr">"number_of_replicas"</span>:<span class="hljs-number">0</span>   &#125;      &#125;&#125;</code></pre></div><p><strong>number_of_shards</strong>：设置分片的数量，在集群中通常设置多个分片，表示一个索引库将拆分成多片分别存储不同的结点，提高了 <code>ES</code> 的处理能力和高可用性，入门程序使用单机环境，这里设置为 1。</p><p><strong>number_of_replicas</strong>：设置副本的数量，设置副本是为了提高 <code>ES</code> 的高可靠性，单机环境设置为 <code>0</code>.</p><p>如下是创建的例子，创建 <code>xc_course</code> 索引库，共 <code>1</code> 个分片，<code>0</code> 个副本：</p><p>使用 <code>postman</code> 发送 put 请求</p><p><a href="https://qnoss.codeyee.com/20200704_10/image23" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image23.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>2）使用head插件创建</strong></p><p><a href="https://qnoss.codeyee.com/20200704_10/image24" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image24.png" srcset="/img/loading.gif" alt="img"></a></p><p>效果如下</p><p><a href="https://qnoss.codeyee.com/20200704_10/image25" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image25.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-创建映射"><a href="#2-创建映射" class="headerlink" title="2. 创建映射"></a>2. 创建映射</h2><h3 id="1、概念说明"><a href="#1、概念说明" class="headerlink" title="1、概念说明"></a>1、概念说明</h3><p>在索引中每个文档都包括了一个或多个 <code>field</code>，创建映射就是向索引库中创建 <code>field</code> 的过程，下边是<code>document</code> 和 <code>field</code> 与关系数据库的概念的类比：</p><p>文档（Document）—————- <code>Row</code> 记录</p><p>字段（Field）——————- <code>Columns</code> 列</p><p>注意：<code>6.0</code> 之前的版本有 <code>type</code>（类型）概念，<code>type</code> 相当于关系数据库的表，<code>ES</code> 官方将在 <code>ES9.0</code> 版本中彻底删除 <code>type</code>。</p><p>上边讲的创建索引库相当于关系数据库中的数据库还是表？</p><p>1、如果相当于数据库就表示一个索引库可以创建很多不同类型的文档，这在 <code>ES</code> 中也是允许的。</p><p>2、如果相当于表就表示一个索引库只能存储相同类型的文档，<code>ES</code> 官方建议 在一个索引库中只存储相同类型的文档。</p><h3 id="2、创建映射"><a href="#2、创建映射" class="headerlink" title="2、创建映射"></a>2、创建映射</h3><p>我们要把课程信息存储到 <code>ES</code> 中，这里我们创建课程信息的映射，先来一个简单的映射，如下：</p><p>发送：post <code>http://localhost:9200/索引库名称/类型名称/_mapping</code></p><p>创建类型为 <code>xc_course</code> 的映射，共包括三个字段：<code>name</code>、<code>description</code>、<code>studymondel</code></p><p>由于 <code>ES6.0</code> 版本还没有将 <code>type</code> 彻底删除，所以暂时把 <code>type</code> 起一个没有特殊意义的名字。</p><p>发送 post 请求：<a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><blockquote><p>在 <code>xc_course</code> 索引库下的 <code>doc</code> 类型下创建映射。<code>doc</code> 是类型名，可以自定义，在 <code>ES6.0</code> 中要弱化类型的概念，给它起一个没有具体业务意义的名称。</p></blockquote><p>body</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"name"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"description"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;    &#125;&#125;</code></pre></div><p>映射创建成功，查看 <code>head</code> 界面：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image26" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image26.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-创建文档"><a href="#3-创建文档" class="headerlink" title="3. 创建文档"></a>3. 创建文档</h2><p>ES中的文档相当于MySQL数据库表中的记录。</p><p>发送：put 或 Post 到<code>http://localhost:9200/xc_course/doc/id值</code>（如果不指定id值ES会自动生成ID）</p><p><a href="http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"Bootstrap开发框架"</span>,    <span class="hljs-attr">"description"</span>:<span class="hljs-string">"Bootstrap是由Twitter推出的一个前台页面开发框架，在行业之中使用较为广泛。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松的实现一个不受浏览器限制的精美界面效果。"</span>,    <span class="hljs-attr">"studymodel"</span>:<span class="hljs-string">"201001"</span>&#125;</code></pre></div><p>使用 <code>postman</code> 测试：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image27" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image27.png" srcset="/img/loading.gif" alt="img"></a></p><p>通过 <code>head</code> 查询数据：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image28" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image28.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-搜索文档"><a href="#4-搜索文档" class="headerlink" title="4. 搜索文档"></a>4. 搜索文档</h2><p>1、根据课程id查询文档<br>发送：get <a href="http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000</a></p><p>使用 <code>postman</code> 测试：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image29" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image29.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、查询所有记录</p><p>发送 get <a href="http://localhost:9200/xc_course/doc/_search" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search</a></p><p>3、查询名称中包括 <code>bootstrap</code> 关键字的的记录<br>发送：get <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:9200/xc_course/doc/_search?q=name:bootstrap</p><p>4、查询学习模式为 <code>201001</code> 的记录<br>发送 get <a href="http://localhost:9200/xc_course/doc/_search?q=studymodel:201001" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_search?q=studymodel:201001</a></p><h3 id="查询结果分析"><a href="#查询结果分析" class="headerlink" title="查询结果分析"></a>查询结果分析</h3><p>分析上边查询结果：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"took"</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">"timed_out"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"_shards"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"successful"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"skipped"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"failed"</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">"hits"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"max_score"</span>: <span class="hljs-number">0.2876821</span>,        <span class="hljs-attr">"hits"</span>: [            &#123;                <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course"</span>,                <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,                <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"4028e58161bcf7f40161bcf8b77c0000"</span>,                <span class="hljs-attr">"_score"</span>: <span class="hljs-number">0.2876821</span>,                <span class="hljs-attr">"_source"</span>: &#123;                    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Bootstrap开发框架"</span>,                    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Bootstrap是由Twitter推出的一个前台页面开发框架，在行业之中使用较为广泛。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松的实现一个不受浏览器限制的精美界面效果。"</span>,                    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>                &#125;            &#125;        ]    &#125;&#125;</code></pre></div><table><thead><tr><th>字段名称</th><th>描述</th></tr></thead><tbody><tr><td>took</td><td>本次操作花费的时间，单位为毫秒。</td></tr><tr><td>timed_out</td><td>请求是否超时</td></tr><tr><td>_shards</td><td>说明本次操作共搜索了哪些分片</td></tr><tr><td>hits</td><td>搜索命中的记录</td></tr><tr><td>hits.total</td><td>符合条件的文档总数 <code>hits.hits</code> ：匹配度较高的前N个文档</td></tr><tr><td>hits.max_score</td><td>文档匹配得分，这里为最高分</td></tr><tr><td>_score</td><td>每个文档都有一个匹配度得分，按照降序排列。</td></tr><tr><td>_source</td><td>显示了文档的原始内容。</td></tr></tbody></table><h1 id="四、IK分词器"><a href="#四、IK分词器" class="headerlink" title="四、IK分词器"></a>四、IK分词器</h1><h2 id="1-测试ES默认的分词器"><a href="#1-测试ES默认的分词器" class="headerlink" title="1. 测试ES默认的分词器"></a>1. 测试ES默认的分词器</h2><p>在添加文档时会进行分词，索引中存放的就是一个一个的词（term），当你去搜索时就是拿关键字去匹配词，最终找到词关联的文档。</p><p>测试当前索引库使用的分词器：</p><p>POST 请求：<a href="http://localhost:9200/_analyze" target="_blank" rel="noopener">http://localhost:9200/_analyze</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"text"</span>:<span class="hljs-string">"分词器"</span>&#125;</code></pre></div><p>结果如下：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tokens"</span>: [        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"分"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">1</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"&lt;IDEOGRAPHIC&gt;"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">0</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"词"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">1</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"&lt;IDEOGRAPHIC&gt;"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">1</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"器"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">3</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"&lt;IDEOGRAPHIC&gt;"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">2</span>        &#125;    ]&#125;</code></pre></div><p>从响应的结果来看，<code>ES</code> 的默认分词器会将我们提交的内容中的每一个词进行分割，这样显然不够智能，下面我们来看一下 <code>IK</code> 分词器。</p><h2 id="2-安装IK分词器"><a href="#2-安装IK分词器" class="headerlink" title="2. 安装IK分词器"></a>2. 安装IK分词器</h2><p>使用IK分词器可以实现对中文分词的效果。<br>下载IK分词器：（Github地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik%EF%BC%89" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik）</a></p><blockquote><p>这里要注意的是，IK分词器的版本的ES的版本的相对应的，也就是说，如果我们 ES 的版本用的是 v6.8.8 那么IK分词器的版本也要对应使用 v6.8.8。</p></blockquote><p>解压，并将解压的文件拷贝到 <code>ES</code> 安装目录的 <code>plugins</code> 下的ik目录下</p><p><a href="https://qnoss.codeyee.com/20200704_10/image30" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image30.png" srcset="/img/loading.gif" alt="img"></a></p><p>测试分词效果：</p><p>POST请求： <a href="http://localhost:9200/_analyze" target="_blank" rel="noopener">http://localhost:9200/_analyze</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"text"</span>:<span class="hljs-string">"测试分词器，后边是测试内容：springcloud实战"</span>,<span class="hljs-attr">"analyzer"</span>:<span class="hljs-string">"ik_max_word"</span>&#125;</code></pre></div><p>请求结果</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tokens"</span>: [        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"测试"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">0</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"分词器"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">5</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">1</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"分词"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">4</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">2</span>        &#125;,<span class="hljs-comment">//...省略一部分结果</span>    ]&#125;</code></pre></div><p>从结果可以看出，在我们引入 IK 插件之后，分词器能识别出我们提交的内容中的词语，细心的老铁会注意到我们在 <code>analyzer</code> 字段中引入了 <code>ik_max_word</code> ，这是 <code>IK</code> 插件中的一个分词模式，下面我们来仔细介绍一下 <code>IK</code> 插件中的几种分词模式。</p><h2 id="3-两种分词模式"><a href="#3-两种分词模式" class="headerlink" title="3. 两种分词模式"></a>3. 两种分词模式</h2><p>ik分词器有两种分词模式：<code>ik_max_word</code> 和 <code>ik_smart</code> 模式，下面我们来测试这两种模式。</p><p><strong>1、ik_max_word</strong></p><p>会将文本做最细粒度的拆分，比如会将 “<strong>中华人民共和国人民大会堂</strong> ” 拆分为“ <strong>中华人民共和国</strong>、<strong>中华人民</strong>、<strong>中华</strong>、<strong>华人</strong>、<strong>人民共和国</strong>、<strong>人民</strong>、<strong>共和国</strong>、<strong>大会堂</strong>、<strong>大会</strong>、<strong>会堂等词语</strong>。</p><p>发送 <code>post</code> 请求： <a href="http://localhost:9200/_analyze" target="_blank" rel="noopener">http://localhost:9200/_analyze</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"text"</span>:<span class="hljs-string">"中华人民共和国人民大会堂"</span>,<span class="hljs-attr">"analyzer"</span>:<span class="hljs-string">"ik_max_word"</span>&#125;</code></pre></div><p>请求结果</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tokens"</span>: [        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"中华人民共和国"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">7</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">0</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"中华人民"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">4</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">1</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"中华"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">2</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"华人"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">1</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">3</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">3</span>        &#125;,        <span class="hljs-comment">//省略部分结果...</span>    ]&#125;</code></pre></div><p><strong>2、ik_smart</strong></p><p>会做最粗粒度的拆分，比如会将 “<strong>中华人民共和国人民大会堂</strong>” 拆分为 <strong>中华人民共和国</strong>、<strong>人民大会堂</strong>。</p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"text"</span>:<span class="hljs-string">"中华人民共和国人民大会堂"</span>,<span class="hljs-attr">"analyzer"</span>:<span class="hljs-string">"ik_smart"</span>&#125;</code></pre></div><p>请求结果</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tokens"</span>: [        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"中华人民共和国"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">7</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">0</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"人民大会堂"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">7</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">12</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">1</span>        &#125;    ]&#125;</code></pre></div><h2 id="4-自定义词库"><a href="#4-自定义词库" class="headerlink" title="4. 自定义词库"></a>4. 自定义词库</h2><p>如果要让分词器支持一些专有词语，可以自定义词库。<br><code>iK</code> 分词器自带一个 <code>main.dic</code> 的文件，此文件为词库文件。</p><p><a href="https://qnoss.codeyee.com/20200704_10/image31" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image31.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们在上边的目录中新建一个 <code>my.dic</code> 文件（注意文件格式为 <code>utf-8</code>，不要选择<code>utf-8 BOM</code>）<br>可以在其中自定义词汇</p><p>定义 <code>my.dic</code> , 以每行为单位</p><div class="hljs"><pre><code class="hljs plain">桂北汇</code></pre></div><p>编辑 <code>config</code> 中的配置文件 <code>IKAnalyzer.cfg.xml</code> 中配置 <code>my.dic</code></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">properties</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"http://java.sun.com/dtd/properties.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"ext_dict"</span>&gt;</span>my.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span> <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"ext_stopwords"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><span class="hljs-comment">&lt;!-- &lt;entry key="remote_ext_dict"&gt;words_location&lt;/entry&gt; --&gt;</span><span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><span class="hljs-comment">&lt;!-- &lt;entry key="remote_ext_stopwords"&gt;words_location&lt;/entry&gt; --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><p>在适自定义配置生效之前，我们先来看一下未自定义之前的效果</p><p>发送：post <a href="http://localhost:9200/_analyze" target="_blank" rel="noopener">http://localhost:9200/_analyze</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"text"</span>:<span class="hljs-string">"桂北汇"</span>, <span class="hljs-attr">"analyzer"</span>:<span class="hljs-string">"ik_max_word"</span> &#125;</code></pre></div><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tokens"</span>: [        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"桂北"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">0</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"汇"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">3</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_CHAR"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">1</span>        &#125;    ]&#125;</code></pre></div><p>可以看到，在自定义的分词未生效之前，ES还是将我们的提交的 “桂北汇” 拆分了，因为常用的词语组合。</p><p>我们重启 <code>ES</code>，使刚才修改的自定义配置生效再次测试分词效果：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"tokens"</span>: [        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"桂北汇"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">3</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">0</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"桂北"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">0</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_WORD"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">1</span>        &#125;,        &#123;            <span class="hljs-attr">"token"</span>: <span class="hljs-string">"汇"</span>,            <span class="hljs-attr">"start_offset"</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">"end_offset"</span>: <span class="hljs-number">3</span>,            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"CN_CHAR"</span>,            <span class="hljs-attr">"position"</span>: <span class="hljs-number">2</span>        &#125;    ]&#125;</code></pre></div><p>从结果可以看出，我们在 <code>my.dic</code> 中添加的 “桂北汇” 分词被识别出来了，由于我们使用的是 <code>ik_max_word</code> 分词模式，所以 <code>ES</code> 的 <code>IK</code> 插件会进行更 <strong>细粒度</strong> 的识别。</p><h1 id="五、映射"><a href="#五、映射" class="headerlink" title="五、映射"></a>五、映射</h1><p>上边章节安装了 <code>ik</code> 分词器，如果在索引和搜索时去使用 <code>ik</code> 分词器呢？如何指定其它类型的 <code>field</code>，比如日期类型、数值类型等。本章节学习各种映射类型及映射维护方法。</p><h2 id="1-映射维护方法"><a href="#1-映射维护方法" class="headerlink" title="1. 映射维护方法"></a>1. 映射维护方法</h2><p>1、查询所有索引的映射</p><p>GET 请求： <a href="http://localhost:9200/_mapping" target="_blank" rel="noopener">http://localhost:9200/_mapping</a></p><p>2、创建映射</p><p>POST 请求：<a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"name"</span>: &#123;        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"description"</span>: &#123;        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;    &#125;&#125;</code></pre></div><p>这里要注意得是，映射只能 <strong>创建</strong>，不能删除，以及类型也不能修改，因为如果这个映射一旦创建后，你可能会关联了大量的数据，所以修改是不可取的。</p><h2 id="2-常用映射类型"><a href="#2-常用映射类型" class="headerlink" title="2. 常用映射类型"></a>2. 常用映射类型</h2><p>下图是ES6.2核心的字段类型如下：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image32" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image32.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="1、text-文本字段"><a href="#1、text-文本字段" class="headerlink" title="1、text 文本字段"></a>1、text 文本字段</h3><p>字符串包括 <code>text</code> 和 <code>keyword</code> 两种类型</p><p><strong>analyzer 属性</strong></p><p>通过 <code>analyzer</code> 属性指定分词器。</p><p>下边指定 <code>name</code> 的字段类型为 <code>text</code>，使用 <code>ik</code> 分词器的 <code>ik_max_word</code> 分词模式。</p><div class="hljs"><pre><code class="hljs json">"name": &#123;    "type": "text",    "analyzer":"ik_max_word"&#125;</code></pre></div><p>上边指定了 <code>analyzer</code> 是指在索引和搜索都使用 <code>ik_max_word</code>，如果单独想定义搜索时使用的分词器则可以通过<br><code>search_analyzer</code> 属性。对于 <code>ik</code> 分词器建议是索引时使用 <code>ik_max_word</code> 将搜索内容进行细粒度分词，搜索时使用 <code>ik_smart</code> 提高搜索精确性 。</p><div class="hljs"><pre><code class="hljs json">"name": &#123;    "type": "text",    "analyzer":"ik_max_word",    "search_analyzer":"ik_smart"&#125;</code></pre></div><p><strong>index 属性</strong></p><p>通过 <code>index</code> 属性指定是否索引。</p><p>默认为 <code>index=true</code>，即要进行索引，只有进行索引才可以从索引库搜索到。</p><p>但是也有一些内容不需要索引，比如：商品图片地址只被用来展示图片，不进行搜索图片，此时可以将 <code>index</code>设置为 <code>false</code>。删除索引，重新创建映射，将 <code>pic</code> 的 <code>index</code> 设置为 <code>false</code>，尝试根据 <code>pic</code> 去搜索，结果搜索不到数据</p><div class="hljs"><pre><code class="hljs json">"pic": &#123;    "type": "text",    "index":false&#125;</code></pre></div><p><strong>store 属性</strong></p><p>是否在 <code>source</code> 之外存储，每个文档索引后会在 <code>ES</code> 中保存一份原始文档，存放在 <code>_source</code> 中，一般情况下不需要设置 <code>store</code> 为 <code>true</code>，因为在 <code>source</code> 中已经有一份原始文档了。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>删除 <code>xc_course/doc</code> 下的映射 ，发送 DELETE 请求到 <code>http://10.1.1.168:9200/xc_course</code></p><p>创建，发送PUT请求 <code>http://localhost:9200/xc_course</code> 索引库名称</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"settings"</span>:&#123;  <span class="hljs-attr">"index"</span>:&#123;      <span class="hljs-attr">"number_of_shards"</span>:<span class="hljs-number">1</span>,      <span class="hljs-attr">"number_of_replicas"</span>:<span class="hljs-number">0</span>   &#125;      &#125;&#125;</code></pre></div><p>创建新映射：POST <a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"name"</span>: &#123;        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,        <span class="hljs-attr">"analyzer"</span>:<span class="hljs-string">"ik_max_word"</span>,        <span class="hljs-attr">"search_analyzer"</span>:<span class="hljs-string">"ik_smart"</span>    &#125;,    <span class="hljs-attr">"description"</span>: &#123;        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,        <span class="hljs-attr">"analyzer"</span>:<span class="hljs-string">"ik_max_word"</span>,        <span class="hljs-attr">"search_analyzer"</span>:<span class="hljs-string">"ik_smart"</span>    &#125;,    <span class="hljs-attr">"pic"</span>:&#123;        <span class="hljs-attr">"type"</span>:<span class="hljs-string">"text"</span>,        <span class="hljs-attr">"index"</span>:<span class="hljs-literal">false</span>    &#125;,    <span class="hljs-attr">"studymodel"</span>:&#123;        <span class="hljs-attr">"type"</span>:<span class="hljs-string">"text"</span>        &#125;    &#125;&#125;</code></pre></div><p>插入文档：</p><p>POST <a href="http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/4028e58161bcf7f40161bcf8b77c0000</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"Bootstrap开发框架"</span>,    <span class="hljs-attr">"description"</span>:<span class="hljs-string">"Bootstrap是由Twitter推出的一个前台页面开发框架，在行业之中使用较为广泛。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松的实现一个不受浏览器限制的精美界面效果。"</span>,    <span class="hljs-attr">"pic"</span>:<span class="hljs-string">"group1/M00/00/01/wKhlQFqO4MmAOP53AAAcwDwm6SU490.jpg"</span>,    <span class="hljs-attr">"studymodel"</span>:<span class="hljs-string">"201002"</span>&#125;</code></pre></div><p><strong>查询测试：</strong></p><p>GET请求： <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:9200/xc_course/_search?q=name:开发</p><p>查询结果：获取到 <code>name</code> 中包含 “开发” 的文档</p><p>GET请求： <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:9200/xc_course/_search?q=description:开发</p><p>查询结果：获取到 <code>description</code> 中包含 “开发” 的文档</p><p>GET请求： <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:9200/xc_course/_search?q=pic:group1/M00/00/01/wKhlQFqO4MmAOP53AAAcwDwm6SU490.jpg</p><p>查询结果：由于前面 <code>pic</code> 字段 设置了 <code>index</code> 属性为 <code>false</code></p><p>GET请求： <a href="http://localhost:9200/xc_course/_search?q=studymodel:201002" target="_blank" rel="noopener">http://localhost:9200/xc_course/_search?q=studymodel:201002</a></p><p>查询结果: 由于没有为 <code>studymodel</code> 字段使用的是默认的分词器，默认分词器会将我们前面插入的 “<code>201002</code>” 索引为一个词，所以需要全部匹配才能搜索到。</p><p>通过测试发现：<code>name</code> 和 <code>description</code> 都支持全文检索，<code>pic</code> 不可作为查询条件。</p><h3 id="2、keyword-关键词字段"><a href="#2、keyword-关键词字段" class="headerlink" title="2、keyword 关键词字段"></a>2、keyword 关键词字段</h3><p>上边介绍的 <code>text</code> 文本字段在映射时要设置分词器，<code>keyword</code> 字段为关键字字段，通常搜索 <code>keyword</code> 是按照整体搜索，所以创建 <code>keyword</code> 字段的索引时是不进行分词的，比如：邮政编码、手机号码、身份证等。<code>keyword</code> 字段通常用于过虑、排序、聚合等。</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>创建一个新的索引库进行测试，或者删除原来的，这里我们创建一个新的</p><p>1、创建索引库 <code>xc_course2</code></p><p>PUT <a href="http://10.1.1.168:9200/xc_course2" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course2</a></p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"settings"</span>:&#123;  <span class="hljs-attr">"index"</span>:&#123;      <span class="hljs-attr">"number_of_shards"</span>:<span class="hljs-number">1</span>,      <span class="hljs-attr">"number_of_replicas"</span>:<span class="hljs-number">0</span>   &#125;      &#125;&#125;</code></pre></div><p>2、创建映射</p><p>这里我们将 <code>name</code> 和 <code>studymodel</code> 这两个字段的 <code>type</code> 设置为 <code>keyword</code></p><p>POST <a href="http://10.1.1.168:9200/xc_course2/doc/_mapping" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course2/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"name"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"description"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;    &#125;&#125;</code></pre></div><p>3、创建文档</p><p>创建映射后，我们创建文档数据用于测试</p><p>POST <a href="http://10.1.1.168:9200/xc_course2/doc/4028e58161bcf7f40161bcf8b77c0000" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course2/doc/4028e58161bcf7f40161bcf8b77c0000</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"java编程基础"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"java语言是世界第一编程语言，在软件开发领域使用人数最多。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>&#125;</code></pre></div><p>4、测试查询</p><p>GET <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:9200/xc_course2/_search?q=name:java</p><p>查询结果如下</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"took"</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">"timed_out"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"_shards"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"successful"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"skipped"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"failed"</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">"hits"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"max_score"</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">"hits"</span>: []    &#125;&#125;</code></pre></div><p><code>name</code>是 <code>keyword</code> 类型，所以查询方式是精确查询，所以查询不到任何数据。</p><p>下面我们尝试一下精确的查询</p><p>GET <a href="http://10.1.1.168:9200/xc_course2/_search?q=name:java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course2/_search?q=name:java编程基础</a></p><p>查询结果如下</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"took"</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">"timed_out"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"_shards"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"successful"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"skipped"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"failed"</span>: <span class="hljs-number">0</span>    &#125;,    <span class="hljs-attr">"hits"</span>: &#123;        <span class="hljs-attr">"total"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"max_score"</span>: <span class="hljs-number">0.2876821</span>,        <span class="hljs-attr">"hits"</span>: [            &#123;                <span class="hljs-attr">"_index"</span>: <span class="hljs-string">"xc_course2"</span>,                <span class="hljs-attr">"_type"</span>: <span class="hljs-string">"doc"</span>,                <span class="hljs-attr">"_id"</span>: <span class="hljs-string">"4028e58161bcf7f40161bcf8b77c0000"</span>,                <span class="hljs-attr">"_score"</span>: <span class="hljs-number">0.2876821</span>,                <span class="hljs-attr">"_source"</span>: &#123;                    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"java编程基础"</span>,                    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"java语言是世界第一编程语言，在软件开发领域使用人数最多。"</span>,                    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>                &#125;            &#125;        ]    &#125;&#125;</code></pre></div><p>查询成功。</p><h3 id="3、date-日期类型"><a href="#3、date-日期类型" class="headerlink" title="3、date 日期类型"></a>3、date 日期类型</h3><p>日期类型不用设置分词器，通常日期类型的字段用于排序。</p><p><strong>format 属性</strong></p><p>通过 <code>format</code> 设置日期格式</p><p>例子：</p><p>下边的设置允许 <code>date</code>字段存储年月日时分秒、年月日及毫秒三种格式。</p><p>POST: <a href="http://10.1.1.168:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"timestamp"</span>: &#123;        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,        <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd"</span>        &#125;    &#125;&#125;</code></pre></div><p>插入文档：</p><p>POST: <a href="http://localhost:9200/xc_course/doc/00002" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/00002</a></p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"spring 在java领域非常流行，java程序员都在用。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,    <span class="hljs-attr">"pic"</span>:<span class="hljs-string">"group1/M00/00/01/wKhlQFqO4MmAOP53AAAcwDwm6SU490.jpg"</span>,    <span class="hljs-attr">"timestamp"</span>:<span class="hljs-string">"2018‐07‐04 18:28:58"</span>&#125;</code></pre></div><p>查询测试</p><p>GET <a href="http://10.1.1.168:9200/xc_course/_search?q=name:%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course/_search?q=name:开发</a></p><h3 id="4、数值类型"><a href="#4、数值类型" class="headerlink" title="4、数值类型"></a>4、数值类型</h3><p>下边是ES支持的数值类型</p><p><a href="https://qnoss.codeyee.com/20200704_10/image33" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image33.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、尽量选择范围小的类型，提高搜索效率</p><p>2、对于浮点数尽量用 <strong>比例因子</strong>，比如一个价格字段，单位为元，我们将比例因子设置为 <code>100</code>这在 <code>ES</code> 中会按 分 存储，映射如下</p><div class="hljs"><pre><code class="hljs json">"price": &#123;    "type": "scaled_float",    "scaling_factor": 100&#125;,</code></pre></div><p>由于比例因子为100，如果我们输入的价格是 <code>23.45</code> 则 <code>ES</code> 中会将 <code>23.45</code> 乘以 <code>100</code> 存储在ES中。</p><p>如果输入的价格是 <code>23.456</code>，ES 会将 <code>23.456</code> 乘以 <code>100</code> 再取一个接近原始值的数，得出 <code>2346</code>。</p><p>使用比例因子的好处是 <strong>整型比浮点型更易压缩</strong>，节省磁盘空间。</p><p>如果比例因子不适合，则从下表选择范围小的去用：</p><p><a href="https://qnoss.codeyee.com/20200704_10/image34" target="_blank" rel="noopener"><img src="/2020/08/17/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday10/image34.png" srcset="/img/loading.gif" alt="img"></a></p><p>更新已有映射，并插入文档：</p><p>POST: <a href="http://localhost:9200/xc_course/doc/3" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/3</a></p><div class="hljs"><pre><code class="hljs json">&#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"spring开发基础"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"spring 在java领域非常流行，java程序员都在用。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201001"</span>,    <span class="hljs-attr">"pic"</span>:<span class="hljs-string">"group1/M00/00/01/wKhlQFqO4MmAOP53AAAcwDwm6SU490.jpg"</span>,    <span class="hljs-attr">"timestamp"</span>:<span class="hljs-string">"2018‐07‐04 18:28:58"</span>,    <span class="hljs-attr">"price"</span>:<span class="hljs-number">38.6</span>&#125;</code></pre></div><h3 id="5、综合例子"><a href="#5、综合例子" class="headerlink" title="5、综合例子"></a>5、综合例子</h3><p>1、发送 DELETE 请求到 <code>http://10.1.1.168:9200/xc_course</code></p><p>2、创建，发送PUT请求 <code>http://localhost:9200/xc_course</code> 索引库名称</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"settings"</span>:&#123;  <span class="hljs-attr">"index"</span>:&#123;      <span class="hljs-attr">"number_of_shards"</span>:<span class="hljs-number">1</span>,      <span class="hljs-attr">"number_of_replicas"</span>:<span class="hljs-number">0</span>   &#125;      &#125;&#125;</code></pre></div><p>3、创建如下映射</p><p>post：<a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"name"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>        &#125;,        <span class="hljs-attr">"description"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>        &#125;,        <span class="hljs-attr">"pic"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"index"</span>: <span class="hljs-literal">false</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>        &#125;    &#125;&#125;</code></pre></div><p>4、插入文档</p><p>POST: <a href="http://localhost:9200/xc_course/doc/1" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/1</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Bootstrap开发"</span>,    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Bootstrap是由Twitter推出的一个前台页面开发框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长页面开发的程序人员）轻松的实现一个不受浏览器限制的精美界面效果。"</span>,    <span class="hljs-attr">"studymodel"</span>: <span class="hljs-string">"201002"</span>,    <span class="hljs-attr">"price"</span>: <span class="hljs-number">38.6</span>,    <span class="hljs-attr">"timestamp"</span>: <span class="hljs-string">"2018-04-25 19:11:35"</span>,    <span class="hljs-attr">"pic"</span>: <span class="hljs-string">"group1/M00/00/00/wKhlQFs6RCeAY0pHAA Jx5ZjNDEM428.jpg"</span>&#125;</code></pre></div><p>5、搜索测试</p><p>GET: <a href="http://10.1.1.168:9200/xc_course/doc/_search?q=name:%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">http://10.1.1.168:9200/xc_course/doc/_search?q=name:开发</a></p><h1 id="六、索引管理（Java-API）"><a href="#六、索引管理（Java-API）" class="headerlink" title="六、索引管理（Java API）"></a>六、索引管理（Java API）</h1><h2 id="1-搭建工程"><a href="#1-搭建工程" class="headerlink" title="1. 搭建工程"></a>1. 搭建工程</h2><h3 id="1、ES客户端简介"><a href="#1、ES客户端简介" class="headerlink" title="1、ES客户端简介"></a>1、ES客户端简介</h3><p>ES提供多种不同的客户端：</p><p><strong>TransportClient</strong></p><p>ES提供的传统客户端，官方计划8.0版本删除此客户端。</p><p><strong>RestClient</strong></p><p><code>RestClient</code> 是官方推荐使用的，它包括两种：<code>Java Low Level REST Client</code> 和 <code>Java High Level REST Client</code>。</p><p>ES在 <strong>6.0</strong> 之后提供 <code>Java High Level REST Client</code>， 两种客户端官方更推荐使用 J<code>ava High Level REST Client</code>，不过当前它还处于完善中，有些功能还没有。</p><p>文章中准备采用 <code>Java High Level REST Client</code>，如果它有不支持的功能，则使用 <code>Java Low Level REST Client</code>。</p><p>添加依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch‐rest‐high‐level‐client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="2、创建搜索工程"><a href="#2、创建搜索工程" class="headerlink" title="2、创建搜索工程"></a>2、创建搜索工程</h3><p>创建搜索工程（maven工程）：<code>xc-service-search</code>，添加 <code>RestHighLevelClient</code> 依赖及<code>junit</code> 依赖。</p><p><strong>1）完整依赖文件如下</strong></p><p><code>pom.xml</code></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-search<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p><strong>2）配置文件</strong></p><p><code>application.yml</code></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;port:40100&#125;</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc-search-service</span><span class="hljs-attr">xuecheng:</span>  <span class="hljs-attr">elasticsearch:</span>    <span class="hljs-attr">hostlist:</span> <span class="hljs-string">$&#123;eshostlist:127.0.0.1:9200&#125;</span> <span class="hljs-comment">#多个结点中间用逗号分隔</span></code></pre></div><p><strong>3）配置类</strong></p><p>创建 <code>com.xuecheng.search.config</code> 包在其下创建配置类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.search.config;<span class="hljs-keyword">import</span> org.apache.http.HttpHost;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestClient;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElasticsearchConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.elasticsearch.hostlist&#125;"</span>)    <span class="hljs-keyword">private</span> String hostlist;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * restHighLevelClient</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title">restHighLevelClient</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//解析hostlist配置信息</span>        String[] split = hostlist.split(<span class="hljs-string">","</span>);        <span class="hljs-comment">//创建HttpHost数组，其中存放es主机和端口的配置信息</span>        HttpHost[] httpHostArray = <span class="hljs-keyword">new</span> HttpHost[split.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;split.length;i++)&#123;            String item = split[i];            httpHostArray[i] = <span class="hljs-keyword">new</span> HttpHost(item.split(<span class="hljs-string">":"</span>)[<span class="hljs-number">0</span>], Integer.parseInt(item.split(<span class="hljs-string">":"</span>)[<span class="hljs-number">1</span>]), <span class="hljs-string">"http"</span>);        &#125;        <span class="hljs-comment">//创建RestHighLevelClient客户端</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(httpHostArray));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 项目主要使用RestHighLevelClient，对于低级的客户端暂时不用</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestClient <span class="hljs-title">restClient</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//解析hostlist配置信息</span>        String[] split = hostlist.split(<span class="hljs-string">","</span>);        <span class="hljs-comment">//创建HttpHost数组，其中存放es主机和端口的配置信息</span>        HttpHost[] httpHostArray = <span class="hljs-keyword">new</span> HttpHost[split.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;split.length;i++)&#123;            String item = split[i];            httpHostArray[i] = <span class="hljs-keyword">new</span> HttpHost(item.split(<span class="hljs-string">":"</span>)[<span class="hljs-number">0</span>], Integer.parseInt(item.split(<span class="hljs-string">":"</span>)[<span class="hljs-number">1</span>]), <span class="hljs-string">"http"</span>);        &#125;        <span class="hljs-keyword">return</span> RestClient.builder(httpHostArray).build();    &#125;&#125;</code></pre></div><p><strong>4、启动类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.search;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.domain.EntityScan;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EntityScan</span>(<span class="hljs-string">"com.xuecheng.framework.domain.search"</span>)<span class="hljs-comment">//扫描实体类</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.api"</span>&#125;)<span class="hljs-comment">//扫描接口</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.search"</span>&#125;)<span class="hljs-comment">//扫描本项目下的所有类</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)<span class="hljs-comment">//扫描common下的所有类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SpringApplication.run(SearchApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h2 id="2-创建索引库"><a href="#2-创建索引库" class="headerlink" title="2. 创建索引库"></a>2. 创建索引库</h2><p><strong>1、API</strong></p><p>创建索引：</p><p>PUT： <a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%90%8D%E7%A7%B0" target="_blank" rel="noopener">http://localhost:9200/索引名称</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"settings"</span>:&#123;        <span class="hljs-attr">"index"</span>:&#123;            "number_of_shards":1, #分片的数量            "number_of_replicas":0 #副本数量        &#125;,    &#125;,&#125;</code></pre></div><p>创建映射：</p><p><a href="http://localhost:9200/%E7%B4%A2%E5%BC%95%E5%BA%93%E5%90%8D%E7%A7%B0/%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0/" target="_blank" rel="noopener">http://localhost:9200/索引库名称/类型名称/</a><em>mapping</em></p><p>创建类型为 <code>xc_course</code> 的映射，共包括三个字段：name、description、studymodel</p><p>PUT: <a href="http://localhost:9200/xc_course/doc/_mapping" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/_mapping</a></p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"properties"</span>: &#123;        <span class="hljs-attr">"name"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>        &#125;,        <span class="hljs-attr">"description"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,            <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span>,            <span class="hljs-attr">"search_analyzer"</span>: <span class="hljs-string">"ik_smart"</span>        &#125;,        <span class="hljs-attr">"studymodel"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"keyword"</span>        &#125;,        <span class="hljs-attr">"price"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>        &#125;,        <span class="hljs-attr">"timestamp"</span>: &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis"</span>        &#125;    &#125;&#125;</code></pre></div><p><strong>2、Java Client</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.search;<span class="hljs-keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;<span class="hljs-keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;<span class="hljs-keyword">import</span> org.elasticsearch.client.IndicesClient;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestClient;<span class="hljs-keyword">import</span> org.elasticsearch.client.RestHighLevelClient;<span class="hljs-keyword">import</span> org.elasticsearch.common.settings.Settings;<span class="hljs-keyword">import</span> org.elasticsearch.common.xcontent.XContent;<span class="hljs-keyword">import</span> org.elasticsearch.common.xcontent.XContentType;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestIndex</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RestHighLevelClient restHighLevelClient;    <span class="hljs-meta">@Autowired</span>    RestClient restClient;    <span class="hljs-comment">//创建索引库</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//创建索引请求对象</span>        CreateIndexRequest createIndexRequest = <span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">"xc_course"</span>);        <span class="hljs-comment">//设置索引参数</span>        createIndexRequest.settings(Settings.builder()                .put(<span class="hljs-string">"number_of_shards"</span>,<span class="hljs-number">1</span>)                .put(<span class="hljs-string">"number_of_replicas"</span>,<span class="hljs-number">0</span>)        );        <span class="hljs-comment">//设置索引库的映射</span>        <span class="hljs-comment">//这里的映射数据直接前面测试API的JSON字符串</span>        createIndexRequest.mapping(<span class="hljs-string">"doc"</span>,<span class="hljs-string">"&#123;\n"</span> +                <span class="hljs-string">"    \"properties\": &#123;\n"</span> +                <span class="hljs-string">"        \"name\": &#123;\n"</span> +                <span class="hljs-string">"            \"type\": \"text\",\n"</span> +                <span class="hljs-string">"            \"analyzer\": \"ik_max_word\",\n"</span> +                <span class="hljs-string">"            \"search_analyzer\": \"ik_smart\"\n"</span> +                <span class="hljs-string">"        &#125;,\n"</span> +                <span class="hljs-string">"        \"description\": &#123;\n"</span> +                <span class="hljs-string">"            \"type\": \"text\",\n"</span> +                <span class="hljs-string">"            \"analyzer\": \"ik_max_word\",\n"</span> +                <span class="hljs-string">"            \"search_analyzer\": \"ik_smart\"\n"</span> +                <span class="hljs-string">"        &#125;,\n"</span> +                <span class="hljs-string">"        \"studymodel\": &#123;\n"</span> +                <span class="hljs-string">"            \"type\": \"keyword\"\n"</span> +                <span class="hljs-string">"        &#125;,\n"</span> +                <span class="hljs-string">"        \"price\": &#123;\n"</span> +                <span class="hljs-string">"            \"type\": \"float\"\n"</span> +                <span class="hljs-string">"        &#125;,\n"</span> +                <span class="hljs-string">"        \"timestamp\": &#123;\n"</span> +                <span class="hljs-string">"            \"type\": \"date\",\n"</span> +                <span class="hljs-string">"            \"format\": \"yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis\"\n"</span> +                <span class="hljs-string">"        &#125;\n"</span> +                <span class="hljs-string">"    &#125;\n"</span> +                <span class="hljs-string">"&#125;"</span>,XContentType.JSON);        <span class="hljs-comment">//操作客户端</span>        IndicesClient indices = restHighLevelClient.indices();        <span class="hljs-comment">//创建响应对象</span>        CreateIndexResponse createIndexResponse = indices.create(createIndexRequest);        <span class="hljs-comment">//得到响应结果</span>        <span class="hljs-keyword">boolean</span> shardsAcknowledged = createIndexResponse.isShardsAcknowledged();        System.out.println(shardsAcknowledged);    &#125;&#125;</code></pre></div><p>运行后成功创建映射</p><h2 id="3-添加文档"><a href="#3-添加文档" class="headerlink" title="3. 添加文档"></a>3. 添加文档</h2><p><strong>1、API</strong></p><p>格式如下： PUT <code>/{index}/{type}/{id} { &quot;field&quot;: &quot;value&quot;, ... }</code></p><p>如果不指定 <code>id</code>，<code>ES</code> 会自动生成。</p><p>一个例子：<br>put <a href="http://localhost:9200/xc_course/doc/3" target="_blank" rel="noopener">http://localhost:9200/xc_course/doc/3</a></p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"name"</span>:<span class="hljs-string">"spring cloud实战"</span>,    <span class="hljs-attr">"description"</span>:<span class="hljs-string">"本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战Spring</span><span class="hljs-string">    Boot 4.注册中心eureka。"</span>,    <span class="hljs-attr">"studymodel"</span>:<span class="hljs-string">"201001"</span>    <span class="hljs-string">"price"</span>:<span class="hljs-number">5.6</span>&#125;</code></pre></div><p><strong>2、Java Client</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加文档</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//准备json数据</span>    Map&lt;String, Object&gt; jsonMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    jsonMap.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"spring cloud实战"</span>);    jsonMap.put(<span class="hljs-string">"description"</span>, <span class="hljs-string">"本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战Spring Boot 4.注册中心eureka。"</span>);    jsonMap.put(<span class="hljs-string">"studymodel"</span>, <span class="hljs-string">"201001"</span>);    SimpleDateFormat dateFormat =<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy‐MM‐dd HH:mm:ss"</span>);    jsonMap.put(<span class="hljs-string">"timestamp"</span>, dateFormat.format(<span class="hljs-keyword">new</span> Date()));    jsonMap.put(<span class="hljs-string">"price"</span>, <span class="hljs-number">5.6f</span>);    <span class="hljs-comment">//索引请求对象</span>    IndexRequest indexRequest = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">"xc_course"</span>,<span class="hljs-string">"doc"</span>);    <span class="hljs-comment">//指定索引文档内容</span>    indexRequest.source(jsonMap);    <span class="hljs-comment">//索引响应对象</span>    IndexResponse indexResponse = restHighLevelClient.index(indexRequest);    <span class="hljs-comment">//获取响应结果</span>    DocWriteResponse.Result result = indexResponse.getResult();    System.out.println(result);&#125;</code></pre></div><h2 id="4-查询文档"><a href="#4-查询文档" class="headerlink" title="4. 查询文档"></a>4. 查询文档</h2><p><strong>1、API</strong></p><p>格式如下： GET <code>/{index}/{type}/{id}</code></p><p><strong>2、Java Client</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 查询文档</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    GetRequest getRequest = <span class="hljs-keyword">new</span> GetRequest(            <span class="hljs-string">"xc_course"</span>,            <span class="hljs-string">"doc"</span>,            <span class="hljs-string">"eWb_kXEB39nW0xAzs9Pd"</span>    );    GetResponse getResponse = restHighLevelClient.get(getRequest);    <span class="hljs-keyword">boolean</span> exists = getResponse.isExists();    <span class="hljs-keyword">if</span>(!exists)&#123;        System.out.println(<span class="hljs-string">"文档不存在"</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        Map&lt;String, Object&gt; sourceAsMap = getResponse.getSourceAsMap();        System.out.println(sourceAsMap);    &#125;&#125;</code></pre></div><h2 id="5-更新文档"><a href="#5-更新文档" class="headerlink" title="5. 更新文档"></a>5. 更新文档</h2><p><strong>1、API</strong></p><p><code>ES</code> 更新文档的顺序是：先检索到文档、将原来的文档标记为删除、创建新文档、删除旧文档，创建新文档就会重建索引。</p><p>通过请求 <code>Url</code> 有两种方法：</p><p>1）完全替换</p><p>POST：<a href="http://localhost:9200/xc_test/doc/3" target="_blank" rel="noopener">http://localhost:9200/xc_test/doc/3</a></p><div class="hljs"><pre><code class="hljs json">&#123; <span class="hljs-attr">"name"</span>:<span class="hljs-string">"spring cloud实战"</span>,    <span class="hljs-attr">"description"</span>:<span class="hljs-string">"本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战SpringBoot 4.注册中心eureka。"</span>,    <span class="hljs-attr">"studymodel"</span>:<span class="hljs-string">"201001"</span>,    <span class="hljs-attr">"price"</span>:<span class="hljs-number">5.6</span>&#125;</code></pre></div><p>2）局部更新</p><p>下边的例子是只更新 <code>price</code> 字段。</p><p>post: <a href="http://localhost:9200/xc_test/doc/3/_update" target="_blank" rel="noopener">http://localhost:9200/xc_test/doc/3/_update</a></p><div class="hljs"><pre><code class="hljs json">&#123;<span class="hljs-attr">"doc"</span>:&#123;<span class="hljs-attr">"price"</span>:<span class="hljs-number">66.6</span>&#125;&#125;</code></pre></div><p><strong>2、Java Client</strong></p><p>使用 <code>Client Api</code> 更新文档的方法同上边第二种局部更新方法。<br>可以指定文档的部分字段也可以指定完整的文档内容。</p><div class="hljs"><pre><code class="hljs json"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 更新文档</span><span class="hljs-comment"> */</span>@Testpublic void updateDoc() throws IOException &#123;    UpdateRequest updateRequest = new UpdateRequest("xc_course", "doc","eWb_kXEB39nW0xAzs9Pd");    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();    map.put("name", "spring cloud alibaba");    updateRequest.doc(map);    UpdateResponse update = restHighLevelClient.update(updateRequest);    RestStatus status = update.status();    System.out.println(status);&#125;</code></pre></div><h2 id="6-删除文档"><a href="#6-删除文档" class="headerlink" title="6. 删除文档"></a>6. 删除文档</h2><p><strong>1、API</strong></p><p>根据 <code>id</code> 删除，格式如下：</p><p>DELETE： <code>/{index}/{type}/{id}</code></p><p>搜索匹配删除，将搜索出来的记录删除，格式如下：</p><p>POST： <code>/{index}/{type}/_delete_by_query</code></p><p>下边是搜索条件例子：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"query"</span>:&#123;        <span class="hljs-attr">"term"</span>:&#123;        <span class="hljs-attr">"studymodel"</span>:<span class="hljs-string">"201001"</span>        &#125;    &#125;&#125;</code></pre></div><p>上边例子的搜索匹配删除会将 <code>studymodel</code> 为 <code>201001</code> 的记录全部删除。</p><p><strong>2、Java Client</strong></p><div class="hljs"><pre><code class="hljs json"><span class="hljs-comment">//根据id删除文档</span>@Testpublic void testDelDoc() throws IOException &#123;    <span class="hljs-comment">//删除文档id</span>    String id = "eqP_amQBKsGOdwJ4fHiC";    <span class="hljs-comment">//删除索引请求对象</span>    DeleteRequest deleteRequest = new DeleteRequest("xc_course","doc",id);    <span class="hljs-comment">//响应对象</span>    DeleteResponse deleteResponse = client.delete(deleteRequest);    <span class="hljs-comment">//获取响应结果</span>    DocWriteResponse.Result result = deleteResponse.getResult();    System.out.println(result);&#125;</code></pre></div><p>搜索匹配删除还没有具体的 <code>api</code>，可以采用先搜索出文档 <code>id</code>，根据文档 <code>id</code> 删除。</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day09：Eureka、Feign、课程预览实现</title>
    <link href="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/"/>
    <url>/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day09</code> 的内容</p><ul><li>构建基于 <code>Eureka</code> 的服务注册中心</li><li><code>Ribbon</code> 的基本使用，以及使用 <code>Ribbon</code> 来进行服务间的负载均衡调用</li><li>使用 <code>Feign</code> 实现服务之间的远程调用</li><li>课程预览功能开发</li></ul><h1 id="一、Eureka-注册中心"><a href="#一、Eureka-注册中心" class="headerlink" title="一、Eureka 注册中心"></a>一、Eureka 注册中心</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>在前后端分离架构中，服务层被拆分成了很多的微服务，微服务的信息如何管理？Spring Cloud中提供服务注册中心来管理微服务信息。</p><p><strong>为什么 要用注册中心？</strong></p><p>1、微服务数量众多，要进行远程调用就需要知道服务端的 <code>ip</code> 地址和端口，注册中心帮助我们管理这些服务的 <code>ip</code> 和端口。</p><p>2、微服务会实时上报自己的状态，注册中心统一管理这些微服务的状态，将存在问题的服务踢出服务列表，客户端获取到可用的服务进行调用。</p><h2 id="2-Eureka介绍"><a href="#2-Eureka介绍" class="headerlink" title="2. Eureka介绍"></a>2. Eureka介绍</h2><p><code>Spring Cloud Eureka</code> 是对 <code>Netflix</code> 公司的 <code>Eureka</code> 的二次封装，它实现了服务治理的功能，<code>Spring Cloud Eureka</code> 提供服务端与客户端，服务端即是 <code>Eureka</code> 服务注册中心，客户端完成微服务向 <code>Eureka</code> 服务的注册与发现。服务端和客户端均采用Java语言编写。下图显示了 <code>Eureka Server</code> 与 <code>Eureka Client</code> 的关系：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image1" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、<code>Eureka Server</code> 是服务端，负责管理各各微服务结点的信息和状态。</p><p>2 、在微服务上部署 <code>Eureka Client</code> 程序，远程访问 <code>Eureka Server</code> 将自己注册在 <code>Eureka Server</code>。</p><p>3、微服务需要调用另一个微服务时从 <code>Eureka Server</code> 中获取服务调用地址，进行远程调用。</p><h2 id="3-Eureka-Server搭建"><a href="#3-Eureka-Server搭建" class="headerlink" title="3. Eureka Server搭建"></a>3. Eureka Server搭建</h2><h3 id="1、单机环境搭建"><a href="#1、单机环境搭建" class="headerlink" title="1、单机环境搭建"></a>1、单机环境搭建</h3><p><strong>1）创建 xc-govern-center 工程：</strong></p><p>包结构：com.xuecheng.govern.center</p><p><a href="https://qnoss.codeyee.com/20200704_9/image2" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>2）添加依赖</strong></p><p>在父工程添加：（有了则不用重复添加）</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p><strong>3）启动类</strong></p><div class="hljs"><pre><code class="hljs javascript">package com.xuecheng.govern.center;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer  <span class="hljs-comment">//标识这是一个EurekaServer</span>@SpringBootApplicationpublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GorvernCenterApplication</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        SpringApplication.run(GorvernCenterApplication.class,args);    &#125;&#125;</code></pre></div><blockquote><p>需要在启动类上用 <code>@EnableEurekaServer</code> 标识此服务为Eureka服务</p></blockquote><p><strong>4）配置文件</strong></p><p>从其它服务拷贝 <code>application.yml</code> 和 <code>logback-spring.xml</code>。</p><p>application.yml 的配置内容如下：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <span class="hljs-attr">port:</span> <span class="hljs-number">50101</span> <span class="hljs-comment">#服务端口</span><span class="hljs-attr">spring:</span> <span class="hljs-attr">application:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">xc-govern-center</span> <span class="hljs-comment">#指定服务名</span><span class="hljs-attr">eureka:</span> <span class="hljs-attr">client:</span>  <span class="hljs-attr">registerWithEureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#服务注册，是否将自己注册到Eureka服务中</span>  <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#服务发现，是否从Eureka中获取注册信息</span>  <span class="hljs-attr">serviceUrl:</span> <span class="hljs-comment">#Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口）</span>   <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:50101/eureka/</span> <span class="hljs-attr">server:</span>  <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否开启自我保护模式</span>  <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">60000</span> <span class="hljs-comment">#服务注册表清理间隔（单位毫秒，默认是60*1000）</span></code></pre></div><ul><li><code>registerWithEureka</code>：被其它服务调用时需向Eureka注册</li><li><code>fetchRegistry</code>：需要从Eureka中查找要调用的目标服务时需要设置为true</li><li><code>enable-self-preservation</code>：自保护设置，下边有介绍。</li><li><code>eviction-interval-timer-in-ms</code>：清理失效结点的间隔，在这个时间段内如果没有收到该结点的上报则将结点从服务列表中剔除。</li></ul><p><strong>5）启动Eureka Server</strong></p><p>启动Eureka Server，浏览50101端口。</p><p><a href="https://qnoss.codeyee.com/20200704_9/image3" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>说明：</p><p>上图红色提示信息：<br><code>THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OFNETWORK/OTHER PROBLEMS.</code></p><p>自我保护模式被关闭。在网络或其他问题的情况下可能不会保护实例失效。</p><p><code>Eureka Server</code> 有一种自我保护模式，当微服务不再向 <code>Eureka Server</code> 上报状态，<code>Eureka Server</code> 会从服务列表将此服务删除，如果出现网络异常情况（微服务正常），此时 <code>Eureka server</code> 进入自保护模式，不再将微服务从服务列表删除。</p><p>在开发阶段建议关闭自保护模式。</p><p>详细的参考资料：<a href="https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html" target="_blank" rel="noopener">https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html</a></p><h3 id="2、高可用环境配置"><a href="#2、高可用环境配置" class="headerlink" title="2、高可用环境配置"></a>2、高可用环境配置</h3><p><code>Eureka Server</code> 高可用环境需要部署两个 <code>Eureka server</code>，它们互相向对方注册。如果在本机启动两个 <code>Eureka</code> 需要注意两个 <code>Eureka Server</code> 的端口要设置不一样，这里我们部署一个 <code>Eureka Server</code> 工程，将端口可配置，制作两个 <code>Eureka Server</code> 启动脚本，启动不同的端口，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image4" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、在实际使用时 <code>Eureka Server</code> 至少部署两台服务器，实现高可用。</p><p>2、两台 <code>Eureka Server</code> 互相注册。</p><p>3、微服务需要连接两台 <code>Eureka Server</code> 注册，当其中一台 <code>Eureka</code> 死掉也不会影响服务的注册与发现。</p><p>4、微服务会定时向 <code>Eureka server</code> 发送心跳，报告自己的状态。</p><p>5、微服务从注册中心获取服务地址以 <code>RESTful</code> 方式发起远程调用。</p><p>配置如下:</p><p><strong>1、端口配置加入变量</strong></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>    <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;PORT:50101&#125;</span> <span class="hljs-comment">#服务端口</span></code></pre></div><p><strong>2、在 Eureka 服务端的地址加入变量</strong></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>      <span class="hljs-attr">registerWithEureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务注册，是否将自己注册到Eureka服务中</span>      <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务发现，是否从Eureka中获取注册信息</span>      <span class="hljs-attr">serviceUrl:</span> <span class="hljs-comment">#Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口）</span>        <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">$&#123;EUREKA_SERVER:http://eureka02:50102/eureka/&#125;</span></code></pre></div><p><strong>3、 配置 hostname</strong></p><p><code>Eureka</code> 组成高可用，两个<code>Eureka</code> 互相向对方注册，这里需要通过域名或主机名访问，这里我们设置两个 <code>Eureka</code> 服务的主机名分别为 <code>eureka01</code>、<code>eureka02</code>。</p><p>完整配置如下</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>      <span class="hljs-attr">registerWithEureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务注册，是否将自己注册到Eureka服务中</span>      <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务发现，是否从Eureka中获取注册信息</span>      <span class="hljs-attr">serviceUrl:</span> <span class="hljs-comment">#Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口）</span>        <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">$&#123;EUREKA_SERVER:http://eureka02:50102/eureka/&#125;</span>  <span class="hljs-attr">server:</span>        <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否开启自我保护模式</span>        <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">60000</span> <span class="hljs-comment">#服务注册表清理间隔（单位毫秒，默认是6）0*1000</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">$&#123;EUREKA_DOMAIN:eureka01&#125;</span></code></pre></div><p>注意这里的 <code>eureka01</code>、<code>eureka02</code> 的域名，在开放环境中，我们需要在hosts 文件中增加相应的映射：</p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> eureka01<span class="hljs-number">127.0.0.1</span> eureka02</code></pre></div><p><strong>4、在IDEA中制作启动脚本</strong></p><p><a href="https://qnoss.codeyee.com/20200704_9/image5" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>运行两个启动脚本，分别浏览：</p><p><a href="http://localhost:50101/" target="_blank" rel="noopener">http://localhost:50101/</a><br><a href="http://localhost:50102/" target="_blank" rel="noopener">http://localhost:50102/</a></p><p>Eureka 主画面如下：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image6" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image6.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="0x04-服务注册"><a href="#0x04-服务注册" class="headerlink" title="0x04 服务注册"></a>0x04 服务注册</h2><p><strong>1、将 cms 注册到 Eureka Server</strong></p><p>1）在 cms 服务中添加依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入Eureka客户端的依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2）在 <code>application.yml</code> 中进行配置</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>      <span class="hljs-attr">registerWithEureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务注册开关</span>      <span class="hljs-attr">fetchRegistry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#服务发现开关</span>      <span class="hljs-attr">serviceUrl:</span> <span class="hljs-comment">#Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔</span>        <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">$&#123;EUREKA_SERVER:http://eureka01:50101/eureka/,http://eureka02:50102/eureka/&#125;,</span>  <span class="hljs-attr">instance:</span>      <span class="hljs-attr">prefer-ip-address:</span>  <span class="hljs-literal">true</span>  <span class="hljs-comment">#将自己的ip地址注册到Eureka服务中</span>      <span class="hljs-attr">ip-address:</span> <span class="hljs-string">$&#123;IP_ADDRESS:127.0.0.1&#125;</span>      <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment">#指定实例id</span></code></pre></div><p>3）在启动类上添加注解 <code>@EnableDiscoveryClient</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EntityScan</span>(<span class="hljs-string">"com.xuecheng.framework.domain.cms"</span>) <span class="hljs-comment">//扫描公共的实体类</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.api"</span>&#125;) <span class="hljs-comment">//扫描接口</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.manage_cms"</span>&#125;)  <span class="hljs-comment">// 扫描本项目下的所有类</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)  <span class="hljs-comment">// 扫描framework</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;&#125;</code></pre></div><p>4）刷新 Eureka Server 查看注册情况</p><p><a href="https://qnoss.codeyee.com/20200704_9/image7" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image7.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>2、注册 course 服务</strong></p><p>方法同上。</p><p>1、在 <code>manage-course</code> 工程中添加 <code>spring-cloud-starter-eureka</code> 依赖：</p><p>2、在 <code>application.yml</code> 配置 <code>eureka</code></p><p>3、在启动类上添加注解 <code>@EnableDiscoveryClient</code></p><h1 id="二、Feign-远程调用"><a href="#二、Feign-远程调用" class="headerlink" title="二、Feign 远程调用"></a>二、Feign 远程调用</h1><p>在前后端分离架构中，服务层被拆分成了很多的微服务，服务与服务之间难免发生交互，比如：</p><p>课程发布需要调用 <code>CMS</code> 服务生成课程静态化页面，本节研究微服务远程调用所使用的技术。</p><p>下图是课程管理服务远程调用 <code>CMS</code> 服务的流程图：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image8" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>工作流程如下：</p><p>1 、<code>cms</code> 服务将自己注册到注册中心。</p><p>2、课程管理服务从注册中心获取 <code>cms</code> 服务的地址。</p><p>3、课程管理服务远程调用 <code>cms</code> 服务。</p><p>Feign的实现是基于 <code>Ribbon</code> 的，所以在介绍 Feign 的使用之前，我们先来了解一下 Ribbon， 以便能更深刻的理解 <code>Feign</code>。</p><h2 id="1-Ribbon-简介"><a href="#1-Ribbon-简介" class="headerlink" title="1. Ribbon 简介"></a>1. Ribbon 简介</h2><p><code>Ribbon</code> 是 <code>Netflix</code> 公司开源的一个负载均衡的项目，它是一个基于 HTTP、TCP的 <strong>客户端负载均衡器</strong>。</p><p><code>Ribbon</code> 的开源地址：<a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">https://github.com/Netflix/ribbon</a></p><p><strong>1、什么是负载均衡？</strong></p><p>负载均衡是 微服务架构 中必须使用的技术，通过 负载均衡 来实现系统的 高可用、集群扩容 等功能。负载均衡 可通过 硬件设备 及 软件 来实现，硬件比如：<code>F5</code>、<code>Array</code> 等，软件比如：LVS、<code>Nginx</code> 等。</p><p>如下图是负载均衡的架构图：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image9" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>用户请求先到达负载均衡器（也相当于一个服务），负载均衡器根据负载均衡算法将请求转发到微服务。负载均衡算法有：<code>轮训</code>、<code>随机</code>、<code>加权轮训</code>、<code>加权随机</code>、<code>地址哈希</code> 等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上。所以负载均衡可以为微服务集群分担请求，降低系统的压力。</p><p><strong>2、什么是客户端负载均衡？</strong></p><p>上图是 <code>服务端 负载均衡</code>，<code>客户端负载均衡</code> 与 <code>服务端负载均衡</code> 的区别在于 <strong>客户端</strong> 要维护一份服务列表，<code>Ribbon</code> 从 <code>Eureka Server</code> 获取服务列表，<code>Ribbon</code> 根据负载均衡算法直接请求到具体的微服务，中间省去了负载均衡服务。如下图是 <code>Ribbon</code> 负载均衡的流程图：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image10" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、在消费微服务中使用 <code>Ribbon</code> 实现负载均衡，<code>Ribbon</code> 先从 <code>EurekaServer</code> 中获取服务列表。</p><p>2、<code>Ribbon</code> 根据负载均衡的算法去调用微服务。</p><h2 id="2-Ribbon-的基本使用"><a href="#2-Ribbon-的基本使用" class="headerlink" title="2. Ribbon 的基本使用"></a>2. Ribbon 的基本使用</h2><p>Spring Cloud 引入<code>Ribbon</code> 配合 <code>restTemplate</code> 实现客户端负载均衡。Java中远程调用的技术有很多，如：webservice、socket、rmi、Apache HttpClient、OkHttp 等，互联网项目使用基于 <code>http</code> 的客户端较多，本项目使用 <code>OkHttp</code>。</p><p><strong>1、在客户端添加Ribbon依赖：</strong></p><p>这里在 课程管理服务 配置 <code>ribbon</code> 依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入ribbon依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>由于依赖了 <code>spring-cloud-starter-eureka</code>，会自动添加 <code>spring-cloud-starter-ribbon</code> 依赖</p><p><a href="https://qnoss.codeyee.com/20200704_9/image11" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>2、配置 Ribbbon 参数</strong></p><p>这里在课程管理服务的 <code>application.yml</code> 中配置 <code>ribbon</code> 参数</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">2</span> <span class="hljs-comment">#最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">3</span> <span class="hljs-comment">#切换实例的重试次数</span>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">5000</span>  <span class="hljs-comment">#请求连接的超时时间</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">6000</span> <span class="hljs-comment">#请求处理的超时时间</span></code></pre></div><p><strong>3、负载均衡测试</strong></p><p>1）启动两个 <code>cms</code> 服务，注意端口要不一致</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;PORT:31001&#125;</span></code></pre></div><p><a href="https://qnoss.codeyee.com/20200704_9/image12" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>启动完成观察 <code>Eureka Server</code> 的服务列表</p><p><a href="https://qnoss.codeyee.com/20200704_9/image13" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image13.png" srcset="/img/loading.gif" alt="img"></a></p><p>2）定义 <code>RestTemplate</code>，使用 <code>@LoadBalanced</code> 注解</p><p>在课程管理服务的启动类中定义 <code>RestTemplate</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EntityScan</span>(<span class="hljs-string">"com.xuecheng.framework.domain.course"</span>)<span class="hljs-comment">//扫描实体类</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.api"</span>&#125;)<span class="hljs-comment">//扫描接口</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.manage_course"</span>&#125;)<span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)<span class="hljs-comment">//扫描common下的所有类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCourseApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SpringApplication.run(ManageCourseApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">//开启ribbon负载均衡拦截器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;&#125;</code></pre></div><p>3 ）测试代码</p><p>在课程管理服务工程创建单元测试代码，远程调用cms的查询页面接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestRibbon</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRibbon</span><span class="hljs-params">()</span></span>&#123;        String serviceId = <span class="hljs-string">"xc-service-manage-cms"</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(<span class="hljs-string">"http://"</span> + serviceId + <span class="hljs-string">"/cms/page/get/5a795ac7dd573c04508f3a56"</span>, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            Map body = forEntity.getBody();            System.out.println(body);        &#125;    &#125;&#125;</code></pre></div><p>4）负载均衡测试</p><p>添加 <code>@LoadBalanced</code> 注解后，<code>restTemplate</code> 会走 <code>LoadBalancerInterceptor</code> 拦截器，此拦截器中会通过 <code>RibbonLoadBalancerClient</code> 查询服务地址，可以在此类打断点观察每次调用的服务地址和端口，两个 <code>cms</code> 服务会轮流被调用。</p><p><a href="https://qnoss.codeyee.com/20200704_9/image14" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image14.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-Feign"><a href="#3-Feign" class="headerlink" title="3. Feign"></a>3. Feign</h2><h3 id="1、Fegin-介绍"><a href="#1、Fegin-介绍" class="headerlink" title="1、Fegin 介绍"></a>1、Fegin 介绍</h3><p><code>Feign</code>是 <code>Netflix</code> 公司开源的轻量级 <code>rest</code> <strong>客户端</strong>，使用 <code>Feign</code> 可以非常方便的实现<code>Http</code> 客户端。Spring Cloud 引入 <code>Feign</code> 并且集成了 <code>Ribbon</code> 实现客户端负载均衡调用。</p><h3 id="2、Feign-测试"><a href="#2、Feign-测试" class="headerlink" title="2、Feign 测试"></a>2、Feign 测试</h3><p><strong>1 、在客户端添加依赖</strong></p><p>在 课程管理服务 添加下边的依赖：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--feign相关依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.netflix.feign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>2、定义 FeignClient 接口</strong></p><p>参考 <code>Swagger</code> 文档定义<code>FeignClient</code>，注意接口的 <code>Url</code>、请求参数类型、返回值类型与<code>Swagger</code> 接口一致。在课程管理服务中创建 <code>client</code>包，定义查询 <code>cms</code> 页面的客户端的接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.client;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.response.CmsPageResult;<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"XC-SERVICE-MANAGE-CMS"</span>)<span class="hljs-comment">//这里可以将所有服务做成一个枚举列表</span><span class="hljs-comment">//@FeignClient(value = XcServiceList.XC_SERVICE_MANAGE_CMS)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/cms/page/get/&#123;id&#125;"</span>)    <span class="hljs-comment">//这里我在CmsPage接口定义的返回类型为 CmsPageResult 类型,所以远程调用接口这里也要接收 CmsPageResult 类型</span>    <span class="hljs-function">CmsPageResult <span class="hljs-title">findById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id)</span>;&#125;</code></pre></div><p><strong>3、启动类添加@EnableFeignClients注解</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span>  <span class="hljs-comment">//开启Feign远程调用功能</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EntityScan</span>(<span class="hljs-string">"com.xuecheng.framework.domain.course"</span>)<span class="hljs-comment">//扫描实体类</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.api"</span>&#125;)<span class="hljs-comment">//扫描接口</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.manage_course"</span>&#125;)<span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)<span class="hljs-comment">//扫描common下的所有类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCourseApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SpringApplication.run(ManageCourseApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">//开启ribbon负载均衡拦截器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;&#125;</code></pre></div><p>4、<strong>测试</strong></p><p>创建一个单元测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestFeign</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageClient cmsPageClient;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFeign</span><span class="hljs-params">()</span></span>&#123;        CmsPageResult byId = cmsPageClient.findById(<span class="hljs-string">"5a795ac7dd573c04508f3a56"</span>);        System.out.println(byId.getCmsPage());    &#125;&#125;</code></pre></div><p>运行测试</p><p><a href="https://qnoss.codeyee.com/20200704_9/image15" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image15.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>Feign 工作原理如下：</strong></p><p>1、 启动类添加 <code>@EnableFeignClients</code> 注解，<code>Spring</code>会扫描标记了<code>@FeignClient</code> 注解的接口，并生成此接口的代理对象</p><p>2、 <code>@FeignClient(value = XcServiceList.XC_SERVICE_MANAGE_CMS)</code> 即指定了 <code>cms</code> 的服务名称，<code>Feign</code> 会从注册中心获取 <code>cms</code> 服务列表，并通过负载均衡算法进行服务调用。</p><p>3、在接口方法 中使用注解 <code>@GetMapping(&quot;/cms/page/get/{id}&quot;)</code>，指定调用的<code>url</code>，<code>Feign</code> 将根据 <code>url</code> 进行远程调用。</p><h3 id="3、使用-Feign-有哪些需要注意的地方？"><a href="#3、使用-Feign-有哪些需要注意的地方？" class="headerlink" title="3、使用 Feign 有哪些需要注意的地方？"></a>3、使用 Feign 有哪些需要注意的地方？</h3><p>SpringCloud 对 <code>Feign</code> 进行了增强兼容了 <code>SpringMVC</code> 的注解 ，我们在使用 <code>SpringMVC</code> 的注解时需要注意：</p><p>1、FeignClient 接口 有参数在参数必须加 <code>@PathVariable(&quot;XXX&quot;)</code> 和 <code>@RequestParam(&quot;XXX&quot;)</code></p><p>2、FeignClient 返回值为复杂对象时其类型必须有无参构造函数。</p><h1 id="三、课程预览技术方案"><a href="#三、课程预览技术方案" class="headerlink" title="三、课程预览技术方案"></a>三、课程预览技术方案</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p><strong>课程预览</strong> 是为了保证课程发布后的 <strong>正确性</strong>，通过课程预览可以直观的通过 <strong>课程详情页面</strong> 看到课程的信息是否正确，通过 课程预览 看到的页面内容 和 课程发布后的页面 内容是一致的。</p><p>下图是课程详情页面的预览图：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image16" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image16.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-课程详细页面-技术方案"><a href="#2-课程详细页面-技术方案" class="headerlink" title="2. 课程详细页面 技术方案"></a>2. 课程详细页面 技术方案</h2><h3 id="1、技术需求"><a href="#1、技术需求" class="headerlink" title="1、技术需求"></a>1、技术需求</h3><p>课程详情页面是向用户展示课程信息的窗口，课程相当于网站的 <strong>商品</strong>，本页面的访问量会非常大。此页面的内容设计不仅要展示出课程 <strong>核心重要的内容</strong> 而且用户访问页面的 <strong>速度要有保证</strong>，有统计显示打开一个页面超过4秒用户就走掉了，所以本页面的性能要求是本页面的重要需求。</p><p>本页面另一个需求就是 <code>SEO</code>，要非常有利于爬虫抓取页面上信息，并且生成页面快照，利于用户通过搜索引擎搜索课程信息。</p><h3 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>那么如何在保证 <code>SEO</code> 的前提下提高页面的访问速度？</p><p><strong>方案1：</strong></p><p>对于信息获取类的需求，要想提高页面速度就要使用 <strong>缓存</strong> 来减少或避免对数据库的访问，从而提高页面的访问速度。下图是使用缓存与不使用缓存的区别</p><p><a href="https://qnoss.codeyee.com/20200704_9/image17" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_9/image17" srcset="/img/loading.gif" alt="img"></a></p><p>此页面为动态页面，会根据课程的不同而不同，方案一采用传统的 <code>JavaEE Servlet/jsp</code> 的方式在 <code>Tomcat</code> 完成页面渲染，相比不加缓存速度会有提升。</p><p>优点：使用 <code>redis</code> 作为缓存，速度有提升。</p><p>缺点：采用 <code>Servlet/jsp</code> 动态页面渲染技术，服务器使用 <code>Tomcat</code>，面对高并发量的访问存在性能瓶颈。</p><p><strong>方案2：</strong></p><p>对于不会频繁改变的信息可以采用 <strong>页面静态化</strong> 的技术，提前让页面生成 <code>html</code> 静态页面存储在<code>nginx</code> 服务器，用户直接访问 <code>nginx</code> 即可，对于一些动态信息可以访问服务端获取 <code>json</code>数据在页面渲染。</p><p><a href="https://qnoss.codeyee.com/20200704_9/image18" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p>优点：使用 <code>Nginx</code> 作为 <code>web</code> 服务器，并且直接访问 <code>html</code> 页面，性能出色。</p><p>缺点：需要维护大量的静态页面，增加了维护的难度。</p><p>这里我们选择 <strong>方案2</strong> 作为课程详情页面的技术解决方案，将课程详情页面生成 <code>Html</code> 静态化页面，并发布到 <code>Nginx</code> 上。</p><h2 id="3-课程预览技术-解决方案"><a href="#3-课程预览技术-解决方案" class="headerlink" title="3. 课程预览技术 解决方案"></a>3. 课程预览技术 解决方案</h2><p>根据要求：课程详情页面采用静态化技术生成 <code>Html</code> 页面，课程预览的效果要与最终静态化的<code>Html</code> 页面内容一致。所以，课程预览功能也采用静态化技术生成 <code>Html</code> 页面，课程预览使用的模板与课程详情页面模板一致，这样就可以保证课程预览的效果与最终课程详情页面的效果一致。</p><p><strong>操作流程：</strong></p><p>1、制作课程详情页面模板</p><p>2、开发课程详情页面数据模型的查询接口（为静态化提供数据）</p><p>3、调用cms课程预览接口通过浏览器浏览静态文件</p><p><a href="https://qnoss.codeyee.com/20200704_9/image19" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image19.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="四、课程详细页面静态化"><a href="#四、课程详细页面静态化" class="headerlink" title="四、课程详细页面静态化"></a>四、课程详细页面静态化</h1><h2 id="1-静态页面测试"><a href="#1-静态页面测试" class="headerlink" title="1. 静态页面测试"></a>1. 静态页面测试</h2><h3 id="1、页面内容组成"><a href="#1、页面内容组成" class="headerlink" title="1、页面内容组成"></a>1、页面内容组成</h3><p>我们在编写一个页面时需要知道哪些信息是静态信息，哪些信息为动态信息，下图是页面的设计图：</p><p><a href="https://qnoss.codeyee.com/20200704_9/image20" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image20.png" srcset="/img/loading.gif" alt="img"></a></p><ul><li>打开静态页面，观察每部分的内容。</li><li>红色表示动态信息，红色以外表示静态信息。</li><li>红色动态信息：表示一个按钮，根据用户的登录状态、课程的购买状态显示按钮的名称及按钮的事件。</li></ul><p>包括以下信息内容：</p><p><strong>1、课程信息</strong><br>课程标题、价格、课程等级、授课模式、课程图片、课程介绍、课程目录。</p><p><strong>2、课程统计信息</strong><br>课程时长、评分、收藏人数</p><p><strong>3、教育机构信息</strong><br>公司名称、公司简介</p><p><strong>4、教育机构统计信息</strong><br>好评数、课程数、学生人数</p><p><strong>5、教师信息</strong><br>老师名称、老师介绍</p><h3 id="2、页面拆分"><a href="#2、页面拆分" class="headerlink" title="2、页面拆分"></a>2、页面拆分</h3><ol><li><p>本页头文件和门户使用的页头为同一个文件。<br>参考：<code>代码\页面与模板\include\header.html</code></p></li><li><p>页面尾<br>本页尾文件和门户使用的页尾为同一个文件。<br>参考：<code>代码\页面与模板\include\footer.html</code></p></li><li><p>课程详情主页面<br>每个课程对应一个文件，命名规则为：<code>课程id.html</code>（课程id动态变化）<br>模板页面参考：<code>\代码\页面与模板\course\detail\course_main_template.html</code></p></li><li><p>教育机构页面<br>每个教育机构对应一个文件，文件的命名规则为：<code>company_info_公司id.html</code>（公司id动态变化）<br>参考：<code>代码\页面与模板\company\company_info_template.html</code></p></li><li><p>老师信息页面<br>每个教师信息对应一个文件，文件的命名规则为：<code>teacher_info_教师id.html</code>（教师id动态变化）</p><p>参考：<code>代码 \页面与模板\teacher\teacher_info_template01.html</code></p></li><li><p>课程统计页面<br>每个课程对应一个文件，文件的命名规则为：<code>course_stat_课程id.json</code>（课程id动态变化）<br>参考：<code>\代码\页面与模板\stat\course\course_stat_template.json</code></p></li><li><p>教育机构统计页面<br>每个教育机构对应一个文件，文件的命名规则为：<code>company_stat_公司id.json</code>（公司id动态变化）<br>参考：<code>\代码\页面与模板\stat\company\company_stat_template.json</code></p></li></ol><h3 id="3、页面测试"><a href="#3、页面测试" class="headerlink" title="3、页面测试"></a>3、页面测试</h3><h4 id="1）页面加载思路"><a href="#1）页面加载思路" class="headerlink" title="1）页面加载思路"></a>1）页面加载思路</h4><p>打开课程资料中的 “静态页面目录” 中的课程详情模板页面，研究页面加载的思路。</p><p>模板页面路径如下：</p><div class="hljs"><pre><code class="hljs html">静态页面目录\static\course\detail\course_main_template.html</code></pre></div><ul><li><p>主页面</p><p>我们需要在主页面中通过SSI加载：页头、页尾、教育机构、教师信息</p></li><li><p>异步加载课程统计与教育机构统计信息</p><p>课程统计信息（json）、教育机构统计信息（json）</p></li><li><p>马上学习按钮事件</p><p>用户点击“马上学习”会根据课程收费情况、课程购买情况执行下一步操作。</p></li></ul><h4 id="2）静态资源虚拟主机"><a href="#2）静态资源虚拟主机" class="headerlink" title="2）静态资源虚拟主机"></a>2）静态资源虚拟主机</h4><p>静态资源虚拟主机负责处理课程详情、公司信息、老师信息、统计信息等页面的请求：</p><p>将课程资料中的 “<strong>静态页面目录</strong>” 中的目录拷贝到 <code>F:/develop/xuecheng/static</code> 下</p><p>在nginx中配置静态虚拟主机如下：</p><div class="hljs"><pre><code class="hljs c">#学成网静态资源server &#123;<span class="hljs-built_in">listen</span>       <span class="hljs-number">91</span>;    server_name localhost;    #公司信息    location /<span class="hljs-keyword">static</span>/company/ &#123;      alias  G:/job/code/Project/XueChengOnline/xcEduUI01/xuecheng/<span class="hljs-keyword">static</span>/company/; &#125;#老师信息    location /<span class="hljs-keyword">static</span>/teacher/ &#123;      alias G:/job/code/Project/XueChengOnline/xcEduUI01/xuecheng/<span class="hljs-keyword">static</span>/teacher/;        &#125;     #统计信息    location /<span class="hljs-keyword">static</span>/stat/ &#123;      alias G:/job/code/Project/XueChengOnline/xcEduUI01/xuecheng/<span class="hljs-keyword">static</span>/stat/;        &#125;     location /course/detail/ &#123;      alias G:/job/code/Project/XueChengOnline/xcEduUI01/xuecheng/<span class="hljs-keyword">static</span>/course/detail/;        &#125;     &#125;</code></pre></div><p><strong>通过 <a href="http://www.xuecheng.com" target="_blank" rel="noopener">www.xuecheng.com</a> 虚拟主机转发到静态资源</strong></p><p>由于课程页面需要通过SSI加载页头和页尾所以需要通过 <code>www.xuecheng.com</code> 虚拟主机转发到静态资源<br>在 <code>www.xuecheng.com</code> 虚拟主机加入如下配置：</p><div class="hljs"><pre><code class="hljs c">#静态页面资源location /<span class="hljs-keyword">static</span>/company/ &#123;     proxy_pass http:<span class="hljs-comment">//static_server_pool;        </span>&#125;     location /<span class="hljs-keyword">static</span>/teacher/ &#123;          proxy_pass http:<span class="hljs-comment">//static_server_pool;        </span>&#125;     location /<span class="hljs-keyword">static</span>/stat/ &#123;          proxy_pass http:<span class="hljs-comment">//static_server_pool;        </span>&#125;     location /course/detail/ &#123;          proxy_pass http:<span class="hljs-comment">//static_server_pool;        </span>&#125;</code></pre></div><p>配置 <code>upstream</code> 实现请求转发到资源服务虚拟主机：</p><div class="hljs"><pre><code class="hljs c">#静态资源服务upstream static_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">91</span> weight=<span class="hljs-number">10</span>;&#125;</code></pre></div><h4 id="3）门户静态资源路径"><a href="#3）门户静态资源路径" class="headerlink" title="3）门户静态资源路径"></a>3）门户静态资源路径</h4><p>门户中的一些图片、样式等静态资源统一通过 <code>/static</code> 路径对外提供服务，在 <code>www.xuecheng.com</code> 虚拟主机中配置如下：</p><div class="hljs"><pre><code class="hljs c">#静态资源，包括系统所需要的图片，js、css等静态资源    location /<span class="hljs-keyword">static</span>/img/ &#123;          alias   G:/job/code/Project/XueChengOnline/xcEduUI01/xc-ui-pc-<span class="hljs-keyword">static</span>-portal/img/;        &#125;location /<span class="hljs-keyword">static</span>/css/ &#123;          alias   G:/job/code/Project/XueChengOnline/xcEduUI01/xc-ui-pc-<span class="hljs-keyword">static</span>-portal/css/;        &#125;     location /<span class="hljs-keyword">static</span>/js/ &#123;          alias   G:/job/code/Project/XueChengOnline/xcEduUI01/xc-ui-pc-<span class="hljs-keyword">static</span>-portal/js/;        &#125;     location /<span class="hljs-keyword">static</span>/plugins/ &#123;          # 跨域参数    alias   G:/job/code/Project/XueChengOnline/xcEduUI01/xc-ui-pc-<span class="hljs-keyword">static</span>-portal/plugins/;            add_header Access-Control-Allow-Origin http:<span class="hljs-comment">//ucenter.xuecheng.com;          </span>    add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;              add_header Access-Control-Allow-Methods GET;        &#125;</code></pre></div><p>cors 跨域参数：</p><ul><li>Access-Control-Allow-Origin：允许跨域访问的外域地址如果允许任何站点跨域访问则设置为*，通常这是不建议的。</li><li>Access-Control-Allow-Credentials： 允许客户端携带证书访问</li><li>Access-Control-Allow-Methods：允许客户端跨域访问的方法</li></ul><h4 id="4）页面测试"><a href="#4）页面测试" class="headerlink" title="4）页面测试"></a>4）页面测试</h4><p>请求：<a href="http://www.xuecheng.com/course/detail/course_main_template.html" target="_blank" rel="noopener">http://www.xuecheng.com/course/detail/course_main_template.html</a> 测试课程详情页面模板是否可以正常浏览。</p><p><a href="https://qnoss.codeyee.com/20200704_9/image21" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="5）页面动态脚本"><a href="#5）页面动态脚本" class="headerlink" title="5）页面动态脚本"></a>5）页面动态脚本</h4><p>为了方便日后的维护，我们将 <code>javascript</code> 实现的动态部分单独编写一个 <code>html</code> 文件,在门户的 <code>include</code>目录下定义 <code>course_detail_dynamic.html</code> 文件，此文件通过 <code>ssi</code> 包含在课程详情页面中.</p><p>文件地址：<code>资料 \静态页面目录\include\course_detail_dynamic.html</code></p><p>所有的课程公用一个 页面动态脚本。</p><p>在课程详情主页面下端添加如下代码，通过 <code>SSI</code> 技术包含课程详情页面动态脚本文件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript"><span class="hljs-keyword">var</span> courseId = <span class="hljs-string">"template"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--#include virtual="/include/course_detail_dynamic.html"--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>本页面使用 <code>vue.js</code> 动态获取信息，使用 vue 的 <code>created</code> 钩子函数在页面初始化前获取动态的数据，详细请阅读该文件。</p><h2 id="2-课程数据模型接口"><a href="#2-课程数据模型接口" class="headerlink" title="2. 课程数据模型接口"></a>2. 课程数据模型接口</h2><h3 id="1、API接口定义"><a href="#1、API接口定义" class="headerlink" title="1、API接口定义"></a>1、API接口定义</h3><p>数据模型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.course.ext;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CourseBase;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CourseMarket;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CoursePic;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">//Serializable ?</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    CourseBase courseBase; <span class="hljs-comment">//课程基本信息</span>    CourseMarket courseMarket; <span class="hljs-comment">//课程营销信息</span>    CoursePic coursePic;  <span class="hljs-comment">//课程图片</span>    TeachplanNode teachplanNode; <span class="hljs-comment">//课程营销计划</span>&#125;</code></pre></div><p>API 接口，再 <code>CourseControllerApi</code> 下定义</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"课程视图查询"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CourseView <span class="hljs-title">courseView</span><span class="hljs-params">(String courseId)</span></span>;</code></pre></div><h3 id="2、Dao"><a href="#2、Dao" class="headerlink" title="2、Dao"></a>2、Dao</h3><p>根据数据模型，dao 层我们可以沿用之前开发中定义的</p><ul><li><code>CourseBaseRepository</code></li><li><code>CourseMarketRepository</code></li><li><code>CoursePicRepository</code></li><li><code>TeachplanMapper</code></li></ul><h3 id="3、Service"><a href="#3、Service" class="headerlink" title="3、Service"></a>3、Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取课程视图数据模型</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CourseView <span class="hljs-title">getCourseView</span><span class="hljs-params">(String courseId)</span> </span>&#123;    CourseView courseView = <span class="hljs-keyword">new</span> CourseView();    <span class="hljs-comment">//获取课程基本信息</span>    Optional&lt;CourseBase&gt; courseBaseOptional = courseBaseRepository.findById(courseId);    <span class="hljs-keyword">if</span>(courseBaseOptional.isPresent())&#123;        CourseBase courseBase = courseBaseOptional.get();        courseView.setCourseBase(courseBase);    &#125;    <span class="hljs-comment">//获取课程营销信息</span>    CourseMarket courseMarketById = courseMarketService.findCourseMarketById(courseId);    courseView.setCourseMarket(courseMarketById);    <span class="hljs-comment">//获取课程图片</span>    Optional&lt;CoursePic&gt; coursePicOptional = coursePicRepository.findById(courseId);    <span class="hljs-keyword">if</span>(coursePicOptional.isPresent())&#123;        CoursePic coursePic = coursePicOptional.get();        courseView.setCoursePic(coursePic);    &#125;    <span class="hljs-comment">//获取课程计划</span>    TeachplanNode teachplanNode = teachplanMapper.selectList(courseId);    courseView.setTeachplanNode(teachplanNode);    <span class="hljs-keyword">return</span> courseView;&#125;</code></pre></div><h3 id="4、Controller"><a href="#4、Controller" class="headerlink" title="4、Controller"></a>4、Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 课程预览数据模型查询</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/Courseview/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CourseView <span class="hljs-title">courseView</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.getCourseView(courseId);&#125;</code></pre></div><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p>在 Swagger 中测试</p><p><a href="https://qnoss.codeyee.com/20200704_9/image22" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image22.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-课程信息模板设计"><a href="#3-课程信息模板设计" class="headerlink" title="3. 课程信息模板设计"></a>3. 课程信息模板设计</h2><p>在确定了静态化所需要的数据模型之后，就可以编写页面模板了，课程详情页面由多个静态化页面组成，所以我们<br>需要创建多个页面模板，本章节创建课程详情页面的主模板，即课程信息模板。</p><h3 id="1、模板内容"><a href="#1、模板内容" class="headerlink" title="1、模板内容"></a>1、模板内容</h3><p>完整的模板请参考 <code>资料\课程详情页面模板\course.ftl</code> 文件，下边列出模板中核心的内容：</p><ul><li><p>课程基本信息</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"banner-left"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tit"</span>&gt;</span>$&#123;courseBase.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pic"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"new-pic"</span>&gt;</span>特惠价格￥$&#123;courseMarket.price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><span class="hljs-tag">                                                                                 <span class="hljs-attr">class</span>=<span class="hljs-string">"old-pic"</span>&gt;</span>原价￥$&#123;courseMarket.price_old!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"info"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://ucenter.xuecheng.com/#/learning/$&#123;courseBase.id&#125;/0"</span> </span><span class="hljs-tag">           <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"learnstatus == 1"</span> <span class="hljs-attr">v-cloak</span>&gt;</span>马上学习<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">"addopencourse"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"learnstatus == 2"</span> <span class="hljs-attr">v-cloak</span>&gt;</span>立即报名<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">"buy"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"learnstatus == 3"</span> <span class="hljs-attr">v-cloak</span>&gt;</span>立即购买<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>难度等级<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">courseBase.grade</span>==<span class="hljs-string">'200001'</span>&gt;</span>                        低级                        <span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">courseBase.grade</span>==<span class="hljs-string">'200002'</span>&gt;</span>                    中级                            <span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">courseBase.grade</span>==<span class="hljs-string">'200003'</span>&gt;</span>                                高级                                <span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>课程时长<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">stat</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"course_stat.s601001"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stat</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>评分<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">stat</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"course_stat.s601002"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stat</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>授课模式<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">courseBase.studymodel</span>==<span class="hljs-string">'201001'</span>&gt;</span>                        自由学习                                <span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> <span class="hljs-attr">courseBase.studymodel</span>==<span class="hljs-string">'201002'</span>&gt;</span>                            任务式学习                                    <span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>                         <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"banner-rit"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">coursePic.pic</span>??&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://img.xuecheng.com/$&#123;coursePic.pic&#125;"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"270"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"156"</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/static/img/widget-video.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"270"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"156"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"vid-act"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"i-heart"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>收藏 <span class="hljs-tag">&lt;<span class="hljs-name">stat</span> <span class="hljs-attr">v-</span></span><span class="hljs-tag">                                                                              <span class="hljs-attr">text</span>=<span class="hljs-string">"course_stat.s601003"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stat</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>分享 <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"i-weixin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"i-qq"</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li><li><p>课程计划</p></li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">teachplanNode.children</span>??&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">teachplanNode.children</span> <span class="hljs-attr">as</span> <span class="hljs-attr">firstNode</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title act"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"i-chevron-top"</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>$&#123;firstNode.pname&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"about"</span>&gt;</span>$&#123;firstNode.description!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"drop-down"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: $&#123;firstNode.children?</span></span><span class="hljs-tag"><span class="hljs-string">                                              size * 50&#125;px;"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-box"</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">firstNode.children</span> <span class="hljs-attr">as</span> <span class="hljs-attr">secondNode</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>$&#123;secondNode.pname&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><ul><li>页头引入</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">data-spy</span>=<span class="hljs-string">"scroll"</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">"#articleNavbar"</span> <span class="hljs-attr">data-offset</span>=<span class="hljs-string">"150"</span>&gt;</span> <span class="hljs-comment">&lt;!-- 页面头部 --&gt;</span><span class="hljs-comment">&lt;!--#include virtual="/include/header.html"--&gt;</span></code></pre></div><ul><li>页尾引入</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  页面底部 --&gt;</span><span class="hljs-comment">&lt;!--底部版权--&gt;</span><span class="hljs-comment">&lt;!--#include virtual="/include/footer.html"--&gt;</span></code></pre></div><ul><li>动态脚本文件引入</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> <span class="actionscript">    <span class="hljs-comment">//课程id</span></span><span class="actionscript">    <span class="hljs-keyword">var</span> courseId = <span class="hljs-string">"template"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--#include virtual="/include/course_detail_dynamic.html"--&gt;</span></code></pre></div><ul><li><p>教师信息</p><p>从课程数据中获取课程所属的教师Id，这里由于教师信息管理功能没有开发我们使用固定的教师信息文件</p></li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content-com course"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>课程制作<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!--#include virtual="/teacher/teacher_info_template01.html"--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><ul><li><p>教育机构文件</p><p>同教师信息一样，由于教育机构功能模块没有开发，这里我们使用固定的教育机构文件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"about-teach"</span>&gt;</span>     <span class="hljs-comment">&lt;!--机构信息--&gt;</span>    <span class="hljs-comment">&lt;!--#include virtual="/company/company_info_template.html"--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li></ul><h3 id="2、模板测试"><a href="#2、模板测试" class="headerlink" title="2、模板测试"></a>2、模板测试</h3><p>使用test-freemarker工程测试模板</p><p>编写模板过程采用test-freemarker工程测试模板。</p><p>将 <code>course.ftl</code> 拷贝到 <code>test-freemarker</code> 工程的 <code>resources/templates</code> 下，并在 <code>test-freemarker</code> 工程的<code>controller</code> 中加测试方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//课程详情页面测试</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/course"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">course</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>&#123;    ResponseEntity&lt;Map&gt; forEntity =restTemplate.getForEntity(<span class="hljs-string">"http://localhost:31200/course/courseview/4028e581617f945f01617f9dabc40000"</span>, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    Map body = forEntity.getBody();    map.put(<span class="hljs-string">"model"</span>,body);    <span class="hljs-keyword">return</span> <span class="hljs-string">"course"</span>;&#125;</code></pre></div><p>注意：上边的测试页面不显示样式，原因是页面通过 <code>SSI</code> 包含了页面头，而使用 <code>test-freemarker</code> 工程无法加载页头，测试模板主要查看 <code>html</code> 页面内容是否正确，待课程预览时解决样式不显示问题。</p><h3 id="3、模板保存"><a href="#3、模板保存" class="headerlink" title="3、模板保存"></a>3、模板保存</h3><p>模板编写并测试通过后要在数据库保存：</p><p>1、模板信息保存在 <code>xc_cms</code> 数据库(mongodb)的 <code>cms_template</code>表<br>2、模板文件保存在 <code>mongodb</code> 的 <code>GridFS</code> 中。</p><p>这里我们在 <code>cms</code> 服务的单元测试中进行保存。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//存文件</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGridFs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;    <span class="hljs-comment">//要储存的文件</span>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/resources/course.ftl"</span>);    <span class="hljs-comment">//定义输入流</span>    FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);    <span class="hljs-comment">//向GridFS存储文件</span>    ObjectId objectId = gridFsTemplate.store(fileInputStream, <span class="hljs-string">"index-banner"</span>);    <span class="hljs-comment">//得到文件ID</span>    String fileId = objectId.toString();    System.out.println(fileId);&#125;</code></pre></div><p>保存成功需要记录模板文件的id，即上边代码中的fileId。</p><p>第二步：向 <code>cms_template</code> 表添加模板记录（请不要重复添加）</p><p>使用 <code>Studio 3T</code> 连接<code>mongodb</code>，向 <code>cms_template</code> 添加记录：</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"_class"</span> : <span class="hljs-string">"com.xuecheng.framework.domain.cms.CmsTemplate"</span>,  <span class="hljs-attr">"siteId"</span> : <span class="hljs-string">"5a751fab6abb5044e0d19ea1"</span>,  <span class="hljs-attr">"templateName"</span> : <span class="hljs-string">"课程详情页面正式模板"</span>,  <span class="hljs-attr">"templateFileId"</span> : <span class="hljs-string">"5e93d284cc53e43424beea42"</span>&#125;</code></pre></div><h3 id="4、其他模板"><a href="#4、其他模板" class="headerlink" title="4、其他模板"></a>4、其他模板</h3><p>除了课程详情主页面需要设计模板所有静态化的页面都要设计模板，如下：</p><p><code>教育机构页面模板</code>、<code>教师信息页面模板</code>、<code>课程统计信息json模板</code>、<code>教育机构统计信息json模板</code>。</p><p>本项目我们实现课程详情主页面模板的制作和测试，其它页面模板的开发参考课程详情页面去实现。</p><h1 id="五、课程预览功能开发"><a href="#五、课程预览功能开发" class="headerlink" title="五、课程预览功能开发"></a>五、课程预览功能开发</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>课程预览功能将使用 <code>cms</code> 系统提供的页面预览功能，业务流程如下：</p><p>1、用户进入课程管理页面，点击课程预览，请求到课程管理服务</p><p>2、课程管理服务远程调用 <code>cms</code> 添加页面接口向 <code>cms</code> 添加课程详情页面</p><p>3、课程管理服务得到 <code>cms</code> 返回课程详情页面 <code>id</code>，并拼接生成课程预览 <code>Url</code></p><p>4、课程管理服务将课程预览 <code>Url</code> 给前端返回</p><p>5、用户在前端页面请求课程预览 <code>Url</code> ，打开新窗口显示课程详情内容</p><h2 id="2-CMS页面预览测试"><a href="#2-CMS页面预览测试" class="headerlink" title="2. CMS页面预览测试"></a>2. CMS页面预览测试</h2><p><code>CMS</code> 服务已经提供了页面预览功能，课程预览功能要使用 <code>CMS</code> 页面预览接口实现，下边通过 <code>cms</code> 页面预览接口测试课程预览的效果。</p><p><strong>1、向 cms_page 表插入一条页面记录或者从 cms_page 找一个页面进行测试。</strong></p><p>注意：页面配置一定要正确，需设置正确的模板 <code>id</code> 和 <code>dataUrl</code>。</p><p>如下，是一条页面的记录。</p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"5b3469f794db44269cb2bff1"</span>),     <span class="hljs-attr">"_class"</span> : <span class="hljs-string">"com.xuecheng.framework.domain.cms.CmsPage"</span>,     <span class="hljs-attr">"siteId"</span> : <span class="hljs-string">"5a751fab6abb5044e0d19ea1"</span>,     <span class="hljs-attr">"pageName"</span> : <span class="hljs-string">"4028e581617f945f01617f9dabc40000.html"</span>,     <span class="hljs-attr">"pageAliase"</span> : <span class="hljs-string">"bootstrip课程详情页面"</span>,     <span class="hljs-attr">"pageWebPath"</span> : <span class="hljs-string">"/course/detail/"</span>,     <span class="hljs-attr">"pagePhysicalPath"</span> : <span class="hljs-string">"/course/detail/"</span>,     <span class="hljs-attr">"pageType"</span> : <span class="hljs-string">"1"</span>,     <span class="hljs-attr">"pageCreateTime"</span> : ISODate(<span class="hljs-string">"2018-02-03T05:37:53.256+0000"</span>),     <span class="hljs-attr">"templateId"</span> : <span class="hljs-string">"5e93d2e3d79e7d6ed1009b95"</span>,     <span class="hljs-attr">"dataUrl"</span> : <span class="hljs-string">"http://localhost:31200/course/courseview/4028e581617f945f01617f9dabc40000"</span>&#125;</code></pre></div><p><strong>2、课程详细页面 使用 ssi 注意</strong></p><p>由于 <code>Nginx</code> 先请求 <code>cms</code> 的课程预览功能得到 <code>html</code> 页面，再解析页面中的 <code>ssi</code> 标签，这里必须保证 <code>cms</code> 页面预览返回的页面的 <code>Content-Type</code> 为 <code>text/html;charset=utf-8</code></p><p>在 <code>cms</code> 页面预览的 <code>controller</code> 方法中添加：</p><div class="hljs"><pre><code class="hljs html">response.setHeader("Content-type","text/html;charset=utf-8");</code></pre></div><p><strong>3、测试</strong></p><p>请求：<a href="http://www.xuecheng.com/cms/preview/5b3469f794db44269cb2bff1%E4%BC%A0%E5%85%A5%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">http://www.xuecheng.com/cms/preview/5b3469f794db44269cb2bff1传入页面</a> Id，测试效果如下:</p><h2 id="3-CMS添加页面接口"><a href="#3-CMS添加页面接口" class="headerlink" title="3. CMS添加页面接口"></a>3. CMS添加页面接口</h2><p>在之前进行 <code>cms</code> 服务的开发中，已经开发有页面添加的接口，为什么还要重新写一个？</p><p>因为每次进行课程预览都需要进行页面添加的操作，如果页面已经存在则不需要重复添加，只需要执行更新操作即可。</p><p>所以这里我们在 cms服务中 实现一个 <code>save</code> 接口：如果不存在页面则添加，否则就更新页面信息。</p><h3 id="1、API-接口"><a href="#1、API-接口" class="headerlink" title="1、API 接口"></a>1、API 接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 保存页面数据</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"保存页面数据"</span>)<span class="hljs-meta">@ApiImplicitParams</span>(&#123;        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"cmsPage"</span>,value = <span class="hljs-string">"请提交json形式的页面数据"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"CmsPage"</span>,dataType=<span class="hljs-string">"CmsPage"</span>),&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">saveCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span></span>;</code></pre></div><h3 id="2、Service"><a href="#2、Service" class="headerlink" title="2、Service"></a>2、Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 保存页面：如果不存在则添加，存在则更新。</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cmsPage</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">saveCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-comment">//效验cmsPage是否为空</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//抛出异常，非法参数</span>        ExceptionCast.cast(CommonCode.INVALID_PARAM);    &#125;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage one = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath());    <span class="hljs-comment">//如果页面已存在则进行更新操作</span>    <span class="hljs-keyword">if</span> (cmsPage1 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.updateCmsPage(one.getPageId(),one);    &#125;    <span class="hljs-comment">//不存在则直接添加</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addCmsPage(cmsPage);&#125;</code></pre></div><h3 id="3、Controller"><a href="#3、Controller" class="headerlink" title="3、Controller"></a>3、Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 保存页面</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> cmsPage</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/save"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">saveCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-keyword">return</span> pageService.saveCmsPage(cmsPage);&#125;</code></pre></div><h2 id="4-课程预览服务端"><a href="#4-课程预览服务端" class="headerlink" title="4. 课程预览服务端"></a>4. 课程预览服务端</h2><h3 id="1、API-定义"><a href="#1、API-定义" class="headerlink" title="1、API 定义"></a>1、API 定义</h3><p>此 <code>Api</code> 是课程管理前端请求服务端进行课程预览的Api</p><p>请求：课程 <code>Id</code></p><p>响应：状态码，课程预览 <code>Url</code></p><p>1、定义响应类型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoursePublishResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    String previewUrl;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoursePublishResult</span><span class="hljs-params">(ResultCode resultCode, String previewUrl)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.previewUrl = previewUrl;    &#125;&#125;</code></pre></div><p>2、接口定义如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"课程发布预览"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CoursePublishResult <span class="hljs-title">CoursePublishPreview</span><span class="hljs-params">(String courseId)</span></span>;</code></pre></div><h3 id="2、创建-Feign-Client"><a href="#2、创建-Feign-Client" class="headerlink" title="2、创建 Feign Client"></a>2、创建 Feign Client</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/cms/page/save"</span>)<span class="hljs-function">CmsPageResult <span class="hljs-title">saveCmsPage</span><span class="hljs-params">(@RequestBody CmsPage cmsPage)</span></span>;</code></pre></div><h3 id="3、Service-1"><a href="#3、Service-1" class="headerlink" title="3、Service"></a>3、Service</h3><div class="hljs"><pre><code class="hljs java"> <span class="hljs-comment">//从配置文件获取课程发布的基本配置</span><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;course-publish.dataUrlPre&#125;"</span>)<span class="hljs-keyword">private</span> String publish_dataUrlPre;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;course-publish.pagePhysicalPath&#125;"</span>)<span class="hljs-keyword">private</span> String publish_page_physicalpath;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;course-publish.pageWebPath&#125;"</span>)<span class="hljs-keyword">private</span> String publish_page_webpath;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;course-publish.siteId&#125;"</span>)<span class="hljs-keyword">private</span> String publish_siteId;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;course-publish.templateId&#125;"</span>)<span class="hljs-keyword">private</span> String publish_templateId;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;course-publish.previewUrl&#125;"</span>)<span class="hljs-keyword">private</span> String previewUrl;<span class="hljs-meta">@Autowired</span>CmsPageClient cmsPageClient;<span class="hljs-comment">//根据id查询课程基本信息</span><span class="hljs-function"><span class="hljs-keyword">public</span> CourseBase <span class="hljs-title">findCourseBaseById</span><span class="hljs-params">(String courseId)</span></span>&#123;    <span class="hljs-comment">//获取课程信息</span>    Optional&lt;CourseBase&gt; optionalCourseBase = courseBaseRepository.findById(courseId);    <span class="hljs-keyword">if</span>(!optionalCourseBase.isPresent())&#123;        <span class="hljs-comment">//课程不存在抛出异常</span>        ExceptionCast.cast(CourseCode.COURSE_NOTEXIST);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> optionalCourseBase.get();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 课程详细页面发布前预览</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CoursePublishResult <span class="hljs-title">coursePublishPreview</span><span class="hljs-params">(String courseId)</span> </span>&#123;    <span class="hljs-comment">//获取课程信息</span>    CourseBase courseBaseById = <span class="hljs-keyword">this</span>.findCourseBaseById(courseId);    <span class="hljs-comment">//拼装页面基本信息</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    cmsPage.setDataUrl(publish_dataUrlPre + courseId);    cmsPage.setPagePhysicalPath(publish_page_physicalpath);    cmsPage.setPageWebPath(publish_page_webpath);    cmsPage.setSiteId(publish_siteId);    cmsPage.setTemplateId(publish_templateId);    <span class="hljs-comment">//页面别名</span>    cmsPage.setPageAliase(courseBaseById.getName());    <span class="hljs-comment">//远程调用，保存页面信息</span>    CmsPageResult cmsPageResult = cmsPageClient.saveCmsPage(cmsPage);    <span class="hljs-keyword">if</span>(!cmsPageResult.isSuccess())&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoursePublishResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//页面id</span>    String cmsPageId = cmsPageResult.getCmsPage().getPageId();    <span class="hljs-comment">//返回预览url</span>    String url = previewUrl + cmsPageId;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoursePublishResult(CommonCode.SUCCESS,url);&#125;</code></pre></div><h3 id="4、Controller-1"><a href="#4、Controller-1" class="headerlink" title="4、Controller"></a>4、Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 发布页面</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">*/</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/postPage/&#123;pageId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">post</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"pageId"</span>)</span> String pageId) </span>&#123;    <span class="hljs-keyword">return</span> pageService.postPage(pageId);&#125;</code></pre></div><h3 id="5、测试-1"><a href="#5、测试-1" class="headerlink" title="5、测试"></a>5、测试</h3><p>先在 course 服务中的 swagger 进行测试</p><p><a href="https://qnoss.codeyee.com/20200704_9/image23" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image23.png" srcset="/img/loading.gif" alt="img"></a></p><p>得到预览url，访问测试</p><p><a href="https://qnoss.codeyee.com/20200704_9/image24" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image24.png" srcset="/img/loading.gif" alt="img"></a></p><p>这里实际上只动态渲染了课程部分的数据，例如课程名称，课程介绍等，教师信息和公司介绍等都是静态数据，需要后期进行完善。</p><h2 id="5-前端开发"><a href="#5-前端开发" class="headerlink" title="5. 前端开发"></a>5. 前端开发</h2><p>1、API 方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*预览课程*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> preview = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/course/preview/'</span>+id);&#125;</code></pre></div><p>2、页面</p><p>创建 <code>course_pub.vue</code></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el‐card</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box‐card"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"header"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>课程预览<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text item"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>  @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"preview"</span> &gt;</span>课程预览<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">if</span>=<span class="hljs-string">"previewurl &amp;&amp; previewurl!=''"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"previewurl"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>点我查看课程预览页面 <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐card</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>数据对象：</p><div class="hljs"><pre><code class="hljs js">data() &#123;   <span class="hljs-keyword">return</span> &#123;    dotype:<span class="hljs-string">''</span>,    courseid:<span class="hljs-string">''</span>,    course: &#123;<span class="hljs-string">"id"</span>:<span class="hljs-string">""</span>,<span class="hljs-string">"name"</span>:<span class="hljs-string">""</span>,<span class="hljs-string">"status"</span>:<span class="hljs-string">""</span>&#125;,    previewurl:<span class="hljs-string">''</span>  &#125;</code></pre></div><p>方法 ：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 预览</span>preview()&#123;  courseApi.preview(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(res.success)&#123;      <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'预览页面生成成功，请点击下方预览链接'</span>);           <span class="hljs-keyword">if</span>(res.url)&#123;         <span class="hljs-comment">//预览url</span>        <span class="hljs-keyword">this</span>.previewurl = res.url      &#125;    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">this</span>.$message.error(res.message);    &#125;  &#125;);&#125;</code></pre></div><p>3、测试</p><p>点击预览后成功链接</p><p><a href="https://qnoss.codeyee.com/20200704_9/image25" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image25.png" srcset="/img/loading.gif" alt="img"></a></p><p>访问预览链接</p><p><a href="https://qnoss.codeyee.com/20200704_9/image26" target="_blank" rel="noopener"><img src="/2020/08/16/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday09/image26.png" srcset="/img/loading.gif" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eureka</tag>
      
      <tag>Feign</tag>
      
      <tag>Ribbon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day08：FastDFS实现课程图片管理</title>
    <link href="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/"/>
    <url>/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day08</code> 的内容</p><ul><li><code>FastDFS</code> 的 安装与基本使用流程。</li><li>基于 <code>Java Api</code> 来操作 <code>FastDFS</code></li><li>结合 <code>FastDFS</code> 实现对课程图片的 <code>CRUD</code></li><li>图片删除的场景使用 <code>Promise</code> 解决一些问题</li></ul><h1 id="一、FastDFS-探究"><a href="#一、FastDFS-探究" class="headerlink" title="一、FastDFS 探究"></a>一、FastDFS 探究</h1><h2 id="1-什么是fastDFS"><a href="#1-什么是fastDFS" class="headerlink" title="1. 什么是fastDFS ?"></a>1. 什么是fastDFS ?</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>FastDFS是用c语言编写的一款开源的分布式文件系统，它是由淘宝资深架构师余庆编写并开源。FastDFS专为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><p>为什么要使用 <code>fastDFS</code> 呢？</p><p>上边介绍的 <code>NFS</code>、<code>GFS</code> 都是通用的分布式文件系统，通用的分布式文件系统的优点的是开发体验好，但是系统复杂性高、性能一般，而专用的分布式文件系统虽然开发体验性差，但是系统复杂性低并且性能高。<code>fastDFS</code> 非常适合存储图片等那些小文件，<code>fastDFS</code> 不对文件进行分块，所以它就没有分块合并的开销，<code>fastDFS</code> 网络通信采用 <code>socket</code>，通信速度很快。</p><h3 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h3><p><code>FastDFS</code> 架构包括 <code>Tracker server</code> 和 <code>Storageserver</code>。客户端请求 <code>Tracker server</code> 进行文件上传、下载，通过 <code>Tracker server</code> 调度最终由 <code>Storage server</code> 完成文件上传和下载。</p><p><a href="https://qnoss.codeyee.com/20200704_8/image1" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>1）Tracker</strong></p><p>Tracker Server作用是负载均衡和调度，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将 <code>tracker</code> 称为追踪服务器或调度服务器。</p><p><code>FastDFS</code> 集群中的 <code>Tracker server</code> 可以有多台，<code>Tracker server</code> 之间是相互平等关系同时提供服务，<code>Tracker server</code> 不存在单点故障。客户端请求 <code>Tracker server</code> 采用轮询方式，如果请求的 <code>tracker</code> 无法提供服务则换另一个 <code>tracker</code>。</p><p><strong>2）Storage</strong></p><p><code>Storage Server</code> 作用是文件存储，客户端上传的文件最终存储在 <code>Storage</code> 服务器上，<code>Storage server</code> 没有实现自己的文件系统而是使用操作系统的文件系统来管理文件。可以将 <code>storage</code> 称为存储服务器。</p><p><code>Storage</code> 集群采用了分组存储方式。<code>storage</code> 集群由一个或多个组构成，集群存储总容量为集群中所有组的存储容量之和。一个组由一台或多台存储服务器组成，组内的 <code>Storage server</code> 之间是平等关系，不同组的 <code>Storage server</code> 之间不会相互通信，同组内的 <code>Storage server</code> 之间会相互连接进行文件同步，从而保证同组内每个storage上的文件完全一致的。一个组的存储容量为该组内的存储服务器容量最小的那个，由此可见组内存储服务器的软硬件配置最好是一致的。</p><p>采用分组存储方式的好处是灵活、可控性较强。比如上传文件时，可以由客户端直接指定上传到的组也可以由 <code>tracker</code> 进行调度选择。一个分组的存储服务器访问压力较大时，可以在该组增加存储服务器来扩充服务能力（纵向扩容）。当系统容量不足时，可以增加组来扩充存储容量（横向扩容）。</p><p><strong>3）Storage状态收集</strong></p><p><code>Storage server</code> 会连接集群中所有的 <code>Tracker server</code>，定时向他们报告自己的状态，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。</p><h3 id="3、文件上传流程"><a href="#3、文件上传流程" class="headerlink" title="3、文件上传流程"></a>3、文件上传流程</h3><p><a href="https://qnoss.codeyee.com/20200704_8/image2" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>客户端上传文件后存储服务器将 <code>文件ID</code> 返回给客户端，此 <code>文件ID</code> 用于以后访问该文件的索引信息。文件索引信息，包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><a href="https://qnoss.codeyee.com/20200704_8/image3" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image3.png" srcset="/img/loading.gif" alt="img"></a></p><ul><li>组名：文件上传后所在的 storage组名称，在文件上传成功后有 storage服务器返回，需要客户端自行保存。</li><li>虚拟磁盘路径： storage配置的虚拟路径，与磁盘选项 store_path* 对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。</li><li>数据两级目录： storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。</li><li>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</li></ul><h3 id="4、文件下载流程"><a href="#4、文件下载流程" class="headerlink" title="4、文件下载流程"></a>4、文件下载流程</h3><p><a href="https://qnoss.codeyee.com/20200704_8/image4" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p><code>tracker</code> 根据请求的文件路径即文件ID 来快速定义文件。</p><p>比如请求下边的文件：</p><p><a href="https://qnoss.codeyee.com/20200704_8/image5" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image5.png" srcset="/img/loading.gif" alt="img"></a></p><p>1.通过组名tracker能够很快的定位到客户端需要访问的存储服务器组是group1，并选择合适的存储服务器提供客户端访问。</p><p>2.存储服务器根据“文件存储虚拟磁盘路径”和“数据文件两级目录”可以很快定位到文件所在目录，并根据文件名找到客户端需要访问的文件。</p><h2 id="2-FastDFS入门"><a href="#2-FastDFS入门" class="headerlink" title="2. FastDFS入门"></a>2. FastDFS入门</h2><h3 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h3><p>安装 FastDFS 流程 参考： <a href="https://www.cnblogs.com/yufeng218/p/8111961.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8111961.html</a></p><p>搭建好的Centos7成品:</p><p>链接：<a href="https://pan.baidu.com/s/1GgUzfd8CnxzemQzvHXSzmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GgUzfd8CnxzemQzvHXSzmA</a><br>提取码：jk00<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p><p><strong>具体搭建过程完全按照这篇博客完成的</strong>：</p><p><a href="https://www.cnblogs.com/yufeng218/p/8111961.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8111961.html</a></p><p>感兴趣的可以试着做做。（良心文章）</p><p>另外，使用我搭建好的Centos7有几个地方需要<strong>注意一下</strong>。</p><h4 id="配置和启动storage"><a href="#配置和启动storage" class="headerlink" title="配置和启动storage"></a>配置和启动storage</h4><ol><li>cd切换目录到： /etc/fdfs/ 目录下</li><li>修改storage.conf ;   <strong>vi  storage.conf</strong></li></ol><div class="hljs"><pre><code class="hljs angelscript">#配置tracker服务器:IPtracker_server=<span class="hljs-number">192.168</span><span class="hljs-number">.172</span><span class="hljs-number">.20</span>:<span class="hljs-number">22122</span>#如果有多个则配置多个tracker#tracker_server=<span class="hljs-number">192.168</span><span class="hljs-number">.101</span><span class="hljs-number">.4</span>:<span class="hljs-number">22122</span>这里的storage.conf配置文件要成自己虚拟机的ip地址</code></pre></div><ol start="3"><li><strong>vi /etc/fdfs/mod_fastdfs.conf，改成虚拟机ip地址（同上）</strong></li></ol><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">base_path</span>=/home/fastdfs<span class="hljs-attr">tracker_server</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">172.20</span>:<span class="hljs-number">22122</span> <span class="hljs-comment">#tracker_server=192.168.172.20:22122 #(多个tracker配置多行)</span><span class="hljs-attr">url_have_group_name</span>=<span class="hljs-literal">true</span>        <span class="hljs-comment">#url中包含group名称</span><span class="hljs-attr">store_path0</span>=/home/fdfs_storage  <span class="hljs-comment">#指定文件存储路径（上面配置的store路径）</span></code></pre></div><p>　　　　4.修改nginx配置文件，改iP地址（同上）</p><div class="hljs"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /usr/<span class="hljs-keyword">local</span>/nginx/<span class="hljs-keyword">conf</span>/vi nginx.<span class="hljs-keyword">conf</span></code></pre></div><p><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/20.png" srcset="/img/loading.gif" alt="img"></p><p>我的Centos7默认配置<strong>tracker，**</strong>storage和nginx默认开机自动启动了**</p><p>可以启动完成后进入 /home/fdfs_storage/data 目录下，可以看到已经启动了。</p><p><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/21.png" srcset="/img/loading.gif" alt="img"></p><p> nginx可以通过ps -ef | grep nginx查看进程，</p><p><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/22.png" srcset="/img/loading.gif" alt="img"></p><h4 id="上传图片测试"><a href="#上传图片测试" class="headerlink" title="上传图片测试"></a>上传图片测试</h4><p>拷贝一张图片1.jpg 到Centos服务器上的 root目录下,输入以下指令</p><div class="hljs"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/fdfs_test /</span>etc<span class="hljs-regexp">/fdfs/</span>client.conf upload <span class="hljs-regexp">/root/</span><span class="hljs-number">1</span>.jpg</code></pre></div><p><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/23.png" srcset="/img/loading.gif" alt="img"></p><p> 红色既是url地址，在浏览器上输入，可以看到上传图片成功！！</p><p><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/24.png" srcset="/img/loading.gif" alt="img"></p><h3 id="2、上传、下载、查询-测试"><a href="#2、上传、下载、查询-测试" class="headerlink" title="2、上传、下载、查询 测试"></a>2、上传、下载、查询 测试</h3><p>在工程下创建 <code>test-fastdfs</code> 模块</p><h4 id="1）上传测试"><a href="#1）上传测试" class="headerlink" title="1）上传测试"></a>1）上传测试</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestFastDFS</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 测试文件上传</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFileUpload</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//加载配置文件</span>            ClientGlobal.initByProperties(<span class="hljs-string">"config/fastdfs-client.properties"</span>);            <span class="hljs-comment">//连接 Tracker</span>            TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();            TrackerServer trackerServer = trackerClient.getConnection();            <span class="hljs-comment">//获取 Storage</span>            StorageServer storeStorage = trackerClient.getStoreStorage(trackerServer);            <span class="hljs-comment">//创建 Storage Client</span>            StorageClient1 storageClient1 = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storeStorage);            <span class="hljs-comment">//向 Storage 服务器上传文件,拿到文件id</span>            String filePath = <span class="hljs-string">"d:/test1.html"</span>;            String fileId = storageClient1.upload_file1(filePath, <span class="hljs-string">"html"</span>, <span class="hljs-keyword">null</span>);            System.out.println(<span class="hljs-string">"上传成功："</span> + fileId);        &#125; <span class="hljs-keyword">catch</span> (Exception ex)&#123;            ex.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>在上述的代码中，我们通过访问 <code>Tracker</code> 将 <code>d:/test1.html</code> 文件上传到了 Storage 服务器中，上传完成后得到了文件的完整的储存路径，如下：</p><p><code>group1/M00/00/00/CgEBmF6QKa-Abjv7AAAGqbcDljA60.html</code></p><p><a href="https://qnoss.codeyee.com/20200704_8/image6" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们可以在 <code>Storage</code> 中的物理 <code>fdfs_storage/data</code> 路径找到该文件</p><p><a href="https://qnoss.codeyee.com/20200704_8/image7" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image7.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="2）文件查询"><a href="#2）文件查询" class="headerlink" title="2）文件查询"></a>2）文件查询</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 文件信息查询</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFileInfoQuery</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//加载配置文件</span>        ClientGlobal.initByProperties(<span class="hljs-string">"config/fastdfs-client.properties"</span>);        <span class="hljs-comment">//连接 Tracker</span>        TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();        TrackerServer trackerServer = trackerClient.getConnection();        <span class="hljs-comment">//获取 Storage</span>        StorageServer storeStorage = trackerClient.getStoreStorage(trackerServer);        <span class="hljs-comment">//创建 Storage Client</span>        StorageClient1 storageClient1 = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storeStorage);        String fileId = <span class="hljs-string">"group1/M00/00/00/CgEBmF6QKa-Abjv7AAAGqbcDljA60.html"</span>;        FileInfo fileInfo = storageClient1.query_file_info1(fileId);        System.out.println(<span class="hljs-string">"文件信息: "</span>+ fileInfo);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></div><p>运行结果</p><p><a href="https://qnoss.codeyee.com/20200704_8/image8" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image8.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="3）文件下载"><a href="#3）文件下载" class="headerlink" title="3）文件下载"></a>3）文件下载</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 文件下载</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFileDownload</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//加载配置文件</span>        ClientGlobal.initByProperties(<span class="hljs-string">"config/fastdfs-client.properties"</span>);        <span class="hljs-comment">//连接 Tracker</span>        TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();        TrackerServer trackerServer = trackerClient.getConnection();        <span class="hljs-comment">//获取 Storage</span>        StorageServer storeStorage = trackerClient.getStoreStorage(trackerServer);        <span class="hljs-comment">//创建 Storage Client</span>        StorageClient1 storageClient1 = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storeStorage);        String fileId = <span class="hljs-string">"group1/M00/00/00/CgEBmF6QKa-Abjv7AAAGqbcDljA60.html"</span>;        String saveToPath = <span class="hljs-string">"d:/test.html"</span>;        <span class="hljs-comment">//下载文件</span>        <span class="hljs-keyword">byte</span>[] bytes = storageClient1.download_file1(fileId);        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(saveToPath));        fileOutputStream.write(bytes);        System.out.println(<span class="hljs-string">"下载成功! "</span> + saveToPath);    &#125; <span class="hljs-keyword">catch</span> (Exception ex)&#123;        ex.printStackTrace();    &#125;&#125;</code></pre></div><p>运行结果</p><p><a href="https://qnoss.codeyee.com/20200704_8/image9" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image9.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="3、搭建图片虚拟主机"><a href="#3、搭建图片虚拟主机" class="headerlink" title="3、搭建图片虚拟主机"></a>3、搭建图片虚拟主机</h3><h4 id="1）-在storage上安装Nginx"><a href="#1）-在storage上安装Nginx" class="headerlink" title="1） 在storage上安装Nginx"></a>1） 在storage上安装Nginx</h4><p>在 <code>storage server</code> 上安装 <code>nginx</code> 的目的是对外通过 <code>http</code> 访问 <code>storage server</code> 上的文 件。使用 <code>nginx</code> 的模块 <code>FastDFS-nginx-module</code> 的作用是通过 <code>http</code> 方式访问 <code>storage</code> 中 的文件，当 <code>storage</code> 本机没有要找的文件时向源<code>storage</code> 主机代理请求文件。</p><p>在storage上安装nginx（安装 <code>FastDFS-nginx-module</code> 模块）</p><p>参考：<code>FastDFS安装教程.pdf</code> 进行安装</p><p>安装完成启动 <code>storage</code>上的 <code>nginx</code>：</p><div class="hljs"><pre><code class="hljs shell">/usr/local/nginx/sbin/nginx ‐c /usr/local/nginx/conf/nginx‐fdfs.conf</code></pre></div><h4 id="2）配置-Nginx-的图片服务的虚拟主机"><a href="#2）配置-Nginx-的图片服务的虚拟主机" class="headerlink" title="2）配置 Nginx 的图片服务的虚拟主机"></a>2）配置 Nginx 的图片服务的虚拟主机</h4><p>图片服务虚拟主机的作用是负载均衡，将图片请求转发到 <code>storage server</code> 上。</p><p>1、 通过图片服务虚拟主机请求图片流程图</p><p><a href="https://qnoss.codeyee.com/20200704_8/image10" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>2、在 <code>nginx</code> 图片代理服务上配置图片服务器虚拟主机</p><p>修改本地的 <code>hosts</code> 文件，将 img.xuecheng.com 映射到本地IP <code>127.0.0.1</code></p><p>windows 的 hosts 文件路径为：<code>C:\Windows\System32\drivers\etc</code></p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> img.xuecheng.com</code></pre></div><p>增加 <code>nginx</code> 虚拟机主机</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">图片服务</span>upstream img_server_pool&#123;<span class="hljs-meta">#</span><span class="bash">server 192.168.101.64:80 weight=10;</span>server 10.1.1.152:80 weight=10;&#125; <span class="hljs-meta">#</span><span class="bash">学成网图片服务</span>server &#123;listen       80;    server_name img.xuecheng.com;    <span class="hljs-meta">#</span><span class="bash">个人中心    </span>location /group1 &#123;      proxy_pass http://img_server_pool;          &#125;     location /group2 &#123;      proxy_pass http://img_server_pool;          &#125;     &#125;</code></pre></div><p>3、测试访问</p><p><a href="http://img.xuecheng.com/group1/M00/00/00/CgEBmF6QKa-Abjv7AAAGqbcDljA60.html" target="_blank" rel="noopener">http://img.xuecheng.com/group1/M00/00/00/CgEBmF6QKa-Abjv7AAAGqbcDljA60.html</a></p><p>成功映射到 storage 服务上</p><p><a href="https://qnoss.codeyee.com/20200704_8/image11" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image11.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>通过本次课程的学习您要达到以下目标：</p><p><strong>1）了解分布式文件系统的概念及应用场景</strong></p><p>分布式文件系统是通过网络将单机上的文件系统组成一个网络文件系统。</p><p>分布式文件系统主要应用在大型互联网项目中，实现图片存储、音视频存储等服务。</p><p>分布式文件系统的优点：可以快速扩容存储，提高文件访问速度。</p><p><strong>2）理解fastDFS的工作原理</strong></p><p>fastDFS 由 <code>tracker</code> 和 <code>storage</code> 组成，它们都可以部署集群。</p><p><code>tracker</code> 负责调度，<code>storage</code> 负责存储。</p><p><strong>3）掌握 fastDFS 存取文件方法</strong></p><p>客户端与 <code>fastDFS</code> 采用 <code>socket</code> 协议通信，可以采用官方提供的 <code>java</code>版本的 <code>fastDSF-client</code>快速开发。</p><p><strong>4）能够动手搭建一个 fastDSF 文件服务器</strong></p><h1 id="二、上传课程图片"><a href="#二、上传课程图片" class="headerlink" title="二、上传课程图片"></a>二、上传课程图片</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>在很多系统都有上传图片/上传文件的需求，比如：上传课程图片、上传课程资料、上传用户头像等，为了提供系统的可重用性专门设立文件系统服务承担图片/文件的管理，文件系统服务实现对文件的上传、删除、查询等功能进行管理。</p><p>各个子系统不再开发上传文件的请求，各个子系统通过文件系统服务进行文件的上传、删除等操作。文件系统服务最终会将文件存储到 <code>fastDSF</code> 文件系统中。</p><p>下图是各各子系统与文件系统服务之间的关系：</p><p><a href="https://qnoss.codeyee.com/20200704_8/image12" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>下图是课程管理中上传图片处理流程：</p><p><a href="https://qnoss.codeyee.com/20200704_8/image13" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image13.png" srcset="/img/loading.gif" alt="img"></a></p><p>执行流程如下：</p><p>1、管理员进入教学管理前端，点击上传图片</p><p>2、图片上传至文件系统服务，文件系统请求 <code>fastDFS</code> 上传文件</p><p>3、文件系统将文件入库，存储到文件系统服务数据库中。</p><p>4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的 <code>Url</code> 路径。</p><p>5、课程管理前端请求 课程管理 进行保存课程图片信息到课程 数据库。</p><p>6、课程管理服务将课程图片保存在 课程数据库。</p><h2 id="2-创建工程"><a href="#2-创建工程" class="headerlink" title="2. 创建工程"></a>2. 创建工程</h2><p>导入<code>xc-service-base-filesystem.zip</code>工程。</p><p>1）工程目录结构如下</p><p><a href="https://qnoss.codeyee.com/20200704_8/image14" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image14.png" srcset="/img/loading.gif" alt="image-20200410193248194"></a></p><p><a href="https://qnoss.codeyee.com/20200704_8/image14" target="_blank" rel="noopener">image-20200410193248194</a></p><p>1）pom.xml 文件</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-base-filesystem<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>2）配置文件</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">22100</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc-service-base-filesystem</span><span class="hljs-comment">#mongo配置</span>  <span class="hljs-attr">data:</span>    <span class="hljs-attr">mongodb:</span>      <span class="hljs-attr">database:</span> <span class="hljs-string">xc_fs</span>      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://root:123123@127.0.0.1:27017</span><span class="hljs-comment">#SpringMVC上传文件配置</span>  <span class="hljs-attr">servlet:</span>    <span class="hljs-attr">multipart:</span>      <span class="hljs-comment">#默认支持文件上传.</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>      <span class="hljs-comment">#支持文件写入磁盘.</span>      <span class="hljs-attr">file-size-threshold:</span> <span class="hljs-number">0</span>      <span class="hljs-comment"># 上传文件的临时目录</span>      <span class="hljs-attr">location:</span>      <span class="hljs-comment"># 最大支持文件大小</span>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">1MB</span>      <span class="hljs-comment"># 最大支持请求大小</span>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">30MB</span><span class="hljs-attr">xuecheng:</span>  <span class="hljs-attr">fastdfs:</span>    <span class="hljs-attr">connect_timeout_in_seconds:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">network_timeout_in_seconds:</span> <span class="hljs-number">30</span>    <span class="hljs-attr">charset:</span> <span class="hljs-string">UTF-8</span>    <span class="hljs-attr">tracker_servers:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.101</span><span class="hljs-number">.65</span><span class="hljs-string">:22122</span> <span class="hljs-comment">#多个 trackerServer中间以逗号分隔</span></code></pre></div><h2 id="3-构建接口"><a href="#3-构建接口" class="headerlink" title="3. 构建接口"></a>3. 构建接口</h2><p>系统的文件信息（图片、文档等小文件的信息）在mongodb中存储，下边是文件信息的模型类。</p><h3 id="1、模型类"><a href="#1、模型类" class="headerlink" title="1、模型类"></a>1、模型类</h3><p><strong>1）模型类如下</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Document</span>(collection = <span class="hljs-string">"filesystem"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystem</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> String fileId;    <span class="hljs-comment">//文件请求路径</span>    <span class="hljs-keyword">private</span> String filePath;    <span class="hljs-comment">//文件大小</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> fileSize;    <span class="hljs-comment">//文件名称</span>    <span class="hljs-keyword">private</span> String fileName;    <span class="hljs-comment">//文件类型</span>    <span class="hljs-keyword">private</span> String fileType;    <span class="hljs-comment">//图片宽度</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fileWidth;    <span class="hljs-comment">//图片高度</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fileHeight;    <span class="hljs-comment">//用户id，用于授权暂时不用</span>    <span class="hljs-keyword">private</span> String userId;    <span class="hljs-comment">//业务key</span>    <span class="hljs-keyword">private</span> String businesskey;    <span class="hljs-comment">//业务标签</span>    <span class="hljs-keyword">private</span> String filetag;    <span class="hljs-comment">//文件元信息</span>    <span class="hljs-keyword">private</span> Map metadata;&#125;</code></pre></div><p>说明：</p><ul><li>fileId：<code>fastDFS</code> 返回的文件 ID。</li><li>filePath：请求<code>fastDFS</code>浏览文件 URL。</li><li>filetag：文件标签，由于文件系统服务是公共服务，文件系统服务会为使用文件系统服务的子系统分配文件标签，用于标识此文件来自哪个系统。</li><li>businesskey：文件系统服务为其它子系统提供的一个业务标识字段，各子系统根据自己的需求去使用，比如：课程管理会在此字段中存储课程 <code>id</code> 用于标识该图片属于哪个课程。</li><li>metadata：文件相关的元信息。</li></ul><p><strong>2）数据库 collection 集合</strong></p><p>在 <code>mongodb</code> 创建数据库xc_fs（文件系统数据库），并创建集合 <code>filesystem</code>。</p><p><a href="https://qnoss.codeyee.com/20200704_8/image15" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="2、API-接口"><a href="#2、API-接口" class="headerlink" title="2、API 接口"></a>2、API 接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"文件管理接口"</span>, description = <span class="hljs-string">"文件管理接口，提供对文件的CRUD"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FileSystemControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"上传文件接口"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> UploadFileResult <span class="hljs-title">uploadFile</span><span class="hljs-params">(MultipartFile multipartFile,</span></span><span class="hljs-function"><span class="hljs-params">                                       String fileTage,</span></span><span class="hljs-function"><span class="hljs-params">                                       String businessKey,</span></span><span class="hljs-function"><span class="hljs-params">                                       String metaData)</span></span>;&#125;</code></pre></div><h3 id="3、Dao-层"><a href="#3、Dao-层" class="headerlink" title="3、Dao 层"></a>3、Dao 层</h3><p>dao 层继承 <code>Spring Data Mongodb</code> 的 API</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.filesystem.dao;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.filesystem.FileSystem;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FileSystemRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">FileSystem</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="4、Service-层"><a href="#4、Service-层" class="headerlink" title="4、Service 层"></a>4、Service 层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.filesystem.service;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.xuecheng.filesystem.dao.FileSystemRepository;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.filesystem.FileSystem;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.filesystem.response.FileSystemCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.filesystem.response.UploadFileResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.csource.common.MyException;<span class="hljs-keyword">import</span> org.csource.fastdfs.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystemService</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.fastdfs.tracker_servers&#125;"</span>)    String tracker_servers;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.fastdfs.connect_timeout_in_seconds&#125;"</span>)    <span class="hljs-keyword">int</span> connect_timeout_in_seconds;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.fastdfs.network_timeout_in_seconds&#125;"</span>)    <span class="hljs-keyword">int</span> network_timeout_in_seconds;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.fastdfs.charset&#125;"</span>)    String charset;    <span class="hljs-meta">@Autowired</span>    FileSystemRepository fileSystemRepository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 上传文件到FastDFS</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> multipartFile 文件数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileTag 文件标签</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessKey 业务key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaData 文件元数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UploadFileResult <span class="hljs-title">uploadFile</span><span class="hljs-params">(MultipartFile multipartFile,</span></span><span class="hljs-function"><span class="hljs-params">                                       String fileTag,</span></span><span class="hljs-function"><span class="hljs-params">                                       String businessKey,</span></span><span class="hljs-function"><span class="hljs-params">                                       String metaData)</span></span>&#123;        <span class="hljs-comment">//验证提交的文件是否为空</span>        <span class="hljs-keyword">if</span>(multipartFile == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_FILEISNULL);        &#125;        <span class="hljs-comment">//第一步：将文件上传到 FastDFS中</span>        String fileId = <span class="hljs-keyword">this</span>.fdfsUpload(multipartFile);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(fileId))&#123;    <span class="hljs-comment">//上传文件为空时抛出异常</span>            ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_SERVERFAIL);        &#125;        <span class="hljs-comment">//第二步：将文件储存到mongoDB内</span>        <span class="hljs-comment">//设置相关的文件信息</span>        FileSystem fileSystem = <span class="hljs-keyword">new</span> FileSystem();        fileSystem.setFileId(fileId);        fileSystem.setFileName(multipartFile.getOriginalFilename());        fileSystem.setBusinesskey(businessKey);        fileSystem.setFilePath(fileId); <span class="hljs-comment">//FastDFS的fileId就是实际的物理路径</span>        fileSystem.setFileSize(multipartFile.getSize());        fileSystem.setFiletag(fileTag);        fileSystem.setFileType(multipartFile.getContentType());        <span class="hljs-comment">//文件元数据需要转换成Map对象</span>        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(metaData))&#123;            Map metaDataMap = JSON.parseObject(metaData, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            fileSystem.setMetadata(metaDataMap);        &#125;        FileSystem save = fileSystemRepository.save(fileSystem);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UploadFileResult(CommonCode.SUCCESS,save);    &#125;    <span class="hljs-comment">//上传文件到FastDFS</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">fdfsUpload</span><span class="hljs-params">(MultipartFile multipartFile)</span></span>&#123;        <span class="hljs-comment">//初始化FastDFS的环境</span>        <span class="hljs-keyword">try</span> &#123;            initFdfsConfig();            TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();            TrackerServer trackerServer = trackerClient.getConnection();            <span class="hljs-comment">//得到 Storage 连接信息</span>            StorageServer storeStorage = trackerClient.getStoreStorage(trackerServer);            <span class="hljs-comment">//获取 Storage 客户端</span>            StorageClient1 storageClient1 = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storeStorage);            <span class="hljs-comment">//上传文件</span>            <span class="hljs-keyword">byte</span>[] fileBytes = multipartFile.getBytes();   <span class="hljs-comment">// 获取文件信息</span>            String originalFilename = multipartFile.getOriginalFilename();            <span class="hljs-comment">// 获取文件拓展名</span>            String extStr = originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">"."</span>) + <span class="hljs-number">1</span>);            <span class="hljs-comment">//上传文件</span>            String fileId = storageClient1.upload_file1(fileBytes, extStr, <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> fileId;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//初始化FastDFS环境</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFdfsConfig</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;              ClientGlobal.initByTrackers(tracker_servers);              ClientGlobal.setG_connect_timeout(connect_timeout_in_seconds);              ClientGlobal.setG_network_timeout(network_timeout_in_seconds);              ClientGlobal.setG_charset(charset);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-comment">//抛出异常</span>            ExceptionCast.cast(FileSystemCode.FS_INITFDFS_ERROR);        &#125;    &#125;&#125;</code></pre></div><h3 id="5、Controller-层"><a href="#5、Controller-层" class="headerlink" title="5、Controller 层"></a>5、Controller 层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.filesystem.controller;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/filesystem"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystemController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FileSystemControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    FileSystemService fileSystemService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> UploadFileResult <span class="hljs-title">uploadFile</span><span class="hljs-params">(MultipartFile multipartFile, String fileTag, String businessKey, String metaData)</span> </span>&#123;        <span class="hljs-keyword">return</span> fileSystemService.uploadFile(multipartFile,fileTag,businessKey,metaData);    &#125;&#125;</code></pre></div><h3 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h3><p>在 Swagger UI 生成的接口文档内进行测试 <a href="http://localhost:22100/swagger-ui.html" target="_blank" rel="noopener">http://localhost:22100/swagger-ui.html</a></p><p><a href="https://qnoss.codeyee.com/20200704_8/image16" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image16.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-前端配置"><a href="#4-前端配置" class="headerlink" title="4. 前端配置"></a>4. 前端配置</h2><h3 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h3><p>上传图片界面如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_8/image17" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image17.png" srcset="/img/loading.gif" alt="img"></a></p><p>点击“加号”上传图片，图片上传成功自动显示；点击“删除”将删除图片。</p><h3 id="2、页面"><a href="#2、页面" class="headerlink" title="2、页面"></a>2、页面</h3><p>使用 <code>Element-UI</code> 的<code>Upload</code>上传组件实现上边的效果。</p><p><strong>1) template</strong></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐upload</span></span><span class="hljs-tag">  <span class="hljs-attr">action</span>=<span class="hljs-string">"/filesystem/upload"</span></span><span class="hljs-tag">  <span class="hljs-attr">list</span>‐<span class="hljs-attr">type</span>=<span class="hljs-string">"picture‐card"</span></span><span class="hljs-tag">  <span class="hljs-attr">name</span>=<span class="hljs-string">"multipartFile"</span> </span><span class="hljs-tag">  <span class="hljs-attr">:before</span>‐<span class="hljs-attr">upload</span>=<span class="hljs-string">"setbusinesskey"</span></span><span class="hljs-tag">  <span class="hljs-attr">:on</span>‐<span class="hljs-attr">success</span>=<span class="hljs-string">"handleSuccess"</span></span><span class="hljs-tag">  <span class="hljs-attr">:file</span>‐<span class="hljs-attr">list</span>=<span class="hljs-string">"fileList"</span></span><span class="hljs-tag">  <span class="hljs-attr">:limit</span>=<span class="hljs-string">"picmax"</span></span><span class="hljs-tag">  <span class="hljs-attr">:on</span>‐<span class="hljs-attr">exceed</span>=<span class="hljs-string">"rejectupload"</span></span><span class="hljs-tag">  <span class="hljs-attr">:data</span>=<span class="hljs-string">"uploadval"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"el‐icon‐plus"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐upload</span>&gt;</span></code></pre></div><p>el-upload参数说明：</p><ul><li>action：必选参数，上传的地址</li><li>list-type：文件列表的类型（text/picture/picture-card）</li><li>name: 提交的文件参数名称，这里要跟后端接收的对应上</li><li>before-upload：上传前执行钩子方法 ，function(file)</li><li>on-success：上传成功 执行的钩子方法 ，function(response, file, fileList)</li><li>on-error：上传失败的钩子方法，function(err, file, fileList)</li><li>on-remove：文件删除的钩子方法，function(file, fileList)</li><li>file-list：文件列表，此列表为上传成功 的文件</li><li>limit：最大允许上传个数</li><li>on-exceed：文件超出个数限制时的钩子，方法为：function(files, fileList)</li><li>data：提交上传的额外参数，需要封装为json对象，最终提交给服务端为key/value串</li></ul><p><strong>2) 数据模型</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> sysConfig <span class="hljs-keyword">from</span> <span class="hljs-string">'@/../config/sysConfig'</span>;  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../api/course'</span>;  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../common/utils'</span>;  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> systemApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../base/api/system'</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;      <span class="hljs-keyword">return</span> &#123;        picmax:<span class="hljs-number">1</span>,        courseid:<span class="hljs-string">''</span>,        dialogImageUrl: <span class="hljs-string">''</span>,        dialogVisible: <span class="hljs-literal">false</span>,        fileList:[],        uploadval:&#123;<span class="hljs-attr">filetag</span>:<span class="hljs-string">"course"</span>&#125;,        imgUrl:sysConfig.imgUrl      &#125;    &#125;,    methods: &#123;      <span class="hljs-comment">//超出文件上传个数提示信息</span>      rejectupload()&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"最多上传"</span>+<span class="hljs-keyword">this</span>.picmax+<span class="hljs-string">"个图片"</span>);      &#125;,      <span class="hljs-comment">//在上传前设置上传请求的数据</span>      setuploaddata()&#123;      &#125;,      <span class="hljs-comment">//删除图片</span>      handleRemove(file, fileList) &#123;        <span class="hljs-built_in">console</span>.log(file)        alert(<span class="hljs-string">'删除'</span>)      &#125;,      <span class="hljs-comment">//上传成功的钩子方法</span>      handleSuccess(response, file, fileList)&#123;        <span class="hljs-built_in">console</span>.log(response)        alert(<span class="hljs-string">'上传成功'</span>)      &#125;,      <span class="hljs-comment">//上传失败执行的钩子方法</span>      handleError(err, file, fileList)&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'上传失败'</span>);        <span class="hljs-comment">//清空文件队列</span>        <span class="hljs-keyword">this</span>.fileList = []      &#125;    &#125;,    mounted()&#123;      <span class="hljs-comment">//课程id</span>      <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid;    &#125;  &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>1、点击“加号”测试上传图片</p><p><a href="https://qnoss.codeyee.com/20200704_8/image18" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image18.png" srcset="/img/loading.gif" alt="img"></a></p><h1 id="三、保存课程图片"><a href="#三、保存课程图片" class="headerlink" title="三、保存课程图片"></a>三、保存课程图片</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>图片上传到文件系统后，其它子系统如果想使用图片可以引用图片的地址，课程管理模块使用图片的方式是将图片地址保存到课程数据库中。</p><p><a href="https://qnoss.codeyee.com/20200704_8/image19" target="_blank" rel="noopener"><img src="/2020/08/14/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday08/image19.png" srcset="/img/loading.gif" alt="img"></a></p><p>业务流程如下：</p><p>1、上传图片到文件系统服务</p><p>2、保存图片地址到课程管理服务在课程管理服务创建保存课程与图片对应关系的表 <code>course_pic</code>。</p><p>3、在 <code>course_pic</code> 保存图片成功后方可查询课程图片信息。</p><p>通过查询 <code>course_pic</code> 表数据则查询到某课程的图片信息。</p><h2 id="2-构建接口"><a href="#2-构建接口" class="headerlink" title="2. 构建接口"></a>2. 构建接口</h2><h3 id="1、API-接口"><a href="#1、API-接口" class="headerlink" title="1、API 接口"></a>1、API 接口</h3><p>在 <code>com.xuecheng.api.course</code> 包下创建该接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"保存课程图片信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">saveCoursePic</span><span class="hljs-params">(String courseId, String pic)</span></span>;</code></pre></div><h3 id="2、Dao-层"><a href="#2、Dao-层" class="headerlink" title="2、Dao 层"></a>2、Dao 层</h3><p>由于是对 <code>mysql</code> 的单表操作，这里我们通过继承 spring data jpa 提供的接口来实现 dao</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.dao;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CourseBase;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CoursePic;<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by Administrator.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoursePicRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">CoursePic</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="3、Service-层"><a href="#3、Service-层" class="headerlink" title="3、Service 层"></a>3、Service 层</h3><p>在 <code>CourseService</code> 下新增 <code>saveCoursePic</code> 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 保存课程图片信息到数据库</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId 课程id</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pic 图片id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Transactional</span>  <span class="hljs-comment">//Mysql操作需要添加到Spring事务</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">saveCoursePic</span><span class="hljs-params">(String courseId, String pic)</span> </span>&#123;    CoursePic coursePic = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//判断该课程id是否已经存在图片</span>    Optional&lt;CoursePic&gt; byId = coursePicRepository.findById(courseId);    <span class="hljs-keyword">if</span>(byId.isPresent())&#123;        coursePic = byId.get();    &#125;    <span class="hljs-comment">//不存在则重新创建一个课程图片对象并保存信息</span>    <span class="hljs-keyword">if</span>(coursePic == <span class="hljs-keyword">null</span>)&#123;        coursePic = <span class="hljs-keyword">new</span> CoursePic();    &#125;    coursePic.setCourseid(courseId);    coursePic.setPic(pic);    CoursePic save = coursePicRepository.save(coursePic);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);&#125;</code></pre></div><h3 id="4、Controller-层"><a href="#4、Controller-层" class="headerlink" title="4、Controller 层"></a>4、Controller 层</h3><p>在 <code>CourseContorller</code> 下新增 <code>saveCoursePic</code> 方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 保存课程信息与图片的对应关系</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId 课程id</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pic 图片文件id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/coursepic/add"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">saveCoursePic</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"courseId"</span>)</span> String courseId, @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"pic"</span>)</span> String pic) </span>&#123;    <span class="hljs-keyword">return</span> courseService.saveCoursePic(courseId,pic);&#125;</code></pre></div><h2 id="3-前端配置"><a href="#3-前端配置" class="headerlink" title="3. 前端配置"></a>3. 前端配置</h2><h3 id="1、需求-1"><a href="#1、需求-1" class="headerlink" title="1、需求"></a>1、需求</h3><p>前端需要在上传图片成功后保存课程图片信息。</p><h3 id="2、页面-1"><a href="#2、页面-1" class="headerlink" title="2、页面"></a>2、页面</h3><p>在 course.js 下创建 <code>ajax</code> 请求的 api</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//保存课程图片地址到课程数据 库</span>export <span class="hljs-keyword">const</span> addCoursePic= (courseId,pic) =&gt; &#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/course/coursepic/add?courseId='</span>+courseId+<span class="hljs-string">"&amp;pic="</span>+pic)&#125;</code></pre></div><p>el-upload 组件在上传成功后，会调用上传成功的钩子方法，配置如 <code>:on-success=&quot;handleSuccess&quot;</code></p><p>钩子方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//上传成功的钩子方法</span>handleSuccess(response, file, fileList)&#123;    console.log(response)    <span class="hljs-comment">//调用课程管理的保存图片接口，将图片信息保存到课程管理数据库course_pic中</span>    <span class="hljs-comment">//从response得到新的图片文件的地址</span>    <span class="hljs-keyword">if</span>(response.success)&#123;        let fileId = response.fileSystem.fileId;        courseApi.addCoursePic(<span class="hljs-keyword">this</span>.courseid,fileId).then(res=&gt;&#123;            <span class="hljs-keyword">if</span>(res.success)&#123;                <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">"图片上传成功"</span>)            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"图片保存失败!"</span>)            &#125;        &#125;)    &#125;&#125;,</code></pre></div><h3 id="3、测试-1"><a href="#3、测试-1" class="headerlink" title="3、测试"></a>3、测试</h3><p>上传成功</p><p><a href="https://qnoss.codeyee.com/20200704_8/image20" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_8/image20" srcset="/img/loading.gif" alt="img"></a></p><h1 id="四、图片信息查询"><a href="#四、图片信息查询" class="headerlink" title="四、图片信息查询"></a>四、图片信息查询</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>在进入到 课程图片 页面之前，根据当前课程的id，找到该课程对应的课程图片。</p><h2 id="2-构建接口-1"><a href="#2-构建接口-1" class="headerlink" title="2. 构建接口"></a>2. 构建接口</h2><h3 id="1、API-接口-1"><a href="#1、API-接口-1" class="headerlink" title="1、API 接口"></a>1、API 接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"获得课程图片信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CoursePic <span class="hljs-title">getCoursePic</span><span class="hljs-params">(String courseId)</span></span>;</code></pre></div><h3 id="2、Dao-层-1"><a href="#2、Dao-层-1" class="headerlink" title="2、Dao 层"></a>2、Dao 层</h3><p><code>CoursePicRepository</code> ，在编写保存功能时已构建。</p><h3 id="3、Service-层-1"><a href="#3、Service-层-1" class="headerlink" title="3、Service 层"></a>3、Service 层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据课程id获得课程的图片信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">//Mysql操作需要添加到Spring事务</span><span class="hljs-function"><span class="hljs-keyword">public</span> CoursePic <span class="hljs-title">getCoursePic</span><span class="hljs-params">(String courseId)</span> </span>&#123;    Optional&lt;CoursePic&gt; byId = coursePicRepository.findById(courseId);    <span class="hljs-keyword">if</span>(byId.isPresent())&#123;        CoursePic coursePic = byId.get();        <span class="hljs-keyword">return</span> coursePic;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h3 id="4、Controller-层-1"><a href="#4、Controller-层-1" class="headerlink" title="4、Controller 层"></a>4、Controller 层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据课程id获取该课程的课程图片信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 由于这里每个课程只有一个图片，所以只返回一个 CoursePic 对象</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/coursepic/get/&#123;courseId&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CoursePic <span class="hljs-title">getCoursePic</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"courseId"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.getCoursePic(courseId);&#125;</code></pre></div><h3 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h3><p><a href="https://qnoss.codeyee.com/20200704_8/image21" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_8/image21" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-前端配置-1"><a href="#3-前端配置-1" class="headerlink" title="3. 前端配置"></a>3. 前端配置</h2><h3 id="1、需求-2"><a href="#1、需求-2" class="headerlink" title="1、需求"></a>1、需求</h3><p>在课程图片页面的 <code>mounted</code> 钩子方法 中查询课程图片信息，并将图片地址赋值给数据对象</p><h3 id="2、页面-2"><a href="#2、页面-2" class="headerlink" title="2、页面"></a>2、页面</h3><p>API 接口</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//查询课程图片</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> findCoursePicList = <span class="hljs-function"><span class="hljs-params">courseId</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">'/course/coursepic/get/'</span>+courseId)&#125;</code></pre></div><p>钩子函数</p><div class="hljs"><pre><code class="hljs js">mounted()&#123;  <span class="hljs-comment">//课程id</span>  <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid;  <span class="hljs-comment">//查询课程</span>  courseApi.findCoursePicList(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;      <span class="hljs-keyword">if</span>(res &amp;&amp; res.pic)&#123;          <span class="hljs-keyword">let</span> imgUrl = <span class="hljs-keyword">this</span>.imgUrl+res.pic;          <span class="hljs-comment">//将图片地址设置到</span>        <span class="hljs-keyword">this</span>.fileList.push(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">'pic'</span>,<span class="hljs-attr">url</span>:imgUrl,<span class="hljs-attr">fileId</span>:res.pic&#125;)      &#125;  &#125;)&#125;</code></pre></div><h3 id="3、测试-2"><a href="#3、测试-2" class="headerlink" title="3、测试"></a>3、测试</h3><p>别忘了启动 nginx ，这里是通过 img.xuecheng.com 访问图片。</p><p><a href="https://qnoss.codeyee.com/20200704_8/image22" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_8/image22" srcset="/img/loading.gif" alt="img"></a></p><h1 id="五、课程图片删除"><a href="#五、课程图片删除" class="headerlink" title="五、课程图片删除"></a>五、课程图片删除</h1><h2 id="1-需求分析-3"><a href="#1-需求分析-3" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><h2 id="2-构建接口-2"><a href="#2-构建接口-2" class="headerlink" title="2. 构建接口"></a>2. 构建接口</h2><h3 id="1、API-接口-2"><a href="#1、API-接口-2" class="headerlink" title="1、API 接口"></a>1、API 接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"删除课程图片信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">deleteCoursePic</span><span class="hljs-params">(String courseId)</span></span>;</code></pre></div><h3 id="2、Dao-层-2"><a href="#2、Dao-层-2" class="headerlink" title="2、Dao 层"></a>2、Dao 层</h3><p><code>JPA</code> 自带的 <code>deleteById</code> 方法没有返回值，所以这里我们需要在 Dao 里面再定义一个 deleteByCourseid 方法，删除后返回影响的行数。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.dao;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CourseBase;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CoursePic;<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by Administrator.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoursePicRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">CoursePic</span>,<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据课程id删除图片信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回删除影响的行,小于1则表示删除失败</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">deleteByCourseid</span><span class="hljs-params">(String courseId)</span></span>;&#125;</code></pre></div><h3 id="3、Service-层-2"><a href="#3、Service-层-2" class="headerlink" title="3、Service 层"></a>3、Service 层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除课程图片信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">//Mysql操作需要添加到Spring事务</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">deleteCoursePic</span><span class="hljs-params">(String courseId)</span> </span>&#123;    <span class="hljs-keyword">long</span> byCourseid = coursePicRepository.deleteByCourseid(courseId);    <span class="hljs-keyword">if</span>(byCourseid &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);&#125;</code></pre></div><h3 id="4、Controller-层-2"><a href="#4、Controller-层-2" class="headerlink" title="4、Controller 层"></a>4、Controller 层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除课程图片信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/coursepic/delete"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">deleteCoursePic</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"courseId"</span>)</span> String courseId) </span>&#123;    <span class="hljs-keyword">return</span> courseService.deleteCoursePic(courseId);&#125;</code></pre></div><h3 id="5、测试-1"><a href="#5、测试-1" class="headerlink" title="5、测试"></a>5、测试</h3><p><a href="https://qnoss.codeyee.com/20200704_8/image23" target="_blank" rel="noopener"><img src="https://qnoss.codeyee.com/20200704_8/image23" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-前端配置-2"><a href="#3-前端配置-2" class="headerlink" title="3. 前端配置"></a>3. 前端配置</h2><h3 id="1、需求-3"><a href="#1、需求-3" class="headerlink" title="1、需求"></a>1、需求</h3><h3 id="2、页面-3"><a href="#2、页面-3" class="headerlink" title="2、页面"></a>2、页面</h3><p>api 接口</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//删除课程图片</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteCoursePic= <span class="hljs-function"><span class="hljs-params">courseId</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestDelete(apiUrl+<span class="hljs-string">'/course/coursepic/delete?courseId='</span>+courseId)&#125;</code></pre></div><p>before-remove钩子方法</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐upload</span></span><span class="hljs-tag">  <span class="hljs-attr">action</span>=<span class="hljs-string">"/filesystem/upload"</span></span><span class="hljs-tag">  <span class="hljs-attr">list</span>‐<span class="hljs-attr">type</span>=<span class="hljs-string">"picture‐card"</span></span><span class="hljs-tag">  <span class="hljs-attr">:before</span>‐<span class="hljs-attr">remove</span>=<span class="hljs-string">"handleRemove"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"el‐icon‐plus"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐upload</span>&gt;</span></code></pre></div><p>在upload组件的 <code>before-remove</code>钩子方法 中实现删除动作。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//删除图片</span>handleRemove(file, fileList) &#123;  <span class="hljs-built_in">console</span>.log(file)  <span class="hljs-comment">//调用服务端去删除课程图片信息，如果返回false，前端停止删除</span>  <span class="hljs-comment">//异步调用</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,rejct</span>)=&gt;</span>&#123;    courseApi.deleteCoursePic(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;      <span class="hljs-keyword">if</span>(res.success)&#123;          <span class="hljs-comment">//成功</span>        resolve()      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">"删除失败"</span>);          <span class="hljs-comment">//失败</span>        rejct()      &#125;    &#125;)  &#125;)&#125;,</code></pre></div><p><code>before-remove</code> 说明：删除文件之前的钩子，参数为上传的文件和文件列表，若返回 <code>false</code> 或者返回 <code>Promise</code> 且被 <code>reject</code>，则停止删除。</p><h3 id="3、为什么要使用-promise？"><a href="#3、为什么要使用-promise？" class="headerlink" title="3、为什么要使用 promise？"></a>3、为什么要使用 promise？</h3><p>在 <code>handleRemove</code> 方法调用删除图片的 <code>api</code> 方法，删除成功时 return true，删除失败时return false;</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 删除图片</span>handleRemove(file, fileList) &#123;    <span class="hljs-built_in">console</span>.log(file)    <span class="hljs-comment">//        alert('删除')</span>    <span class="hljs-comment">//        return true;</span>    <span class="hljs-comment">//删除图片</span>    courseApi.deleteCoursePic(<span class="hljs-string">'1'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'删除成功'</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.$message.error(res.message);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;);&#125;,</code></pre></div><p>在上边代码中将提交的课程 id 故意写错，按照我们预期应该是删除失败，而测试结果却是图片在页面上删除成功。</p><p><strong>问题原因：</strong></p><p>通过查询 <code>deleteCoursePic</code> 方法的底层代码，<code>deleteCoursePic</code> 最终返回一个 <code>promise</code> 对象。</p><p>Promise 是ES6提供的用于异步处理的对象，因为axios提交是异步提交，这里使用promise作为返回值</p><p><strong>Promise的使用方法如下：</strong></p><p>Promise对象在处理过程中有三种状态：</p><ul><li>pending：进行中</li><li>resolved：操作成功</li><li>rejected: 操作失败</li></ul><p>Promise的构建方法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;     <span class="hljs-comment">//...TODO...</span>    <span class="hljs-keyword">if</span>(操作成功)&#123;        resolve(value);    &#125;<span class="hljs-keyword">else</span>&#123;        reject(error);    &#125;&#125;)</code></pre></div><p>上边的构造方法function(resolve,reject)执行流程如下：</p><p>1）方法执行一些业务逻辑。</p><p>2）如果操作成功将 <code>Promise</code> 的状态由 <code>pending</code> 变为 <code>resolved</code>，并将操作结果传出去</p><p>3）如果操作失败会将 <code>promise</code> 的状态由 <code>pending</code> 变为 <code>rejected</code>，并将失败结果传出去。<br>上边说的操作成功将操作结果传给谁了呢？操作失败将失败结果传给谁了呢？</p><p>我们可以通过 promise 的 <code>then</code>、<code>catch</code> 来指定：</p><div class="hljs"><pre><code class="hljs js">promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'操作成功：'</span> + result);&#125;);promise.catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'操作失败：'</span> + reason);&#125;);</code></pre></div><p>例子如下：</p><p>1、定义一个方法，返回 <code>promise</code> 对象</p><div class="hljs"><pre><code class="hljs js">testpromise(i)&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;      resolve(<span class="hljs-string">'成功了'</span>)    &#125;<span class="hljs-keyword">else</span>&#123;      reject(<span class="hljs-string">'拒绝了'</span>)    &#125;  &#125;)&#125;</code></pre></div><p>2、调用此方法</p><p>向方法传入偶数、奇数进行测试。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">this</span>.testpromise(<span class="hljs-number">3</span>).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<span class="hljs-comment">// 在then中对成功结果进行处理</span>    alert(res)&#125;).catch(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<span class="hljs-comment">//在catch中对操作失败结果进行处理</span>    alert(res)&#125;)</code></pre></div><p>3、最终将 <code>handleRemove</code> 方法修改如下</p><p><code>handleRemove</code> 方法返回 <code>promise</code> 对象，当删除成功则 <code>resolve</code>，删除失败则 <code>reject</code>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 删除图片</span>handleRemove(file, fileList) &#123;    <span class="hljs-built_in">console</span>.log(file)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-comment">//删除图片</span> courseApi.deleteCoursePic(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span>(res.success)&#123;                <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'删除成功'</span>);                resolve()<span class="hljs-comment">//通过</span>            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">this</span>.$message.error(res.message);                reject()<span class="hljs-comment">//拒绝</span>            &#125;        &#125;);    &#125;)&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day07：课程管理实战</title>
    <link href="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/"/>
    <url>/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day07</code> 的内容</p><ul><li>对课程管理的CRUD</li><li>级联菜单</li><li>使用 <code>mongoDB</code> 储存数据字典</li></ul><h1 id="一、课程查询"><a href="#一、课程查询" class="headerlink" title="一、课程查询"></a>一、课程查询</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>课程添加完成后可通过我的课程进入课程修改页面，此页面显示我的课程列表，如下图所示，可分页查询。</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image1.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image1.png" srcset="/img/loading.gif" alt="image-20200403212250200"></a></p><p>上边的查询要实现分页、会存在多表关联查询，所以建议使用mybatis实现我的课程查询。</p><h2 id="2-定义API接口"><a href="#2-定义API接口" class="headerlink" title="2. 定义API接口"></a>2. 定义API接口</h2><p><strong>输入参数</strong>：页码、每页显示个数、查询条件</p><p><strong>输出结果类型</strong>：QueryResponseResult&lt;自定义类型&gt;，在 <code>api</code> 工程创建 <code>course</code> 包，创建<code>CourseControllerApi</code> 接口。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value=<span class="hljs-string">"课程管理API"</span>,description = <span class="hljs-string">"用于对课程的增删查改"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;<span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"分页查询课程列表"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findCourseList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, CourseListRequest courseListRequest)</span></span>;&#125;</code></pre></div><h2 id="3-课程管理服务"><a href="#3-课程管理服务" class="headerlink" title="3. 课程管理服务"></a>3. 课程管理服务</h2><h3 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h3><p><code>PageHelper</code> 是 <code>mybatis</code> 的通用分页插件，通过 <code>mybatis</code> 的拦截器实现分页功能，拦截sql查询请求，添加分页语句，最终实现分页查询功能。</p><p>我的课程具有分页功能，本项目使用 <code>Pagehelper</code> 实现 <code>Mybatis</code> 分页功能开发，由于本项目使用 <code>springboot</code> 开发，在 <code>springboot</code> 上集成 <code>pagehelper</code>（<a href="https://github.com/pagehelper/pagehelper-spring-boot%EF%BC%89" target="_blank" rel="noopener">https://github.com/pagehelper/pagehelper-spring-boot）</a><code>PageHelper</code> 的使用方法及原理如下：</p><ul><li>在调用 <code>dao</code> 的 <code>service</code> 方法中设置分页参数：<strong>PageHelper.startPage(page, size)</strong>，分页参数会设置在 <code>ThreadLocal</code> 中</li><li><code>PageHelper</code> 在 <code>mybatis</code> 执行 <code>sql</code> 前进行拦截，从 <code>ThreadLocal</code> 取出分页参数，修改当前执行的 <code>sql</code> 语句，添加分页 <code>sql</code>。</li><li>最后执行添加了分页<code>sql</code>的 <code>sql</code>语句，实现分页查询。</li></ul><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image2.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image2.png" srcset="/img/loading.gif" alt="image-20200403213815138"></a></p><p>1）添加依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper‐spring‐boot‐starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2）配置pageHelper</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">pagehelper:</span>  <span class="hljs-string">helper‐dialect:</span> <span class="hljs-string">mysql</span></code></pre></div><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>1）mapper 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.github.pagehelper.Page;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CourseBase;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.ext.CourseInfo;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.request.CourseListRequest;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseMapper</span> </span>&#123;    <span class="hljs-function">CourseBase <span class="hljs-title">findCourseBaseById</span><span class="hljs-params">(String id)</span></span>;    <span class="hljs-function">Page&lt;CourseInfo&gt; <span class="hljs-title">findCourseListPage</span><span class="hljs-params">(CourseListRequest courseListRequest)</span></span>;&#125;</code></pre></div><p>2）mapper.xml映射文件</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findCourseListPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.CourseInfo"</span></span><span class="hljs-tag">        <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.request.CourseListRequest"</span>&gt;</span>    SELECT    course_base.*,    (SELECT pic FROM course_pic WHERE courseid = course_base.id) pic    FROM    course_base<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><ol><li>测试dao</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//测试分页</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPageHelper</span><span class="hljs-params">()</span></span>&#123;    PageHelper.startPage(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    CourseListRequest courseListRequest = <span class="hljs-keyword">new</span> CourseListRequest();    Page&lt;CourseInfo&gt; courseListPage = courseMapper.findCourseListPage(courseListRequest);    List&lt;CourseInfo&gt; result = courseListPage.getResult();    System.out.println(courseListPage);&#125;</code></pre></div><p>测试前修改日志级别为debug，并跟踪运行日志，发现sql语句中已经包括分页语句。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>定义CourseService.java类，用于课程管理的service定义：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询课程信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseListRequest</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findCourseList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, CourseListRequest courseListRequest)</span></span>&#123;        <span class="hljs-keyword">if</span> (page &lt;= <span class="hljs-number">0</span>)&#123;            page = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>)&#123;            size = <span class="hljs-number">4</span>;        &#125;        <span class="hljs-keyword">if</span>(courseListRequest == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (courseListRequest.getCompanyId() == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//没输入公司id默认为1</span>            courseListRequest.setCompanyId(<span class="hljs-string">"1"</span>);        &#125;        PageHelper.startPage(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>);        Page&lt;CourseInfo&gt; courseInfos = courseMapper.findCoursePageList(courseListRequest);        <span class="hljs-keyword">long</span> total = courseInfos.getTotal();        List&lt;CourseInfo&gt; result = courseInfos.getResult();        QueryResult queryResult = <span class="hljs-keyword">new</span> QueryResult();        queryResult.setTotal(total);        queryResult.setList(result);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);    &#125;</code></pre></div><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/course"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CourseService courseService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/coursebase/list/&#123;page&#125;/&#123;size&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult&lt;CourseInfo&gt; <span class="hljs-title">findCourseList</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            @PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page,</span><span class="hljs-function">            @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size,</span><span class="hljs-function">            CourseListRequest courseListRequest) </span>&#123;        <span class="hljs-keyword">return</span> courseService.findCourseList(page,size,courseListRequest);    &#125;&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用 <code>postman</code> 或 <code>swagger-ui</code> 测试课程列表接口。</p><h2 id="4-前端开发"><a href="#4-前端开发" class="headerlink" title="4. 前端开发"></a>4. 前端开发</h2><h3 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h3><p>创建 ourse_list.vue</p><p>1）使用element 的card组件</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image3.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image3.png" srcset="/img/loading.gif" alt="image-20200403214719252"></a></p><p>页面布局代码如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el‐row</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">"8"</span>  <span class="hljs-attr">:offset</span>=<span class="hljs-string">2</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐card</span> <span class="hljs-attr">:body</span>‐<span class="hljs-attr">style</span>=<span class="hljs-string">"&#123; padding: '10px' &#125;"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/static/images/add.jpg"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"image"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150px"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"padding: 10px;"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>课程名称<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom clearfix"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"time"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/add/base'&#125;"</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span> &gt;</span>新增课程<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>              <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐card</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐col</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">"8"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"(course, index) in courses"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"course.id"</span> <span class="hljs-attr">:offset</span>=<span class="hljs-string">"index &gt; 0 ?</span></span><span class="hljs-tag"><span class="hljs-string">2 : 2"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐card</span> <span class="hljs-attr">:body</span>‐<span class="hljs-attr">style</span>=<span class="hljs-string">"&#123; padding: '10px' &#125;"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"course.pic!=null?imgUrl+course.pic:'/static/images/nonepic.jpg'"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"image"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"150px"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"padding: 10px;"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;course.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bottom clearfix"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"time"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleManage(course.id)"</span>&gt;</span>管理课程<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐card</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐col</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">!‐‐分页‐‐</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">"24"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"toolbar"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐pagination</span> <span class="hljs-attr">background</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">"prev, pager, next"</span> @<span class="hljs-attr">current</span>‐</span><span class="hljs-tag"><span class="hljs-attr">change</span>=<span class="hljs-string">"handleCurrentChange"</span> <span class="hljs-attr">:page</span>‐<span class="hljs-attr">size</span>=<span class="hljs-string">"size"</span></span><span class="hljs-tag">                       <span class="hljs-attr">:total</span>=<span class="hljs-string">"total"</span> <span class="hljs-attr">:current</span>‐<span class="hljs-attr">page</span>=<span class="hljs-string">"page"</span></span><span class="hljs-tag">                       <span class="hljs-attr">style</span>=<span class="hljs-string">"float:right;"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐pagination</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐col</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐row</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/course'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../common/utils'</span>;</span><span class="javascript">  <span class="hljs-keyword">let</span> sysConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/../config/sysConfig'</span>)</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span>        page:1,        size:7,        total: 0,        courses: [],<span class="actionscript">        sels: [],<span class="hljs-comment">//列表选中列</span></span>        imgUrl:sysConfig.imgUrl      &#125;    &#125;,    methods: &#123;<span class="actionscript">        <span class="hljs-comment">//分页方法</span></span>      handleCurrentChange(val) &#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.page = val;</span>      &#125;,<span class="actionscript">      <span class="hljs-comment">//获取课程列表</span></span>      getCourse() &#123;            &#125;,<span class="actionscript">      handleManage: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(id)</span><span class="actionscript">        <span class="hljs-keyword">this</span>.$router.push(&#123; path: <span class="hljs-string">'/course/manager/'</span>+id&#125;)</span>      &#125;    &#125;,    created()&#123;     &#125;,    mounted() &#123;    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.el</span>‐<span class="hljs-selector-tag">col</span>‐8&#123;</span><span class="css">    <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:20</span>%</span>  &#125;<span class="css">  <span class="hljs-selector-class">.el</span>‐<span class="hljs-selector-tag">col</span>‐<span class="hljs-selector-tag">offset</span>‐2&#123;</span><span class="css">    <span class="hljs-selector-tag">margin</span>‐<span class="hljs-selector-tag">left</span><span class="hljs-selector-pseudo">:2</span>%</span>  &#125;<span class="css">  <span class="hljs-selector-class">.time</span> &#123;</span>    font‐size: 13px;<span class="css">    <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#999</span>;</span>  &#125;<span class="css">  <span class="hljs-selector-class">.bottom</span> &#123;</span>    margin‐top: 13px;    line‐height: 12px;  &#125;<span class="css">  <span class="hljs-selector-class">.button</span> &#123;</span>    padding: 0;    float: right;  &#125;<span class="css">  <span class="hljs-selector-class">.image</span> &#123;</span>    width: 100%;    display: block;  &#125;<span class="css">  <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,</span><span class="css">  <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>    display: table;    content: "";  &#125;<span class="css">  <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>    clear: both  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>2）路由</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> course_list <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_list.vue'</span>;<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/home.vue'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [  &#123;     path: <span class="hljs-string">'/course'</span>,    component: Home,    name: <span class="hljs-string">'课程管理'</span>,    hidden: <span class="hljs-literal">false</span>,    iconCls: <span class="hljs-string">'el‐icon‐document'</span>,    children: [      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/list'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'我的课程'</span>,<span class="hljs-attr">component</span>: course_list,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span> &#125;    ]  &#125;]</code></pre></div><h3 id="Api调用"><a href="#Api调用" class="headerlink" title="Api调用"></a>Api调用</h3><p>1、定义Api方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//我的课程列表</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> findCourseList = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;     <span class="hljs-comment">//对于查询条件，向服务端传入key/value串。</span>     <span class="hljs-comment">//使用工具类将json对象转成key/value</span>     <span class="hljs-keyword">let</span> queries = querystring.stringify(params)    <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">"/course/coursebase/list/"</span>+page+<span class="hljs-string">"/"</span>+size+<span class="hljs-string">"?"</span>+queries);&#125;</code></pre></div><p>2、在页面调用 <code>findCourseList</code> 方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//获取课程列表</span>getCourse() &#123;  courseApi.findCourseList(<span class="hljs-keyword">this</span>.page,<span class="hljs-keyword">this</span>.size,&#123;&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(res);          <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">this</span>.total = res.queryResult.total;            <span class="hljs-keyword">this</span>.courses = res.queryResult.list;          &#125;  &#125;);&#125;</code></pre></div><p>在 <code>mounted</code> 钩子中调用 <code>getCourse</code> 方法</p><div class="hljs"><pre><code class="hljs js">mounted() &#123;  <span class="hljs-comment">//查询我的课程</span>  <span class="hljs-keyword">this</span>.getCourse();&#125;</code></pre></div><p>在分页方法中调用 <code>getCourse</code> 方法</p><div class="hljs"><pre><code class="hljs js"> <span class="hljs-comment">//分页方法</span>handleCurrentChange(val) &#123;  <span class="hljs-keyword">this</span>.page = val;  <span class="hljs-keyword">this</span>.getCourse();&#125;,</code></pre></div><h3 id="1测试"><a href="#1测试" class="headerlink" title="1测试"></a>1测试</h3><p>页面效果如下：</p><p>注意：由于课程图片服务器没有搭建，这里图片暂时无法显示。</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image4.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image4.png" srcset="/img/loading.gif" alt="image-20200403215009200"></a></p><h1 id="二、新增课程"><a href="#二、新增课程" class="headerlink" title="二、新增课程"></a>二、新增课程</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>用户操作流程如下：</p><p>1、用户进入“我的课程”页面，点击“新增课程”，进入新增课程页面</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image4.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image5.png" srcset="/img/loading.gif" alt="image-20200403215030231"></a></p><p>2、填写课程信息，选择课程分类、课程等级、学习模式等。</p><p>3、信息填写完毕，点击“提交”，课程添加成功或课程添加失败并提示失败原因。</p><p>需要解决的是在新增页面上输入的信息：</p><p>1、课程分类 多级分类，需要方便用户去选择。</p><p>2、课程等级、学习模式等这些选项建议是可以配置的。</p><h2 id="2-课程分类查询"><a href="#2-课程分类查询" class="headerlink" title="2. 课程分类查询"></a>2. 课程分类查询</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在新增课程界面需要选择课程所属分类， 分类信息是整个项目非常重要的信息，课程即商品，分类信息设置的好坏直接影响用户访问量。</p><p>分类信息在哪里应用？</p><p>1、首页分类导航</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image5.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/imagei5.png" srcset="/img/loading.gif" alt="image-20200403215130650"></a></p><p>2 、课程的归属地</p><p>添加课程时要选择课程的所属分类。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>分类表 <code>category</code> 的结构如下</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image11.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image11.png" srcset="/img/loading.gif" alt="image-20200403215159778"></a></p><h3 id="分类查询"><a href="#分类查询" class="headerlink" title="分类查询"></a>分类查询</h3><h4 id="1）数据格式"><a href="#1）数据格式" class="headerlink" title="1）数据格式"></a>1）数据格式</h4><p>在添加课程时需要选择课程所属的分类，这里需要定义课程分类查询接口。</p><p>接口格式要根据前端需要的数据格式来定义，前端展示课程分类使用 <code>elemenet-ui</code> 的<code>cascader</code>（级联选择器）组件。</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image6.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image6.png" srcset="/img/loading.gif" alt="image-20200403215240113"></a></p><p>数据格式例子如下：</p><div class="hljs"><pre><code class="hljs js">[  &#123;        value: <span class="hljs-string">'zhinan'</span>,        label: <span class="hljs-string">'指南'</span>,        children: [&#123;          value: <span class="hljs-string">'shejiyuanze'</span>,          label: <span class="hljs-string">'设计原则'</span>,          children: [&#123;            value: <span class="hljs-string">'yizhi'</span>,            label: <span class="hljs-string">'一致'</span>          &#125;, &#123;            value: <span class="hljs-string">'fankui'</span>,            label: <span class="hljs-string">'反馈'</span>          &#125;, &#123;            value: <span class="hljs-string">'xiaolv'</span>,            label: <span class="hljs-string">'效率'</span>          &#125;, &#123;            value: <span class="hljs-string">'kekong'</span>,            label: <span class="hljs-string">'可控'</span>          &#125;]        &#125;]  &#125;]</code></pre></div><h4 id="2）数据模型"><a href="#2）数据模型" class="headerlink" title="2）数据模型"></a>2）数据模型</h4><p>1）定义category的模型</p><p>category 模型对数据字段对应，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"category"</span>)<span class="hljs-meta">@GenericGenerator</span>(name = <span class="hljs-string">"jpa‐assigned"</span>, strategy = <span class="hljs-string">"assigned"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Category</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = ‐<span class="hljs-number">906357110051689484L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(generator = <span class="hljs-string">"jpa‐assigned"</span>)    <span class="hljs-meta">@Column</span>(length = <span class="hljs-number">32</span>)    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String label;    <span class="hljs-keyword">private</span> String parentid;    <span class="hljs-keyword">private</span> String isshow;    <span class="hljs-keyword">private</span> Integer orderby;    <span class="hljs-keyword">private</span> String isleaf;&#125;</code></pre></div><p>2）定义数据返回格式</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Category</span> </span>&#123;    List&lt;CategoryNode&gt; children;&#125;</code></pre></div><p>级联菜单属于三级菜单，所以每个菜单下面都会有一个 <code>chaidren</code> 的字段</p><h4 id="3）API-接口"><a href="#3）API-接口" class="headerlink" title="3）API 接口"></a>3）API 接口</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.web.controller.api.course;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.ext.CategoryNode;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"课程分类管理"</span>,description = <span class="hljs-string">"课程分类管理"</span>,tags = &#123;<span class="hljs-string">"课程分类管理"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"查询分类"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CategoryNode <span class="hljs-title">findList</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h4 id="4）DAO"><a href="#4）DAO" class="headerlink" title="4）DAO"></a>4）DAO</h4><p>1）定义mapper</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryMapper</span> </span>&#123;    <span class="hljs-comment">//查询分类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CategoryNode <span class="hljs-title">selectList</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>2）定义mapper映射文件</p><p>采用表的自连接方式输出树型结果集。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.xuecheng.manage_course.dao.CategoryMapper"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"CategoryMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.CategoryNode"</span>&gt;</span>        <span class="hljs-comment">&lt;!--一级节点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_id"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_name"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"label"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_label"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isshow"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_isshow"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"orderby"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_orderby"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isleaf"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_isleaf"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"parentid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_parentid"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"children"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.CategoryNode"</span>&gt;</span>            <span class="hljs-comment">&lt;!--二级节点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_id"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_name"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"label"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_label"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isshow"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_isshow"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"orderby"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_orderby"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isleaf"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_isleaf"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"parentid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_parentid"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"children"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.CategoryNode"</span>&gt;</span>                <span class="hljs-comment">&lt;!--三级节点--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_id"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_name"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"label"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_label"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isshow"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_isshow"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"orderby"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_orderby"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"isleaf"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_isleaf"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"parentid"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_parentid"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--三级菜单查询--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectList"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"CategoryMap"</span>&gt;</span>        select        a.id one_id,        a.name one_name,        a.label one_label,        a.isshow one_isshow,        a.isleaf one_isleaf,        a.orderby one_orderby,        a.parentid one_parentid,        b.id two_id,        b.name two_name,        b.label two_label,        b.isshow two_isshow,        b.isleaf two_isleaf,        b.orderby two_orderby,        b.parentid two_parentid,        c.id three_id,        c.name three_name,        c.label three_label,        c.isshow three_isshow,        c.isleaf three_isleaf,        c.orderby three_orderby,        c.parentid three_parentid        from        category a left join category b        on a.id = b.parentid        left join category c        on b.id = c.parentid        where a.parentid = '0'        order by a.orderby,        b.orderby,        c.orderby    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h4 id="5）Service"><a href="#5）Service" class="headerlink" title="5）Service"></a>5）Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-13  14:14</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CategoryMapper categoryMapper;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CategoryNode <span class="hljs-title">findCategoryList</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> categoryMapper.selectList();    &#125;&#125;</code></pre></div><h4 id="6）Controller"><a href="#6）Controller" class="headerlink" title="6）Controller"></a>6）Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/category"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CategoryControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CategoryService categoryService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CategoryNode <span class="hljs-title">findList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> categoryService.findCategoryList();    &#125;&#125;</code></pre></div><h4 id="7）接口测试"><a href="#7）接口测试" class="headerlink" title="7）接口测试"></a>7）接口测试</h4><p>接口描述如下</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image7.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image7.png" srcset="/img/loading.gif" alt="image-20200403215645362"></a></p><p>使用swagger-ui或postman测试接口。</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image8.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image8.png" srcset="/img/loading.gif" alt="image-20200403215654115"></a></p><h2 id="3-数据字典"><a href="#3-数据字典" class="headerlink" title="3. 数据字典"></a>3. 数据字典</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在新增课程界面需要选择课程等级、课程状态等，这些信息统一采用数据字典管理的方式。<br>本项目对一些业务的分类配置信息，比如：课程等级、课程状态、用户类型、用户状态等进行统一管理，通过在数据库创建数据字典表来维护这些分类信息。</p><p>数据字典对系统的业务分类进行统一管理，并且也可以解决硬编码问题，比如添加课程时选择课程等级，下拉框中的课程等级信息如果在页面硬编码将造成不易修改维护的问题，所以从数据字典表中获取，如果要修改名称则在数据字典修改即可，提高系统的可维护性。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>在 <code>mongodb</code> 中创建数据字典表 <code>sys_dictionary</code></p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image9.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image9.png" srcset="/img/loading.gif" alt="image-20200403220146001"></a></p><p>一个字典信息如下</p><div class="hljs"><pre><code class="hljs json"> &#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"5a7e8d2dd019f15418fa2b71"</span>),<span class="hljs-attr">"d_name"</span> : <span class="hljs-string">"课程等级"</span>,<span class="hljs-attr">"d_type"</span> : <span class="hljs-string">"200"</span>,<span class="hljs-attr">"d_value"</span> : [    &#123;        <span class="hljs-attr">"sd_name"</span> : <span class="hljs-string">"低级"</span>,        <span class="hljs-attr">"sd_id"</span> : <span class="hljs-string">"200001"</span>,        <span class="hljs-attr">"sd_status"</span> : <span class="hljs-string">"1"</span>    &#125;,    &#123;        <span class="hljs-attr">"sd_name"</span> : <span class="hljs-string">"中级"</span>,        <span class="hljs-attr">"sd_id"</span> : <span class="hljs-string">"200002"</span>,        <span class="hljs-attr">"sd_status"</span> : <span class="hljs-string">"1"</span>    &#125;,    &#123;        <span class="hljs-attr">"sd_name"</span> : <span class="hljs-string">"高级"</span>,        <span class="hljs-attr">"sd_id"</span> : <span class="hljs-string">"200003"</span>,        <span class="hljs-attr">"sd_status"</span> : <span class="hljs-string">"1"</span>    &#125;]&#125;</code></pre></div><p>字段说明如下：</p><p><code>d_name</code>：字典名称</p><p><code>d_type</code>：字典分类</p><p><code>d_value</code>：字典数据</p><p>sd_name：项目名称</p><p><code>sd_id</code>：项目id</p><p><code>sd_status</code>：项目状态（1：可用，0不可用）</p><p><strong>数据模型类</strong>：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Document</span>(collection = <span class="hljs-string">"sys_dictionary"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysDictionary</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> String id;    <span class="hljs-meta">@Field</span>(<span class="hljs-string">"d_name"</span>)    <span class="hljs-keyword">private</span> String dName;    <span class="hljs-meta">@Field</span>(<span class="hljs-string">"d_type"</span>)    <span class="hljs-keyword">private</span> String dType;    <span class="hljs-meta">@Field</span>(<span class="hljs-string">"d_value"</span>)    <span class="hljs-keyword">private</span> List&lt;SysDictionaryValue&gt; dValue;&#125;</code></pre></div><p><code>SysDictionaryValue</code> 类型：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysDictionaryValue</span> </span>&#123;    <span class="hljs-meta">@Field</span>(<span class="hljs-string">"sd_id"</span>)    <span class="hljs-keyword">private</span> String sdId;    <span class="hljs-meta">@Field</span>(<span class="hljs-string">"sd_name"</span>)    <span class="hljs-keyword">private</span> String sdName;    <span class="hljs-meta">@Field</span>(<span class="hljs-string">"sd_status"</span>)    <span class="hljs-keyword">private</span> String sdStatus;&#125;</code></pre></div><h3 id="字典查询接口"><a href="#字典查询接口" class="headerlink" title="字典查询接口"></a>字典查询接口</h3><h4 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h4><p>为了方便其它子系统使用，在cms模块下创建字典查询接口，根据字典的type查询字典信息，接口定义如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-13  14:24</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"数据字典接口"</span>,description = <span class="hljs-string">"提供数据字典接口的管理，查询功能"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysDicthionaryControllerApi</span> </span>&#123;    <span class="hljs-comment">//数据字典</span>    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"数据字典查询接口"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SysDictionary <span class="hljs-title">getByType</span><span class="hljs-params">(String type)</span></span>;&#125;</code></pre></div><h4 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h4><p>在cms模块下创建数据库的dao、service等类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-13  14:30</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysDicthionaryRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">SysDictionary</span>,<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysDictionary <span class="hljs-title">findAllByDType</span><span class="hljs-params">(String type)</span></span>;&#125;</code></pre></div><h4 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysDicthinaryService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysDicthionaryRepository sysDicthionaryRepository;    <span class="hljs-function"><span class="hljs-keyword">public</span> SysDictionary <span class="hljs-title">getByType</span><span class="hljs-params">(String type)</span> </span>&#123;        <span class="hljs-keyword">if</span> (type == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CommonCode.INVALID_PARAM);        &#125;        <span class="hljs-keyword">return</span> sysDicthionaryRepository.findAllByDType(type);    &#125;&#125;</code></pre></div><h4 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/sys"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysDicthionaryController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SysDicthionaryControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    SysDicthinaryService sysDicthinaryService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/dictionary/get/&#123;dType&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SysDictionary <span class="hljs-title">getByType</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"dType"</span>)</span> String type) </span>&#123;        <span class="hljs-keyword">return</span> sysDicthinaryService.getByType(type);    &#125;&#125;</code></pre></div><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image10.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image10.png" srcset="/img/loading.gif" alt="image-20200403220513616"></a></p><h2 id="4-新增课程页面完善"><a href="#4-新增课程页面完善" class="headerlink" title="4. 新增课程页面完善"></a>4. 新增课程页面完善</h2><p>本节完成数据字典显示及课程分类显示。</p><h3 id="新增课程页面"><a href="#新增课程页面" class="headerlink" title="新增课程页面"></a>新增课程页面</h3><h4 id="1）页面效果如下："><a href="#1）页面效果如下：" class="headerlink" title="1）页面效果如下："></a>1）页面效果如下：</h4><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image11.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/imagei11.png" srcset="/img/loading.gif" alt="image-20200403220536863"></a></p><h4 id="2）创建-course-add-vue-页面"><a href="#2）创建-course-add-vue-页面" class="headerlink" title="2）创建 course_add.vue 页面"></a>2）创建 course_add.vue 页面</h4><p>在<code>teach</code> 前端工程的 <code>course</code> 模块下创建 <code>course_add.vue</code> 页面。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el‐form</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">"courseForm"</span> <span class="hljs-attr">label</span>‐<span class="hljs-attr">width</span>=<span class="hljs-string">"80px"</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">"courseRules"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"courseForm"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程名称"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"name"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.name"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"适用人群"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"users"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.users"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程分类"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"categoryActive"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐cascader</span></span><span class="hljs-tag">          <span class="hljs-attr">expand</span>‐<span class="hljs-attr">trigger</span>=<span class="hljs-string">"hover"</span></span><span class="hljs-tag">          <span class="hljs-attr">:options</span>=<span class="hljs-string">"categoryList"</span></span><span class="hljs-tag">          <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"categoryActive"</span></span><span class="hljs-tag">          <span class="hljs-attr">:props</span>=<span class="hljs-string">"props"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐cascader</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程等级"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"grade"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"grade in gradeList"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.grade"</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"grade.sdId"</span> &gt;</span>&#123;&#123;grade.sdName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el‐</span></span><span class="hljs-tag"><span class="hljs-attr">radio</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"学习模式"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"studymodel"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"studymodel_v in studymodelList"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.studymodel"</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"studymodel_v.sdId"</span> &gt;</span>&#123;&#123;studymodel_v.sdName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程介绍"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"description"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.description"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"footer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dialog‐footer"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>  @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"save"</span> &gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/course'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../common/utils'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> systemApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../base/api/system'</span>;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span>             studymodelList:[],        gradeList:[],        props: &#123;<span class="actionscript">          value: <span class="hljs-string">'id'</span>,</span><span class="actionscript">          label:<span class="hljs-string">'label'</span>,</span><span class="actionscript">          children:<span class="hljs-string">'children'</span></span>        &#125;,        categoryList: [],        categoryActive:[],        courseForm: &#123;<span class="actionscript">          id:<span class="hljs-string">''</span>,</span><span class="actionscript">          name: <span class="hljs-string">''</span>,</span><span class="actionscript">          users: <span class="hljs-string">''</span>,</span><span class="actionscript">          grade:<span class="hljs-string">''</span>,</span><span class="actionscript">          studymodel:<span class="hljs-string">''</span>,</span><span class="actionscript">          mt:<span class="hljs-string">''</span>,</span><span class="actionscript">          st:<span class="hljs-string">''</span>,</span><span class="actionscript">          description: <span class="hljs-string">''</span></span>        &#125;,        courseRules: &#123;          name: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请输入课程名称'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          category: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择课程分类'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          grade: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择课程等级'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          studymodel: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择学习模式'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ]        &#125;      &#125;    &#125;,    methods: &#123;      save () &#123;      &#125;    &#125;,    created()&#123;    &#125;,    mounted()&#123;    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h4 id="3）页面路由"><a href="#3）页面路由" class="headerlink" title="3）页面路由"></a>3）页面路由</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> course_add <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_add.vue'</span>;     &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/add/base'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'添加课程'</span>,<span class="hljs-attr">component</span>: course_add,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;,</code></pre></div><h4 id="4）课程添加链接"><a href="#4）课程添加链接" class="headerlink" title="4）课程添加链接"></a>4）课程添加链接</h4><p>在我的课程页面添加“新增课程”链接<br>在 <code>course_list.vue</code> 中添加</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/add/base'&#125;"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span> &gt;</span>新增课程<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span></code></pre></div><h3 id="查询数据字典"><a href="#查询数据字典" class="headerlink" title="查询数据字典"></a>查询数据字典</h3><p>课程添加页面中课程等级、学习模式需要从数据字典查询字典信息。</p><p>1）<strong>定义方法</strong></p><p>数据字典查询 为公用方法，所以定义在 <code>/base/api/system.js</code> 中</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sysConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/../config/sysConfig'</span>) <span class="hljs-keyword">let</span> apiUrl = sysConfig.xcApiUrlPre;<span class="hljs-comment">/*数据字典 */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sys_getDictionary= <span class="hljs-function"><span class="hljs-params">dType</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">'/sys/dictionary/get/'</span>+dType)&#125;</code></pre></div><p>2）<strong>在页面获取数据字典</strong></p><p>在 <code>mounted</code> 钩子中定义方法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 查询数据字典字典</span>systemApi.sys_getDictionary(<span class="hljs-string">'201'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<span class="hljs-keyword">this</span>.studymodelList = res.dvalue;&#125;);systemApi.sys_getDictionary(<span class="hljs-string">'200'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<span class="hljs-keyword">this</span>.gradeList = res.dvalue;&#125;);</code></pre></div><p>3）<strong>效果</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image12.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/C:%5CUsers%5CMI%5CDesktop%5CHexo%5Csource_posts%5C%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07%5Cimage12.png" srcset="/img/loading.gif" alt="image-20200403221002719"></a></p><h3 id="课程分类"><a href="#课程分类" class="headerlink" title="课程分类"></a>课程分类</h3><p>课程添加页面中课程分类采用 <code>Cascader</code> 组件完成。</p><p><code>Cascader</code> 级联选择器</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image13.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image13.png" srcset="/img/loading.gif" alt="image-20200403221022081"></a></p><p><strong>1）页面</strong></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">" 课程分类"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"categoryActive"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">el‐cascader</span></span><span class="hljs-tag">    <span class="hljs-attr">expand</span>‐<span class="hljs-attr">trigger</span>=<span class="hljs-string">"hover"</span></span><span class="hljs-tag">    <span class="hljs-attr">:options</span>=<span class="hljs-string">"categoryList"</span></span><span class="hljs-tag">    <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"categoryActive"</span></span><span class="hljs-tag">    <span class="hljs-attr">:props</span>=<span class="hljs-string">"props"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">el‐cascader</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span></code></pre></div><p><strong>2）定义方法</strong><br>在本模块的<code>course.js</code>中定义</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/* 查询课程分类 */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> category_findlist= <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">'/category/list'</span>)&#125;</code></pre></div><p><strong>3）在页面获取课程分类</strong></p><p>在 <code>mounted</code> 钩子中定义</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 取课程分类</span>courseApi.category_findlist(&#123;&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;  <span class="hljs-keyword">this</span>.categoryList = res.children;&#125;);</code></pre></div><p><strong>4）效果</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image14.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image14.png" srcset="/img/loading.gif" alt="image-20200403221132985"></a></p><p><strong>5) 如何获取选择的分类</strong></p><p>用户选择课程分类后，所选分类 <code>ID</code> 绑定到 <code>categoryActive</code>（数组）中，选择了一级、二级分类，分别存储在 <code>categoryActive</code> 数组的第一个、第二个元素中。</p><h2 id="5-新增课程服务端"><a href="#5-新增课程服务端" class="headerlink" title="5. 新增课程服务端"></a>5. 新增课程服务端</h2><h3 id="API接口-1"><a href="#API接口-1" class="headerlink" title="API接口"></a>API接口</h3><p>创建课程添加提交接口：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">" 课程管理"</span>,description = <span class="hljs-string">"课程管理"</span>,tags = &#123;<span class="hljs-string">"课程管理"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;      <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"添加课程基础信息"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> AddCourseResult <span class="hljs-title">addCourseBase</span><span class="hljs-params">(CourseBase courseBase)</span></span>;&#125;</code></pre></div><h3 id="Dao-2"><a href="#Dao-2" class="headerlink" title="Dao"></a>Dao</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseBaseRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">CourseBase</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="Service-2"><a href="#Service-2" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加课程基本信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseBase</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AddCourseResult <span class="hljs-title">addCourseBase</span><span class="hljs-params">(CourseBase courseBase)</span> </span>&#123;        String courseBaseId = courseBase.getId();        courseBaseRepository.save(courseBase);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AddCourseResult(CommonCode.SUCCESS,courseBaseId);    &#125;</code></pre></div><h3 id="Controller-2"><a href="#Controller-2" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"coursebase/add"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> AddCourseResult <span class="hljs-title">addCourseBase</span><span class="hljs-params">(@RequestBody CourseBase courseBase)</span> </span>&#123;       <span class="hljs-keyword">return</span> courseService.addCourseBase(courseBase);   &#125;</code></pre></div><h2 id="6-新增课程前端"><a href="#6-新增课程前端" class="headerlink" title="6. 新增课程前端"></a>6. 新增课程前端</h2><h3 id="Api方法定义"><a href="#Api方法定义" class="headerlink" title="Api方法定义"></a>Api方法定义</h3><p>在前端定义请求服务端添加课程的api的方法，在course模块中定义方法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/* 添加课程基础信息*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addCourseBase = <span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/course/coursebase/add'</span>,params)&#125;</code></pre></div><h3 id="Api方法调用"><a href="#Api方法调用" class="headerlink" title="Api方法调用"></a>Api方法调用</h3><p>在<code>course_add.vue</code> 调用<code>api</code>提交课程信息</p><div class="hljs"><pre><code class="hljs js">methods: &#123;       save () &#123;          <span class="hljs-keyword">this</span>.$refs.courseForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (valid) &#123;              <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                <span class="hljs-comment">//当前选择的分类</span>                <span class="hljs-keyword">let</span> mt = <span class="hljs-keyword">this</span>.categoryActive[<span class="hljs-number">0</span>];                <span class="hljs-keyword">let</span> st = <span class="hljs-keyword">this</span>.categoryActive[<span class="hljs-number">1</span>];                <span class="hljs-keyword">this</span>.courseForm.mt = mt;                <span class="hljs-keyword">this</span>.courseForm.st = st;                <span class="hljs-comment">//请求服务接口</span>                courseApi.addCourseBase(<span class="hljs-keyword">this</span>.courseForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;                  <span class="hljs-keyword">if</span>(res.success)&#123;                    <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'提交成功'</span>);                    <span class="hljs-comment">//跳转到课程图片</span>                    <span class="hljs-comment">//this.$router.push(&#123; path: '/course/add/picture/1/'+this.courseid&#125;)</span>                  &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(res.message)&#123;                      <span class="hljs-keyword">this</span>.$message.error(res.message);                    &#125;<span class="hljs-keyword">else</span>&#123;                      <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);                    &#125;                   &#125;                &#125;);              &#125;);            &#125;          &#125;);      &#125;    &#125;,</code></pre></div><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>注意：将 <code>course_base</code> 表中的 <code>company_id</code> 改为非必填，待认证功能开发完成再修改为必填</p><p>测试流程：</p><p>1、进入我的课程，点击“新增课程”打开新增课程页面</p><p>2、输入课程信息，点击提交</p><h1 id="三、课程信息修改"><a href="#三、课程信息修改" class="headerlink" title="三、课程信息修改"></a>三、课程信息修改</h1><h2 id="1-需求分析-2"><a href="#1-需求分析-2" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>课程添加成功进入课程管理页面，通过课程管理页面修改课程的基本信息、编辑课程图片、编辑课程营销信息等。</p><p>本小节实现修改课程。</p><h2 id="2-课程管理页面说明"><a href="#2-课程管理页面说明" class="headerlink" title="2. 课程管理页面说明"></a>2. 课程管理页面说明</h2><h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><p>课程管理页面的结构如下：</p><p><a href="https://qnoss.codeyee.com/20200706_Nw==/image15.png" target="_blank" rel="noopener"><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/image15.png" srcset="/img/loading.gif" alt="image-20200403221706645"></a></p><h3 id="课程管理导航页面"><a href="#课程管理导航页面" class="headerlink" title="课程管理导航页面"></a>课程管理导航页面</h3><p>1、定义<code>course_manage.vue</code>为课程管理导航页面。</p><p>导航效果使用 <code>Element-UI</code> 的 <code>NavMenu</code> 组件实现。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu</span></span><span class="hljs-tag">      <span class="hljs-attr">:default</span>‐<span class="hljs-attr">active</span>=<span class="hljs-string">"activeIndex"</span></span><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">"el‐menu‐demo"</span></span><span class="hljs-tag">      <span class="hljs-attr">mode</span>=<span class="hljs-string">"horizontal"</span></span><span class="hljs-tag">      <span class="hljs-attr">background</span>‐<span class="hljs-attr">color</span>=<span class="hljs-string">"#eee"</span></span><span class="hljs-tag">      <span class="hljs-attr">text</span>‐<span class="hljs-attr">color</span>=<span class="hljs-string">"#000"</span></span><span class="hljs-tag">      <span class="hljs-attr">active</span>‐<span class="hljs-attr">text</span>‐<span class="hljs-attr">color</span>=<span class="hljs-string">"#000"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/summary/'+this.courseid&#125;"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span>&gt;</span>课程首页<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/baseinfo/'+this.courseid&#125;"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"2"</span>&gt;</span>基本信息<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/picture/'+this.courseid&#125;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"3"</span>&gt;</span>课程图片<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/marketinfo/'+this.courseid&#125;"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"4"</span>&gt;</span>课程营销<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/plan/'+this.courseid&#125;"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"5"</span>&gt;</span>课程计划<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/teacher/'+this.courseid&#125;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"6"</span>&gt;</span>教师信息<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router‐link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mui‐tab‐item"</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/course/manage/pub/'+this.courseid&#125;"</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">el‐menu‐item</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"7"</span>&gt;</span> 发布课程<span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">router‐link</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐menu</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router‐view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"main"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router‐view</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/course'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../common/utils'</span>;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        activeIndex:<span class="hljs-string">'2'</span>,</span><span class="actionscript">        courseid:<span class="hljs-string">''</span></span>      &#125;    &#125;,    methods: &#123;    &#125;,    mounted()&#123;<span class="actionscript">      <span class="hljs-comment">//课程id</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"courseid="</span> + <span class="hljs-keyword">this</span>.courseid)</span><span class="actionscript">      <span class="hljs-comment">//跳转到页面列表</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.$router.push(&#123; path: <span class="hljs-string">'/course/manage/baseinfo/'</span>+<span class="hljs-keyword">this</span>.courseid&#125;)</span>    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>2、<strong>创建各各信息管理页面</strong></p><p>通过管理页面的导航可以进入各各信息管理页面，这里先创建各各信息管理页面，页面内容暂</p><p>时为空，待开发时再完善，在本模块的 <code>page</code> 目录下创建 <code>course_manage</code> 目录，此目录存放</p><p>各个信息管理页面，页面明细如下：</p><p>课程管理首页：<strong>course_summary.vue</strong></p><p>基本信息修改页面：<strong>course_baseinfo.vue</strong></p><p>图片管理页面：<strong>course_picture.vue</strong></p><p>营销信息页面：<strong>course_marketinfo.vue</strong></p><p>老师信息页面：<strong>course_teacher.vue</strong></p><p>课程计划页面：<strong>course_plan.vue</strong></p><p>课程发布页面：<strong>course_pub.vue</strong></p><p>3 、<strong>创建路由</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> course_manage <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage.vue'</span>; <span class="hljs-keyword">import</span> course_summary <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_summary.vue'</span>;<span class="hljs-keyword">import</span> course_picture <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_picture.vue'</span>;<span class="hljs-keyword">import</span> course_baseinfo <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_baseinfo.vue'</span>;<span class="hljs-keyword">import</span> course_marketinfo <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_marketinfo.vue'</span>;<span class="hljs-keyword">import</span> course_teacher <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_teacher.vue'</span>;<span class="hljs-keyword">import</span> course_plan <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_plan.vue'</span>;<span class="hljs-keyword">import</span> course_pub <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/course/page/course_manage/course_pub.vue'</span>;&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manager/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'管理课程'</span>,<span class="hljs-attr">component</span>: course_manage,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> ,        children: [          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/plan/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'课程计划'</span>,<span class="hljs-attr">component</span>: course_plan,<span class="hljs-attr">hidden</span>:<span class="hljs-literal">false</span> &#125;,          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/baseinfo/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'基本信息'</span>,<span class="hljs-attr">component</span>:course_baseinfo,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span> &#125;,          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/picture/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'课程图片'</span>,<span class="hljs-attr">component</span>:course_picture,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span> &#125;,          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/marketinfo/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'营销信息'</span>,<span class="hljs-attr">component</span>:course_marketinfo,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span> &#125;,          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/teacher/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'教师信息'</span>,<span class="hljs-attr">component</span>:course_teacher,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>&#125;,          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/pub/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'发布课程'</span>,<span class="hljs-attr">component</span>: course_pub,<span class="hljs-attr">hidden</span>:<span class="hljs-literal">false</span>&#125;,          &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/manage/summary/:courseid'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'课程首页'</span>,<span class="hljs-attr">component</span>:course_summary,<span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span> &#125;        ]&#125;</code></pre></div><h2 id="3-Api-接口"><a href="#3-Api-接口" class="headerlink" title="3. Api 接口"></a>3. Api 接口</h2><p>修改课程需要如下接口：</p><p>1、根据id查询课程信息</p><p>2、修改课程提交</p><p>接口定义如下：</p><ol><li>根据课程ID查询课程信息</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">" 获取课程基础信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CourseBase <span class="hljs-title">getCourseBaseById</span><span class="hljs-params">(String courseId)</span> <span class="hljs-keyword">throws</span> RuntimeException</span>;</code></pre></div><p>2）修改课程信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"更新课程基础信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateCourseBase</span><span class="hljs-params">(String id,CourseBase courseBase)</span></span>;</code></pre></div><h2 id="4-服务端"><a href="#4-服务端" class="headerlink" title="4. 服务端"></a>4. 服务端</h2><h3 id="Dao-3"><a href="#Dao-3" class="headerlink" title="Dao"></a>Dao</h3><p>略</p><h3 id="Service-3"><a href="#Service-3" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据课程id查询课程基本信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBase <span class="hljs-title">getCourseBaseById</span><span class="hljs-params">(String courseId)</span> </span>&#123;        <span class="hljs-keyword">if</span> (courseId == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CommonCode.INVALID_PARAM);        &#125;        Optional&lt;CourseBase&gt; optional = courseBaseRepository.findById(courseId);        <span class="hljs-keyword">if</span> (optional.isPresent())&#123;            CourseBase courseBase = optional.get();            <span class="hljs-keyword">return</span> courseBase;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新课程基本信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseBase</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateCourseBase</span><span class="hljs-params">(String id, CourseBase courseBase)</span> </span>&#123;        CourseBase courseBaseNew = <span class="hljs-keyword">this</span>.getCourseBaseById(id);        BeanUtils.copyProperties(courseBase,courseBaseNew);        courseBaseRepository.save(courseBaseNew);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;</code></pre></div><h3 id="Controller-3"><a href="#Controller-3" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"coursebase/get/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CourseBase <span class="hljs-title">getCourseBaseById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String courseId) <span class="hljs-keyword">throws</span> RuntimeException </span>&#123;        <span class="hljs-keyword">return</span> courseService.getCourseBaseById(courseId);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"coursebase/update/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateCourseBase</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id,@RequestBody CourseBase courseBase) </span>&#123;        <span class="hljs-keyword">return</span> courseService.updateCourseBase(id,courseBase);    &#125;</code></pre></div><h2 id="5-前端"><a href="#5-前端" class="headerlink" title="5. 前端"></a>5. 前端</h2><h3 id="修改页面"><a href="#修改页面" class="headerlink" title="修改页面"></a>修改页面</h3><p>在 <code>course</code> 模块下的 <code>course_manage</code> 目录下创建 <code>course_baseinfo.vue</code> 页面，本页面实现课程修改</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el‐form</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">"courseForm"</span> <span class="hljs-attr">label</span>‐<span class="hljs-attr">width</span>=<span class="hljs-string">"80px"</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">"courseRules"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"courseForm"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程名称"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"name"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.name"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"适用人群"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"users"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.users"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程分类"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"categoryActive"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐cascader</span></span><span class="hljs-tag">          <span class="hljs-attr">expand</span>‐<span class="hljs-attr">trigger</span>=<span class="hljs-string">"hover"</span></span><span class="hljs-tag">          <span class="hljs-attr">:options</span>=<span class="hljs-string">"categoryList"</span></span><span class="hljs-tag">          <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"categoryActive"</span></span><span class="hljs-tag">          <span class="hljs-attr">:props</span>=<span class="hljs-string">"props"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐cascader</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程等级"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"grade"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"grade in gradeList"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.grade"</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"grade.sdId"</span> &gt;</span>&#123;&#123;grade.sdName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el‐</span></span><span class="hljs-tag"><span class="hljs-attr">radio</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"学习模式"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"studymodel"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"studymodel_v in studymodelList"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.studymodel"</span> <span class="hljs-attr">:label</span>=<span class="hljs-string">"studymodel_v.sdId"</span> &gt;</span>&#123;&#123;studymodel_v.sdName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程介绍"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"description"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"courseForm.description"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"footer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dialog‐footer"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>  @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"save"</span> <span class="hljs-attr">:loading</span>=<span class="hljs-string">"editLoading"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> courseApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../api/course'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> utilApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../common/utils'</span>;</span><span class="javascript">  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> systemApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../base/api/system'</span>;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        courseid:<span class="hljs-string">''</span>,</span>        studymodelList:[],        gradeList:[],<span class="actionscript">        editLoading: <span class="hljs-literal">false</span>,</span>        props: &#123;<span class="actionscript">          value: <span class="hljs-string">'id'</span>,</span><span class="actionscript">          label:<span class="hljs-string">'label'</span>,</span><span class="actionscript">          children:<span class="hljs-string">'children'</span></span>        &#125;,        categoryList: [],        categoryActive:[],        courseForm: &#123;<span class="actionscript">          id:<span class="hljs-string">''</span>,</span><span class="actionscript">          name: <span class="hljs-string">''</span>,</span><span class="actionscript">          users: <span class="hljs-string">''</span>,</span><span class="actionscript">          grade:<span class="hljs-string">''</span>,</span><span class="actionscript">          studymodel:<span class="hljs-string">''</span>,</span><span class="actionscript">          mt:<span class="hljs-string">''</span>,</span><span class="actionscript">          st:<span class="hljs-string">''</span>,</span><span class="actionscript">          description: <span class="hljs-string">''</span></span>        &#125;,        courseRules: &#123;          name: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请输入课程名称'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          category: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择课程分类'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          grade: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择课程等级'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ],          studymodel: [<span class="actionscript">            &#123;required: <span class="hljs-literal">true</span>, message: <span class="hljs-string">'请选择学习模式'</span>, trigger: <span class="hljs-string">'blur'</span>&#125;</span>          ]         &#125;      &#125;    &#125;,    methods: &#123;      save () &#123;               &#125;    &#125;,    created()&#123;    &#125;,    mounted()&#123;        &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 获取课程基本信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getCoursebaseById = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">'/course/coursebase/get/'</span>+id)&#125;<span class="hljs-comment">//更新课程基本信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> updateCoursebase= <span class="hljs-function">(<span class="hljs-params">id,course</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestPut(apiUrl+<span class="hljs-string">'/course/coursebase/update/'</span>+id,course)&#125;</code></pre></div><h3 id="课程信息显示"><a href="#课程信息显示" class="headerlink" title="课程信息显示"></a>课程信息显示</h3><p>在 <code>mounted</code> 钩子方法中查询课程信息及数据字典：</p><div class="hljs"><pre><code class="hljs js">mounted()&#123;       <span class="hljs-comment">//查询数据字典字典</span>      systemApi.sys_getDictionary(<span class="hljs-string">'201'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<span class="hljs-comment">//        console.log(res);</span>        <span class="hljs-keyword">this</span>.studymodelList = res.dvalue;      &#125;);      systemApi.sys_getDictionary(<span class="hljs-string">'200'</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">this</span>.gradeList = res.dvalue;      &#125;);      <span class="hljs-comment">//取课程分类</span>      courseApi.category_findlist(&#123;&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;           <span class="hljs-keyword">this</span>.categoryList = res.children;       &#125;);      <span class="hljs-comment">//查询课程信息</span>        <span class="hljs-comment">//课程id</span>        <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid;        courseApi.getCoursebaseById(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-keyword">this</span>.courseForm = res;          <span class="hljs-comment">//课程分类显示，需要两级分类</span>          <span class="hljs-keyword">this</span>.categoryActive.push(<span class="hljs-keyword">this</span>.courseForm.mt);          <span class="hljs-keyword">this</span>.categoryActive.push(<span class="hljs-keyword">this</span>.courseForm.st);        &#125;);    &#125;</code></pre></div><h3 id="课程修改提交"><a href="#课程修改提交" class="headerlink" title="课程修改提交"></a>课程修改提交</h3><p>编辑课程提交方法</p><div class="hljs"><pre><code class="hljs js">methods: &#123;   save () &#123;      <span class="hljs-comment">//修改课程</span>      <span class="hljs-keyword">this</span>.$refs.courseForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (valid) &#123;          <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-keyword">let</span> mt = <span class="hljs-keyword">this</span>.categoryActive[<span class="hljs-number">0</span>];            <span class="hljs-keyword">let</span> st = <span class="hljs-keyword">this</span>.categoryActive[<span class="hljs-number">1</span>];            <span class="hljs-keyword">this</span>.courseForm.mt = mt;            <span class="hljs-keyword">this</span>.courseForm.st = st;            <span class="hljs-keyword">let</span> id = <span class="hljs-keyword">this</span>.courseForm.id            courseApi.updateCoursebase(id,<span class="hljs-keyword">this</span>.courseForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;              <span class="hljs-keyword">if</span>(res.success)&#123;                <span class="hljs-keyword">this</span>.$message(&#123;                  message: <span class="hljs-string">'提交成功'</span>,                  type: <span class="hljs-string">'success'</span>                &#125;);              &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(res.message)&#123;                  <span class="hljs-keyword">this</span>.$message.error(res.message);                &#125;<span class="hljs-keyword">else</span>&#123;                  <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);                &#125;              &#125;            &#125;);          &#125;);        &#125;      &#125;);  &#125;&#125;,</code></pre></div><h1 id="四、课程营销"><a href="#四、课程营销" class="headerlink" title="四、课程营销"></a>四、课程营销</h1><h2 id="1-需求分析-3"><a href="#1-需求分析-3" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>课程添加成功进入课程管理页面，通过课程管理页面修改课程的基本信息、编辑课程图片、编辑课程营销信息等。</p><p>本小节实现营销信息的查询和修改。</p><h2 id="2-课程管理页面说明-1"><a href="#2-课程管理页面说明-1" class="headerlink" title="2.课程管理页面说明"></a>2.课程管理页面说明</h2><p><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/16.png" srcset="/img/loading.gif" alt></p><h3 id="页面方法"><a href="#页面方法" class="headerlink" title="页面方法"></a>页面方法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//获取课程营销信息</span>      courseApi.getCourseMarketById(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;         <span class="hljs-comment">//console.log(res);</span>        <span class="hljs-keyword">if</span>(res &amp;&amp; res.id)&#123;           <span class="hljs-keyword">this</span>.courseMarketForm = res;        &#125;      &#125;);methods: &#123;save: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.$refs.courseMarketForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (valid) &#123;            <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;              courseApi.updateCourseMarket(<span class="hljs-keyword">this</span>.courseid,<span class="hljs-keyword">this</span>.courseMarketForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;               <span class="hljs-keyword">this</span>.editLoading = <span class="hljs-literal">false</span>;               <span class="hljs-keyword">if</span>(res.success)&#123;                 <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'提交成功'</span>);                 <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.dotype == <span class="hljs-string">'1'</span>)&#123;                   <span class="hljs-comment">//跳转到课程图片</span>                   <span class="hljs-keyword">this</span>.$router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/course/add/plan/3/1/'</span>+<span class="hljs-keyword">this</span>.courseid&#125;)                 &#125;               &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);               &#125;               &#125;);            &#125;);          &#125;        &#125;);      &#125;</code></pre></div><h2 id="3-Api接口"><a href="#3-Api接口" class="headerlink" title="3.Api接口"></a>3.Api接口</h2><p>课程营销需要如下接口：</p><p>1、根据id查询课程营销信息</p><p>2、修改课程营销信息提交</p><p>接口定义如下：</p><ol><li>根据课程ID查询课程营销信息</li></ol><div class="hljs"><pre><code class="hljs arduino">@ApiOperation(<span class="hljs-string">"获取课程营销信息"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CourseMarket <span class="hljs-title">getCourseMarketById</span><span class="hljs-params">(<span class="hljs-keyword">String</span> CourseMarketId)</span></span>;</code></pre></div><p>2）修改课程营销信息</p><div class="hljs"><pre><code class="hljs reasonml">@<span class="hljs-constructor">ApiOperation(<span class="hljs-string">"更新或添加课程营销信息"</span>)</span>public ResponseResult update<span class="hljs-constructor">CourseMarket(String <span class="hljs-params">id</span>,CourseMarket <span class="hljs-params">courseMarket</span>)</span>;</code></pre></div><h2 id="4-服务端-1"><a href="#4-服务端-1" class="headerlink" title="4. 服务端"></a>4. 服务端</h2><h3 id="Dao-4"><a href="#Dao-4" class="headerlink" title="Dao"></a>Dao</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseMarketRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">CourseMarket</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="Service-4"><a href="#Service-4" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseMarketService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CourseMarketRepository courseMarketRepository;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CourseMarket <span class="hljs-title">getCourseMarketById</span><span class="hljs-params">(String courseMarketId)</span> </span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(courseMarketId))&#123;            ExceptionCast.cast(CommonCode.INVALID_PARAM);        &#125;        Optional&lt;CourseMarket&gt; optional = courseMarketRepository.findById(courseMarketId);        <span class="hljs-keyword">if</span> (optional.isPresent())&#123;            <span class="hljs-keyword">return</span> optional.get();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateCourseMarket</span><span class="hljs-params">(String id, CourseMarket courseMarket)</span> </span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(id))&#123;            ExceptionCast.cast(CommonCode.INVALID_PARAM);        &#125;        <span class="hljs-keyword">if</span> (courseMarket == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        CourseMarket courseMarketOld = <span class="hljs-keyword">this</span>.getCourseMarketById(id);        <span class="hljs-keyword">if</span> (courseMarketOld == <span class="hljs-keyword">null</span>)&#123;            courseMarketRepository.save(courseMarket);        &#125;<span class="hljs-keyword">else</span> &#123;            BeanUtils.copyProperties(courseMarket,courseMarketOld);            courseMarketRepository.save(courseMarketOld);        &#125;        <span class="hljs-keyword">return</span> ResponseResult.SUCCESS();    &#125;&#125;</code></pre></div><h3 id="Controller-4"><a href="#Controller-4" class="headerlink" title="Controller"></a>Controller</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/market/get/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CourseMarket <span class="hljs-title">getCourseMarketById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String CourseMarketId) </span>&#123;    <span class="hljs-keyword">return</span> courseMarketService.getCourseMarketById(CourseMarketId);&#125;<span class="hljs-meta">@Override</span><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"market/update/&#123;id&#125;"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">updateCourseMarket</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id,</span><span class="hljs-function">                                         @RequestBody CourseMarket courseMarket) </span>&#123;    <span class="hljs-keyword">return</span> courseMarketService.updateCourseMarket(id,courseMarket);&#125;</code></pre></div><h2 id="5-前端-1"><a href="#5-前端-1" class="headerlink" title="5.前端"></a>5.前端</h2><h3 id="API方法-1"><a href="#API方法-1" class="headerlink" title="API方法"></a>API方法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//获取课程营销信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getCourseMarketById = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl + <span class="hljs-string">'/course/market/get/'</span>+id)&#125;<span class="hljs-comment">//更新或添加课程营销信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> updateCourseMarket= <span class="hljs-function">(<span class="hljs-params">id,courseMarket</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestPut(apiUrl+<span class="hljs-string">'/course/market/update/'</span>+id,courseMarket)&#125;</code></pre></div><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><p><img src="/2020/08/13/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday07/17.png" srcset="/img/loading.gif" alt></p><p>修改方法也通过。</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
      <tag>Spring Data MongoDB</tag>
      
      <tag>Spring Data Jpa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day06：页面发布、课程管理</title>
    <link href="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/"/>
    <url>/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day06</code> 的内容</p><ul><li><p>使用 <code>Spring boot</code> 集成 <code>RabbitMQ</code> 和 <code>GridFS</code> 实现基于生产者和消费者模型的页面静态化发布的流程。</p><p>在本章节的知识点中，再次复习了基于 <code>GridFS</code> 和 <code>RabbitMQ</code> 的分布式静态页面发布的知识点，深化了记忆。</p><p>​</p></li><li><p>使用三级菜单实现课程计划的查询和添加</p><p>这里的技术点不是很多，用到了 <code>Mysql</code> 的表内自连接查询，以及在添加课程的时候，需要考虑一些意外情况的发生，例如再添加课程时，如果该课程的根节点（一级菜单）不存在，则需要为该课程添加一个根节点后再进行该二级节点的添加。</p></li></ul><h1 id="一、页面发布"><a href="#一、页面发布" class="headerlink" title="一、页面发布"></a>一、页面发布</h1><h2 id="1-技术方案"><a href="#1-技术方案" class="headerlink" title="1. 技术方案"></a>1. 技术方案</h2><p>本项目使用MQ实现页面发布的技术方案如下:</p><p><img src="https://qnoss.codeyee.com/20200706_Ng==/image1.png" srcset="/img/loading.gif" alt="学成在线day06/image1.png)"></p><p>*<em>技术方案说明 *</em></p><p>1、平台包括多个站点，页面归属不同的站点。</p><p>2、发布一个页面应将该页面发布到所属站点的服务器上。</p><p>3、每个站点服务部署 <code>cms client</code> 程序，并与交换机绑定，绑定时指定站点Id为routingKey。</p><p>指定站点id为 <code>routingKey</code> 就可以实现 <code>cms client</code> 只能接收到所属站点的页面发布消息。</p><p>4、页面发布程序向MQ发布消息时指定页面所属站点 <code>Id</code> 为 <code>routingKey</code>，将该页面发布到它所在服务器上的<code>cms client</code>。</p><p><strong>路由模式分析如下</strong></p><p>发布一个页面，需发布到该页面所属的每个站点服务器，其它站点服务器不发布。</p><p>比如 发布一个门户的页面，需要发布到每个门户服务器上，而用户中心服务器则不需要发布。</p><p>所以本项目采用 <code>routing</code> 模式，用站点 <code>id</code> 作为 <code>routingKey</code>，这样就可以匹配页面只发布到所属的站点服务器上。</p><p><strong>页面发布流程图如下</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image2.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image2.png" srcset="/img/loading.gif" alt="image-20200401211714847"></a></p><p>1、前端请求 <code>cms</code> 执行页面发布。</p><p>2、<code>cms</code> 执行静态化程序生成 <code>html</code>文件。</p><p>3、<code>cms</code> 将 <code>html</code> 文件存储到 <code>GridFS</code> 中。</p><p>4、<code>cms</code> 向 <code>MQ</code> 发送页面发布消息</p><p>5、<code>MQ</code> 将页面发布消息通知给 <code>Cms Client</code></p><p>6、<code>Cms Client</code> 从 <code>GridFS</code> 中下载 <code>html</code> 文件</p><p>7、<code>Cms Client</code> 将 <code>html</code> 保存到所在服务器指定目录</p><h2 id="2-页面发布消费方"><a href="#2-页面发布消费方" class="headerlink" title="2. 页面发布消费方"></a>2. 页面发布消费方</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>功能分析</p><p>创建 <code>Cms Client</code> 工程作为页面发布消费方，将 <code>Cms Client</code> 部署在多个服务器上，它负责接收到页面发布 的消息后从 <code>GridFS</code> 中下载文件在本地保存。</p><p>需求如下</p><p>1、将 <code>cms Client</code> 部署在服务器，配置队列名称和站点 <code>ID</code>。</p><p>2、<code>cms Client</code> 连接 <code>RabbitMQ</code> 并监听各自的“页面发布队列”</p><p>3、<code>cms Client</code> 接收页面发布队列的消息</p><p>4、根据消息中的页面 <code>id</code> 从 <code>mongodb</code> 数据库下载页面到本地</p><h3 id="创建Cms-Client工程"><a href="#创建Cms-Client工程" class="headerlink" title="创建Cms Client工程"></a>创建Cms Client工程</h3><h4 id="1、POM配置"><a href="#1、POM配置" class="headerlink" title="1、POM配置"></a>1、POM配置</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-manage-cms-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-comment">&lt;!--项目依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h4 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><p>在<code>resources</code>下配置 <code>application.yml</code>。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">31000</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc-service-manage-cms-client</span>  <span class="hljs-attr">data:</span>    <span class="hljs-attr">mongodb:</span>      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://root:123123@localhost:27017</span>      <span class="hljs-attr">database:</span> <span class="hljs-string">xc_cms</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span>  <span class="hljs-attr">freemarker:</span>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#关闭模板缓存，方便测试</span>    <span class="hljs-attr">settings:</span>      <span class="hljs-attr">template_update_delay:</span> <span class="hljs-number">0</span><span class="hljs-attr">xuecheng:</span>  <span class="hljs-attr">mq:</span>  <span class="hljs-comment">#cms客户端监控的队列名称（不同的客户端监控的队列不能重复）</span>    <span class="hljs-attr">queue:</span> <span class="hljs-string">queue_cms_postpage_01</span>    <span class="hljs-attr">routingKey:</span> <span class="hljs-string">5a751fab6abb5044e0d19ea1</span> <span class="hljs-comment">#此routingKey为门户站点ID3</span></code></pre></div><p>说明 在配置文件中配置队列的名称，每个 cms client在部署时注意队列名称不要重复</p><h4 id="3、启动类"><a href="#3、启动类" class="headerlink" title="3、启动类"></a>3、启动类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms_client;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)<span class="hljs-comment">//扫描common下的所有类</span><span class="hljs-meta">@ComponentScan</span>(basePackages=&#123;<span class="hljs-string">"com.xuecheng.manage_cms_client"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsClientApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsClientApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="RabbitmqConfig-配置类"><a href="#RabbitmqConfig-配置类" class="headerlink" title="RabbitmqConfig 配置类"></a>RabbitmqConfig 配置类</h3><p>消息队列设置如下</p><p>1、创建 <code>ex_cms_postpage</code> 交换机</p><p>2、每个 <code>Cms Client</code> 创建一个队列与交换机绑定</p><p>3、每个 <code>Cms Client</code> 程序配置队列名称和 <code>routingKey</code>，将站点ID作为<code>routingKey</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms_client.config;<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;    <span class="hljs-comment">//队列bean的名称</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_CMS_POSTPAGE = <span class="hljs-string">"queue_cms_postpage"</span>;    <span class="hljs-comment">//交换机的名称</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_ROUTING_CMS_POSTPAGE = <span class="hljs-string">"ex_routing_cms_postpage"</span>;    <span class="hljs-comment">//队列的名称</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.mq.queue&#125;"</span>)    <span class="hljs-keyword">public</span> String queue_cms_postpage_name;    <span class="hljs-comment">//站点id作为routing key</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;xuecheng.mq.routingKey&#125;"</span>)    <span class="hljs-keyword">public</span> String routingKey;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置direct交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EX_ROUTING_CMS_POSTPAGE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EXCHANGE_DIRECT_INFORM</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明队列</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(QUEUE_CMS_POSTPAGE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_CMS_POSTPAGE</span><span class="hljs-params">()</span></span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(queue_cms_postpage_name);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定队列到交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_INFORM_SMS</span><span class="hljs-params">(@Qualifier(QUEUE_CMS_POSTPAGE)</span> Queue queue,</span><span class="hljs-function">                                            @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_ROUTING_CMS_POSTPAGE)</span> Exchange exchange)</span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(routingKey).noargs();    &#125;&#125;</code></pre></div><p>配置 MongoConfig</p><blockquote><p>后续的代码中需要将GridFSBucket注入成bean</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms_client.config;<span class="hljs-keyword">import</span> com.mongodb.MongoClient;<span class="hljs-keyword">import</span> com.mongodb.client.MongoDatabase;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.GridFSBucket;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.GridFSBuckets;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.data.mongodb.database&#125;"</span>)    String db;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> GridFSBucket <span class="hljs-title">getGridFSBucket</span><span class="hljs-params">(MongoClient mongoClient)</span></span>&#123;        MongoDatabase database = mongoClient.getDatabase(db);        GridFSBucket gridFSBucket = GridFSBuckets.create(database);        <span class="hljs-keyword">return</span> gridFSBucket;    &#125;&#125;</code></pre></div><h3 id="定义消息格式"><a href="#定义消息格式" class="headerlink" title="定义消息格式"></a>定义消息格式</h3><p>消息内容采用 <code>json</code> 格式存储数据，如下</p><p>页面id 发布页面的id</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"pageId"</span>:<span class="hljs-string">""</span>&#125;</code></pre></div><h3 id="PageDao"><a href="#PageDao" class="headerlink" title="PageDao"></a>PageDao</h3><p>1、使用 <code>CmsPageRepository</code> 查询页面信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsPage</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><p>2、使用 <code>CmsSiteRepository</code> 查询站点信息，主要获取站点物理路径</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsSiteRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsSite</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="PageService"><a href="#PageService" class="headerlink" title="PageService"></a>PageService</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms_client.service;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.GridFSBucket;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.GridFSDownloadStream;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.model.GridFSFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsSite;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CmsCode;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms_client.dao.CmsPageRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms_client.dao.CmsSiteRepository;<span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Criteria;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Query;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.gridfs.GridFsResource;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.gridfs.GridFsTemplate;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-meta">@Autowired</span>    CmsSiteRepository cmsSiteRepository;    <span class="hljs-meta">@Autowired</span>    GridFsTemplate gridFsTemplate;    <span class="hljs-meta">@Autowired</span>    GridFSBucket gridFSBucket;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将页面html保存到页面物理路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageId</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">savePageToServerPath</span><span class="hljs-params">(String pageId)</span></span>&#123;        Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(pageId);        <span class="hljs-comment">//页面不存在则抛出异常</span>        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);        &#125;        CmsPage cmsPage = optional.get();        CmsSite cmsSite = <span class="hljs-keyword">this</span>.getCmsSiteById(cmsPage.getSiteId());        <span class="hljs-keyword">if</span>(cmsSite == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CmsCode.CMS_SIZE_NOT_EXISTS);        &#125;        <span class="hljs-comment">//原讲义和视频中使用的是sizePathysicaiPath,但是SizePage中没有这个字段，使用PageCms中的PathysicaiPath代替</span>        String pagePath = cmsPage.getPagePhysicalPath() + cmsPage.getPageWebPath() + cmsPage.getPageName();        <span class="hljs-comment">//获取页面文件id</span>        String htmlFileId = cmsPage.getHtmlFileId();        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(htmlFileId))&#123;            ExceptionCast.cast(CmsCode.CMS_PAGE_FILEID_NOT_EXISTS);        &#125;        <span class="hljs-comment">//获取文件流</span>        InputStream inputStream = <span class="hljs-keyword">this</span>.getFileInputStreamFileById(htmlFileId);        <span class="hljs-keyword">if</span>(inputStream == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_HTML_IS_NULL);        &#125;        FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(pagePath));            <span class="hljs-comment">//将文件保存至物理路径</span>            IOUtils.copy(inputStream,fileOutputStream);        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭流</span>            <span class="hljs-keyword">try</span> &#123;                inputStream.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">try</span> &#123;                fileOutputStream.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-comment">//根据文件id获取文件的gridFS输入流</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> InputStream <span class="hljs-title">getFileInputStreamFileById</span><span class="hljs-params">(String fileId)</span></span>&#123;        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(<span class="hljs-string">"_id"</span>).is(fileId)));        <span class="hljs-comment">//获取gridFs下载流</span>        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取文件输入流</span>            GridFsResource gridFsResource = <span class="hljs-keyword">new</span> GridFsResource(gridFSFile, gridFSDownloadStream);            <span class="hljs-keyword">return</span> gridFsResource.getInputStream();        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//根据站点id得到站点信息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> CmsSite <span class="hljs-title">getCmsSiteById</span><span class="hljs-params">(String siteId)</span></span>&#123;        Optional&lt;CmsSite&gt; optional = cmsSiteRepository.findById(siteId);        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        CmsSite cmsSite = optional.get();        <span class="hljs-keyword">return</span> cmsSite;    &#125;&#125;</code></pre></div><h3 id="ConsumerPostPage"><a href="#ConsumerPostPage" class="headerlink" title="ConsumerPostPage"></a>ConsumerPostPage</h3><p>在 <code>cms client</code> 工程的 <code>mq</code> 包下创建 <code>ConsumerPostPage</code> 类，<code>ConsumerPostPage</code> 作为发布页面的消费客户端，监听页面发布队列的消息，收到消息后从 <code>mongodb</code> 下载文件，保存在本地。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms_client.mq;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms_client.dao.CmsPageRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms_client.service.PageService;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerPostPage</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ConsumerPostPage<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-meta">@Autowired</span>    PageService pageService;    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">"$&#123;xuecheng.mq.queue&#125;"</span>&#125;) <span class="hljs-comment">//监听队列</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postPage</span><span class="hljs-params">(String msg)</span></span>&#123;        <span class="hljs-comment">//解析消息</span>        Map map = JSON.parseObject(msg, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        LOGGER.info(<span class="hljs-string">"receive cms post page:&#123;&#125;"</span>, msg.toString());        <span class="hljs-comment">//取出页面id</span>        String pageId = (String) map.get(<span class="hljs-string">"pageId"</span>);        <span class="hljs-comment">//查询页面信息</span>        Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(pageId);        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            LOGGER.error(<span class="hljs-string">"receive cms post page,cmsPage is null: &#123;&#125;"</span>,msg.toString());        &#125;        <span class="hljs-comment">//将页面保存到服务器物理路径</span>        pageService.savePageToServerPath(pageId);    &#125;&#125;</code></pre></div><h2 id="3-页面发布生产方"><a href="#3-页面发布生产方" class="headerlink" title="3. 页面发布生产方"></a>3. 页面发布生产方</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>管理员通过 <code>cms</code> 系统发布 “<strong>页面发布</strong>” 的消费，<code>cms</code> 系统作为页面发布的生产方。<br>需求如下</p><p>1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。</p><p>2、cms页面发布接口执行页面静态化，并将静态化页面存储至GridFS中。</p><p>3、静态化成功后，向消息队列发送页面发布的消息。</p><p> 1） 获取页面的信息及页面所属站点ID。</p><p> 2） 设置消息内容为页面ID。（采用json格式，方便日后扩展）</p><p> 3） 发送消息给 <code>ex_cms_postpage</code> 交换机，并将站点ID作为 <code>routingKey</code>。</p><h3 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h3><p>1、配置 <code>Rabbitmq</code> 的连接参数</p><p>在 <code>application.yml</code> 添加如下配置</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>    <span class="hljs-attr">virtualHost:</span> <span class="hljs-string">/</span></code></pre></div><p>2、在 <code>pom.xml</code> 添加依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring‐boot‐starter‐amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>3、<code>RabbitMQConfig</code> 配置</p><p>由于 <code>cms</code> 作为页面发布方要面对很多不同站点的服务器，面对很多页面发布队列，所以这里不再配置队列，只需要配置交换机名称即可。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.config;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> org.springframework.amqp.core.Exchange;<span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeBuilder;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;    <span class="hljs-comment">//交换机的名称</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_ROUTING_CMS_POSTPAGE=<span class="hljs-string">"ex_routing_cms_postpage"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换配置使用direct类型</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EX_ROUTING_CMS_POSTPAGE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EXCHANGE_TOPICS_INFORM</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(<span class="hljs-keyword">true</span>).build();    &#125;&#125;</code></pre></div><h3 id="Api-接口"><a href="#Api-接口" class="headerlink" title="Api 接口"></a>Api 接口</h3><p>在api工程定义页面发布接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"发布页面"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">post</span><span class="hljs-params">(String pageId)</span></span>;</code></pre></div><h3 id="PageService-1"><a href="#PageService-1" class="headerlink" title="PageService"></a>PageService</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.service;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.GridFSBucket;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.GridFSDownloadStream;<span class="hljs-keyword">import</span> com.mongodb.client.gridfs.model.GridFSFile;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsTemplate;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.response.CmsPageResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.*;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.config.RabbitmqConfig;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.dao.CmsPageRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.dao.CmsTemplateRepository;<span class="hljs-keyword">import</span> freemarker.cache.StringTemplateLoader;<span class="hljs-keyword">import</span> freemarker.template.Configuration;<span class="hljs-keyword">import</span> freemarker.template.Template;<span class="hljs-keyword">import</span> freemarker.template.TemplateException;<span class="hljs-keyword">import</span> io.netty.util.internal.StringUtil;<span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.bson.types.ObjectId;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.domain.*;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Criteria;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Query;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.gridfs.GridFsResource;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.gridfs.GridFsTemplate;<span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.ui.freemarker.FreeMarkerTemplateUtils;<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    CmsTemplateRepository templateRepository;    <span class="hljs-meta">@Autowired</span>    GridFsTemplate gridFsTemplate;    <span class="hljs-meta">@Autowired</span>    GridFSBucket gridFSBucket;    <span class="hljs-meta">@Autowired</span>    RabbitTemplate rabbitTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 页面发布</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">postPage</span><span class="hljs-params">(String pageId)</span> </span>&#123;        <span class="hljs-comment">//执行静态化</span>        String pageHtml = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            pageHtml = <span class="hljs-keyword">this</span>.getPageHtml(pageId);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (TemplateException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(pageHtml))&#123;            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_HTML_IS_NULL);        &#125;        <span class="hljs-comment">//保存静态化文件</span>        CmsPage cmsPage = <span class="hljs-keyword">this</span>.saveHtml(pageId, pageHtml);        <span class="hljs-comment">//发送消息</span>        <span class="hljs-keyword">this</span>.sendPostPage(pageId);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">//发送页面发布消息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendPostPage</span><span class="hljs-params">(String pageId)</span></span>&#123;        CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);        CmsPage cmsPage = cmsPageResult.getCmsPage();        <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);        &#125;        Map&lt;String, String&gt; msgMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        msgMap.put(<span class="hljs-string">"pageId"</span>,pageId);        <span class="hljs-comment">//消息内容</span>        String msg = JSON.toJSONString(msgMap);        <span class="hljs-comment">//获取站点id作为routing key</span>        String siteId = cmsPage.getSiteId();        <span class="hljs-comment">//发送消息到指定交换机、routingKey、以及要发送的消息</span>        rabbitTemplate.convertAndSend(RabbitmqConfig.EX_ROUTING_CMS_POSTPAGE,siteId,msg);    &#125;    <span class="hljs-comment">//保存静态化页面内容</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> CmsPage <span class="hljs-title">saveHtml</span><span class="hljs-params">(String pageId,String content)</span></span>&#123;        <span class="hljs-comment">//查询页面是否存在</span>        Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(pageId);        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);        &#125;        CmsPage cmsPage = optional.get();        <span class="hljs-comment">//储存之前先删除</span>        String htmlFileId = cmsPage.getHtmlFileId();        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(htmlFileId))&#123;            gridFsTemplate.delete(Query.query(Criteria.where(<span class="hljs-string">"_id"</span>).is(htmlFileId)));        &#125;        <span class="hljs-comment">//保存html文件到GridFS</span>        <span class="hljs-keyword">try</span> &#123;            InputStream inputStream = IOUtils.toInputStream(content,<span class="hljs-string">"utf-8"</span>);            ObjectId objectId = gridFsTemplate.store(inputStream, cmsPage.getPageName());            <span class="hljs-comment">//文件id</span>            String fileId = objectId.toString();            <span class="hljs-comment">//将文件id储存到cmspage中</span>            cmsPage.setHtmlFileId(fileId);            cmsPageRepository.save(cmsPage);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> cmsPage;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 页面静态化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> TemplateException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPageHtml</span><span class="hljs-params">(String pageId)</span> <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;        <span class="hljs-comment">//获取页面模型数据</span>        Map modelByPageId = <span class="hljs-keyword">this</span>.getModelByPageId(pageId);        <span class="hljs-keyword">if</span>(modelByPageId == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//获取页面模型数据为空</span>            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_DATA_IS_NULL);        &#125;        <span class="hljs-comment">//获取页面模板</span>        String templateContent = getTemplateByPageId(pageId);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(templateContent))&#123;            <span class="hljs-comment">//页面模板为空</span>            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_TEMPLATE_IS_NULL);        &#125;        <span class="hljs-comment">//构建页面静态化数据</span>        String html = generateHtml(templateContent, modelByPageId);        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(html))&#123;            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_HTML_IS_NULL);        &#125;        <span class="hljs-keyword">return</span> html;    &#125;    <span class="hljs-comment">//构建静态化页面数据</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateHtml</span><span class="hljs-params">(String template,Map model)</span> <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;        <span class="hljs-comment">//生成配置类</span>        Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.getVersion());        <span class="hljs-comment">//模板加载器</span>        StringTemplateLoader stringTemplateLoader = <span class="hljs-keyword">new</span> StringTemplateLoader();        stringTemplateLoader.putTemplate(<span class="hljs-string">"template"</span>,template);        <span class="hljs-comment">//配置模板加载器</span>        configuration.setTemplateLoader(stringTemplateLoader);        <span class="hljs-comment">//获取模板</span>        Template template1 = configuration.getTemplate(<span class="hljs-string">"template"</span>);        String html = FreeMarkerTemplateUtils.processTemplateIntoString(template1, model);        <span class="hljs-keyword">return</span> html;    &#125;    <span class="hljs-comment">//获取页面模板文件数据</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getTemplateByPageId</span><span class="hljs-params">(String pageId)</span></span>&#123;        <span class="hljs-comment">//查询页面信息</span>        CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);        CmsPage cmsPage = cmsPageResult.getCmsPage();        <span class="hljs-comment">//页面不存在</span>        <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);        &#125;        <span class="hljs-comment">//获取页面模板数据</span>        String templateId = cmsPage.getTemplateId();        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(templateId))&#123;            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_TEMPLATE_IS_NULL);        &#125;        Optional&lt;CmsTemplate&gt; optional = templateRepository.findById(templateId);        <span class="hljs-keyword">if</span>(optional.isPresent())&#123;            CmsTemplate cmsTemplate = optional.get();            <span class="hljs-comment">//获取模板文件id</span>            String templateFileId = cmsTemplate.getTemplateFileId();            <span class="hljs-comment">//取出模板文件内容</span>            GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(<span class="hljs-string">"_id"</span>).is(templateFileId)));            <span class="hljs-comment">//打开下载流对象</span>            GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());            <span class="hljs-comment">//创建GridResource</span>            GridFsResource gridFsResource = <span class="hljs-keyword">new</span> GridFsResource(gridFSFile, gridFSDownloadStream);            <span class="hljs-keyword">try</span> &#123;                String content = IOUtils.toString(gridFsResource.getInputStream(), <span class="hljs-string">"utf-8"</span>);                <span class="hljs-keyword">return</span> content;            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//从dataUrl中获取页面模型数据</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Map <span class="hljs-title">getModelByPageId</span><span class="hljs-params">(String pageId)</span></span>&#123;        <span class="hljs-comment">//查询页面信息</span>        CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);        CmsPage cmsPage = cmsPageResult.getCmsPage();        <span class="hljs-comment">//页面不存在</span>        <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;            ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);        &#125;        <span class="hljs-comment">//取出dataUrl</span>        String dataUrl = cmsPage.getDataUrl();        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(dataUrl))&#123;            ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_DATAURL_IS_NULL);        &#125;        <span class="hljs-comment">//发送请求获取模型数据</span>        ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(dataUrl,Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        Map body = forEntity.getBody();        <span class="hljs-keyword">return</span> body;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询、页面CURL 部分代码略过，需要请参考前面的章节</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据id获取页面数据</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">cmsPageQueryById</span><span class="hljs-params">(String id)</span> </span>&#123;        Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(id);        <span class="hljs-keyword">if</span> (optional.isPresent()) &#123;            CmsPage cmsPage = optional.get();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS, cmsPage);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre></div><h2 id="4-页面发布前端"><a href="#4-页面发布前端" class="headerlink" title="4. 页面发布前端"></a>4. 页面发布前端</h2><p>用户操作流程</p><p>1、用户进入 <code>cms</code> 页面列表。</p><p>2、点击 “<strong>发布</strong>” 请求服务端接口，发布页面。</p><p>3、提示 “<strong>发布成功</strong>”，或发布失败。</p><h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><p>在 cms前端添加 api方法。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*发布页面*/</span>export <span class="hljs-keyword">const</span> page_postPage= id =&gt; &#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/cms/page/postPage/'</span>+id)&#125;</code></pre></div><h3 id="页面开发"><a href="#页面开发" class="headerlink" title="页面开发"></a>页面开发</h3><p>修改 page_list.vue，添加发布按钮</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐table‐column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"发布"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"80"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>‐<span class="hljs-attr">scope</span>=<span class="hljs-string">"scope"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span></span><span class="hljs-tag">      <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">plain</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"postPage(scope.row.pageId)"</span>&gt;</span>发布    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐table‐column</span>&gt;</span></code></pre></div><p>添加页面发布事件</p><div class="hljs"><pre><code class="hljs js">postPage (id) &#123;  <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认发布该页面吗?'</span>, <span class="hljs-string">'提示'</span>, &#123;  &#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    cmsApi.page_postPage(id).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span>(res.success)&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'发布页面id='</span>+id);        <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'发布成功，请稍后查看结果'</span>);      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'发布失败'</span>);      &#125;    &#125;);  &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  &#125;);&#125;,</code></pre></div><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><p>这里测试轮播图页面修改、发布的流程</p><p>1、修改轮播图页面模板或修改轮播图地址</p><p>注意 先修改页面原型，页面原型调试正常后再修改页面模板。</p><p>2、执行页面预览</p><p>3、执行页面发布，查看页面是否写到网站目录</p><p>4、刷新门户首页并观察轮播图是否变化。</p><h2 id="6-思考"><a href="#6-思考" class="headerlink" title="6. 思考"></a>6. 思考</h2><p>1、如果发布到服务器的页面内容不正确怎么办？</p><p>2、一个页面需要发布很多服务器，点击“发布”后如何知道详细的发布结果？</p><p>3、一个页面发布到多个服务器，其中有一个服务器发布失败时怎么办？</p><h1 id="二、课程管理"><a href="#二、课程管理" class="headerlink" title="二、课程管理"></a>二、课程管理</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。</p><p><strong>课程管理包括如下功能需求</strong></p><p>1、分类管理<br>2、新增课程<br>3、修改课程<br>4、预览课程<br>5、发布课程</p><p><strong>用户的操作流程如下</strong></p><p><strong>1、进入我的课程</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image3.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image3.png" srcset="/img/loading.gif" alt="image-20200401214528987"></a></p><p><strong>2、点击“添加课程”，进入添加课程界面</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image4.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image4.png" srcset="/img/loading.gif" alt="image-20200401214540896"></a></p><p><strong>3、输入课程基本信息，点击提交</strong></p><p><strong>4、课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image5.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image5.png" srcset="/img/loading.gif" alt="image-20200401214605318"></a></p><p><strong>5、编辑图片上传课程图片。</strong></p><p><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image6.png" srcset="/img/loading.gif" alt="image-20200401214657046"></p><p><strong>6、编辑课程营销信息</strong></p><p>营销信息主要是设置课程的收费方式及价格。</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image7.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image7.png" srcset="/img/loading.gif" alt="image-20200401214707765"></a></p><p><strong>7、编辑课程计划</strong></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image8.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image8.png" srcset="/img/loading.gif" alt="image-20200401214718496"></a></p><h2 id="2-教学方法"><a href="#2-教学方法" class="headerlink" title="2. 教学方法"></a>2. 教学方法</h2><p>本模块对课程信息管理功能的教学方法采用实战教学方法，旨在通过实战提高接口编写的能力，具体教学方法如下：</p><p>1、前后端工程导入</p><p>教学管理前端工程采用与系统管理工程相同的技术，直接导入后在此基础上开发。<br>课程管理服务端工程采用Spring Boot技术构建，技术层技术使用Spring data Jpa（与Spring data Mongodb类<br>似）、Mybatis，直接导入后在此基础上开发。</p><p>2、课程计划功能</p><p>课程计划功能采用全程教学。</p><p>3、我的课程、新增课程、修改课程、课程营销</p><p>我的课程、新增课程、修改课程、课程营销四个功能采用实战方式，课堂上会讲解每个功能的需求及技术点，讲解完成学生开始实战，由导师进行技术指导。</p><p>4、参考文档</p><p>实战结束提供每个功能的开发文档，学生参考文档并修正功能缺陷。</p><h2 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3. 环境搭建"></a>3. 环境搭建</h2><h3 id="1、搭建数据库环境"><a href="#1、搭建数据库环境" class="headerlink" title="1、搭建数据库环境"></a>1、搭建数据库环境</h3><ol><li><strong>创建数据库</strong></li></ol><p>课程管理使用 <code>MySQL</code> 数据库，创建课程管理数据库：<code>xc_course</code>。</p><p>导入 <code>xc_course.sql</code> 脚本</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image9.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image9.png" srcset="/img/loading.gif" alt="image-20200401215113957"></a></p><ol><li><strong>数据表介绍</strong></li></ol><p>课程信息内容繁多，将课程信息分类保存在如下表中：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image10.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image10.png" srcset="/img/loading.gif" alt="image-20200401215204860"></a></p><p>分类储存既可以提高解耦合度，也可以保证数据的完整性。</p><p>数据表结构如下：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image11.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image11.png" srcset="/img/loading.gif" alt="image-20200401215300618"></a></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image12.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image12.png" srcset="/img/loading.gif" alt="image-20200401215305777"></a></p><p><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image13.png" srcset="/img/loading.gif" alt="image-20200401215310490"></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image14.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image14.png" srcset="/img/loading.gif" alt="image-20200401215313716"></a></p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image15.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image15.png" srcset="/img/loading.gif" alt="image-20200401215316397"></a></p><h3 id="2、导入课程管理服务工程"><a href="#2、导入课程管理服务工程" class="headerlink" title="2、导入课程管理服务工程"></a>2、导入课程管理服务工程</h3><p>1）持久层技术介绍：</p><p>课程管理服务使用MySQL数据库存储课程信息，持久层技术如下：</p><p>1、spring data jpa：用于表的基本CRUD。</p><p>2、mybatis：用于复杂的查询操作。</p><p>3、druid：使用阿里巴巴提供的spring boot 整合druid包druid-spring-boot-starter管理连接池。</p><blockquote><p>druid-spring-boot-starter地址：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" target="_blank" rel="noopener">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p></blockquote><p><strong>为什么持久层用到了 JPA 还要用 Mybatis ？</strong></p><p>因为 JPA 是面向对象进行开发的，对于一些复杂的sql操作，优化起来会比较麻烦：</p><p>而 Mybatis 是面向sql的，对一些复杂的多表操作比较友好。</p><p>导入资料下的 “xc-service-manage-course.zip”。</p><h3 id="3、导入课程管理前端工程"><a href="#3、导入课程管理前端工程" class="headerlink" title="3、导入课程管理前端工程"></a>3、导入课程管理前端工程</h3><p>课程管理属于教学管理子系统的功能，使用用户为教学机构的管理人员和老师，为保证系统的可维护性，单独创建一个教学管理前端工程。 教学管理前端工程与系统管理前端的工程结构一样，也采用 <code>vue.js</code> 框架来实现。</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image16.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image16.png" srcset="/img/loading.gif" alt="image-20200401215549740"></a></p><p>从课程资料目录拷贝 <code>xc-ui-pc-teach.zip</code> 到工程，使用 <code>webstorm</code> 打开，启动工程</p><p>效果图如下：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image17.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image17.png" srcset="/img/loading.gif" alt="image-20200401215618671"></a></p><h1 id="三、课程计划"><a href="#三、课程计划" class="headerlink" title="三、课程计划"></a>三、课程计划</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>什么是课程计划？</p><p>课程计划定义了课程的章节内容，学生通过课程计划进行在线学习，下图中右侧显示的就是课程计划。</p><p>课程计划包括两级，第一级是课程的大章节、第二级是大章节下属的小章节，每个小章节通常是一段视频，学生点击小章节在线学习。</p><p>教学管理人员对课程计划如何管理？</p><p>功能包括：添加课程计划、删除课程计划、修改课程计划等。例如：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image18.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image18.png" srcset="/img/loading.gif" alt="image-20200401215716660"></a></p><h2 id="2-课程计划查询"><a href="#2-课程计划查询" class="headerlink" title="2. 课程计划查询"></a>2. 课程计划查询</h2><p>课程计划查询是将某个课程的课程计划内容完整的显示出来，如下图所示：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image19.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image19.png" srcset="/img/loading.gif" alt="image-20200401215738194"></a></p><p>左侧显示的就是课程计划，课程计划是一个树型结构，方便扩展课程计划的级别。</p><p>在上边页面中，点击“添加课程计划”即可对课程计划进行添加操作。</p><p>点击修改可对某个章节内容进行修改。</p><p>点击删除可删除某个章节。</p><h3 id="页面原型"><a href="#页面原型" class="headerlink" title="页面原型"></a>页面原型</h3><h4 id="tree组件介绍"><a href="#tree组件介绍" class="headerlink" title="tree组件介绍"></a>tree组件介绍</h4><p>本功能使用 <code>element-ui</code> 的 <code>tree</code> 组件来完成</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image20.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image20.png" srcset="/img/loading.gif" alt="image-20200401215821019"></a></p><p>在 <code>course_plan.vue</code> 文件中添加 <code>tree</code> 组件的代码，进行测试：</p><p>1、组件标签</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐tree</span></span><span class="hljs-tag">      <span class="hljs-attr">:data</span>=<span class="hljs-string">"data"</span></span><span class="hljs-tag">      <span class="hljs-attr">show</span>‐<span class="hljs-attr">checkbox</span></span><span class="hljs-tag">      <span class="hljs-attr">node</span>‐<span class="hljs-attr">key</span>=<span class="hljs-string">"id"</span></span><span class="hljs-tag">      <span class="hljs-attr">default</span>‐<span class="hljs-attr">expand</span>‐<span class="hljs-attr">all</span></span><span class="hljs-tag">      <span class="hljs-attr">:expand</span>‐<span class="hljs-attr">on</span>‐<span class="hljs-attr">click</span>‐<span class="hljs-attr">node</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">      <span class="hljs-attr">:render</span>‐<span class="hljs-attr">content</span>=<span class="hljs-string">"renderContent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐tree</span>&gt;</span></code></pre></div><p>2、数据对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> id = <span class="hljs-number">1000</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;      <span class="hljs-keyword">return</span> &#123;        data : [&#123;          id: <span class="hljs-number">1</span>,          label: <span class="hljs-string">'一级 1'</span>,          children: [&#123;            id: <span class="hljs-number">4</span>,            label: <span class="hljs-string">'二级 1‐1'</span>,            children: [&#123;              id: <span class="hljs-number">9</span>,              label: <span class="hljs-string">'三级 1‐1‐1'</span>            &#125;, &#123;              id: <span class="hljs-number">10</span>,              label: <span class="hljs-string">'三级 1‐1‐2'</span>            &#125;]          &#125;]        &#125;]      &#125;     &#125; &#125;</code></pre></div><h4 id="webstorm-配置JSX"><a href="#webstorm-配置JSX" class="headerlink" title="webstorm 配置JSX"></a>webstorm 配置JSX</h4><p>本组件用到了JSX语法，如下所示：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image21.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image21.png" srcset="/img/loading.gif" alt="image-20200401215955630"></a></p><p><code>JSX</code> 是 <code>Javascript</code> 和 <code>XML</code> 结合的一种格式，它是 <code>React</code> 的核心组成部分，<code>JSX</code>和<code>XML</code> 语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入<code>JavaScript</code> 表达式。遇到 <code>HTML</code> 标签（以 &lt; 开头），就用 <code>HTML</code> 规则解析；<br>遇到代码块（以 { 开头），就用 <code>JavaScript</code> 规则解析。</p><p>下面是官方的一个例子：</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image22.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/C:%5CUsers%5CMI%5CDesktop%5CHexo%5Csource_posts%5C%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06%5Cimage22.png" srcset="/img/loading.gif" alt="image-20200401220038034"></a></p><p>设置方法 如下：</p><p>1 、Javascript version 选择 React JSX （如果没有就选择JSX Harmony）</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image23.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image23.png" srcset="/img/loading.gif" alt="image-20200401220056325"></a></p><p>2、HTML 类型文件中增加vue</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image24.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image24.png" srcset="/img/loading.gif" alt="image-20200401220104955"></a></p><p>preferences -&gt; Editor -&gt; File Types 中找到上边框中HTML 在下边加一个 *.vue</p><p>如果已经在 vue template 中已存在.vue 则把它改为.vue2(因为要在Html中添加.vue)</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image25.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image25.png" srcset="/img/loading.gif" alt="image-20200401220120452"></a></p><h3 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h3><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>1、表结构</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image26.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image26.png" srcset="/img/loading.gif" alt="image-20200401220143626"></a></p><p>2、模型类</p><p>课程计划为树型结构，由树根（课程）和树枝（章节）组成，为了保证系统的可扩展性，在系统设计时将课程计划设置为树型结构。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"teachplan"</span>)<span class="hljs-meta">@GenericGenerator</span>(name = <span class="hljs-string">"jpa‐uuid"</span>, strategy = <span class="hljs-string">"uuid"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teachplan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = ‐<span class="hljs-number">916357110051689485L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(generator = <span class="hljs-string">"jpa‐uuid"</span>)    <span class="hljs-meta">@Column</span>(length = <span class="hljs-number">32</span>)    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> String pname;    <span class="hljs-keyword">private</span> String parentid;    <span class="hljs-keyword">private</span> String grade;    <span class="hljs-keyword">private</span> String ptype;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-keyword">private</span> String courseid;    <span class="hljs-keyword">private</span> String status;    <span class="hljs-keyword">private</span> Integer orderby;    <span class="hljs-keyword">private</span> Double timelength;    <span class="hljs-keyword">private</span> String trylearn;&#125;</code></pre></div><h4 id="自定义模型类"><a href="#自定义模型类" class="headerlink" title="自定义模型类"></a>自定义模型类</h4><p>前端页面需要树型结构的数据来展示Tree组件，如下：</p><div class="hljs"><pre><code class="hljs js">[&#123;      id: <span class="hljs-number">1</span>,      label: <span class="hljs-string">'一级 1'</span>,      children: [&#123;        id: <span class="hljs-number">4</span>,        label: <span class="hljs-string">'二级 1‐1'</span>       &#125;]     &#125;]</code></pre></div><p>自定义课程计划结点类如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeachplanNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Teachplan</span> </span>&#123;    List&lt;TeachplanNode&gt; children;&#125;</code></pre></div><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><p>根据课程id查询课程的计划接口如下，在api工程创建 <code>course</code> 包，创建<code>CourseControllerApi</code> 接口类并定义接口方法如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"课程计划查询"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">findTeachplanList</span><span class="hljs-params">(String courseId)</span></span>;&#125;</code></pre></div><h3 id="课程管理服务"><a href="#课程管理服务" class="headerlink" title="课程管理服务"></a>课程管理服务</h3><h4 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  a.id one_id,  a.pname one_pname,  b.id two_id,  b.pname two_pname,  c.id three_id,  c.pname three_pname<span class="hljs-keyword">FROM</span>  teachplan a  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> teachplan b    <span class="hljs-keyword">ON</span> a.id = b.parentid  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> teachplan c    <span class="hljs-keyword">ON</span> b.id = c.parentid<span class="hljs-keyword">WHERE</span> a.parentid = <span class="hljs-string">'0'</span>  <span class="hljs-keyword">AND</span> a.courseid = <span class="hljs-string">'402885816243d2dd016243f24c030002'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.orderby,  b.orderby,  c.orderby</code></pre></div><h4 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h4><ol><li>mapper接口</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeachplanMapper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">selectList</span><span class="hljs-params">(String courseId)</span></span>;&#125;</code></pre></div><p>2）mapper映射文件</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.xuecheng.manage_course.dao.TeachplanMapper"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"teachplanMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.TeachplanNode"</span>&gt;</span>        <span class="hljs-comment">&lt;!--一级节点--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_id"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"one_pname"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"children"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.TeachplanNode"</span>&gt;</span>            <span class="hljs-comment">&lt;!--二级节点--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_id"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"two_pname"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"children"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"com.xuecheng.framework.domain.course.ext.TeachplanNode"</span>&gt;</span>                <span class="hljs-comment">&lt;!--三级节点--&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_id"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"pname"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"three_pname"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>    <span class="hljs-comment">&lt;!--三级菜单查询--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectList"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"teachplanMap"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.String"</span>&gt;</span>        SELECT            a.id one_id,            a.pname one_pname,            a.courseid one_course,            b.id two_id,            b.pname two_pname,            c.id three_id,            c.pname three_pname        FROM            teachplan a        LEFT JOIN teachplan b            ON b.parentid = a.id        LEFT JOIN teachplan c            ON c.parentid = b.id        WHERE            a.parentid = '0'        <span class="hljs-comment">&lt;!--判断参数不为空时才进行参数的匹配--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"_parameter!=null and _parameter!=''"</span>&gt;</span>            and a.courseid = #&#123;courseId&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        ORDER BY a.orderby,            b.orderby,            c.orderby    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>说明：针对输入参数为简单类型 #{}中可以是任意类型，判断参数是否为空要用 _parameter（它属于<code>mybatis</code>的内置参数）</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    TeachplanMapper teachplanMapper;    <span class="hljs-comment">//查询课程计划</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">findTeachplanList</span><span class="hljs-params">(String courseId)</span></span>&#123;        TeachplanNode teachplanNode = teachplanMapper.selectList(courseId);        <span class="hljs-keyword">return</span> teachplanNode;    &#125;&#125;</code></pre></div><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/course"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CourseService courseService;    <span class="hljs-comment">//查询课程计划</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/teachplan/list/&#123;courseId&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">findTeachplanList</span><span class="hljs-params">(String courseId)</span> </span>&#123;        <span class="hljs-keyword">return</span> courseService.findTeachplanList(courseId);    &#125;&#125;</code></pre></div><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>使用postman或swagger-ui测试查询接口。</p><p>Get 请求：<a href="http://localhost:31200/course/teachplan/list/402885816243d2dd016243f24c030002" target="_blank" rel="noopener">http://localhost:31200/course/teachplan/list/402885816243d2dd016243f24c030002</a></p><h3 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h3><h4 id="API方法-1"><a href="#API方法-1" class="headerlink" title="API方法"></a>API方法</h4><p>定义课程计划查询的api方法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/*查询课程计划*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> findTeachplanList = <span class="hljs-function"><span class="hljs-params">courseid</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl+<span class="hljs-string">'/course/teachplan/list/'</span>+courseid)&#125;</code></pre></div><h4 id="Api调用"><a href="#Api调用" class="headerlink" title="Api调用"></a>Api调用</h4><ol><li>在 <code>mounted</code> 钩子方法 中查询 课程计划<br>定义查询课程计划的方法，赋值给数据对象 <code>teachplanList</code></li></ol><div class="hljs"><pre><code class="hljs js">findTeachplan()&#123;    courseApi.findTeachplanList(<span class="hljs-keyword">this</span>.courseid).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;    <span class="hljs-keyword">this</span>.teachplanList = [];<span class="hljs-comment">//清空树</span>    <span class="hljs-keyword">if</span>(res.children)&#123;    <span class="hljs-keyword">this</span>.teachplanList = res.children;    &#125;&#125;);&#125;</code></pre></div><p>2）在mounted钩子中查询课程计划</p><div class="hljs"><pre><code class="hljs js">mounted()&#123;   <span class="hljs-comment">//课程id</span>  <span class="hljs-keyword">this</span>.courseid = <span class="hljs-keyword">this</span>.$route.params.courseid;  <span class="hljs-comment">//课程计划</span>  <span class="hljs-keyword">this</span>.findTeachplan();&#125;</code></pre></div><p>3）修改树结点的标签属性</p><p>课程计划信息中 <code>pname</code> 为结点的名称，需要修改树结点的标签属性方可正常显示课程计划名称，如下：</p><div class="hljs"><pre><code class="hljs js">defaultProps: &#123;   children: <span class="hljs-string">'children'</span>,  label: <span class="hljs-string">'pname'</span>&#125;</code></pre></div><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image27.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image27.png" srcset="/img/loading.gif" alt="image-20200401221133565"></a></p><h2 id="3-添加课程计划"><a href="#3-添加课程计划" class="headerlink" title="3. 添加课程计划"></a>3. 添加课程计划</h2><h3 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h3><p>用户操作流程</p><p>1 、进入课程计划页面，点击“添加课程计划”</p><p>2、打开添加课程计划页面，输入课程计划信息</p><p><a href="https://qnoss.codeyee.com/20200706_Ng==/image28.png" target="_blank" rel="noopener"><img src="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/image28.png" srcset="/img/loading.gif" alt="image-20200401221202889"></a></p><p><strong>上级结点说明</strong>：</p><p>如果不选择上级节点的话，表示当前添加的课程计划的父节点作为该课程的根节点，也就是说，添加的是二级菜单，如果选择了上级节点，表示添加的是三级菜单，如果添加该课程时，在课程计划中没有该课程的根节点时，要自动将该课程设置为根节点。</p><h4 id="页面原型说明"><a href="#页面原型说明" class="headerlink" title="页面原型说明"></a>页面原型说明</h4><p>添加课程计划采用弹出窗口组件Dialog。</p><p>1、视图部分</p><p>在course_plan.vue页面添加添加课程计划的弹出窗口代码：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el‐dialog</span> <span class="hljs-attr">title</span>=<span class="hljs-string">" 添加课程计划"</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">"teachplayFormVisible"</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">el‐form</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"teachplayForm"</span>  <span class="hljs-attr">:model</span>=<span class="hljs-string">"teachplanActive"</span> <span class="hljs-attr">label</span>‐<span class="hljs-attr">width</span>=<span class="hljs-string">"140px"</span></span><span class="hljs-tag"><span class="hljs-attr">style</span>=<span class="hljs-string">"width:600px;"</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">"teachplanRules"</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"上级结点"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐select</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.parentid"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"不填表示根结点"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el‐option</span></span><span class="hljs-tag">              <span class="hljs-attr">v</span>‐<span class="hljs-attr">for</span>=<span class="hljs-string">"item in teachplanList"</span></span><span class="hljs-tag">              <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span></span><span class="hljs-tag">              <span class="hljs-attr">:label</span>=<span class="hljs-string">"item.pname"</span></span><span class="hljs-tag">              <span class="hljs-attr">:value</span>=<span class="hljs-string">"item.id"</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">el‐option</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el‐select</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"章节/课时名称"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"pname"</span>&gt;</span>                  <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.pname"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"课程类型"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio‐group</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.ptype"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">'1'</span>&gt;</span>视频<span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">'2'</span>&gt;</span>文档<span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio‐group</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"学习时长（分钟）  请输入数字"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.timelength"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐</span></span><span class="hljs-tag"><span class="hljs-attr">input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"排序字段"</span> &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.orderby"</span> <span class="hljs-attr">auto</span>‐<span class="hljs-attr">complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"章节/课时介绍"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"description"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"textarea"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.description"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el‐input</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"状态"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"status"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio‐group</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">model</span>=<span class="hljs-string">"teachplanActive.status"</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"0"</span> &gt;</span>未发布<span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el‐radio</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">'1'</span>&gt;</span>已发布<span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">el‐radio‐group</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">el‐form‐item</span>  &gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">on:click</span>=<span class="hljs-string">"addTeachplan"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">el‐button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v</span>‐<span class="hljs-attr">on:click</span>=<span class="hljs-string">"resetForm"</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">el‐button</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form‐item</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">el‐form</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">el‐dialog</span>&gt;</span></code></pre></div><p>2、数据模型</p><p>在数据模型中添加如下变量：</p><div class="hljs"><pre><code class="hljs js">teachplayFormVisible:<span class="hljs-literal">false</span>,teachplanRules: &#123;        pname: [            &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入课程计划名称'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;        ],            status: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择状态'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ]&#125;,teachplanActive:&#123;&#125;,</code></pre></div><p>3、 添加按钮</p><p>通过变量 <code>teachplayFormVisible</code> 控制弹出窗口是否显示。</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;teachplayFormVisible &#x3D; true&quot;&gt; 添加课程计划&lt;&#x2F;el‐button&gt;</code></pre></div><p>4、定义表单提交方法和重置方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 提交课程计划</span>addTeachplan()&#123;    alert()&#125;,<span class="hljs-comment">//重置表单</span>resetForm()&#123;  <span class="hljs-keyword">this</span>.teachplanActive = &#123;&#125;&#125;,</code></pre></div><h3 id="API接口-1"><a href="#API接口-1" class="headerlink" title="API接口"></a>API接口</h3><p>1）添加课程计划</p><div class="hljs"><pre><code class="hljs java">ApiOperation(<span class="hljs-string">"添加课程计划"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">addTeachplan</span><span class="hljs-params">(Teachplan teachplan)</span></span>;</code></pre></div><h3 id="课程管理服务-1"><a href="#课程管理服务-1" class="headerlink" title="课程管理服务"></a>课程管理服务</h3><h4 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeachplanRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Teachplan</span>, <span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//定义方法根据课程id和父结点id查询出结点列表，可以使用此方法实现查询根结点</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Teachplan&gt; <span class="hljs-title">findByCourseidAndParentid</span><span class="hljs-params">(String courseId,String parentId)</span></span>;&#125;</code></pre></div><h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.service;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.CourseBase;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.Teachplan;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.ext.TeachplanNode;<span class="hljs-keyword">import</span> com.xuecheng.framework.exception.ExceptionCast;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_course.dao.CourseBaseRepository;<span class="hljs-keyword">import</span> com.xuecheng.manage_course.dao.TeachplanMapper;<span class="hljs-keyword">import</span> com.xuecheng.manage_course.dao.TeachplanRepository;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.springframework.beans.BeanUtils;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Optional;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    TeachplanMapper teachplanMapper;    <span class="hljs-meta">@Autowired</span>    CourseBaseRepository courseBaseRepository;    <span class="hljs-meta">@Autowired</span>    TeachplanRepository teachplanRepository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加课程计划</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> teachplan</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Transactional</span>  <span class="hljs-comment">//增删改操作都需要加spring事务</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">addTeachplan</span><span class="hljs-params">(Teachplan teachplan)</span> </span>&#123;        <span class="hljs-comment">//校验课程id和课程计划名称</span>        <span class="hljs-keyword">if</span>(teachplan == <span class="hljs-keyword">null</span>|| StringUtils.isEmpty(teachplan.getCourseid()) || StringUtils.isEmpty(teachplan.getPname()))&#123;            ExceptionCast.cast(CommonCode.INVALID_PARAM);        &#125;        <span class="hljs-comment">//取出课程id</span>        String courseId = teachplan.getCourseid();        <span class="hljs-comment">//取出父节点id</span>        String parentId = teachplan.getParentid();        String newTeachplanGrade = <span class="hljs-string">"3"</span>;  <span class="hljs-comment">//设置新节点的菜单等级</span>        <span class="hljs-comment">// 如果用户未在添加时候未选择根节点,表示需要添加的是一个二级菜单，并且默认添加到当前课程的根节点下</span>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(parentId))&#123;            newTeachplanGrade = <span class="hljs-string">"2"</span>;            <span class="hljs-comment">//根据课程id取根节点的id</span>            parentId = <span class="hljs-keyword">this</span>.getTeachplanRoot(courseId);            <span class="hljs-keyword">if</span>(StringUtils.isEmpty(parentId))&#123;                ExceptionCast.cast(CommonCode.INVALID_PARAM);            &#125;        &#125;        <span class="hljs-comment">//创建新节点</span>        Teachplan teachplanNew = <span class="hljs-keyword">new</span> Teachplan();        <span class="hljs-comment">//将传入的节点信息赋值到新节点内</span>        BeanUtils.copyProperties(teachplan,teachplanNew);        teachplanNew.setParentid(parentId);        teachplanNew.setCourseid(courseId);        <span class="hljs-comment">/* 设置新节点的级别</span><span class="hljs-comment">            方法1：根据父节点的级别进行设置，父节点级别为1，当前则为2，为2则当前为3</span><span class="hljs-comment">            方法2：在判断前端传入的父节点是否为空时进行设置，如果为空，表示需求为添加二级节点，设置2</span><span class="hljs-comment">                  如果不为空，则表示要添加的是三级节点，设置为3，与方法1相比可以减少一次查询。</span><span class="hljs-comment">         */</span>        teachplanNew.setGrade(newTeachplanGrade); <span class="hljs-comment">//节点级别，根据父节点的级别进行设置</span>        teachplanRepository.save(teachplanNew);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-comment">//根据课程id获取课程根节点id，如果根节点不存在 则创建一个根节点，并作为该课程的根节点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getTeachplanRoot</span><span class="hljs-params">(String courseId)</span></span>&#123;        <span class="hljs-comment">//校验课程id</span>        Optional&lt;CourseBase&gt; optional = courseBaseRepository.findById(courseId);        <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        CourseBase courseBase = optional.get();        <span class="hljs-comment">//取出一级根节点菜单</span>        List&lt;Teachplan&gt; teachplanList = teachplanRepository.findByCourseidAndParentid(courseId, <span class="hljs-string">"0"</span>);        <span class="hljs-comment">//如果根节点不存在，则新增一个节点，并且作为该课程的根节点</span>        <span class="hljs-keyword">if</span>(teachplanList == <span class="hljs-keyword">null</span> || teachplanList.size() == <span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//新增一个节点</span>            Teachplan teachplanNewRoot = <span class="hljs-keyword">new</span> Teachplan();            teachplanNewRoot.setCourseid(courseId);            teachplanNewRoot.setPname(courseBase.getName());            teachplanNewRoot.setCourseid(courseId);            teachplanNewRoot.setGrade(<span class="hljs-string">"1"</span>); <span class="hljs-comment">//1级菜单</span>            teachplanNewRoot.setStatus(<span class="hljs-string">"0"</span>); <span class="hljs-comment">//未发布</span>            teachplanRepository.save(teachplanNewRoot);            <span class="hljs-keyword">return</span> teachplanNewRoot.getId();        &#125;        Teachplan teachplan = teachplanList.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> teachplan.getId();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询课程计划</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> courseId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">findTeachplanList</span><span class="hljs-params">(String courseId)</span></span>&#123;        TeachplanNode teachplanNode = teachplanMapper.selectList(courseId);        <span class="hljs-keyword">return</span> teachplanNode;    &#125;&#125;</code></pre></div><h4 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_course.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.course.CourseControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.Teachplan;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.course.ext.TeachplanNode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_course.service.CourseService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/course"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CourseController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CourseControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CourseService courseService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/teachplan/list/&#123;courseId&#125;"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TeachplanNode <span class="hljs-title">findTeachplanList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"courseId"</span>)</span> String courseId) </span>&#123;        <span class="hljs-keyword">return</span> courseService.findTeachplanList(courseId);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/teachplan/add"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">addTeachplan</span><span class="hljs-params">(@RequestBody Teachplan teachplan)</span> </span>&#123;        <span class="hljs-keyword">return</span> courseService.addTeachplan(teachplan);    &#125;&#125;</code></pre></div><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>复杂一些的业务逻辑建议写完服务端代码就进行单元测试。</p><p>使用<code>swagger-ui</code> 或<code>postman</code>测试上边的课程计划添加接口。</p><h3 id="前端Api调用"><a href="#前端Api调用" class="headerlink" title="前端Api调用"></a>前端Api调用</h3><p>1、定义 api方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/* 添加课程计划*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addTeachplan = <span class="hljs-function"><span class="hljs-params">teachplah</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl+<span class="hljs-string">'/course/teachplan/add'</span>,teachplah)&#125;</code></pre></div><p>2、调用 api</p><div class="hljs"><pre><code class="hljs js">addTeachplan()&#123;  <span class="hljs-keyword">this</span>.$refs.teachplayForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (valid) &#123;      <span class="hljs-comment">//添加课程计划时带上课程id</span>      <span class="hljs-keyword">this</span>.teachplanActive.courseid = <span class="hljs-keyword">this</span>.courseid;      courseApi.addTeachplan(<span class="hljs-keyword">this</span>.teachplanActive).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(res.success)&#123;          <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'提交成功'</span>);          <span class="hljs-comment">//清空表单</span>          <span class="hljs-keyword">this</span>.teachplanActive = &#123;&#125;          <span class="hljs-comment">//刷新整个树</span>          <span class="hljs-keyword">this</span>.findTeachplan();          &#125;<span class="hljs-keyword">else</span>&#123;          <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);        &#125;      &#125;);    &#125;  &#125;)&#125;,</code></pre></div><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><p>测试流程：</p><p>1、新建一个课程</p><p>2、向新建课程中添加课程计划</p><p> 添加一级结点</p><p> 添加二级结点</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GridFS</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day05：消息中间件RabbitMQ</title>
    <link href="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/"/>
    <url>/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day05</code> 的内容</p><ul><li><code>RabbitMQ</code> 的基本应用场景</li><li>使用原生<code>RabbitMQ</code> 库构建生产者与消费者模型</li><li>整合 <code>Springboot</code> 实现 <code>RabbitMQ</code> 生产者与消费者模型</li></ul><h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><p><a href="https://qnoss.codeyee.com/20200704_5/image1" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image1.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>业务流程如下：</strong></p><p>1、管理员进入管理界面点击 “页面发布”，前端请求 <code>cms</code> 页面发布接口。</p><p>2、cms 页面发布接口执行页面静态化，并将静态化页面(<code>html</code>文件)存储至<code>GridFS</code>中。</p><p>3、静态化成功后，向消息队列发送页面发布的消息。页面发布的最终目标是将页面发布到<strong>服务器</strong>。通过消息队列将页面发布的消息发送给各个服务器。</p><p>4、消息队列负责将消息发送给各各服务器上部署的 <strong>Cms Client (Cms客户端)</strong>。在服务器上部署 <strong>Cms Client(Cms客户端)</strong>，客户端接收消息队列的通知。</p><p>5、每个接收到页面发布消息的 <code>Cms Client</code> 从 <code>GridFS</code> 获取 <code>Html</code> 页面文件，并将 <code>Html</code> 文件存储在本地服务器。<code>CmsClient</code> 根据页面发布消息的内容请求 <code>GridFS</code> 获取页面文件，存储在本地服务器 。</p><h1 id="二、初识RabbitMQ"><a href="#二、初识RabbitMQ" class="headerlink" title="二、初识RabbitMQ"></a>二、初识RabbitMQ</h1><p>要实现上边页面发布的功能，有一个重要的环节就是由消息队列将页面发布的消息通知给各各服务器。</p><p>本节的教学目标是对MQ的研究：</p><p>1、理解MQ的应用场景</p><p>2、理解MQ常用的工作模式</p><h2 id="1-简单的介绍"><a href="#1-简单的介绍" class="headerlink" title="1.简单的介绍"></a>1.简单的介绍</h2><h3 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h3><p>MQ全称为 Message Queue，即消息队列， <code>RabbitMQ</code>是由 <code>erlang</code> 语言开发，基于<strong>AMQP（Advanced Message Queue 高级消息队列协议）</strong>协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p><p>RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p><p>开发中消息队列通常有如下应用场景：</p><ul><li><p><strong>任务异步处理</strong></p><p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p></li><li><p><strong>应用程序解耦合</strong></p><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p></li><li><p><strong>市场上还有哪些消息队列？</strong><br>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。</p></li><li><p><strong>为什么使用RabbitMQ呢？</strong></p><p>1、使得简单，功能强大。<br>2、基于 <code>AMQP</code> 协议。<br>3、社区活跃，文档完善。<br>4、高并发性能好，这主要得益于 <code>Erlang</code> 语言。<br>5、Spring Boot 默认已集成 <code>RabbitMQ</code></p></li></ul><h3 id="其它相关知识"><a href="#其它相关知识" class="headerlink" title="其它相关知识"></a>其它相关知识</h3><p>AMQP是什么 ？</p><p><code>AMQP</code> 是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决 <code>MQ</code> 市场上协议不统一的问题。<code>RabbitMQ</code> 就是遵循 <code>AMQP</code> 标准协议开发的MQ服务。</p><p>JMS是什么 ？</p><p><code>JMS</code>是 <code>java</code> 提供的一套消息服务API标准，其目的是为所有的 <code>java</code> 应用程序提供统一的消息通信的标准，类似 <code>java</code> 的 <code>jdbc</code>，只要遵循 <code>jms</code> 标准的应用程序之间都可以进行消息通信。它和 <code>AMQP</code> 有什么 不同，<code>jms</code> 是java语言专属的消息服务标准，它是在api层定义标准，并且只能用于 <code>java</code> 应用；而 <code>AMQP</code> 是在协议层定义的标准，是跨语言的 。</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><h3 id="RabbitMQ-的工作原理"><a href="#RabbitMQ-的工作原理" class="headerlink" title="RabbitMQ 的工作原理"></a>RabbitMQ 的工作原理</h3><p>下图是 <code>RabbitMQ</code> 的基本结构</p><p><a href="https://qnoss.codeyee.com/20200704_5/image2" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>组成部分说明如下：</p><ul><li><strong>Broker</strong>：消息队列服务进程，此进程包括两个部分：<code>Exchange</code> 和 <code>Queue</code>。</li><li><strong>Exchange</strong>：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过滤。</li><li><strong>Queue</strong>：消息队列，储存消息的队列，消息到达队列并转发给指定的消费方。</li><li><strong>Producer</strong>：消息生产者，即生产方客户端，生产方客户端将消息发送到 <code>MQ</code> 。</li><li><strong>Consumer</strong>：消息消费者，即消费方客户端，接收 <code>MQ</code> 转发的消息。</li></ul><p>消息 <strong>发布</strong> 与 <strong>接收</strong> 流程：</p><p>—–发送消息—–</p><p>1、生产者和 <code>Broker</code> 建立TCP连接。</p><p>2、生产者和 <code>Broker</code> 建立通道。</p><p>3、生产者通过通道消息发送给 <code>Broker</code> ，由 <code>Exchange</code> 将消息进行转发。</p><p>4、<code>Exchange</code>将消息转发到指定的 <code>Queue</code>（队列）</p><p>—-接收消息—–</p><p>1、消费者和 <code>Broker</code> 建立TCP连接</p><p>2、消费者和 <code>Broker</code> 建立通道</p><p>3、消费者监听指定的 <code>Queue</code>（队列）</p><p>4、当有消息到达 <code>Queue</code> 时 <code>Broker</code> 默认将消息推送给消费者。</p><p>5、消费者接收到消息。</p><h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><h4 id="1、下载并安装"><a href="#1、下载并安装" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h4><p>RabbitMQ由 <code>Erlang</code> 语言开发，<code>Erlang</code> 语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（OpenTelecom Platform）作为 <code>Erlang</code> 语言的一部分，包含了很多基于 <code>Erlang</code> 开发的中间件及工具库，安装 <code>RabbitMQ</code> 需要安装 Erlang/OTP，并保持版本匹配，如下图：</p><p><a href="https://qnoss.codeyee.com/20200704_5/image3" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>本项目使用 <code>Erlang/OTP 20.3</code> 版本和 <code>RabbitMQ3.7.3</code> 版本。</p><p>官网 <code>RabbitMQ</code> 的下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p><h5 id="下载erlang"><a href="#下载erlang" class="headerlink" title="下载erlang"></a>下载erlang</h5><p>地址如下：<a href="http://erlang.org/download/otp_win64_20.3.exe" target="_blank" rel="noopener">http://erlang.org/download/otp_win64_20.3.exe</a></p><p>erlang安装完成需要配置erlang环境变量： ERLANG_HOME=D:\Program Files\erl9.3 在path中添<br>加%ERLANG_HOME%\bin;</p><h5 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h5><p>下载地址 <a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3</a></p><p>这里要注意 rabbitMQ的安装路径</p><h4 id="2、启动"><a href="#2、启动" class="headerlink" title="2、启动"></a>2、启动</h4><p>安装成功后会自动创建RabbitMQ服务并且启动。</p><ol><li><p>在系统path变量中添加 <code>rabbitMQ</code> 的环境变量：<code>D:\[rabbitMQ的安装路径]\sbin;</code></p></li><li><p>添加环境变量后，按下 <code>Win + X</code> 以管理员身份运行powershell 或者 cmd</p></li><li><p>运行 <code>rabbitmq-plugins.bat enable rabbitmq_management</code> 命令</p><p><a href="https://qnoss.codeyee.com/20200704_5/image4" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image4.png" srcset="/img/loading.gif" alt="安装过程"></a></p><p><a href="https://qnoss.codeyee.com/20200704_5/image4" target="_blank" rel="noopener">安装过程</a></p><p>​</p></li><li><p>运行 <code>rabbitmq-service.bat stop</code> 和 <code>rabbitmq-service.bat start</code> 重启 rabbitMQ</p></li><li><p>启动成功，访问 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672</a> 登录Rabbit MQ，初始账号密码为 guest/guest</p></li></ol><h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、安装 <code>erlang</code> 和 <code>rabbitMQ</code> 以管理员身份运行。</p><p>2、当卸载重新安装时会出现 <code>RabbitMQ</code> 服务注册失败，此时需要进入注册表清理 <code>erlang</code><br>搜索RabbitMQ、ErlSrv，将对应的项全部删除。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p><a href="https://qnoss.codeyee.com/20200704_5/image5" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image5.png" srcset="/img/loading.gif" alt="工作模式"></a></p><p>以下过程我们参考官方教程(<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a>)测试hello world:</p><h4 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a>1、搭建环境</h4><h5 id="java-client"><a href="#java-client" class="headerlink" title="java client"></a>java client</h5><p>生产者和消费者都属于客户端，rabbitMQ的java客户端如下：</p><p><a href="https://qnoss.codeyee.com/20200704_5/image6" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image6.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们先用 <code>rabbitMQ</code> 官方提供的 <code>java client</code> 测试，目的是对 <code>RabbitMQ</code> 的交互过程有个清晰的认识。</p><p>参考 ：<a href="https://github.com/rabbitmq/rabbitmq-java-client/" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-java-client/</a></p><h5 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h5><p>创建生产者工程和消费者工程，分别加入<code>RabbitMQ java client</code>的依赖。</p><p>test-rabbitmq-producer：生产者工程</p><p>test-rabbitmq-consumer：消费者工程</p><p><strong>依赖配置如下：</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!--此版本与spring boot 1.5.9版本匹配--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p><a href="https://qnoss.codeyee.com/20200704_5/image7" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image7.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="2、生产者"><a href="#2、生产者" class="headerlink" title="2、生产者"></a>2、生产者</h4><p>在生产者工程下的单元测试内创建测试类如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer01</span> </span>&#123;    <span class="hljs-comment">//队列名称</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">"helloworld2"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        Channel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();            factory.setHost(<span class="hljs-string">"localhost"</span>);            factory.setPort(<span class="hljs-number">5672</span>);            factory.setUsername(<span class="hljs-string">"guest"</span>);            factory.setPassword(<span class="hljs-string">"guest"</span>);            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>            factory.setVirtualHost(<span class="hljs-string">"/"</span>);            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>            connection = factory.newConnection();            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>            channel = connection.createChannel();            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span><span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * param1:队列名称</span><span class="hljs-comment">             * param2:是否持久化</span><span class="hljs-comment">             * param3:队列是否独占此连接</span><span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span><span class="hljs-comment">             * param5:队列参数</span><span class="hljs-comment">             */</span>            channel.queueDeclare(QUEUE,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            String message = <span class="hljs-string">"hello world 小明"</span> + System.currentTimeMillis();            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 消息发布方法</span><span class="hljs-comment">             消息发布方法</span><span class="hljs-comment">             * param1：Exchange的名称，如果没有指定，则使用Default Exchange</span><span class="hljs-comment">             * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列</span><span class="hljs-comment">             * param3:消息包含的属性</span><span class="hljs-comment">             * param4：消息体</span><span class="hljs-comment">             * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定</span><span class="hljs-comment">             * 默认的交换机，routingKey等于队列名称</span><span class="hljs-comment">             */</span>            channel.basicPublish(<span class="hljs-string">""</span>,QUEUE,<span class="hljs-keyword">null</span>,message.getBytes());            System.out.println(<span class="hljs-string">"Send Message is: ' "</span> + message + <span class="hljs-string">" '"</span>);        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;            ex.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//先关闭通道，再关闭连接</span>            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                channel.close();            &#125;            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                connection.close();            &#125;        &#125;    &#125;&#125;</code></pre></div><p>运行生产者后，<code>RabbitMQ</code> 后台会接收到一条等待消费的消息</p><p><a href="https://qnoss.codeyee.com/20200704_5/image8" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image8.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="3、消费者"><a href="#3、消费者" class="headerlink" title="3、消费者"></a>3、消费者</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer01</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">"helloworld2"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"localhost"</span>);        factory.setPort(<span class="hljs-number">5672</span>);        factory.setUsername(<span class="hljs-string">"guest"</span>);        factory.setPassword(<span class="hljs-string">"guest"</span>);        <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>        factory.setVirtualHost(<span class="hljs-string">"/"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//声明队列</span>        <span class="hljs-comment">/** 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete,</span><span class="hljs-comment">         Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">         * 参数明细：</span><span class="hljs-comment">         * 1、queue 队列名称</span><span class="hljs-comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span><span class="hljs-comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭，队列则自动删除,可用于临时队列的创建</span><span class="hljs-comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive共同为true，就可以实现临时队列</span><span class="hljs-comment">         * 5、argmuacnts，可以设置一个队列扩展参数，比如：可设置存活的时间</span><span class="hljs-comment">         */</span>        channel.queueDeclare(QUEUE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//定义消费方法</span>        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 消费者接收消息调用此方法</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> consumerTag 消费者的标签，在channel.basicConsume()去指定</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志</span><span class="hljs-comment">            (收到消息失败后是否需要重新发送)</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> properties 消息属性</span><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> body 消息内容</span><span class="hljs-comment">             * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">            1、发送端操作流程</span><span class="hljs-comment">            1）创建连接</span><span class="hljs-comment">            2）创建通道</span><span class="hljs-comment">            3）声明队列</span><span class="hljs-comment">            4）发送消息</span><span class="hljs-comment">            2、接收端</span><span class="hljs-comment">            1）创建连接</span><span class="hljs-comment">            2）创建通道</span><span class="hljs-comment">            3）声明队列</span><span class="hljs-comment">            4）监听队列</span><span class="hljs-comment">            5）接收消息</span><span class="hljs-comment">             */</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">//交换机</span>                String exchange = envelope.getExchange();                <span class="hljs-comment">//路由key</span>                String routingKey = envelope.getRoutingKey();                <span class="hljs-comment">//消息id</span>                <span class="hljs-keyword">long</span> deliveryTag = envelope.getDeliveryTag();                <span class="hljs-comment">//消息内容</span>                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);                System.out.println(<span class="hljs-string">"receive message.."</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 监听队列String queue, boolean autoAck,Consumer callback</span><span class="hljs-comment">         * 参数明细</span><span class="hljs-comment">         * 1、queue 队列名称</span><span class="hljs-comment">         * 2、autoAck 是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复</span><span class="hljs-comment">         * 3、callback 消费消息的方法，消费者接收到消息后调用此方法</span><span class="hljs-comment">         */</span>        channel.basicConsume(QUEUE, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre></div><h4 id="4、消息接收测试"><a href="#4、消息接收测试" class="headerlink" title="4、消息接收测试"></a>4、消息接收测试</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image9" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image9.gif" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-工作模式"><a href="#3-工作模式" class="headerlink" title="3. 工作模式"></a>3. 工作模式</h2><p><code>RabbitMQ</code> 有以下几种工作模式 ：</p><p>1、Work queues，工作队列模式</p><p>2、Publish/Subscribe，发布订阅模式</p><p>3、Routing，路由模式</p><p>4、Topics，通配符模式</p><p>5、Header，header模式</p><p>6、RPC ，rpc模式</p><h3 id="Work-queues-模式"><a href="#Work-queues-模式" class="headerlink" title="Work queues 模式"></a>Work queues 模式</h3><p><code>work queues</code> 工作模式，与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息。</p><p>应用场景：对于 <strong>任务过重</strong> 或 <strong>任务较多</strong> 情况使用工作队列可以提高任务处理的速度 。</p><p><strong>测试：</strong></p><p>1、使用入门程序，启动多个消费者。</p><p>2、生产者发送多个消息。</p><p><strong>测试结果：</strong></p><p><a href="https://qnoss.codeyee.com/20200704_5/image10" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image10.gif" srcset="/img/loading.gif" alt="img"></a></p><p>1、一条消息只会被一个消费者接收；</p><p>2、<code>rabbit</code> 采用 <strong>轮询</strong> 的方式将消息是平均发送给消费者的；</p><p>3、消费者在处理完某条消息后，才会收到下一条消息。</p><h3 id="Publish-Subscribe-模式"><a href="#Publish-Subscribe-模式" class="headerlink" title="Publish/Subscribe 模式"></a>Publish/Subscribe 模式</h3><h4 id="1、发布订阅模式"><a href="#1、发布订阅模式" class="headerlink" title="1、发布订阅模式"></a>1、发布订阅模式</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image11" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image11.png" srcset="/img/loading.gif" alt="发布订阅模式"></a></p><p><a href="https://qnoss.codeyee.com/20200704_5/image11" target="_blank" rel="noopener"></a></p><p>1、每个消费者监听自己的队列。</p><p>2、生产者将消息发给 <code>broker</code>，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 。</p><h4 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h4><p>案例：</p><p>用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法 。</p><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p>声明 <code>Exchange_fanout_inform</code> 交换机。</p><p>声明两个队列并且绑定到此交换机，绑定时不需要指定 <code>routingkey</code></p><p>发送消息时不需要指定 <code>routingkey</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;<span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer02_publish</span> </span>&#123;    <span class="hljs-comment">//队列名称</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_FANOUT_INFORM = <span class="hljs-string">"exchange_fanout_inform"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        Channel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();            factory.setHost(<span class="hljs-string">"localhost"</span>);            factory.setPort(<span class="hljs-number">5672</span>);            factory.setUsername(<span class="hljs-string">"guest"</span>);            factory.setPassword(<span class="hljs-string">"guest"</span>);            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>            factory.setVirtualHost(<span class="hljs-string">"/"</span>);            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>            connection = factory.newConnection();            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>            channel = connection.createChannel();            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明交换机</span><span class="hljs-comment">             * 1、交换机名称</span><span class="hljs-comment">             * 2、交换机类型：fanout、topic、direct、headers</span><span class="hljs-comment">             */</span>            channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT);            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span><span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * param1:队列名称</span><span class="hljs-comment">             * param2:是否持久化</span><span class="hljs-comment">             * param3:队列是否独占此连接</span><span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span><span class="hljs-comment">             * param5:队列参数</span><span class="hljs-comment">             */</span>            channel.queueDeclare(QUEUE_INFORM_EMAIL,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            channel.queueDeclare(QUEUE_INFORM_SMS,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 将交换机和队列进行绑定</span><span class="hljs-comment">             */</span>            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>);            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>);            <span class="hljs-comment">//发布消息</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to user "</span> + i;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 消息发布方法</span><span class="hljs-comment">                 消息发布方法</span><span class="hljs-comment">                 * param1：Exchange的名称，如果没有指定，则使用Default Exchange</span><span class="hljs-comment">                 * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列</span><span class="hljs-comment">                 * param3:消息包含的属性</span><span class="hljs-comment">                 * param4：消息体</span><span class="hljs-comment">                 * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定</span><span class="hljs-comment">                 * 默认的交换机，routingKey等于队列名称</span><span class="hljs-comment">                 */</span>                channel.basicPublish(EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;            ex.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭通道和连接</span>            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                channel.close();            &#125;            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                connection.close();            &#125;        &#125;    &#125;&#125;</code></pre></div><h5 id="邮件消费者"><a href="#邮件消费者" class="headerlink" title="邮件消费者"></a>邮件消费者</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;<span class="hljs-keyword">import</span> com.rabbitmq.client.*;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer02_subscribe_email</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_FANOUT_INFORM = <span class="hljs-string">"exchange_fanout_inform"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"localhost"</span>);        factory.setPort(<span class="hljs-number">5672</span>);        factory.setUsername(<span class="hljs-string">"guest"</span>);        factory.setPassword(<span class="hljs-string">"guest"</span>);        <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>        factory.setVirtualHost(<span class="hljs-string">"/"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//声明队列</span>        <span class="hljs-comment">/** 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete,</span><span class="hljs-comment">         Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">         * 参数明细：</span><span class="hljs-comment">         * 1、queue 队列名称</span><span class="hljs-comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span><span class="hljs-comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭，队列则自动删除,可用于临时队列的创建</span><span class="hljs-comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive共同为true，就可以实现临时队列</span><span class="hljs-comment">         * 5、argmuacnts，可以设置一个队列扩展参数，比如：可设置存活的时间</span><span class="hljs-comment">         */</span>        channel.queueDeclare(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 声明交换机</span><span class="hljs-comment">         */</span>        channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM,BuiltinExchangeType.FANOUT);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 绑定交换机</span><span class="hljs-comment">         */</span>        channel.queueBind(QUEUE_INFORM_EMAIL, EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>);        <span class="hljs-comment">//定义消费方法</span>        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">//交换机</span>                String exchange = envelope.getExchange();                <span class="hljs-comment">//路由key</span>                String routingKey = envelope.getRoutingKey();                <span class="hljs-comment">//消息id</span>                <span class="hljs-keyword">long</span> deliveryTag = envelope.getDeliveryTag();                <span class="hljs-comment">//消息内容</span>                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);                System.out.println(<span class="hljs-string">"receive message.."</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 监听队列String queue, boolean autoAck,Consumer callback</span><span class="hljs-comment">         * 参数明细</span><span class="hljs-comment">         * 1、queue 队列名称</span><span class="hljs-comment">         * 2、autoAck 是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复</span><span class="hljs-comment">         * 3、callback 消费消息的方法，消费者接收到消息后调用此方法</span><span class="hljs-comment">         */</span>        channel.basicConsume(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre></div><h5 id="短信消费者"><a href="#短信消费者" class="headerlink" title="短信消费者"></a>短信消费者</h5><p>参考上边的邮件发送消费者代码，修改队列名称即可</p><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image12" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image12.gif" srcset="/img/loading.gif" alt="img"></a></p><h4 id="4、思考"><a href="#4、思考" class="headerlink" title="4、思考"></a>4、思考</h4><ol><li><p><strong>publish/subscribe与work queues有什么区别。</strong></p><p><strong>区别：</strong><br>1）<code>work queues</code> 不用定义交换机，而 <code>publish/subscribe</code> 需要定义交换机。</p><p>2）<code>publish/subscribe</code> 的生产方是面向交换机发送消息，<code>work queues</code> 的生产方是面向队列</p><p>发送消息(底层使用默认交换机)。</p><p>3）<code>publish/subscribe</code> 需要设置队列和交换机的绑定，<code>work queues</code> 不需要设置，实质上<code>work queues</code> 会将队列绑定到默认的交换机 。</p><p><strong>相同点：</strong></p><p>所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p></li><li><p><strong>实质工作用什么 publish/subscribe 还是 work queues</strong></p><p>建议使用 <code>publish/subscribe</code>，发布订阅模式比工作队列模式更强大，并且发布订阅模式可以指定自己专用的交换机。</p></li></ol><h3 id="Routing-模式"><a href="#Routing-模式" class="headerlink" title="Routing 模式"></a>Routing 模式</h3><h4 id="1、路由模式"><a href="#1、路由模式" class="headerlink" title="1、路由模式"></a>1、路由模式</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image13" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image13.png" srcset="/img/loading.gif" alt=" "></a></p><p>1、每个消费者监听自己的队列，并且设置 <code>routingkey</code>。</p><p>2、生产者将消息发给交换机，由交换机根据 <code>routingkey</code> 来转发消息到指定的队列。</p><h4 id="2、代码-1"><a href="#2、代码-1" class="headerlink" title="2、代码"></a>2、代码</h4><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><p>路由模式的生产者代码基于 <strong>发布订阅模式</strong> 的代码，在这基础上增加以下几点</p><ul><li>增加 <code>routing key</code> 以及 修改交换机的模式</li><li>为每个队列绑定 <code>routing key</code></li><li>在下面的代码当中，我为 <code>CMS</code> 和 <code>EMAIL</code> 的队列分别绑定了一个单独的 <code>routing key</code>，再绑定了一个 共有的名为 <code>ALL</code> 的key，以便测试 <code>routing</code> 模式的特性</li></ul><p>具体代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;<span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer03_routing</span> </span>&#123;    <span class="hljs-comment">//队列名称</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_ROUTING_INFORM = <span class="hljs-string">"exchange_routing_inform"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_EMAIL = <span class="hljs-string">"inform_email"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_SMS = <span class="hljs-string">"inform_sms"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        Channel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();            factory.setHost(<span class="hljs-string">"localhost"</span>);            factory.setPort(<span class="hljs-number">5672</span>);            factory.setUsername(<span class="hljs-string">"guest"</span>);            factory.setPassword(<span class="hljs-string">"guest"</span>);            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>            factory.setVirtualHost(<span class="hljs-string">"/"</span>);            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>            connection = factory.newConnection();            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>            channel = connection.createChannel();            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明交换机</span><span class="hljs-comment">             * 1、交换机名称</span><span class="hljs-comment">             * 2、交换机类型：fanout、topic、direct、headers</span><span class="hljs-comment">             */</span>            channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT);            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span><span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * param1:队列名称</span><span class="hljs-comment">             * param2:是否持久化</span><span class="hljs-comment">             * param3:队列是否独占此连接</span><span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span><span class="hljs-comment">             * param5:队列参数</span><span class="hljs-comment">             */</span>            channel.queueDeclare(QUEUE_INFORM_EMAIL,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            channel.queueDeclare(QUEUE_INFORM_SMS,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 将交换机和队列进行绑定</span><span class="hljs-comment">             */</span>            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_SMS);            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_EMAIL);            <span class="hljs-comment">//两个队列都绑定一个ALL的KEY</span>            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>);            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>);            <span class="hljs-comment">//发布消息到EMAIL</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to email "</span> + i;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 消息发布方法</span><span class="hljs-comment">                 消息发布方法</span><span class="hljs-comment">                 * param1：Exchange的名称，如果没有指定，则使用Default Exchange</span><span class="hljs-comment">                 * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列</span><span class="hljs-comment">                 * param3:消息包含的属性</span><span class="hljs-comment">                 * param4：消息体</span><span class="hljs-comment">                 * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定</span><span class="hljs-comment">                 * 默认的交换机，routingKey等于队列名称</span><span class="hljs-comment">                 */</span>                channel.basicPublish(EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_EMAIL,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;            <span class="hljs-comment">//发布消息SMS</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to sms "</span> + i;                channel.basicPublish(EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_SMS,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;            <span class="hljs-comment">//发布消息ALL</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to all user "</span> + i;                channel.basicPublish(EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;            ex.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭通道和连接</span>            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                channel.close();            &#125;            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                connection.close();            &#125;        &#125;    &#125;&#125;</code></pre></div><p>单独运行生产者后，我们可以在 rabbitMQ 后台的 <code>EXCHANGES</code> 栏中看到，建立了4个队列对应 <code>routing key</code> 的通讯连接</p><p><a href="https://qnoss.codeyee.com/20200704_5/image14" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image14.png" srcset="/img/loading.gif" alt="img"></a></p><h5 id="短信消费者-1"><a href="#短信消费者-1" class="headerlink" title="短信消费者"></a>短信消费者</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;<span class="hljs-keyword">import</span> com.rabbitmq.client.*;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer03_routing_sms</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_ROUTING_INFORM = <span class="hljs-string">"exchange_routing_inform"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_SMS = <span class="hljs-string">"inform_sms"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        factory.setHost(<span class="hljs-string">"localhost"</span>);        factory.setPort(<span class="hljs-number">5672</span>);        factory.setUsername(<span class="hljs-string">"guest"</span>);        factory.setPassword(<span class="hljs-string">"guest"</span>);        <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>        factory.setVirtualHost(<span class="hljs-string">"/"</span>);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        <span class="hljs-comment">//声明队列</span>        <span class="hljs-comment">/** 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete,</span><span class="hljs-comment">         Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">         * 参数明细：</span><span class="hljs-comment">         * 1、queue 队列名称</span><span class="hljs-comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span><span class="hljs-comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭，队列则自动删除,可用于临时队列的创建</span><span class="hljs-comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive共同为true，就可以实现临时队列</span><span class="hljs-comment">         * 5、argmuacnts，可以设置一个队列扩展参数，比如：可设置存活的时间</span><span class="hljs-comment">         */</span>        channel.queueDeclare(QUEUE_INFORM_SMS, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 声明交换机</span><span class="hljs-comment">         */</span>        channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM,BuiltinExchangeType.DIRECT);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 绑定交换机</span><span class="hljs-comment">         */</span>        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_SMS);        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>); <span class="hljs-comment">//绑定一个公有的key,用于接收公共的key</span>        <span class="hljs-comment">//定义消费方法</span>        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">//交换机</span>                String exchange = envelope.getExchange();                <span class="hljs-comment">//路由key</span>                String routingKey = envelope.getRoutingKey();                <span class="hljs-comment">//消息id</span>                <span class="hljs-keyword">long</span> deliveryTag = envelope.getDeliveryTag();                <span class="hljs-comment">//消息内容</span>                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);                System.out.println(<span class="hljs-string">"receive message.."</span> + msg);            &#125;        &#125;;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 监听队列String queue, boolean autoAck,Consumer callback</span><span class="hljs-comment">         * 参数明细</span><span class="hljs-comment">         * 1、queue 队列名称</span><span class="hljs-comment">         * 2、autoAck 是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复</span><span class="hljs-comment">         * 3、callback 消费消息的方法，消费者接收到消息后调用此方法</span><span class="hljs-comment">         */</span>        channel.basicConsume(QUEUE_INFORM_SMS, <span class="hljs-keyword">true</span>, defaultConsumer);    &#125;&#125;</code></pre></div><p>这里要注意的一点是，在队列绑定交换机的代码中，除了绑定短信的key 我还单独绑定了一个 ALL 的key，用于接收全局的消息，代码块如下</p><div class="hljs"><pre><code class="hljs java">channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>); <span class="hljs-comment">//绑定一个公有的key,用于接收公共的key</span></code></pre></div><h5 id="邮件消费者-1"><a href="#邮件消费者-1" class="headerlink" title="邮件消费者"></a>邮件消费者</h5><p>具体代码参考短信消费者的代码</p><h4 id="3、测试-1"><a href="#3、测试-1" class="headerlink" title="3、测试"></a>3、测试</h4><p>预期结果：生产者分别发送5条消息到 <strong>SMS消费者</strong> 和 <strong>EMAIL 消费者</strong>，以及发送5条消息给<strong>全部消费者</strong>。</p><p><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image15.gif" srcset="/img/loading.gif" alt="img"></p><h4 id="4、思考-1"><a href="#4、思考-1" class="headerlink" title="4、思考"></a>4、思考</h4><p>1、Routing模式 和 Publish/subscibe有啥区别？</p><p>Routing模式要求队列在绑定交换机时要指定<code>routingkey</code>，消息会转发到符合 <code>routingkey</code> 的队列。</p><h3 id="Topics-模式"><a href="#Topics-模式" class="headerlink" title="Topics 模式"></a>Topics 模式</h3><h4 id="4-1、通配符模式（Topics）"><a href="#4-1、通配符模式（Topics）" class="headerlink" title="4-1、通配符模式（Topics）"></a>4-1、通配符模式（Topics）</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image16" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image16.png" srcset="/img/loading.gif" alt="img"></a></p><p>通配符路由模式：</p><p>1、每个消费者监听自己的队列，并且设置带 <strong>通配符</strong> 的 <code>routingkey</code>。</p><p>2、生产者将消息发给 <code>broker</code>，由交换机根据 <code>routingkey</code> 来转发消息到指定的队列。</p><h4 id="4-2、代码"><a href="#4-2、代码" class="headerlink" title="4-2、代码"></a>4-2、代码</h4><p>根据用户的通知设置去通知用户，设置接收 <code>Email</code> 的用户只接收 <code>Email</code>，设置接收 <code>sms</code> 的用户只接收 <code>sms</code> ，设置两种通知类型都接收的则两种通知都有效</p><h5 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h5><p>声明交换机，指定topic类型：</p><p>核心代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 声明交换机</span><span class="hljs-comment">* param1：交换机名称</span><span class="hljs-comment">* param2:交换机类型 四种交换机类型：direct、fanout、topic、headers</span><span class="hljs-comment">*/</span>channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);<span class="hljs-comment">//Email通知</span>channel.basicPublish(EXCHANGE_TOPICS_INFORM, <span class="hljs-string">"inform.email"</span>, <span class="hljs-keyword">null</span>, message.getBytes());<span class="hljs-comment">//sms通知</span>channel.basicPublish(EXCHANGE_TOPICS_INFORM, <span class="hljs-string">"inform.sms"</span>, <span class="hljs-keyword">null</span>, message.getBytes());<span class="hljs-comment">//两种都通知</span>channel.basicPublish(EXCHANGE_TOPICS_INFORM, <span class="hljs-string">"inform.sms.email"</span>, <span class="hljs-keyword">null</span>, message.getBytes());</code></pre></div><p>全部代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;<span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer04_topcis</span> </span>&#123;    <span class="hljs-comment">//队列名称</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_TOPICS_INFORM = <span class="hljs-string">"exchange_topics_inform"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_EMAIL = <span class="hljs-string">"inform.#.email.#"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_SMS = <span class="hljs-string">"inform.#.sms.#"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        Connection connection = <span class="hljs-keyword">null</span>;        Channel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();            factory.setHost(<span class="hljs-string">"localhost"</span>);            factory.setPort(<span class="hljs-number">5672</span>);            factory.setUsername(<span class="hljs-string">"guest"</span>);            factory.setPassword(<span class="hljs-string">"guest"</span>);            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>            factory.setVirtualHost(<span class="hljs-string">"/"</span>);            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>            connection = factory.newConnection();            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>            channel = connection.createChannel();            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明交换机</span><span class="hljs-comment">             * 1、交换机名称</span><span class="hljs-comment">             * 2、交换机类型：fanout、topic、direct、headers</span><span class="hljs-comment">             */</span>            channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span><span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span><span class="hljs-comment">             *</span><span class="hljs-comment">             * param1:队列名称</span><span class="hljs-comment">             * param2:是否持久化</span><span class="hljs-comment">             * param3:队列是否独占此连接</span><span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span><span class="hljs-comment">             * param5:队列参数</span><span class="hljs-comment">             */</span>            channel.queueDeclare(QUEUE_INFORM_EMAIL,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            channel.queueDeclare(QUEUE_INFORM_SMS,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 将交换机和队列进行绑定</span><span class="hljs-comment">             */</span>            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_TOPICS_INFORM,ROUTINGKEY_INFORM_SMS);            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_TOPICS_INFORM,ROUTINGKEY_INFORM_EMAIL);            <span class="hljs-comment">//发布消息到EMAIL</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to email "</span> + i;                channel.basicPublish(EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.email"</span>,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;            <span class="hljs-comment">//发布消息SMS</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to sms "</span> + i;                channel.basicPublish(EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.sms"</span>,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;            <span class="hljs-comment">//发布消息到cms和email</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;                String message = <span class="hljs-string">"inform to sms and email "</span> + i;                channel.basicPublish(EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.sms.email"</span>,<span class="hljs-keyword">null</span>,message.getBytes());                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);            &#125;        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;            ex.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭通道和连接</span>            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                channel.close();            &#125;            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;                connection.close();            &#125;        &#125;    &#125;&#125;</code></pre></div><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p>队列绑定交换机指定通配符 <code>routing key</code></p><p>统配符规则：中间以“.”分隔。符号#可以匹配多个词，符号*可以匹配一个词语。</p><p>核心代码如下，具体代码参考 <code>routing</code> 模式的消费者</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//声明队列</span>channel.queueDeclare(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);channel.queueDeclare(QUEUE_INFORM_SMS, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//声明交换机</span>channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);<span class="hljs-comment">//绑定email通知队列</span>channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.#.email.#"</span>);<span class="hljs-comment">//绑定sms通知队列</span>channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.#.sms.#"</span>);</code></pre></div><h4 id="4-3、测试"><a href="#4-3、测试" class="headerlink" title="4-3、测试"></a>4-3、测试</h4><p>在生产者端分别向 inform.email、inform.sms、inform.sms.email 这三个通配符发送了消息</p><p><a href="https://qnoss.codeyee.com/20200704_5/image17" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image17.png" srcset="/img/loading.gif" alt="rabbitMQ上的交换状态"></a></p><p>预期结果：ems和email消费者分别接收到 <code>sms</code> 和 <code>email</code> 信息和 <code>sms and email</code> 信息</p><p><strong>执行生产者</strong></p><p><a href="https://qnoss.codeyee.com/20200704_5/image18" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>查看执行消费者端</strong></p><p>sms消费者</p><p><a href="https://qnoss.codeyee.com/20200704_5/image19" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image19.png" srcset="/img/loading.gif" alt="img"></a></p><p>email消费者</p><p><a href="https://qnoss.codeyee.com/20200704_5/image20" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image20.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="4-4、思考"><a href="#4-4、思考" class="headerlink" title="4-4、思考"></a>4-4、思考</h4><p>1、本案例的需求使用 <code>routing</code> 模式是否能实现？</p><p>使用 <code>routing</code> 模式也可以实现本案例，共设置三个 <code>routing key</code> ，分别是 email、sms、all 这三个，email 队列绑定 <code>email</code> 和 <code>all</code> ，sms 队列绑定 sms 和 all，这样就可以实现上述的案例，但是实现过程比 <code>topics</code> 复杂。</p><p>Topics 模式更强大，它可以实现 <code>Routing</code> 、<code>publish/subscirbe</code> 模式的功能。</p><h3 id="Header-模式"><a href="#Header-模式" class="headerlink" title="Header 模式"></a>Header 模式</h3><p><code>header</code> 模式与 <code>routing</code> 不同的地方在于，<code>header</code> 模式取消 <code>routing key</code>，使用 <code>header</code>中的 <code>key/value</code>（键值对）匹配<br>队列。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><p>根据用的通知设置去通知用户，设置接收 <code>Email</code> 的用户只接收<code>Email</code>，设置接收 <code>sms</code> 的用户只接收 <code>sms</code>，设置两种通知类型都接收的则两种通知都有效。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>生产者</p><p>队列与交换机绑定的代码与之前不同，核心代码如下：</p><div class="hljs"><pre><code class="hljs java">Map&lt;String, Object&gt; headers_email = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();headers_email.put(<span class="hljs-string">"inform_type"</span>, <span class="hljs-string">"email"</span>);Map&lt;String, Object&gt; headers_sms = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();headers_sms.put(<span class="hljs-string">"inform_type"</span>, <span class="hljs-string">"sms"</span>);channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,<span class="hljs-string">""</span>,headers_email);channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_HEADERS_INFORM,<span class="hljs-string">""</span>,headers_sms);</code></pre></div><p>发布消息核心代码:</p><div class="hljs"><pre><code class="hljs java">String message = <span class="hljs-string">"email inform to user"</span>+i;Map&lt;String,Object&gt; headers = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();headers.put(<span class="hljs-string">"inform_type"</span>, <span class="hljs-string">"email"</span>);<span class="hljs-comment">//匹配email通知消费者绑定的header</span><span class="hljs-comment">//headers.put("inform_type", "sms");//匹配sms通知消费者绑定的header</span>AMQP.BasicProperties.Builder properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder();properties.headers(headers);<span class="hljs-comment">//Email通知</span>channel.basicPublish(EXCHANGE_HEADERS_INFORM, <span class="hljs-string">""</span>, properties.build(), message.getBytes());</code></pre></div><h4 id="邮消费者"><a href="#邮消费者" class="headerlink" title="邮消费者"></a>邮消费者</h4><p>email 消费者核心代码</p><div class="hljs"><pre><code class="hljs java">channel.exchangeDeclare(EXCHANGE_HEADERS_INFORM, BuiltinExchangeType.HEADERS);Map&lt;String, Object&gt; headers_email = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();headers_email.put(<span class="hljs-string">"inform_email"</span>, <span class="hljs-string">"email"</span>);<span class="hljs-comment">//交换机和队列绑定</span>channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,<span class="hljs-string">""</span>,headers_email);<span class="hljs-comment">//指定消费队列</span>channel.basicConsume(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, consumer);</code></pre></div><p>测试</p><p><a href="https://qnoss.codeyee.com/20200704_5/image21" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h3><p><a href="https://qnoss.codeyee.com/20200704_5/image22" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>RPC即客户端远程调用服务端的方法 ，使用 <code>MQ</code> 可以实现 <code>RPC</code> 的异步调用，基于 <code>Direct</code> 交换机实现，流程如下：</p><p>1、客户端即是生产者就是消费者，向 <code>RPC</code> 请求队列发送 <code>RPC</code> 调用消息，同时监听 <code>RPC</code> 响应队列。</p><p>2、服务端监听 <code>RPC</code> 请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果</p><p>3、服务端将 <code>RPC</code> 方法 的结果发送到 <code>RPC</code> 响应队列</p><p>4、客户端（<strong>RPC调用方</strong>）监听<code>RPC</code>响应队列，接收到 <code>RPC</code> 调用结果。</p><h2 id="4-Spring-Boot整合RibbitMQ"><a href="#4-Spring-Boot整合RibbitMQ" class="headerlink" title="4. Spring Boot整合RibbitMQ"></a>4. Spring Boot整合RibbitMQ</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>我们选择基于Spring-Rabbit去操作<code>RabbitMQ</code></p><p>源代码地址：<a href="https://github.com/spring-projects/spring-amqp" target="_blank" rel="noopener">https://github.com/spring-projects/spring-amqp</a></p><p>在我们之前创建得生产者模块中进行构建，添加如下依赖，注释掉之前原生的 <code>rabbitmq</code> 依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!--原生rabbitMQ--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;dependency&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;version&gt;4.0.3&lt;/version&gt;&amp;lt;!&amp;ndash;此版本与spring boot 1.5.9版本匹配&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;/dependency&gt;--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!--Springboot整合rabbitMQ启动器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1、配置application.yml</p><p>配置连接 <code>rabbitmq</code> 的参数</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">44000</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">test-rabbitmq-producer</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>    <span class="hljs-attr">virtualHost:</span> <span class="hljs-string">/</span></code></pre></div><p>创建 Springboot启动程序</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.rabbitmq;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRabbitmqApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(TestRabbitmqApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>构建 <code>RabbitmqConfig</code> ，用于配置交换机以及绑定队列</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.rabbitmq.config;<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_TOPICS_INFORM = <span class="hljs-string">"exchange_topics_inform"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换机配置</span><span class="hljs-comment">     * ExchangeBuilder提供了fanout、direct、topic、header交换机类型的配置</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EXCHANGE_TOPICS_INFORM)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EXCHANGE_TOPICS_INFORM</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//DURABLE(true) 持久化，消息队列重启后交换机仍然存在</span>        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 声明队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(QUEUE_INFORM_SMS)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_INFORM_SMS</span><span class="hljs-params">()</span></span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(QUEUE_INFORM_SMS);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-meta">@Bean</span>(QUEUE_INFORM_EMAIL)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_INFORM_EMAIL</span><span class="hljs-params">()</span></span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(QUEUE_INFORM_EMAIL);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定队列到交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 指定队列</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 指定交换机</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_INFORM_SMS</span><span class="hljs-params">(@Qualifier(QUEUE_INFORM_SMS)</span> Queue queue,</span><span class="hljs-function">                                            @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange)</span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">"inform.#.sms.#"</span>).noargs();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_INFORM_EMAIL</span><span class="hljs-params">(@Qualifier(QUEUE_INFORM_EMAIL)</span> Queue queue,</span><span class="hljs-function">                                            @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange)</span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">"inform.#.email.#"</span>).noargs();    &#125;&#125;</code></pre></div><p>运行测试，成功生成5条消息到rabbitmq</p><p><a href="https://qnoss.codeyee.com/20200704_5/image23" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image23.png" srcset="/img/loading.gif" alt="img"></a></p><blockquote><p>运行生产端前删除原有的交换机</p></blockquote><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>准备工作</p><ol><li>配置 <strong>4.1</strong> 给出的依赖包</li><li>复制 生产者端的 <code>RabbitmqConfig.java</code></li><li>创建消费端 <code>Springboot</code> 启动程序</li></ol><p>目录结构如下</p><p><a href="https://qnoss.codeyee.com/20200704_5/image24" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image24.png" srcset="/img/loading.gif" alt="消费端目录结构"></a></p><p>配置 <code>ReceiveHandler.java</code>，监听 rabbitMQ 的消息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.rabbitmq.mq;<span class="hljs-keyword">import</span> com.xuecheng.test.rabbitmq.config.RabbitmqConfig;<span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.amqp.RabbitProperties;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveHandler</span> </span>&#123;    <span class="hljs-comment">//监听email队列</span>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive_email</span><span class="hljs-params">(String msg, Message message, Channel channel)</span></span>&#123;        System.out.println(<span class="hljs-string">"receive: "</span>+msg);    &#125;    <span class="hljs-comment">//监听sms队列</span>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitmqConfig.QUEUE_INFORM_SMS&#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive_sms</span><span class="hljs-params">(String msg, Message message,Channel channel)</span></span>&#123;        System.out.println(<span class="hljs-string">"receive: "</span>+msg);    &#125;&#125;</code></pre></div><p>启动消费者测试，可以看到刚才我们运行生产者所生产的消息，如下图</p><p><a href="https://qnoss.codeyee.com/20200704_5/image25" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image25.png" srcset="/img/loading.gif" alt="消费者端接收到消息"></a></p><p><a href="https://qnoss.codeyee.com/20200704_5/image25" target="_blank" rel="noopener"></a></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>SpringBoot整合RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day04：页面静态化</title>
    <link href="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/"/>
    <url>/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day04</code> 的内容</p><ul><li>页面静态化的基本概念</li><li><code>Freemarker</code> 框架基础入门</li><li>使用 <code>MongoDB</code> 提供的 <code>GridFS</code> 来实现页面数据的分布式储存</li><li>使用 <code>freemarker</code> 框架实现页面静态化以及发布</li></ul><h1 id="一、页面静态化需求"><a href="#一、页面静态化需求" class="headerlink" title="一、页面静态化需求"></a>一、页面静态化需求</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p><strong>为什么要进行页面管理？</strong></p><p>本项目的 <code>cms</code> 系统的功能就是根据运营的需要，对门户等子系统的部分页面进行管理，从而实现快速的根据用户需求修改页面的内容并上线需求。</p></li><li><p><strong>如何修改页面的内容？</strong></p><p>在开发中修改页面的内容是需要人工编写 <code>html</code> 以及 <code>js</code> 文件， <code>cms</code> 系统是通过程序自动化的对页面的内容进行修改，通过页面静态化技术生成 <code>html</code> 页面。</p></li><li><p><strong>如何对页面进行静态化？</strong></p><p>一个页面等于 <code>模板</code> + <code>数据</code>，在添加页面的时候我们选择了页面的模板。</p></li><li><p><strong>页面静态化以及页面发布的流程</strong></p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image1" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image1.png" srcset="/img/loading.gif" alt="发布流程图"></a></p><p>​</p><p>​</p></li></ol><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>业务流程如下</p><ol><li>获取模型数据</li><li>制作模板</li><li>对页面进行静态化</li><li>将静态化生成的 <code>html</code> 页面存放在文件系统中</li><li>将存放在文件系统的 <code>html</code> 页面发布到服务器</li></ol><h1 id="二、FreeMarker研究"><a href="#二、FreeMarker研究" class="headerlink" title="二、FreeMarker研究"></a>二、FreeMarker研究</h1><h2 id="1-FreeMarker介绍"><a href="#1-FreeMarker介绍" class="headerlink" title="1. FreeMarker介绍"></a>1. FreeMarker介绍</h2><ol><li><p><code>freemarker</code> 是一个用 <code>Java</code> 开发的模板引擎</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image2" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image2.png" srcset="/img/loading.gif" alt="img"></a></p><p>常用的 <code>java</code> 模板引擎还有哪些?</p><p>Jsp、Freemarker、Thymeleaf、Velocity 等</p></li><li><p>模板+数据模型 = 输出</p><p><code>freemarker</code> 并不关心数据的来源，只是根据模板的内容，将数据模型在模板中显示并输出具体的（通常为 <code>html</code> ，也可以生成其他格式的文件）</p><ol><li><p><strong>数据模型</strong></p><p>数据模型在 <code>java</code> 中可以是基本类型也可以是 List、Map、Pojo 等复杂类型</p></li><li><p><strong>来自官方的例子</strong>：（<a href="https://freemarker.apache.org/docs/dgui_quickstart_basics.html%EF%BC%89" target="_blank" rel="noopener">https://freemarker.apache.org/docs/dgui_quickstart_basics.html）</a></p><p>数据模型：</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image3" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image3.png" srcset="/img/loading.gif" alt="img"></a></p><p>模板：</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image4" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image4.png" srcset="/img/loading.gif" alt="img"></a></p><p>输出：</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image5" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image5.png" srcset="/img/loading.gif" alt="img"></a></p></li></ol></li></ol><h2 id="2-FreeMark-快速入门"><a href="#2-FreeMark-快速入门" class="headerlink" title="2. FreeMark 快速入门"></a>2. FreeMark 快速入门</h2><p>freemarker 作为 <code>Springmvc</code> 一种视图的格式，默认情况下， <code>SpringMvc</code> 支持 <code>freemarker</code> 视图格式。</p><p>需要创建 <code>Spring boot</code> + <code>Freemarker</code>工程用于测试的模板。</p><h3 id="1、创建测试工程"><a href="#1、创建测试工程" class="headerlink" title="1、创建测试工程"></a>1、创建测试工程</h3><p>我们在原有的工程下，创建一个<code>test-freemarker</code> 的 <code>maven</code> 模块，测试工程专门用于freemarker的功能测试与模板的测试。</p><p>pom如下</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0</span></span><span class="hljs-tag"><span class="hljs-string">http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>test-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p>配置 <code>application.yml</code> 和 <code>logback-spring.xml</code>，从 <code>cms</code> 工程拷贝这两个文件，进行更改， <code>logback-spring.xml</code> 无需更改，<code>application.yml</code> 内容如下：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span> <span class="hljs-comment">#服务端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">test‐freemarker</span> <span class="hljs-comment">#指定服务名</span>  <span class="hljs-attr">freemarker:</span>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#关闭模板缓存，方便测试</span>    <span class="hljs-attr">settings:</span>      <span class="hljs-attr">template_update_delay:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便</span></code></pre></div><h3 id="3、创建模型类"><a href="#3、创建模型类" class="headerlink" title="3、创建模型类"></a>3、创建模型类</h3><p>在 <code>freemarker</code> 的测试工程下创建模型类型用于测试；</p><p>创建 <code>com.xuecheng.test.freemarker.model</code> 包，并构建一个 <code>Student</code> 模型类用于后面的测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.freemarker.model;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//姓名</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<span class="hljs-comment">//年龄</span>    <span class="hljs-keyword">private</span> Date birthday;<span class="hljs-comment">//生日</span>    <span class="hljs-keyword">private</span> Float money;<span class="hljs-comment">//钱包</span>    <span class="hljs-keyword">private</span> List&lt;Student&gt; friends;<span class="hljs-comment">//朋友列表</span>    <span class="hljs-keyword">private</span> Student bestFriend;<span class="hljs-comment">//最好的朋友</span>&#125;</code></pre></div><h3 id="4、创建模板"><a href="#4、创建模板" class="headerlink" title="4、创建模板"></a>4、创建模板</h3><p>在 <code>src/main/resources</code> 下创建 <code>templates</code>，此目录为 <code>freemarker</code> 的默认模板存放目录；</p><p>在 <code>templates</code> 下创建模板文件 <code>test1.ftl</code>，模板中的 <code>${name}</code> 最终会被<code>freemarker</code> 替换成具体的数据。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf‐8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello $&#123;name&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="5、-创建-controller"><a href="#5、-创建-controller" class="headerlink" title="5、 创建 controller"></a>5、 创建 controller</h3><p>创建 <code>Controller</code> 类，向 <code>Map</code> 中添加 <code>name</code>，最后返回模板文件。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/freemarker"</span>)<span class="hljs-meta">@Controller</span>  <span class="hljs-comment">//这里主要不要使用RestController,RestController默认返回json数据,使模板引擎失效</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkerController</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 测试1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map freemarker引擎会自动从Map形参中读取变量进行渲染</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test1"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">freemarker</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>&#123;        map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"黑马程序员"</span>);        <span class="hljs-comment">//返回模板文件名称</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"test1"</span>;    &#125;&#125;</code></pre></div><h3 id="6、创建启动类"><a href="#6、创建启动类" class="headerlink" title="6、创建启动类"></a>6、创建启动类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.freemarker;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkerTestApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(FreemarkerTestApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h3><p>访问 <a href="http://localhost:8088/freemarker/test1" target="_blank" rel="noopener">http://localhost:8088/freemarker/test1</a> 测试</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image6" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image6.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-Freemarker-基础语法"><a href="#3-Freemarker-基础语法" class="headerlink" title="3.Freemarker 基础语法"></a>3.Freemarker 基础语法</h2><h3 id="1、核心指令"><a href="#1、核心指令" class="headerlink" title="1、核心指令"></a>1、核心指令</h3><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p><code>Freemarker</code> 静态化依赖数据模型和模板，下边定义数据模型；</p><p>下边方法形参 <code>map</code> 即为 <code>freemarker</code> 静态化所需要的数据模型，在 <code>map</code> 中填充数据：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.freemarker.controller;<span class="hljs-keyword">import</span> com.xuecheng.test.freemarker.model.Student;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/freemarker"</span>)<span class="hljs-meta">@Controller</span>  <span class="hljs-comment">//这里主要不要使用RestController,RestController默认返回json数据,使模板引擎失效</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkerController</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 测试1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map freemarker引擎会自动从Map形参中读取变量进行渲染</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test1"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">freemarker</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>&#123;        map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"黑马程序员"</span>);        <span class="hljs-comment">//学生对象1</span>        Student stu1 = <span class="hljs-keyword">new</span> Student();        stu1.setName(<span class="hljs-string">"小明"</span>);        stu1.setAge(<span class="hljs-number">18</span>);        stu1.setMoney(<span class="hljs-number">1888.123f</span>);        stu1.setBirthday(<span class="hljs-keyword">new</span> Date());        <span class="hljs-comment">//学生对象2</span>        Student stu2 = <span class="hljs-keyword">new</span> Student();        stu2.setName(<span class="hljs-string">"小红"</span>);        stu2.setAge(<span class="hljs-number">22</span>);        stu2.setMoney(<span class="hljs-number">1888.123f</span>);        stu2.setBirthday(<span class="hljs-keyword">new</span> Date());        <span class="hljs-comment">//创建一个List对象，用于储存上面这两个学生对象</span>        ArrayList&lt;Object&gt; stus = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        stus.add(stu1);        stus.add(stu2);        <span class="hljs-comment">//向数据模型中放入List</span>        map.put(<span class="hljs-string">"stus"</span>,stus);        <span class="hljs-comment">//返回模板文件名称</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"test1"</span>;    &#125;&#125;</code></pre></div><h4 id="List指令"><a href="#List指令" class="headerlink" title="List指令"></a>List指令</h4><p>本节定义freemarker模板，模板中使用freemarker的指令，关于freemarker的指令需要知道：</p><div class="hljs"><pre><code class="hljs html">1、注释，即<span class="hljs-tag">&lt;<span class="hljs-name">#‐‐和‐‐</span>&gt;</span>，介于其之间的内容会被freemarker忽略2、插值（Interpolation）：即$&#123;..&#125;部分,freemarker会用真实的值代替$&#123;..&#125;3、FTL指令：和HTML标记类似，名字前加#予以区分，Freemarker会解析标签中的表达式或逻辑。4、文本，仅文本信息，这些不是freemarker的注释、插值、FTL指令的内容会被freemarker忽略解析，直接输出内容</code></pre></div><p>在 <code>test1.ftl</code> 模板中使用list指令遍历数据模型中的数据：</p><div class="hljs"><pre><code class="hljs jsp">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=<span class="hljs-string">"utf‐8"</span>&gt;    &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello $&#123;name&#125;!&lt;p&gt;在test1.ftl模板中使用list指令遍历数据模型中的数据：&lt;/p&gt;&lt;table&gt;    &lt;thead&gt;        &lt;td&gt;序号&lt;/td&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td&gt;年龄&lt;/td&gt;        &lt;td&gt;钱包&lt;/td&gt;    &lt;/thead&gt;    &lt;#list stus as stu&gt;        &lt;tr&gt;            &lt;#--使用 _index 来遍历的序号--&gt;            &lt;td&gt;$&#123;stu_index + 1&#125;&lt;/td&gt;            &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt;            &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt;            &lt;td&gt;$&#123;stu.money&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/#list&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><p>效果</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image7" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image7.png" srcset="/img/loading.gif" alt="LIST输出效果"></a></p><h4 id="遍历Map数据"><a href="#遍历Map数据" class="headerlink" title="遍历Map数据"></a>遍历Map数据</h4><p>1、数据模型</p><p>在<code>controller</code> 内使用<code>map</code>指令遍历数据模型中的 <code>stuMap</code>。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//准备map数据</span>HashMap&lt;Object, Object&gt; stuMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();stuMap.put(<span class="hljs-string">"stu1"</span>,stu1);stuMap.put(<span class="hljs-string">"stu2"</span>,stu2);<span class="hljs-comment">//像数据模型内放数据</span>map.put(<span class="hljs-string">"stu1"</span>,stu1);<span class="hljs-comment">//向数据模型放入stuMap</span>map.put(<span class="hljs-string">"stuMap"</span>, stuMap);</code></pre></div><p>2、模板</p><div class="hljs"><pre><code class="hljs html">通过Map输出stu1的学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>姓名：$&#123;stuMap['stu1'].name&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>年龄：$&#123;stuMap['stu1'].age&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>通过Map输出stu1的学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>姓名：$&#123;stuMap.stu1.name&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>年龄：$&#123;stuMap.stu1.age&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>使用map指令遍历数据模型中的stuMap。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stuMap</span>?<span class="hljs-attr">keys</span> <span class="hljs-attr">as</span> <span class="hljs-attr">k</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;k_index + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stuMap[k].name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stuMap[k].age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stuMap[k].money&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p>3、输出</p><p><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image8.png" srcset="/img/loading.gif" alt></p><h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>if 指令即判断指令，是常用的FTL指令，freemarker在解析时遇到if会进行判断，条件为真则输出if中间的内容，否则跳过内容不再输出。</p><ol><li><p><strong>数据模型：</strong></p><p>使用list指令中测试数据模型。</p></li><li><p><strong>模板</strong></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stus</span> <span class="hljs-attr">as</span> <span class="hljs-attr">stu</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">#--使用</span> <span class="hljs-attr">_index</span> 来遍历的序号<span class="hljs-attr">--</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu_index + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            &lt;td &lt;#if stu.name == '小明'&gt;style="background: red" &lt;/#if&gt;&gt;$&#123;stu.name&#125;&lt;/td&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu.money&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><p>通过阅读上边的代码，实现的功能是：如果姓名为 “<code>小明</code>” 则背景色显示为红色。</p></li><li><p><strong>输出</strong></p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image9" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>通过测试发现 姓名为小明的背景色为红色。</p></li></ol><h4 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h4><div class="hljs"><pre><code class="hljs js">$&#123; (type == <span class="hljs-string">'SPOT'</span>) ?string(<span class="hljs-string">'热点词'</span>,<span class="hljs-string">'热点搜索'</span>)&#125;</code></pre></div><h3 id="2、其他指令"><a href="#2、其他指令" class="headerlink" title="2、其他指令"></a>2、其他指令</h3><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ol><li>算数运算符 FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , %</li><li>逻辑运算符 逻辑运算符有如下几个: 逻辑与:&amp;&amp; 逻辑或:|| 逻辑非:! 逻辑运算符只能作用于布尔值,否则将产生错误</li><li>比较运算符 表达式中支持的比较运算符有如下几个: 1 =或者==:判断两个值是否相等. 2 !=:判断两个值是否不等. 3 &gt;<br>或者gt:判断左边值是否大于右边值</li><li><code>&gt;=</code> 或者 <code>gte:</code> 判断左边值是否大于等于右边值</li><li><code>&lt;</code> 或者 <code>lt:</code> 判断左边值是否小于右边值</li><li><code>&lt;=</code> 或者 <code>lte:</code> 判断左边值是否小于等于右边值，注意: <code>=</code> 和 <code>!=</code> 可以用于字符</li></ol><p>串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误</p><p>而且 <code>FreeMarker</code> 是精确比较, <code>&quot;x&quot;,&quot;x &quot;,&quot;X&quot;</code> 是不等的.其它的运行符可以作用</p><p>于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替 <code>&gt;</code> 会有更好的效果,因为 <code>FreeMarker</code> 会把 <code>&gt;</code> 解释成 <code>FTL</code> 标签的结束字符, 当然,也可以使 <strong>括号</strong> 来避免这种情况, 如:<code>&lt;#if (x&gt;y)&gt;</code></p><h4 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h4><ol><li><p>判断某变量是否存在使用 “??” 用法为:variable??,如果该变量存在,返回true,否则返回false</p><p>例：为防止stus为空报错可以加上判断如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">stus</span>??&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stus</span> <span class="hljs-attr">as</span> <span class="hljs-attr">stu</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></code></pre></div></li><li><p>缺失变量默认值使用 <code>“!”</code> 使用 <code>!</code> 要以指定一个默认值，当变量为空时显示默认值。例如： <code>${name!&#39;&#39;}</code> 表示如果 <code>name</code> 为空显示空字符串。</p><p>如果是嵌套对象则建议使用（）括起来。</p><p>例： ${(stu.bestFriend.name)!’’}表示，如果stu或bestFriend或name为空默认显示空字符串。</p></li></ol><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p>内建函数语法格式： 变量+?+函数名称</p><ol><li><p>得到某个集合的大小：<code>${集合名?size}</code></p></li><li><p>日期格式化</p><div class="hljs"><pre><code class="hljs html">显示年月日: $&#123;today?date&#125;显示时分秒：$&#123;today?time&#125;显示日期+时间：$&#123;today?datetime&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>自定义格式化： $&#123;today?string("yyyy年MM月")&#125;</code></pre></div></li><li><p>内建函数 <code>c</code></p><p><code>map.put(&quot;point&quot;, 102920122);</code></p><p><code>point</code> 是数字型，使用 <code>${point}</code> 会显示这个数字的值，并且每三位使用逗号分隔。例如：“102,920,122”</p><p>如果不想显示为每三位分隔的数字，可以使用 <code>c</code> 函数将数字型转成字符串输出</p><p>例如：<code>${point?c}</code></p></li><li><p>将json字符串转成对象</p><p>一个例子：</p><p>其中用到了 assign标签，assign的作用是定义一个变量。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">text</span>=<span class="hljs-string">"&#123;'bank':'工商银行','account':'10101920201920212'&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">data</span>=<span class="hljs-string">text?eval</span> /&gt;</span>开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125;</code></pre></div></li></ol><h4 id="完整的模板"><a href="#完整的模板" class="headerlink" title="完整的模板"></a>完整的模板</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf‐8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello $&#123;name&#125;!<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stus</span> <span class="hljs-attr">as</span> <span class="hljs-attr">stu</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu_index + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    &lt;td &lt;#if stu.name =='小明'&gt;style="background:red;"&lt;/#if&gt;&gt;$&#123;stu.name&#125;&lt;/td&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span>$&#123;stu.money&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>输出stu1的学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>姓名：$&#123;stuMap['stu1'].name&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>年龄：$&#123;stuMap['stu1'].age&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>输出stu1的学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>姓名：$&#123;stu1.name&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>年龄：$&#123;stu1.age&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>遍历输出两个学生信息：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stuMap</span>?<span class="hljs-attr">keys</span> <span class="hljs-attr">as</span> <span class="hljs-attr">k</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;k_index + 1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stuMap[k].name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stuMap[k].age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span>$&#123;stuMap[k].money&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>出生日期<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>钱包<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>最好的朋友<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>朋友个数<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>朋友列表<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">stus</span>??&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stus</span> <span class="hljs-attr">as</span> <span class="hljs-attr">stu</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu.name!''&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;(stu.birthday?date)!''&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;stu.money&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;(stu.bestFriend.name)!''&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;(stu.friends?size)!0&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">stu.friends</span>??&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">stu.friends</span> <span class="hljs-attr">as</span> <span class="hljs-attr">firend</span>&gt;</span>    $&#123;firend.name!''&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">text</span>=<span class="hljs-string">"&#123;'bank':'工商银行','account':'10101920201920212'&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">data</span>=<span class="hljs-string">text?eval</span> /&gt;</span>开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>&gt;</code></pre></div><h3 id="3、静态化测试"><a href="#3、静态化测试" class="headerlink" title="3、静态化测试"></a>3、静态化测试</h3><p>在cms中使用freemarker将页面生成html文件，本节测试html文件生成的方法：</p><p><strong>1、使用模板文件静态化</strong></p><p>定义模板文件，使用freemarker静态化程序生成html文件。</p><p><strong>2、使用模板字符串静态化</strong></p><p>定义模板字符串，使用freemarker静态化程序生成html文件。</p><h4 id="使用模板文件静态化"><a href="#使用模板文件静态化" class="headerlink" title="使用模板文件静态化"></a>使用模板文件静态化</h4><p>在 <code>test</code> 下创建测试类，并且将<code>main</code>下的 <code>resource/templates</code> 拷贝到 <code>test</code> 下，本次测试使用之前我们在 <code>main</code> 下创建的模板文件，并创建测试类。 目录结构如下</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image10" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image10.png" srcset="/img/loading.gif" alt="img"></a></p><p>创建测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//基于模板生成静态文件</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGenerateHtml</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;    <span class="hljs-comment">//创建配置类</span>    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.getVersion());    <span class="hljs-comment">//设置模板路径</span>    String classPath = <span class="hljs-keyword">this</span>.getClass().getResource(<span class="hljs-string">"/"</span>).getPath();    classPath = java.net.URLDecoder.decode(classPath,<span class="hljs-string">"utf-8"</span>); <span class="hljs-comment">//路径包含中文需要进行转码</span>    configuration.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> File(classPath +<span class="hljs-string">"/templates"</span>));    <span class="hljs-comment">//设置字符集</span>    configuration.setDefaultEncoding(<span class="hljs-string">"utf-8"</span>);    <span class="hljs-comment">//加载模板</span>    Template template = configuration.getTemplate(<span class="hljs-string">"test1.ftl"</span>);    <span class="hljs-comment">//数据模型</span>    Map map = getMap();    <span class="hljs-comment">//静态化</span>    String content = FreeMarkerTemplateUtils.processTemplateIntoString(template, map);    <span class="hljs-comment">//静态化内容</span>    InputStream inputStream = IOUtils.toInputStream(content);    <span class="hljs-comment">//输出到文件</span>    FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/test1.html"</span>));    <span class="hljs-keyword">int</span> copy = IOUtils.copy(inputStream, fileOutputStream);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getMap</span><span class="hljs-params">()</span></span>&#123;    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"黑马程序员"</span>);    <span class="hljs-comment">//学生对象1</span>    Student stu1 = <span class="hljs-keyword">new</span> Student();    stu1.setName(<span class="hljs-string">"小明"</span>);    stu1.setAge(<span class="hljs-number">18</span>);    stu1.setMoney(<span class="hljs-number">1888.123f</span>);    stu1.setBirthday(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">//学生对象2</span>    Student stu2 = <span class="hljs-keyword">new</span> Student();    stu2.setName(<span class="hljs-string">"小红"</span>);    stu2.setAge(<span class="hljs-number">22</span>);    stu2.setMoney(<span class="hljs-number">1888.123f</span>);    stu2.setBirthday(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">//创建一个List对象，用于储存上面这两个学生对象</span>    ArrayList&lt;Object&gt; stus = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    stus.add(stu1);    stus.add(stu2);    <span class="hljs-comment">//向数据模型中放入List</span>    map.put(<span class="hljs-string">"stus"</span>,stus);    <span class="hljs-comment">//准备map数据</span>    HashMap&lt;Object, Object&gt; stuMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    stuMap.put(<span class="hljs-string">"stu1"</span>,stu1);    stuMap.put(<span class="hljs-string">"stu2"</span>,stu2);    <span class="hljs-comment">//像数据模型内放数据</span>    map.put(<span class="hljs-string">"stu1"</span>,stu1);    <span class="hljs-comment">//向数据模型放入stuMap</span>    map.put(<span class="hljs-string">"stuMap"</span>, stuMap);    <span class="hljs-keyword">return</span> map;&#125;</code></pre></div><p>运行测试，得到html模板</p><p><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image11.png" srcset="/img/loading.gif" alt="img"></p><h4 id="使用模板字符串静态化"><a href="#使用模板字符串静态化" class="headerlink" title="使用模板字符串静态化"></a>使用模板字符串静态化</h4><p>详细代码省略，使用字符串和使用模板的区别是 这里直接定义一个 <code>HTML</code> 的字符串变量，例如</p><div class="hljs"><pre><code class="hljs java">String templateString=<span class="hljs-string">""</span> +    <span class="hljs-string">"&lt;html&gt;\n"</span> +    <span class="hljs-string">" &lt;head&gt;&lt;/head&gt;\n"</span> +    <span class="hljs-string">" &lt;body&gt;\n"</span> +    <span class="hljs-string">" 名称：$&#123;name&#125;\n"</span> +    <span class="hljs-string">" &lt;/body&gt;\n"</span> +    <span class="hljs-string">"&lt;/html&gt;"</span>;</code></pre></div><p>而前面的例子是从ftl模板中获取内容</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//加载模板</span>Template template = configuration.getTemplate(<span class="hljs-string">"test1.ftl"</span>);</code></pre></div><h2 id="4-章节总结"><a href="#4-章节总结" class="headerlink" title="4. 章节总结"></a>4. 章节总结</h2><p>本章节主要介绍了 <code>Freemarker</code> 模板引擎的语法介绍和基本的应用，并了解了 <code>Freemarker</code> 在进行模板渲染时的API调用过程。</p><h1 id="三、页面静态化实战"><a href="#三、页面静态化实战" class="headerlink" title="三、页面静态化实战"></a>三、页面静态化实战</h1><h2 id="1-页面静态化流程"><a href="#1-页面静态化流程" class="headerlink" title="1.页面静态化流程"></a>1.页面静态化流程</h2><p>通过上边对 <code>FreeMarker</code> 的研究我们得出：<strong>模板 + 数据模型 = 输出</strong>，页面静态化需要准备数据模型和模板，先知道数据模型的结构才可以编写模板，因为在模板中要引用数据模型中的数据，本节将系统讲解 <code>CMS</code> 页面数据模型获取、模板管理及静态化的过程。</p><p>下边我们讨论一个问题：<strong>如何获取页面的数据模型？</strong></p><p><code>CMS</code> 管理了各种页面，<code>CMS</code> 对页面进行静态化时需要数据模型，但是 <code>CMS</code> 并不知道每个页面的数据模型的具体内容，它只管执行静态化程序便可对页面进行静态化，所以 <code>CMS</code> 静态化程序需要通过一种通用的方法来获取数据模型。</p><p>在编辑页面信息时指定一个 <code>DataUrl</code> ，此 <code>DataUrl</code> 便是获取数据模型的 <code>Url</code>，它基于 <code>Http</code>方式，<code>CMS</code> 对页面进行静态化时会从页面信息中读取 <code>DataUrl</code>，通过 <code>Http</code> 远程调用的方法请求 <code>DataUrl</code> 获取数据模型 。</p><p>管理员怎么知道 <code>DataUrl</code> 的内容呢？</p><p><strong>举例说明</strong>：</p><p>此页面是轮播图页面，它的 <code>DataUrl</code> 由开发轮播图管理的程序员提供。</p><p>此页面是精品课程推荐页面，它的 <code>DataUrl</code> 由精品课程推荐的程序员提供。</p><p>此页面是课程详情页面，它的 <code>DataUrl</code> 由课程管理的程序员提供。</p><p>页面静态化流程如下图：</p><p>1、静态化程序首先读取页面获取DataUrl。</p><p>2、静态化程序远程请求DataUrl得到数据模型。</p><p>3、获取页面模板。</p><p>4、执行页面静态化</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image12" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image12.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h2><h3 id="1、轮播图DataUrl接口"><a href="#1、轮播图DataUrl接口" class="headerlink" title="1、轮播图DataUrl接口"></a>1、轮播图DataUrl接口</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><code>CMS</code> 中有轮播图管理、精品课程推荐的功能，以轮播图管理为例说明：轮播图管理是通过可视化的操作界面由管理员指定轮播图图片地址，最后将轮播图图片地址保存在 <code>cms_config</code> 集合中，下边是轮播图数据模型</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image13" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image13.png" srcset="/img/loading.gif" alt="img"></a></p><p>针对首页的轮播图信息、精品推荐等信息的获取统一提供一个 <code>Url</code> 供静态化程序调用，这样我们就知道了轮播图页面、精品课程推荐页面的 <code>DataUrl</code>，管理在页面配置中将此 <code>Url</code> 配置在页面信息中。本小节开发一个查询轮播图、精品推荐信息的接口，此接口供静态化程序调用获取数据模型 。</p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><p>轮播图信息、精品推荐等信息存储在MongoDB的cms_config集合中。</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image14" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image14.png" srcset="/img/loading.gif" alt="img"></a></p><p>cms_config有固定的数据结构，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.cms;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> org.springframework.data.annotation.Id;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@Document</span>(collection = <span class="hljs-string">"cms_config"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsConfig</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> String id; <span class="hljs-comment">//主键</span>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//数据模型名称</span>    <span class="hljs-keyword">private</span> List&lt;CmsConfigModel&gt; model;  <span class="hljs-comment">//数据模型项目</span>&#125;</code></pre></div><p>数据类型项目的内容如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.cms;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@Data</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsConfigModel</span> </span>&#123;    <span class="hljs-keyword">private</span> String key;  <span class="hljs-comment">//主键</span>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//项目名称</span>    <span class="hljs-keyword">private</span> String url;  <span class="hljs-comment">//项目url</span>    <span class="hljs-keyword">private</span> Map mapValue;  <span class="hljs-comment">//项目复杂值</span>    <span class="hljs-keyword">private</span> String value;  <span class="hljs-comment">//项目简单值</span>&#125;</code></pre></div><p>上边的数据结构可以对照 <code>cms_config</code> 的数据进行分析。</p><p>其中，在 <code>mapValue</code> 中可以储存一些复杂的数据的模型内容。</p><p>根据配置信息Id查询配置信息，定义接口如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.cms;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsConfig;<span class="hljs-keyword">import</span> io.swagger.annotations.Api;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<span class="hljs-meta">@Api</span>(value=<span class="hljs-string">"cms配置管理接口"</span>,description = <span class="hljs-string">"cms配置管理接口，提供数据模型的管理、查询接口"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsConfigControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"根据id查询CMS配置信息"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsConfig <span class="hljs-title">getModel</span><span class="hljs-params">(String id)</span></span>;&#125;</code></pre></div><h4 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.dao;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsConfig;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsConfigRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsConfig</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h4><p>在原service层添加（此处应新创建一个Service）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据id查询cmsconfig</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsConfig <span class="hljs-title">getConfigById</span><span class="hljs-params">(String id)</span></span>&#123;        Optional&lt;CmsConfig&gt; optional = cmsConfigRepository.findById(id);        <span class="hljs-keyword">if</span> (optional.isPresent())&#123;            CmsConfig cmsConfig = optional.get();            <span class="hljs-keyword">return</span> cmsConfig;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;</code></pre></div><h4 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.cms.CmsConfigControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsConfig;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.service.CmsConfigService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/cms/config"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsConfigController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CmsConfigControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsConfigService cmsConfigService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getmodel/&#123;id&#125;"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsConfig <span class="hljs-title">getModel</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;        CmsConfig configById = cmsConfigService.getConfigById(id);        <span class="hljs-keyword">return</span> configById;    &#125;&#125;</code></pre></div><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>使用postman测试接口：</p><p>get请求：<a href="http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f" target="_blank" rel="noopener">http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f</a> （轮播图信息）</p><h3 id="2、远程请求接口"><a href="#2、远程请求接口" class="headerlink" title="2、远程请求接口"></a>2、远程请求接口</h3><p><code>SpringMVC</code> 提供 <code>RestTemplate</code> 请求 <code>http</code> 接口，<code>RestTemplate</code> 的底层可以使用第三方的 <code>http</code> 客户端工具实现 <code>http</code> 的请求，常用的 <code>http</code> 客户端工具有 <code>Apache HttpClient</code>、<code>OkHttpClient</code> 等，本项目使用 <code>OkHttpClient</code> 完成 <code>http</code> 请求，原因也是因为它的性能比较出众。</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span></span></code></pre></div><h4 id="配置-RestTemplate"><a href="#配置-RestTemplate" class="headerlink" title="配置 RestTemplate"></a>配置 RestTemplate</h4><p>在<code>SpringBoot</code>启动类中配置 <code>RestTemplate</code></p><div class="hljs"><pre><code class="hljs java">...<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;&#125;</code></pre></div><h4 id="3、测试-RestTemplate"><a href="#3、测试-RestTemplate" class="headerlink" title="3、测试 RestTemplate"></a>3、测试 RestTemplate</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">RestTemplateTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRestTemplate</span><span class="hljs-params">()</span></span>&#123;        ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(<span class="hljs-string">"http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f"</span>, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        System.out.println(forEntity);    &#125;&#125;</code></pre></div><p>运行测试</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image15" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-模板管理"><a href="#3-模板管理" class="headerlink" title="3.模板管理"></a>3.模板管理</h2><h3 id="1、模板管理业务流程"><a href="#1、模板管理业务流程" class="headerlink" title="1、模板管理业务流程"></a>1、模板管理业务流程</h3><p>CMS提供模板管理功能，业务流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image16" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image16.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、要增加新模板首先需要制作模板，模板的内容就是 <code>Freemarker ftl</code> 模板内容。</p><p>2、通过模板管理模块功能新增模板、修改模板、删除模板。</p><p>3、模板信息存储在 <code>MongoDB</code> 数据库，其中模板信息存储在 <code>cms_template</code> 集合中，模板文件存储在 <code>GridFS</code> 文件系统中。</p><p>下边是一个模板的例子：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"5a962b52b00ffc514038faf7"</span>),    <span class="hljs-attr">"_class"</span> : <span class="hljs-string">"com.xuecheng.framework.domain.cms.CmsTemplate"</span>,    <span class="hljs-attr">"siteId"</span> : <span class="hljs-string">"5a751fab6abb5044e0d19ea1"</span>,    <span class="hljs-attr">"templateName"</span> : <span class="hljs-string">"首页"</span>,    <span class="hljs-attr">"templateParameter"</span> : <span class="hljs-string">""</span>,    <span class="hljs-attr">"templateFileId"</span> : <span class="hljs-string">"5a962b52b00ffc514038faf5"</span>&#125;</code></pre></div><p>上边模板信息中 <code>templateFileId</code> 是模板文件的ID，此ID对应 <code>GridFS</code> 文件系统中文件ID。</p><h3 id="2、模板制作"><a href="#2、模板制作" class="headerlink" title="2、模板制作"></a>2、模板制作</h3><h4 id="编写模板文件"><a href="#编写模板文件" class="headerlink" title="编写模板文件"></a>编写模板文件</h4><p>轮播图页面原型</p><p>在门户的静态工程目录有轮播图的静态页面，路径是：<code>/include/index_banner.html</code>。</p><p>数据模型为：</p><p>通过http 获取到数据模型如下：</p><p>下图数据模型的图片路径改成可以浏览的正确路径。</p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"5a791725dd573c3574ee333f"</span>),     <span class="hljs-attr">"_class"</span> : <span class="hljs-string">"com.xuecheng.framework.domain.cms.CmsConfig"</span>,     <span class="hljs-attr">"name"</span> : <span class="hljs-string">"轮播图"</span>,     <span class="hljs-attr">"model"</span> : [        &#123;            <span class="hljs-attr">"key"</span> : <span class="hljs-string">"banner1"</span>,             <span class="hljs-attr">"name"</span> : <span class="hljs-string">"轮播图1地址"</span>,             <span class="hljs-attr">"value"</span> : <span class="hljs-string">"http://www.xuecheng.com/img/widget-bannerA.jpg"</span>        &#125;,         &#123;            <span class="hljs-attr">"key"</span> : <span class="hljs-string">"banner2"</span>,             <span class="hljs-attr">"name"</span> : <span class="hljs-string">"轮播图2地址"</span>,             <span class="hljs-attr">"value"</span> : <span class="hljs-string">"http://www.xuecheng.com/img/widget-bannerB.jpg"</span>        &#125;    ]&#125;</code></pre></div><p>编写模板</p><p>在freemarker测试工程中新建模板 <code>index_banner.ftl</code>。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.xuecheng.com/plugins/normalize-css/normalize.css"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.xuecheng.com/plugins/bootstrap/dist/css/bootstrap.css"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.xuecheng.com/css/page-learing-index.css"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.xuecheng.com/css/page-header.css"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"banner-roll"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"banner-item"</span>&gt;</span>        &lt;#--&lt;div class="item" style="background-image: url(http://www.xuecheng.com/img/widget-bannerB.jpg);"&gt;&lt;/div&gt;--&gt;        &lt;#--&lt;div class="item" style="background-image: url(http://www.xuecheng.com/img/widget-bannerA.jpg);"&gt;&lt;/div&gt;--&gt;        &lt;#--&lt;div class="item" style="background-image: url(http://www.xuecheng.com/img/widget-banner3.png);"&gt;&lt;/div&gt;--&gt;        &lt;#--&lt;div class="item" style="background-image: url(http://www.xuecheng.com/img/widget-bannerB.jpg);"&gt;&lt;/div&gt;--&gt;        &lt;#--&lt;div class="item" style="background-image: url(http://www.xuecheng.com/img/widget-bannerA.jpg);"&gt;&lt;/div&gt;--&gt;        &lt;#--&lt;div class="item" style="background-image: url(http://www.xuecheng.com/img/widget-banner3.png);"&gt;&lt;/div&gt;--&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">#--渲染轮播图--</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">model</span>??&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">model</span> <span class="hljs-attr">as</span> <span class="hljs-attr">item</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background-image: url($&#123;item.value&#125;);"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"indicators"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.xuecheng.com/plugins/jquery/dist/jquery.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://www.xuecheng.com/plugins/bootstrap/dist/js/bootstrap.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> tg = $(<span class="hljs-string">'.banner-item .item'</span>);</span><span class="actionscript">    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;</span>    for (i = 0; i &lt; tg.length; i++) &#123;<span class="javascript">        $(<span class="hljs-string">'.indicators'</span>).append(<span class="hljs-string">'&lt;span&gt;&lt;/span&gt;'</span>);</span><span class="javascript">        $(<span class="hljs-string">'.indicators'</span>).find(<span class="hljs-string">'span'</span>).eq(num).addClass(<span class="hljs-string">'active'</span>);</span>    &#125;<span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">roll</span><span class="hljs-params">()</span> </span>&#123;</span>        tg.eq(num).animate(&#123;<span class="actionscript">            <span class="hljs-string">'opacity'</span>: <span class="hljs-string">'1'</span>,</span><span class="actionscript">            <span class="hljs-string">'z-index'</span>: num</span>        &#125;, 1000).siblings().animate(&#123;<span class="actionscript">            <span class="hljs-string">'opacity'</span>: <span class="hljs-string">'0'</span>,</span><span class="actionscript">            <span class="hljs-string">'z-index'</span>: <span class="hljs-number">0</span></span>        &#125;, 1000);<span class="javascript">        $(<span class="hljs-string">'.indicators'</span>).find(<span class="hljs-string">'span'</span>).eq(num).addClass(<span class="hljs-string">'active'</span>).siblings().removeClass(<span class="hljs-string">'active'</span>);</span>        if (num &gt;= tg.length - 1) &#123;            num = 0;<span class="actionscript">        &#125; <span class="hljs-keyword">else</span> &#123;</span>            num++;        &#125;    &#125;<span class="javascript">    $(<span class="hljs-string">'.indicators'</span>).find(<span class="hljs-string">'span'</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        num = $(<span class="hljs-keyword">this</span>).index();</span>        roll();    &#125;);<span class="actionscript">    <span class="hljs-keyword">var</span> timer = setInterval(roll, <span class="hljs-number">3000</span>);</span><span class="javascript">    $(<span class="hljs-string">'.banner-item'</span>).mouseover(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span>        clearInterval(timer)    &#125;);<span class="javascript">    $(<span class="hljs-string">'.banner-item'</span>).mouseout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span>        timer = setInterval(roll, 3000)    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h4><p>在 <code>freemarker</code> 测试工程的入口文件注册 <code>RestTemplate</code> 的Bean</p><blockquote><p>原讲义只在 cms工程下注册了bean，记得 <code>freemarker</code> 测试工程下也要注册</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkerTestApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(FreemarkerTestApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;&#125;</code></pre></div><p>在 <code>freemarker</code> 测试工程的 <code>FreemarkerController</code> 下编写一个方法测试轮播图模板，代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>RestTemplate restTemplate;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于调试banner模板</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/banner"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">indexBanner</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>&#123;    String dataUrl = <span class="hljs-string">"http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f"</span>;    ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(dataUrl, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    Map body = forEntity.getBody();    map.putAll(body); <span class="hljs-comment">//将获取到的数据赋值给map，并渲染至模板内</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"index-banner"</span>;&#125;</code></pre></div><p>请求：<a href="http://localhost:8088/freemarker/banner" target="_blank" rel="noopener">http://localhost:8088/freemarker/banner</a></p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image17" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image17.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="3、GridFS-研究"><a href="#3、GridFS-研究" class="headerlink" title="3、GridFS 研究"></a>3、GridFS 研究</h3><h4 id="GridFS介绍"><a href="#GridFS介绍" class="headerlink" title="GridFS介绍"></a>GridFS介绍</h4><p><code>GridFS</code> 是 <code>MongoDB</code> 提供的用于持久化存储文件的模块，CMS使用<code>MongoDB</code>存储数据，使用<code>GridFS</code> 可以快速集成开发。</p><p>它的工作原理是：</p><p>在 <code>GridFS</code> 存储文件是将文件分块存储，文件会按照256KB的大小分割成多个块进行存储，<code>GridFS</code> 使用两个集合（<code>collection</code>）存储文件，一个集合是 <code>chunks</code>, 用于存储文件的二进制数据；一个集合是 <code>files</code>，用于存储文件的元数据信息（文件名称、块大小、上传时间等信息）。</p><p>从 <code>GridFS</code> 中读取文件要对文件的各各块进行组装、合并。<br>详细参考：<a href="https://docs.mongodb.com/manual/core/gridfs/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/core/gridfs/</a></p><h4 id="GridFS-存取文件测试"><a href="#GridFS-存取文件测试" class="headerlink" title="GridFS 存取文件测试"></a>GridFS 存取文件测试</h4><p>1、存文件</p><p>这里我们在cms工程内进行测试</p><p>使用 <code>GridFsTemplate</code> 存储文件测试代码：<br>向测试程序注入 <code>GridFsTemplate</code> 。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">GridFsTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    GridFsTemplate gridFsTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGridFs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;        <span class="hljs-comment">//要储存的文件</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"d:/resources/index-banner.ftl"</span>);        <span class="hljs-comment">//定义输入流</span>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);        <span class="hljs-comment">//向GridFS存储文件</span>        ObjectId objectId = gridFsTemplate.store(fileInputStream, <span class="hljs-string">"index-banner"</span>);        <span class="hljs-comment">//得到文件ID</span>        String fileId = objectId.toString();        System.out.println(fileId);    &#125;&#125;</code></pre></div><p>储存结果</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image18" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image18.png" srcset="/img/loading.gif" alt="img"></a></p><p><strong>存储原理说明：</strong></p><p>文件存储成功得到一个文件 <code>id</code><br>此文件 <code>id</code> 是 <code>fs.files</code> 集合中的主键。<br>可以通过文件 <code>id</code> 查询 <code>fs.chunks</code> 表中的记录，得到文件的内容。</p><p>2、读取文件</p><p>1）在<code>config</code>包中定义 <code>Mongodb</code> 的配置类，如下：</p><p><code>GridFSBucket</code>用于打开下载流对象</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoConfig</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.data.mongodb.database&#125;"</span>)    String db;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> GridFSBucket <span class="hljs-title">getGridFSBucket</span><span class="hljs-params">(MongoClient mongoClient)</span></span>&#123;        MongoDatabase database = mongoClient.getDatabase(db);        GridFSBucket gridFSBucket = GridFSBuckets.create(database);        <span class="hljs-keyword">return</span> gridFSBucket;    &#125;&#125;</code></pre></div><p>2）测试代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>GridFSBucket gridFSBucket;<span class="hljs-comment">//取文件</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    String fileId = <span class="hljs-string">"5e79e4323304a26aecec55cd"</span>;    <span class="hljs-comment">//根据ID查询文件</span>    GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(<span class="hljs-string">"_id"</span>).is(fileId)));    <span class="hljs-comment">//打开下载流对象</span>    GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());    <span class="hljs-comment">//创建gridFsResource，用于获取流对象</span>    GridFsResource gridFsResource = <span class="hljs-keyword">new</span> GridFsResource(gridFSFile, gridFSDownloadStream);    <span class="hljs-comment">//获取流中的数据</span>    String s = IOUtils.toString(gridFsResource.getInputStream(), <span class="hljs-string">"utf-8"</span>);    System.out.println(s);&#125;</code></pre></div><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除文件</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-comment">//根据文件id删除fs.files和fs.chunks中的记录</span>gridFsTemplate.delete(Query.query(Criteria.where(<span class="hljs-string">"_id"</span>).is(<span class="hljs-string">"5b32480ed3a022164c4d2f92"</span>)));&#125;</code></pre></div><h3 id="4、模板储存"><a href="#4、模板储存" class="headerlink" title="4、模板储存"></a>4、模板储存</h3><p>根据模板管理的流程，最终将模板信息存储到 <code>MongoDB</code> 的 <code>cms_template</code> 中，将模板文件存储到 <code>GridFS</code>中。模板管理功能在课堂中不再讲解，教学中手动向 <code>cms_template</code> 及 <code>GridFS</code> 中存储模板，方法如下：</p><h4 id="1）添加模板"><a href="#1）添加模板" class="headerlink" title="1）添加模板"></a>1）添加模板</h4><p>使用 <code>GridFS</code> 测试代码存储模板文件到 <code>GridFS</code>，并得到文件模板 <code>id</code>，向 <code>cms_template</code> 添加记录</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image19" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image19.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="2）删除模板"><a href="#2）删除模板" class="headerlink" title="2）删除模板"></a>2）删除模板</h4><p>使用 <code>GridFS</code> 测试代码根据文件id删除模板文件。</p><p>根据模板id删除 <code>cms_template</code> 中的记录。</p><h4 id="3）修改模板信息"><a href="#3）修改模板信息" class="headerlink" title="3）修改模板信息"></a>3）修改模板信息</h4><p>使用Studio 3T修改 <code>cms_template</code> 中的记录。</p><h4 id="4）修改模板文件"><a href="#4）修改模板文件" class="headerlink" title="4）修改模板文件"></a>4）修改模板文件</h4><p>1）通过Studio 3T修改模板文件(此方法限文件小于256K)可以通过Studio 3T修改模板文件，先找到模板文件，再导入进去：</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image20" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image20.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-静态化测试"><a href="#4-静态化测试" class="headerlink" title="4. 静态化测试"></a>4. 静态化测试</h2><h3 id="1、填写页面-DataUrl"><a href="#1、填写页面-DataUrl" class="headerlink" title="1、填写页面 DataUrl"></a>1、填写页面 DataUrl</h3><p>修改页面管理模板代码，实现编辑页面DataUrl。<br>注意：此地址由程序员提供给系统管理员，由系统管理员录入到系统中。</p><p><strong>修改页面管理前端的 page_edit.vue</strong></p><p>在表单中添加 <code>dataUrl</code> 输入框：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"数据Url"</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"dataUrl"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"pageForm.dataUrl"</span> <span class="hljs-attr">auto-complete</span>=<span class="hljs-string">"off"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></code></pre></div><p><code>fromData</code> 表单内添加 <code>dataUrl</code> 字段</p><p><strong>修改页面管理服务端 PageService</strong></p><p>在 <code>PageService.updateCmsPage</code> 更新 <code>cmsPage</code> 数据代码中添加：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//更新dataUrl</span>one.setDataUrl(cmsPage.getDataUrl());</code></pre></div><p><strong>新增页面也重复上面的操作，新增 dataUrl 的表单</strong></p><h3 id="2、静态化程序"><a href="#2、静态化程序" class="headerlink" title="2、静态化程序"></a>2、静态化程序</h3><p>在 <code>model.response.cmscode</code> 下新增一些错误代码</p><div class="hljs"><pre><code class="hljs java">CMS_PAGE_NOT_EXISTS(<span class="hljs-keyword">false</span>,<span class="hljs-number">24002</span>,<span class="hljs-string">"页面不存在！"</span>),CMS_GENRATEHTML_DATAURL_IS_NULL(<span class="hljs-keyword">false</span>,<span class="hljs-number">24003</span>,<span class="hljs-string">"从页面信息中找不到获取数据的url"</span>),CMS_GENRATEHTML_DATA_IS_NULL(<span class="hljs-keyword">false</span>,<span class="hljs-number">24004</span>,<span class="hljs-string">"根据页面的数据url获取不到数据"</span>),CMS_GENRATEHTML_TEMPLATE_IS_NULL(<span class="hljs-keyword">false</span>,<span class="hljs-number">24005</span>,<span class="hljs-string">"页面模板为空"</span>),CMS_GENRATEHTML_HTML_IS_NULL(<span class="hljs-keyword">false</span>,<span class="hljs-number">24006</span>,<span class="hljs-string">"生成的静态html为空"</span>),CMS_GENRATEHTML_SAVE_HTML_ERROR(<span class="hljs-keyword">false</span>,<span class="hljs-number">24007</span>,<span class="hljs-string">"保存静态html出错"</span>),CMS_GENRATEHTML_PERVIEW_IS_NULL(<span class="hljs-keyword">false</span>,<span class="hljs-number">24008</span>,<span class="hljs-string">"预览页面为空"</span>);</code></pre></div><h4 id="获取数据模型"><a href="#获取数据模型" class="headerlink" title="获取数据模型"></a>获取数据模型</h4><blockquote><p>静态化程序远程请求DataUrl得到数据模型</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>RestTemplate restTemplate;<span class="hljs-comment">//从dataUrl中获取页面模型数据</span><span class="hljs-function"><span class="hljs-keyword">private</span> Map <span class="hljs-title">getModelByPageId</span><span class="hljs-params">(String pageId)</span></span>&#123;    <span class="hljs-comment">//查询页面信息</span>    CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);    CmsPage cmsPage = cmsPageResult.getCmsPage();    <span class="hljs-comment">//页面不存在</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);    &#125;    <span class="hljs-comment">//取出dataUrl</span>    String dataUrl = cmsPage.getDataUrl();    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(dataUrl))&#123;        ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_DATAURL_IS_NULL);    &#125;    <span class="hljs-comment">//发送请求获取模型数据</span>    ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(dataUrl,Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    Map body = forEntity.getBody();    <span class="hljs-keyword">return</span> body;&#125;</code></pre></div><h4 id="获取页面模板"><a href="#获取页面模板" class="headerlink" title="获取页面模板"></a>获取页面模板</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>CmsTemplateRepository templateRepository;<span class="hljs-meta">@Autowired</span>GridFsTemplate gridFsTemplate;<span class="hljs-meta">@Autowired</span>GridFSBucket gridFSBucket;<span class="hljs-comment">//获取页面模板数据</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getTemplateByPageId</span><span class="hljs-params">(String pageId)</span></span>&#123;    <span class="hljs-comment">//查询页面信息</span>    CmsPageResult cmsPageResult = <span class="hljs-keyword">this</span>.cmsPageQueryById(pageId);    CmsPage cmsPage = cmsPageResult.getCmsPage();    <span class="hljs-comment">//页面不存在</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        ExceptionCast.cast(CmsCode.CMS_PAGE_NOT_EXISTS);    &#125;    <span class="hljs-comment">//获取页面模板</span>    String templateId = cmsPage.getTemplateId();    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(templateId))&#123;        ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_TEMPLATE_IS_NULL);    &#125;    Optional&lt;CmsTemplate&gt; optional = templateRepository.findById(templateId);    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;        CmsTemplate cmsTemplate = optional.get();        <span class="hljs-comment">//获取模板文件id</span>        String templateFileId = cmsTemplate.getTemplateFileId();        <span class="hljs-comment">//取出模板文件内容</span>        GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(<span class="hljs-string">"_id"</span>).is(templateFileId)));        <span class="hljs-comment">//打开下载流对象</span>        GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId());        <span class="hljs-comment">//创建GridResource</span>        GridFsResource gridFsResource = <span class="hljs-keyword">new</span> GridFsResource(gridFSFile, gridFSDownloadStream);        <span class="hljs-keyword">try</span> &#123;            String content = IOUtils.toString(gridFsResource.getInputStream(), <span class="hljs-string">"utf‐8"</span>);            <span class="hljs-keyword">return</span> content;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h4 id="执行页面静态化"><a href="#执行页面静态化" class="headerlink" title="执行页面静态化"></a>执行页面静态化</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 页面静态化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageId</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> TemplateException</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPageHtml</span><span class="hljs-params">(String pageId)</span> <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;    <span class="hljs-comment">//获取页面模型数据</span>    Map modelByPageId = <span class="hljs-keyword">this</span>.getModelByPageId(pageId);    <span class="hljs-keyword">if</span>(modelByPageId == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//获取页面模型数据为空</span>        ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_DATA_IS_NULL);    &#125;    <span class="hljs-comment">//获取页面模板</span>    String templateContent = getTemplateByPageId(pageId);    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(templateContent))&#123;        <span class="hljs-comment">//页面模板为空</span>        ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_TEMPLATE_IS_NULL);    &#125;    <span class="hljs-comment">//获取页面静态化数据</span>    String html = generateHtml(templateContent, modelByPageId);    <span class="hljs-keyword">if</span>(StringUtils.isEmpty(html))&#123;        ExceptionCast.cast(CmsCode.CMS_GENRATEHTML_HTML_IS_NULL);    &#125;    <span class="hljs-keyword">return</span> html;&#125;<span class="hljs-comment">//构建静态化页面数据</span><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateHtml</span><span class="hljs-params">(String template,Map model)</span> <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;    <span class="hljs-comment">//生成配置类</span>    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.getVersion());    <span class="hljs-comment">//模板加载器</span>    StringTemplateLoader stringTemplateLoader = <span class="hljs-keyword">new</span> StringTemplateLoader();    stringTemplateLoader.putTemplate(<span class="hljs-string">"template"</span>,template);    <span class="hljs-comment">//配置模板加载器</span>    configuration.setTemplateLoader(stringTemplateLoader);    <span class="hljs-comment">//获取模板</span>    Template template1 = configuration.getTemplate(<span class="hljs-string">"template"</span>);    String html = FreeMarkerTemplateUtils.processTemplateIntoString(template1, model);    <span class="hljs-keyword">return</span> html;&#125;</code></pre></div><p>调用逻辑</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image21" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="创建测试的页面"><a href="#创建测试的页面" class="headerlink" title="创建测试的页面"></a>创建测试的页面</h4><blockquote><p>原讲义中该步骤是省略的</p></blockquote><p>为了更清晰的了解页面静态化的逻辑，我们新建一个页面来进行测试；</p><p>在<code>GridFS</code> 的章节中，我们在单元测试中将 <code>index-banner.ftl</code> 文件的内容储存到了 <code>GridFS</code> 得到一个 <code>fileId</code> ，我这里的是 <code>5e7a20fc3304a25230861f4c</code> ，我们用这个<code>fileId</code> 在 mongoDB 的 <code>cms_tempalte</code> 集合中手动创建一个页面模板，创建成功后我们得到如下的数据</p><div class="hljs"><pre><code class="hljs json">&#123;     <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"5e7a2212b1afec2187ed89ac"</span>),     <span class="hljs-attr">"_class"</span> : <span class="hljs-string">"com.xuecheng.framework.domain.cms.CmsTemplate"</span>,     <span class="hljs-attr">"siteId"</span> : <span class="hljs-string">"5a751fab6abb5044e0d19ea1"</span>,     <span class="hljs-attr">"templateName"</span> : <span class="hljs-string">"轮播图_测试"</span>,     <span class="hljs-attr">"templateParameter"</span> : <span class="hljs-string">""</span>,     <span class="hljs-attr">"templateFileId"</span> : <span class="hljs-string">"5e7a20fc3304a25230861f4c"</span>&#125;</code></pre></div><p>然后进入到我们之前构建的新增页面选项，添加一个新的页面；</p><p>填入 dataUrl <code>http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f</code></p><p><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image22.png" srcset="/img/loading.gif" alt="img"></p><p>得到该页面的id为 <code>5e7a251a3304a252280804dc</code></p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">TestPageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PageService pageService;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetPageHtml</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;        String pageHtml = pageService.getPageHtml(<span class="hljs-string">"5e7a251a3304a252280804dc"</span>);        System.out.println(pageHtml);    &#125;&#125;</code></pre></div><h1 id="四、页面预览"><a href="#四、页面预览" class="headerlink" title="四、页面预览"></a>四、页面预览</h1><h2 id="1、页面预览开发"><a href="#1、页面预览开发" class="headerlink" title="1、页面预览开发"></a>1、页面预览开发</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>页面在发布前增加页面预览的步骤，方便用户检查页面内容是否正确。页面预览的流程如下：</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image23" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image23.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、用户进入 <code>cms</code> 前端，点击 “<strong>页面预览</strong>” 在浏览器请求 <strong>cms</strong> 页面预览链接。</p><p>2、<strong>cms</strong> 根据页面 <code>id</code> 查询<code>DataUrl</code>并远程请求DataUrl获取数据模型。</p><p>3、<strong>cms</strong> 根据页面id查询页面模板内容</p><p>4、<strong>cms</strong> 执行页面静态化。</p><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>在cms服务需要集成freemarker：</p><p>1、在CMS服务中加入freemarker的依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--freemarker--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、在application.yml配置freemarker</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">31001</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc-service-manage-cms</span>  <span class="hljs-attr">data:</span>    <span class="hljs-attr">mongodb:</span>      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://root:123123@localhost:27017</span>      <span class="hljs-attr">database:</span> <span class="hljs-string">xc_cms</span>  <span class="hljs-attr">freemarker:</span>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#关闭模板缓存，方便测试</span>    <span class="hljs-attr">settings:</span>      <span class="hljs-attr">template_update_delay:</span> <span class="hljs-number">0</span></code></pre></div><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>静态化方法在静态化测试章节已经实现</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>调用 <code>service</code> 的静态化方法，将静态化内容通过 <code>response</code> 输出到浏览器显示</p><p>创建 <code>CmsPagePreviewController</code> 类，用于页面预览：</p><p>请求页面id，查询得到页面的模板信息、数据模型 <code>url</code>，根据模板和数据生成静态化内容，并输出到浏览器。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPagePreviewController</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PageService pageService;    <span class="hljs-comment">//接收到页面id</span>    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/cms/preview/&#123;pageId&#125;"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preView</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"pageId"</span>)</span> String pageId) <span class="hljs-keyword">throws</span> IOException, TemplateException </span>&#123;        String pageHtml = pageService.getPageHtml(pageId);        <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(pageHtml))&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//通过response对象将页面内容输出</span>                ServletOutputStream outputStream = response.getOutputStream();                outputStream.write(pageHtml.getBytes(<span class="hljs-string">"utf-8"</span>));            &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="2、页面预览测试"><a href="#2、页面预览测试" class="headerlink" title="2、页面预览测试"></a>2、页面预览测试</h2><h3 id="配置nginx代理"><a href="#配置nginx代理" class="headerlink" title="配置nginx代理"></a>配置nginx代理</h3><blockquote><p>这里说一下我们为什么要通过nginx代理来配置页面预览，因为在实际生产环境中，我们的cms节点可能会有多个，需要从nginx进行反向代理，实现负载均衡的等需求。</p></blockquote><p>为了通过 <code>nginx</code> 请求静态资源（<code>css</code>、图片等），通过 <code>nginx</code> 代理进行页面预览。</p><p>在<a href="http://www.xuecheng.xn--com:-2h5f960ibngim6ct9m7zz/">www.xuecheng.com虚拟主机配置：</a></p><div class="hljs"><pre><code class="hljs c">#页面预览location /cms/preview/ &#123;proxy_pass http:<span class="hljs-comment">//cms_server_pool/cms/preview/;</span>&#125;</code></pre></div><p>配置 <code>cms_server_pool</code> 将请求转发到 <code>cms</code>：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#cms页面预览</span>upstream cms_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">31001</span> weight=<span class="hljs-number">10</span>;&#125;</code></pre></div><p>全部配置</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#cms页面预览</span>upstream cms_server_pool&#123;server <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">31001</span> weight=<span class="hljs-number">10</span>;&#125;server&#123;<span class="hljs-built_in">listen</span>       <span class="hljs-number">80</span>;server_name  www.xuecheng.com;ssi on;ssi_silent_errors on;location / &#123;alias  C:/Users/root/Desktop/笔记/demos/JavaEE/微服务/Project/XueChengOnline/xcEduUI01/xc-ui-pc-<span class="hljs-keyword">static</span>-portal/;index  index.html;&#125;#页面预览location /cms/preview/ &#123;proxy_pass http:<span class="hljs-comment">//cms_server_pool/cms/preview/;</span>&#125;&#125;</code></pre></div><p>重新加载nginx 配置文件。<br>从cms_page找一个页面进行测试。注意：页面配置一定要正确，需设置正确的模板 <code>id</code> 和<code>dataUrl</code>。</p><p>在浏览器打开：<a href="http://www.xuecheng.com/cms/preview/5e7a251a3304a252280804dc" target="_blank" rel="noopener">http://www.xuecheng.com/cms/preview/5e7a251a3304a252280804dc</a></p><p>5e7a251a3304a252280804dc：轮播图页面的id （根据自己实际用于测试的页面ID）</p><p><a href="https://qnoss.codeyee.com/20200704_xuechengday04/image24" target="_blank" rel="noopener"><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image24.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="添加-“页面预览”-链接"><a href="#添加-“页面预览”-链接" class="headerlink" title="添加 “页面预览” 链接"></a>添加 “页面预览” 链接</h3><p>添加预览按钮</p><div class="hljs"><pre><code class="hljs java"> &lt;el-table-column label=<span class="hljs-string">"操作"</span> width=<span class="hljs-string">"230"</span> fixed=<span class="hljs-string">"right"</span>&gt;    &lt;template slot-scope=<span class="hljs-string">"scope"</span>&gt;        &lt;el-button        size=<span class="hljs-string">"mini"</span>        type=<span class="hljs-string">"success"</span>        <span class="hljs-meta">@click</span>=<span class="hljs-string">"preview(scope.row.pageId)"</span>&gt;预览        &lt;/el-button&gt;    &lt;/template&gt;&lt;/el-table-column&gt;</code></pre></div><p>预览函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//页面预览</span>preview(pageId)&#123;  <span class="hljs-built_in">window</span>.open(<span class="hljs-string">"http://www.xuecheng.com/cms/preview/"</span>+pageId)&#125;,</code></pre></div><p>测试</p><p><img src="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/image25.gif" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Freemarker</tag>
      
      <tag>GridFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day03：CMS页面管理开发</title>
    <link href="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/"/>
    <url>/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day03</code> 的内容</p><ul><li>使用 <code>Spring data</code> 提供的 <code>PageRequest</code> 模块进行分页查询的应用</li><li>使用 <code>Spring data</code> 提供 <code>MongoDB</code> 的dao接口进行前后端联调的 CRUD 操作</li><li>基于 <code>VUE.JS</code> 的前端模块化开发</li><li>使用统一的响应模型、状态码进行 <code>RESTful</code> 风格的API开发</li><li>熟悉使用 <code>Swagger</code> 进行接口文档的生成与测试</li><li>异常处理以及如何自定义异常，根据不同的异常自定义返回的消息格式。</li></ul><h1 id="一、自定义条件查询"><a href="#一、自定义条件查询" class="headerlink" title="一、自定义条件查询"></a>一、自定义条件查询</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>在页面输入查询条件，查询符合条件的页面信息。</p><p>查询条件如下：</p><p>站点Id：精确匹配</p><p>模板Id：精确匹配</p><p>页面别名：模糊匹配</p><h2 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h2><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>使用 <code>CmsPageRepository</code> 中的 <code>findAll(Example&lt;S&gt; var1, Pageable var2)</code> 方法实现，无需定义。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>下边测试findAll方法实现自定义条件查询：</p><p>1、指定站点id、模板id作为查询条件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//自定义条件查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDiyFindAll</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//精确匹配条件值</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    cmsPage.setSiteId(<span class="hljs-string">"5a751fab6abb5044e0d19ea1"</span>);    cmsPage.setTemplateId(<span class="hljs-string">"5a925be7b00ffc4b3c1578b5"</span>);    <span class="hljs-comment">//条件匹配器,用于模糊匹配</span>    ExampleMatcher matching = ExampleMatcher.matching();    <span class="hljs-comment">//条件查询实例</span>    Example&lt;CmsPage&gt; example = Example.of(cmsPage, matching);    <span class="hljs-comment">//分页参数</span>    <span class="hljs-keyword">int</span> page = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> size = <span class="hljs-number">20</span>;    Pageable pageable = PageRequest.of(page,size);    <span class="hljs-comment">//调用dao</span>    Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(example, pageable);    List&lt;CmsPage&gt; content = all.getContent();    System.out.println(content);&#125;</code></pre></div><p>查询结果</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image1.png" srcset="/img/loading.gif" alt></p><p>在上面的代码基础上，增加 <code>ExampleMatcher</code> 实例的一些属性作为模糊查询的参数，增加的代码如下</p><div class="hljs"><pre><code class="hljs java">cmsPage.setPageAliase(<span class="hljs-string">"详细"</span>);<span class="hljs-comment">//条件匹配器,用于模糊匹配</span>ExampleMatcher matching = ExampleMatcher.matching()       .withMatcher(<span class="hljs-string">"pageAliase"</span>,ExampleMatcher.GenericPropertyMatchers.contains());</code></pre></div><p><code>.withMatcher</code> 的第一个参数表示要将哪个字段进行匹配，第二个则是要使用的匹配器；</p><p><code>ExampleMatcher.GenericPropertyMatchers</code> 有多个匹配器，这里我们用 <code>.contains()</code> 进行模糊匹配</p><p><a href="https://qnoss.codeyee.com/20200704_3/image2" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image2.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>CmsPageRepository cmsPageRepository;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page 页号</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> size 每页大小</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queryPageRequest 查询条件</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page,<span class="hljs-keyword">int</span> size,QueryPageRequest queryPageRequest)</span> </span>&#123;    <span class="hljs-comment">//判断条件对象是否为空</span>    <span class="hljs-keyword">if</span>(queryPageRequest == <span class="hljs-keyword">null</span>)&#123;        queryPageRequest = <span class="hljs-keyword">new</span> QueryPageRequest();    &#125;    <span class="hljs-comment">//匹配条件值</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    <span class="hljs-comment">//设置条件值</span>    <span class="hljs-comment">//站点ID</span>    <span class="hljs-keyword">if</span>(!StringUtil.isNullOrEmpty(queryPageRequest.getSiteId()))&#123;        cmsPage.setSiteId(queryPageRequest.getSiteId());    &#125;    <span class="hljs-comment">//模板ID</span>    <span class="hljs-keyword">if</span>(!StringUtil.isNullOrEmpty(queryPageRequest.getTemplateId()))&#123;        cmsPage.setTemplateId(queryPageRequest.getTemplateId());    &#125;    <span class="hljs-comment">//站点别名</span>    <span class="hljs-keyword">if</span>(!StringUtil.isNullOrEmpty(queryPageRequest.getPageAliase()))&#123;        cmsPage.setPageAliase(queryPageRequest.getPageAliase());    &#125;    <span class="hljs-comment">//条件匹配器，用于模糊查询</span>    ExampleMatcher exampleMatcher = ExampleMatcher.matching()            .withMatcher(<span class="hljs-string">"pageAliase"</span>, ExampleMatcher.GenericPropertyMatchers.contains());    <span class="hljs-comment">//条件查询实例</span>    Example&lt;CmsPage&gt; example = Example.of(cmsPage, exampleMatcher);    <span class="hljs-comment">//过滤条件</span>    <span class="hljs-keyword">if</span>(page &lt;= <span class="hljs-number">0</span>)&#123;        page = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;        size = <span class="hljs-number">10</span>;    &#125;    page = page - <span class="hljs-number">1</span>;    <span class="hljs-comment">//创建分页查询参数</span>    PageRequest pageable = PageRequest.of(page, size);    <span class="hljs-comment">//分页查询数据</span>    Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(example, pageable);    <span class="hljs-comment">//整理查询到的数据</span>    QueryResult queryResult = <span class="hljs-keyword">new</span> QueryResult();    queryResult.setList(all.getContent());    queryResult.setTotal(all.getTotalElements());    <span class="hljs-comment">//返回结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);&#125;</code></pre></div><p>Controller层无需修改</p><h3 id="使用SwaggerUI测试"><a href="#使用SwaggerUI测试" class="headerlink" title="使用SwaggerUI测试"></a>使用SwaggerUI测试</h3><p>参数</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image3.png" srcset="/img/loading.gif" alt="img"></p><p>查询结果</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image4.png" srcset="/img/loading.gif" alt="img"></p><p>从查询结果中我们可以看出，根据我们输入的条件，查询到了指定 <code>sizeId</code> 并且 <code>pageAliase</code> 包含预览的信息。</p><h2 id="3-前端"><a href="#3-前端" class="headerlink" title="3. 前端"></a>3. 前端</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>1、增加查询表单</p><blockquote><p>在el-table上方添加该表单</p></blockquote><div class="hljs"><pre><code class="hljs vue">&lt;!--查询表单--&gt;&lt;el-form :model&#x3D;&quot;params&quot;&gt;  &lt;el-select v-model&#x3D;&quot;params.siteId&quot; placeholder&#x3D;&quot;请选择站点&quot;&gt;    &lt;el-option    v-for&#x3D;&quot;item in siteList&quot;    :key&#x3D;&quot;item.siteId&quot;    :label&#x3D;&quot;item.siteName&quot;    :value&#x3D;&quot;item.siteId&quot;&gt;    &lt;&#x2F;el-option&gt;  &lt;&#x2F;el-select&gt;  页面别名: &lt;el-input v-model&#x3D;&quot;params.pageAliase&quot; style&#x3D;&quot;width: 100px&quot;&gt;&lt;&#x2F;el-input&gt;&lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;query&quot; size&#x3D;&quot;small&quot;&gt;查询&lt;&#x2F;el-button&gt;&lt;&#x2F;el-form&gt;</code></pre></div><p>2、新增数据模型对象</p><div class="hljs"><pre><code class="hljs js">data() &#123;  <span class="hljs-keyword">return</span> &#123;    siteList:[],<span class="hljs-comment">//站点列表</span>    list:[],    total:<span class="hljs-number">0</span>,    params:&#123;      siteId:<span class="hljs-string">''</span>,      pageAliase:<span class="hljs-string">''</span>,      page:<span class="hljs-number">1</span>,<span class="hljs-comment">//页码</span>      size:<span class="hljs-number">10</span><span class="hljs-comment">//每页显示个数</span>    &#125;  &#125;&#125;,</code></pre></div><p>3、在钩子方法中 获取 <code>siteList</code> 站点列表（这里暂时用静态数据代替）</p><div class="hljs"><pre><code class="hljs js">mounted() &#123;  <span class="hljs-comment">//默认查询页面</span>  <span class="hljs-keyword">this</span>.query()  <span class="hljs-comment">//初始化站点列表</span>  <span class="hljs-keyword">this</span>.siteList = [    &#123;      siteId:<span class="hljs-string">'5a751fab6abb5044e0d19ea1'</span>,      siteName:<span class="hljs-string">'门户主站'</span>    &#125;,    &#123;      siteId:<span class="hljs-string">'102'</span>,      siteName:<span class="hljs-string">'测试站'</span>    &#125;  ]&#125;,</code></pre></div><h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><p>1、向服务端传递查询条件，修改 cms.js，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//public是对axios的工具类封装，定义了http请求方法</span><span class="hljs-keyword">import</span> http from <span class="hljs-string">'./../../../base/api/public'</span>  <span class="hljs-comment">//ES6 导入</span><span class="hljs-keyword">import</span> querystring from <span class="hljs-string">"querystring"</span>let sysConfig = require(<span class="hljs-string">'@/../config/sysConfig'</span>)let apiUrl = sysConfig.xcApiUrlPre<span class="hljs-comment">//页面查询</span>export <span class="hljs-keyword">const</span> page_list = (page,size,params) =&gt; &#123;  <span class="hljs-comment">//将json对象转成key/value对</span>  let queryString = querystring.stringify(params);  <span class="hljs-comment">//定义方法，请求服务端查询接口</span>  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl + <span class="hljs-string">'/cms/page/list/'</span>+page+<span class="hljs-string">'/'</span>+ size +<span class="hljs-string">'?'</span> + queryString)&#125;</code></pre></div><p>2、页面调用api方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//查询</span>query:function () &#123;  <span class="hljs-comment">//调用服务端接口</span>  cmsApi.page_list(<span class="hljs-keyword">this</span>.params.page, <span class="hljs-keyword">this</span>.params.size, <span class="hljs-keyword">this</span>.params).then((res) =&gt;&#123;    console.log(res)    <span class="hljs-comment">//将res结果数据赋值给数据模型对象</span>    <span class="hljs-keyword">this</span>.list = res.queryResult.list    <span class="hljs-keyword">this</span>.total = res.queryResult.total  &#125;)&#125;</code></pre></div><p>3、测试</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image5.png" srcset="/img/loading.gif" alt="img"></p><h1 id="二、新增页面"><a href="#二、新增页面" class="headerlink" title="二、新增页面"></a>二、新增页面</h1><h2 id="1-准备工作，页面管理API"><a href="#1-准备工作，页面管理API" class="headerlink" title="1.准备工作，页面管理API"></a>1.准备工作，页面管理API</h2><p>在配置新增页面的功能之前，我们先配置一个接口，用于获取页面的信息</p><h3 id="Dao层-1"><a href="#Dao层-1" class="headerlink" title="Dao层"></a>Dao层</h3><p>CmsPageRepository</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 继承MongoDB自带的Repository</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  22:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsPage</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="定义查询模型"><a href="#定义查询模型" class="headerlink" title="定义查询模型"></a>定义查询模型</h3><p>QueryPageRequest</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.cms.request;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  21:13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPageRequest</span> </span>&#123;    <span class="hljs-comment">//接收页面查询的查询条件</span>    <span class="hljs-comment">//站点id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"站点id"</span>)    <span class="hljs-keyword">private</span> String siteId;    <span class="hljs-comment">//页面id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面id"</span>)    <span class="hljs-keyword">private</span> String pageId;    <span class="hljs-comment">//页面名称</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面名称"</span>)    <span class="hljs-keyword">private</span> String pageName;    <span class="hljs-comment">//别名</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"别名"</span>)    <span class="hljs-keyword">private</span> String pageAliase;    <span class="hljs-comment">//模板id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"模板id"</span>)    <span class="hljs-keyword">private</span> String templateId;    <span class="hljs-comment">//...</span>&#125;</code></pre></div><h3 id="定义响应模型"><a href="#定义响应模型" class="headerlink" title="定义响应模型"></a>定义响应模型</h3><p>CmsPageResult</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    CmsPage cmsPage;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmsPageResult</span><span class="hljs-params">(ResultCode resultCode,CmsPage cmsPage)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.cmsPage = cmsPage;    &#125;&#125;</code></pre></div><h3 id="Service层-1"><a href="#Service层-1" class="headerlink" title="Service层"></a>Service层</h3><p>PageService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    &#125;</code></pre></div><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>定义页面相关操作的api</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  21:16</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"cms页面管理接口"</span>,description = <span class="hljs-string">"cms页面管理接口，提供页面的增，删，改，查"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-comment">//页面查询</span>    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"分页查询页面列表"</span>)    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"page"</span>,value = <span class="hljs-string">"页码"</span>,required = <span class="hljs-keyword">true</span>,paramType = <span class="hljs-string">"path"</span>,dataType = <span class="hljs-string">"int"</span>),            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"size"</span>,value = <span class="hljs-string">"每页记录数"</span>,required = <span class="hljs-keyword">true</span>,paramType = <span class="hljs-string">"path"</span>,dataType = <span class="hljs-string">"int"</span>)    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest)</span></span>; &#125;</code></pre></div><p>CmsPageController</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.cms.CmsPageControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.response.CmsPageResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.service.PageService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  22:04</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/cms/page"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PageService pageService;        <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list/&#123;page&#125;/&#123;size&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page, </span><span class="hljs-function">               @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest) </span>&#123;                   QueryResponseResult responseResult = pageService.findList(page, size, queryPageRequest);        <span class="hljs-keyword">return</span> responseResult;    &#125;</code></pre></div><p>测试</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image6.png" srcset="/img/loading.gif" alt="img"></p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image7.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-后端接口定义"><a href="#2-后端接口定义" class="headerlink" title="2.后端接口定义"></a>2.后端接口定义</h2><h3 id="1、定义响应模型"><a href="#1、定义响应模型" class="headerlink" title="1、定义响应模型"></a>1、定义响应模型</h3><blockquote><p>用于接口的响应规范，继承于项目中的ResponseResult</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    CmsPage cmsPage;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmsPageResult</span><span class="hljs-params">(ResultCode resultCode,CmsPage cmsPage)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.cmsPage = cmsPage;&#125;&#125;</code></pre></div><h3 id="2、定义添加Api"><a href="#2、定义添加Api" class="headerlink" title="2、定义添加Api"></a>2、定义添加Api</h3><p>在 <code>CmsPageControllerApi</code> 中新增 <code>addCmsPage</code> 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加页面数据</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"添加页面数据"</span>)<span class="hljs-meta">@ApiImplicitParams</span>(&#123;        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"cmsPage"</span>,value = <span class="hljs-string">"请提交json形式的页面数据"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"CmsPage"</span>,dataType=<span class="hljs-string">"CmsPage"</span>),&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span></span>;</code></pre></div><h2 id="3-服务端开发"><a href="#3-服务端开发" class="headerlink" title="3. 服务端开发"></a>3. 服务端开发</h2><h3 id="1、页面唯一值索引"><a href="#1、页面唯一值索引" class="headerlink" title="1、页面唯一值索引"></a>1、页面唯一值索引</h3><blockquote><p>为了保证站点的唯一性，所以我们要根据 sizeId、pageName、pageWebPath 这三个字段来决定站点的数据是否唯一。</p></blockquote><p>右键 <code>cms_page</code> 集合，选择 <code>Add Index</code> 添加一个索引</p><p><a href="https://qnoss.codeyee.com/20200704_3/image8" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>根据下图所示，点击 <code>Add Field</code> 按钮，选择 sizeId、pageName、pageWebPath 这三个字段，然后点击添加，选择第三步所示的 <code>Unique</code>，最后点击右边的 <code>Create Index</code> 创建索引。</p><p><a href="https://qnoss.codeyee.com/20200704_3/image9" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>创建成功后</p><p><a href="https://qnoss.codeyee.com/20200704_3/image10" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image10.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="2、Dao层"><a href="#2、Dao层" class="headerlink" title="2、Dao层"></a>2、Dao层</h3><p>1、添加根据页面名称、站点Id、页面webpath查询页面方法，此方法用于校验页面是否存在</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据站点id、站点名称、站点路径来查询站点信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> siteId</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageName</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageWebPath</span><span class="hljs-comment"> */</span><span class="hljs-function">CmsPage <span class="hljs-title">findBySiteIdAndPageNameAndPageWebPath</span><span class="hljs-params">(String siteId, String pageName, String pageWebPath)</span></span>;</code></pre></div><p>2、使用 CmsPageRepository提供的save方法 。</p><h3 id="3、Service层"><a href="#3、Service层" class="headerlink" title="3、Service层"></a>3、Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加页面数据</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span></span>&#123;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage cmsPage1 = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());    <span class="hljs-keyword">if</span>(cmsPage1 == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//站点id由mongoDB自动生成，防止前端传值</span>        cmsPage.setPageId(<span class="hljs-keyword">null</span>);        CmsPage save = cmsPageRepository.save(cmsPage);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS,save);    &#125;    <span class="hljs-comment">//添加失败</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL,cmsPage);&#125;</code></pre></div><h3 id="4、Controller层"><a href="#4、Controller层" class="headerlink" title="4、Controller层"></a>4、Controller层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/add"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(@RequestBody CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-keyword">return</span> pageService.addCmsPage(cmsPage);&#125;</code></pre></div><h3 id="5、接口测试"><a href="#5、接口测试" class="headerlink" title="5、接口测试"></a>5、接口测试</h3><p>我们在 <code>swagger</code> 自动生成的文档接口中进行测试</p><p><a href="https://qnoss.codeyee.com/20200704_3/image11" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p>第一次添加，添加成功</p><p><a href="https://qnoss.codeyee.com/20200704_3/image12" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>第二次添加重复的内容，由于唯一性的效验，返回添加失败</p><p><a href="https://qnoss.codeyee.com/20200704_3/image13" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image13.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-前端开发"><a href="#4-前端开发" class="headerlink" title="4. 前端开发"></a>4. 前端开发</h2><h3 id="构建新增页面"><a href="#构建新增页面" class="headerlink" title="构建新增页面"></a>构建新增页面</h3><h4 id="1、页面创建"><a href="#1、页面创建" class="headerlink" title="1、页面创建"></a>1、页面创建</h4><p>使用Element-UI的form组件编写添加表单内容，页面效果如下：</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image14.png" srcset="/img/loading.gif" alt="img"></p><p><strong>1）创建页面</strong></p><p>创建page_add.vue页面</p><p><strong>2）配置路由</strong></p><p>在cms模块的路由文件中配置“添加页面”的路由：</p><div class="hljs"><pre><code class="hljs vue">&#123;path:&#39;&#x2F;cms&#x2F;page&#x2F;add&#39;,name:&#39;新增页面&#39;,component: page_add,hidden:true&#125;</code></pre></div><p>注意：由于 “添加页面” 不需要显示为一个菜单，这里 <code>hidden</code> 设置为 <code>true</code> 隐藏菜单。</p><p>测试，在浏览器地址栏输入<a href="http://localhost:11000/#/cms/page/add" target="_blank" rel="noopener">http://localhost:11000/#/cms/page/add</a></p><p><strong>3）“添加页面” 的按钮</strong></p><p>实际情况是用户进入页面查询列表，点击“新增页面”按钮进入新增页面窗口。</p><p>在查询按钮的旁边添加：</p><div class="hljs"><pre><code class="hljs vue">&lt;router‐link class&#x3D;&quot;mui‐tab‐item&quot; :to&#x3D;&quot;&#123;path:&#39;&#x2F;cms&#x2F;page&#x2F;add&#x2F;&#39;&#125;&quot;&gt;&lt;el‐button type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot;&gt;新增页面&lt;&#x2F;el‐button&gt;&lt;&#x2F;router‐link&gt;</code></pre></div><blockquote><p>router-link是vue提供的路由功能，用于在页面生成路由链接，最终在html渲染后就是&lt;a标签。<br>to：目标路由地址</p></blockquote><p><strong>4）完善页面内容</strong></p><div class="hljs"><pre><code class="hljs vue">&lt;el-form :model&#x3D;&quot;pageForm&quot; label-width&#x3D;&quot;80px&quot;&gt;  &lt;el-form-item label&#x3D;&quot;所属站点&quot; prop&#x3D;&quot;siteId&quot;&gt;    &lt;el-select v-model&#x3D;&quot;pageForm.siteId&quot; placeholder&#x3D;&quot;请选择站点&quot;&gt;      &lt;el-option        v-for&#x3D;&quot;item in siteList&quot;        :key&#x3D;&quot;item.siteId&quot;        :label&#x3D;&quot;item.siteName&quot;        :value&#x3D;&quot;item.siteId&quot;&gt;      &lt;&#x2F;el-option&gt;    &lt;&#x2F;el-select&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;选择模版&quot; prop&#x3D;&quot;templateId&quot;&gt;    &lt;el-select v-model&#x3D;&quot;pageForm.templateId&quot; placeholder&#x3D;&quot;请选择&quot;&gt;      &lt;el-option        v-for&#x3D;&quot;item in templateList&quot;        :key&#x3D;&quot;item.templateId&quot;        :label&#x3D;&quot;item.templateName&quot;        :value&#x3D;&quot;item.templateId&quot;&gt;      &lt;&#x2F;el-option&gt;    &lt;&#x2F;el-select&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;页面名称&quot; prop&#x3D;&quot;pageName&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pageName&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;别名&quot; prop&#x3D;&quot;pageAliase&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pageAliase&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;访问路径&quot; prop&#x3D;&quot;pageWebPath&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pageWebPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;物理路径&quot; prop&#x3D;&quot;pagePhysicalPath&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pagePhysicalPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;类型&quot;&gt;    &lt;el-radio-group v-model&#x3D;&quot;pageForm.pageType&quot;&gt;      &lt;el-radio label&#x3D;&quot;0&quot;&gt;静态&lt;&#x2F;el-radio&gt;      &lt;el-radio label&#x3D;&quot;1&quot;&gt;动态&lt;&#x2F;el-radio&gt;    &lt;&#x2F;el-radio-group&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;创建时间&quot;&gt;    &lt;el-date-picker type&#x3D;&quot;datetime&quot; placeholder&#x3D;&quot;创建时间&quot; v-model&#x3D;&quot;pageForm.pageCreateTime&quot;&gt;    &lt;&#x2F;el-date-picker&gt;  &lt;&#x2F;el-form-item&gt;&lt;&#x2F;el-form&gt;&lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;  &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addSubmit&quot;&gt;提交&lt;&#x2F;el-button&gt;&lt;&#x2F;div&gt;</code></pre></div><p>Form Attributes说明：</p><ul><li>model 表单数据对象</li><li>rules 表单验证规则</li></ul><p>Form-Item Attributes说明：</p><ul><li>prop 表单域 model 字段，在使用 validate、resetFields 方法的情况下，该属性是必填的</li><li>label 标签文本</li></ul><p>详情属性及事件参考 <a href="http://element.eleme.io/#/zh-CN/component/form" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/form</a></p><p><strong>5）数据对象</strong></p><div class="hljs"><pre><code class="hljs js">  <span class="hljs-comment">//站点列表</span>    siteList: [],    <span class="hljs-comment">//模版列表</span>    templateList: [],    <span class="hljs-comment">//新增界面数据</span>    pageForm: &#123;      siteId: <span class="hljs-string">''</span>,      templateId: <span class="hljs-string">''</span>,      pageName: <span class="hljs-string">''</span>,      pageAliase: <span class="hljs-string">''</span>,      pageWebPath: <span class="hljs-string">''</span>,      pageParameter: <span class="hljs-string">''</span>,      pagePhysicalPath: <span class="hljs-string">''</span>,      pageType: <span class="hljs-string">'0'</span>,  <span class="hljs-comment">//默认选中0</span>      pageCreateTime: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()    &#125;  &#125;&#125;,methods: &#123;  addSubmit() &#123;    alert(<span class="hljs-string">"提交"</span>)  &#125;,&#125;</code></pre></div><p><strong>6）站点及模板数据</strong></p><p>定义请求api</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//获取所有站点信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> site_list = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestGet(apiUrl + <span class="hljs-string">"/cms/site/list"</span>)&#125;<span class="hljs-comment">//获取所有模板信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> template_list = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestGet(apiUrl + <span class="hljs-string">"/cms/template/list"</span>)&#125;</code></pre></div><blockquote><p>在created钩子中定义，原讲义内使用的是静态数据</p></blockquote><div class="hljs"><pre><code class="hljs js">created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//初始化站点数据</span>    cmsApi.site_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"站点数据"</span>,res)            <span class="hljs-comment">//赋值给站点信息列表</span>            <span class="hljs-keyword">this</span>.siteList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取站点信息时发生了错误"</span>, res)        &#125;    &#125;)    <span class="hljs-comment">//初始化模板数据</span>    cmsApi.template_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"模板数据"</span>,res)            <span class="hljs-comment">//赋值给模板列表</span>            <span class="hljs-keyword">this</span>.templateList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取模板信息时发生了错误"</span>, res)        &#125;    &#125;)&#125;,</code></pre></div><p><strong>7）测试预览</strong></p><p><a href="https://qnoss.codeyee.com/20200704_3/image15" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="2、添加返回"><a href="#2、添加返回" class="headerlink" title="2、添加返回"></a>2、添加返回</h4><blockquote><p>进入新增页面后只能通过菜单再次进入页面列表，可以在新增页面添加“返回”按钮，点击返回按钮返回到页面列表。</p></blockquote><ol><li>新增页面按钮带上参数</li></ol><div class="hljs"><pre><code class="hljs vue">&lt;router-link class&#x3D;&quot;mui-tab-item&quot;             :to&#x3D;&quot;&#123;path:&#39;&#x2F;cms&#x2F;page&#x2F;add&#x2F;&#39;, query:&#123; page:this.params.page,siteId:this.params.siteId &#125;&#125;&quot;&gt;  &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot;&gt;新增页面&lt;&#x2F;el-button&gt;&lt;&#x2F;router-link&gt;</code></pre></div><p>说明：query表示在路由url上带上参数</p><p>2）定义返回方法</p><p>在page_add.vue上定义返回按钮</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;go_back&quot; &gt;返回&lt;&#x2F;el‐button&gt;</code></pre></div><p>在page_add.vue上定义返回方法</p><div class="hljs"><pre><code class="hljs js">go_back()&#123;    <span class="hljs-keyword">this</span>.$router.push(&#123;        path: <span class="hljs-string">'/cms/page/list'</span>, <span class="hljs-attr">query</span>: &#123;        page: <span class="hljs-keyword">this</span>.$route.query.page,        siteId:<span class="hljs-keyword">this</span>.$route.query.siteId    &#125;    &#125;)&#125;</code></pre></div><p>说明：this.$route.query 表示取出路由上的参数列表，有两个取路由参数的方法：</p><blockquote><p>a、通过在路由上添加 key/value 串使用 <code>this.$route.query</code> 来取参数，例如：<code>/router1?id=123</code> , <code>/router1?id=456</code> 可以通过 <code>this.$route.query.id</code> 获取参数id的值。</p><p>b、通过将参数作为路由一部分进行传参数使用 <code>this.$route.params</code> 来获取，例如：定义的路由为 <code>/router1/:id</code> ，请求 <code>/router1/123</code> 时可以通过 <code>this.$route.params.id</code> 来获取，此种情况用 <code>this.$route.query.id</code> 是拿不到的。</p></blockquote><p>3）查询列表支持回显</p><p>进入查询列表，从url中获取页码和站点id并赋值给数据模型对象，从而实现页面回显。</p><p>url例子：<a href="http://localhost:12000/#/cms/page/list?page=2&amp;siteId=5a751fab6abb5044e0d19ea1" target="_blank" rel="noopener">http://localhost:12000/#/cms/page/list?page=2&amp;siteId=5a751fab6abb5044e0d19ea1</a></p><div class="hljs"><pre><code class="hljs js">created() &#123;    <span class="hljs-comment">//从路由上获取参数</span>    <span class="hljs-keyword">this</span>.params.page = <span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.$route.query.page||<span class="hljs-number">1</span>);    <span class="hljs-keyword">this</span>.params.siteId = <span class="hljs-keyword">this</span>.$route.query.siteId||<span class="hljs-string">''</span>;    .....&#125;</code></pre></div><blockquote><p>小技巧：使用 ||返回第一个有效值</p></blockquote><h4 id="1-3、表单验证"><a href="#1-3、表单验证" class="headerlink" title="1.3、表单验证"></a>1.3、表单验证</h4><p>1）配置校验规则</p><p>Element-UI的Form组件提供表单校验的方法：</p><p>在form属性上配置rules（表单验证规则）</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐form :model&#x3D;&quot;pageForm&quot; :rules&#x3D;&quot;pageFormRules&quot; label‐width&#x3D;&quot;80px&quot; &gt;</code></pre></div><p>在数据模型中配置校验规则：</p><div class="hljs"><pre><code class="hljs js">data() &#123;    <span class="hljs-keyword">return</span> &#123;        pageFormRules: &#123;            siteId:[                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择站点'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            templateId:[                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择模版'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pageName: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入页面名称'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pageAliase: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入页面别名'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pageWebPath: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入访问路径'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pagePhysicalPath: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入物理路径'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ]        &#125;,    &#125;&#125;</code></pre></div><p>更多的校验规则参考 <a href="http://element.eleme.io/#/zh-CN/component/form" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/form</a> 中“表单验证”的例子</p><p>2）点击提交按钮触发校验</p><p>在form表单上添加 ref属性（ref=”pageForm”）在校验时引用此表单对象</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐form :model&#x3D;&quot;pageForm&quot; :rules&#x3D;&quot;pageFormRules&quot; label‐width&#x3D;&quot;80px&quot; ref&#x3D;&quot;pageForm&quot;&gt;</code></pre></div><p>在提交表单时执行校验</p><div class="hljs"><pre><code class="hljs js">addSubmit() &#123;    <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (valid) &#123;            alert(<span class="hljs-string">'提交'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            alert(<span class="hljs-string">'校验失败'</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;)&#125;,</code></pre></div><p>测试</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image16.png" srcset="/img/loading.gif" alt="img"></p><h3 id="API调用-1"><a href="#API调用-1" class="headerlink" title="API调用"></a>API调用</h3><h4 id="1、在cms-js中定义page-add方法"><a href="#1、在cms-js中定义page-add方法" class="headerlink" title="1、在cms.js中定义page_add方法"></a>1、在cms.js中定义page_add方法</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_add = <span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl + <span class="hljs-string">"/cms/page/add"</span>,params)&#125;</code></pre></div><h4 id="2、添加事件"><a href="#2、添加事件" class="headerlink" title="2、添加事件"></a>2、添加事件</h4><p>完整的代码如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//提交表单</span>addSubmit()&#123;  <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (valid) &#123;      <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        cmsApi.page_add(<span class="hljs-keyword">this</span>.pageForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(res);          <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">this</span>.$message(&#123;              message: <span class="hljs-string">'提交成功'</span>,              type: <span class="hljs-string">'success'</span>          &#125;);          <span class="hljs-keyword">this</span>.$refs[<span class="hljs-string">'pageForm'</span>].resetFields();          &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);          &#125;        &#125;);      &#125;);    &#125;  &#125;)&#125;,</code></pre></div><p>本功能使用到两个UI组件：</p><ul><li>使用 <code>element-ui</code> 的 <code>message-box</code> 组件弹出确认提交窗口（<a href="http://element.eleme.io/#/zhCN/component/message-box%EF%BC%89" target="_blank" rel="noopener">http://element.eleme.io/#/zhCN/component/message-box）</a></li><li>使用 <code>message</code>组件提示操作结果 （<a href="http://element.eleme.io/#/zh-CN/component/message%EF%BC%89" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/message）</a></li></ul><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image17.gif" srcset="/img/loading.gif" alt="img"></p><h1 id="三、修改页面"><a href="#三、修改页面" class="headerlink" title="三、修改页面"></a>三、修改页面</h1><p>修改页面用户操作流程：</p><p>1、用户进入修改页面，在页面上显示了修改页面的信息</p><p>2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败”</p><h2 id="1-后端接口定义"><a href="#1-后端接口定义" class="headerlink" title="1. 后端接口定义"></a>1. 后端接口定义</h2><p>修改页面需要定义的API如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//根据页面id查询页面信息</span>    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"根据页面id查询页面信息"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPage <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span></span>;    <span class="hljs-comment">//修改页面</span>    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"修改页面"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">edit</span><span class="hljs-params">(String id,CmsPage cmsPage)</span></span>;</code></pre></div><blockquote><p>我们从前面定义的 findList 用的是 <code>QueryResponseResult</code> 作为响应模型，但是这里我们定义的 <code>CmsPageResult</code> 作为响应模型，两者的区别是什么？</p><p>我个人的理解是，<code>findList</code> 是分页查询并且返回了多个对象的信息，而 <code>findById</code> 则是查询单个对象的信息，所以 <code>CmsPageResult</code> 作为操作或查询单个对象时的响应模型，而 <code>QueryResponseResult</code> 则作为操作多个对象时的响应模型。</p></blockquote><p>说明：提交数据使用post、put都可以，只是根据http方法的规范，put方法是对服务器指定资源进行修改，所以这里使用put方法对页面修改进行修改。</p><h2 id="2-服务端开发"><a href="#2-服务端开发" class="headerlink" title="2. 服务端开发"></a>2. 服务端开发</h2><h3 id="Dao层-2"><a href="#Dao层-2" class="headerlink" title="Dao层"></a>Dao层</h3><p>使用 Spring Data提供的findById方法完成根据主键查询 。<br>使用 Spring Data提供的save方法完成数据保存 。</p><h3 id="Service层-2"><a href="#Service层-2" class="headerlink" title="Service层"></a>Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//根据页面id查询页面</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPage <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span> </span>&#123;        Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(id);        <span class="hljs-keyword">if</span> (optional.isPresent())&#123;            CmsPage cmsPage = optional.get();            <span class="hljs-keyword">return</span> cmsPage;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//修改页面</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">edit</span><span class="hljs-params">(String id, CmsPage cmsPage)</span> </span>&#123;        <span class="hljs-comment">//根据id从数据查询页面信息</span>        CmsPage updateCmsPage = <span class="hljs-keyword">this</span>.findById(id);        <span class="hljs-keyword">if</span> (updateCmsPage != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//设置要修改的数据</span>            updateCmsPage.setTemplateId(cmsPage.getTemplateId());            updateCmsPage.setSiteId(cmsPage.getSiteId());            updateCmsPage.setPageAliase(cmsPage.getPageAliase());            updateCmsPage.setPageName(cmsPage.getPageName());            updateCmsPage.setPageWebPath(cmsPage.getPageWebPath());            updateCmsPage.setPagePhysicalPath(cmsPage.getPagePhysicalPath());            <span class="hljs-comment">//提交修改</span>            cmsPageRepository.save(updateCmsPage);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS,updateCmsPage);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;</code></pre></div><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/get/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPage <span class="hljs-title">findById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;        <span class="hljs-keyword">return</span> pageService.findById(id);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/edit/&#123;id&#125;"</span>)<span class="hljs-comment">//put表示更新</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">edit</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id,@RequestBody CmsPage cmsPage) </span>&#123;        <span class="hljs-keyword">return</span> pageService.edit(id,cmsPage);    &#125;</code></pre></div><h2 id="3-修改：前端开发"><a href="#3-修改：前端开发" class="headerlink" title="3. 修改：前端开发"></a>3. 修改：前端开发</h2><h3 id="页面处理流程"><a href="#页面处理流程" class="headerlink" title="页面处理流程"></a>页面处理流程</h3><blockquote><p>可以参考新增的逻辑</p></blockquote><ol><li>进入页面，通过钩子方法请求服务端获取页面信息，并赋值给数据模型对象。</li><li>页面信息通过数据绑定在表单中显示。</li><li>用户修改信息点击 “提交” 请求服务端修改页面信息接口。</li></ol><h3 id="前端HTTP-API构建"><a href="#前端HTTP-API构建" class="headerlink" title="前端HTTP API构建"></a>前端HTTP API构建</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//查询单个页面信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_query = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestPut(apiUrl + <span class="hljs-string">"/cms/page/get/"</span> + id)&#125;<span class="hljs-comment">//更新接口</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_update = <span class="hljs-function">(<span class="hljs-params">id,params</span>) =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestPut(apiUrl + <span class="hljs-string">"/cms/page/edit/"</span> + id,params)&#125;<span class="hljs-comment">//获取站点和模板列表</span></code></pre></div><h3 id="添加页面路由"><a href="#添加页面路由" class="headerlink" title="添加页面路由"></a>添加页面路由</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> page_update <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/cms/page/page_update.vue'</span>;<span class="hljs-comment">//子菜单</span>children: [    &#123;        path: <span class="hljs-string">'/cms/page/edit/:pageId'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">"编辑页面信息"</span>,<span class="hljs-attr">component</span>: page_edit, <span class="hljs-attr">hidden</span>:<span class="hljs-literal">true</span>    &#125;,]</code></pre></div><p>path中的 <code>:pageId</code> 表示在路由url中定义了一个pageId变量</p><h3 id="构建前端页面"><a href="#构建前端页面" class="headerlink" title="构建前端页面"></a>构建前端页面</h3><p>在 <code>page_list</code> 页面新增编辑按钮</p><div class="hljs"><pre><code class="hljs vue">&lt;el-table-column label&#x3D;&quot;编辑&quot; width&#x3D;&quot;75&quot; fixed&#x3D;&quot;right&quot;&gt;    &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;&lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;info&quot; @click&#x3D;&quot;toEdit(scope.row.pageId)&quot;&gt;编辑&lt;&#x2F;el-button&gt;    &lt;&#x2F;template&gt;&lt;&#x2F;el-table-column&gt;</code></pre></div><p>增加跳转edit页面的函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//跳转至编辑页面</span>toEdit(pageId)&#123;  <span class="hljs-keyword">this</span>.$router.push(&#123;    path:<span class="hljs-string">"/cms/page/edit/"</span> + pageId,    query:&#123;      page:<span class="hljs-keyword">this</span>.params.page,      siteId:<span class="hljs-keyword">this</span>.params.siteId    &#125;  &#125;)&#125;,</code></pre></div><p>使用 <code>scope</code> 获取当前行数据中的 <code>pageId</code> 传入 toEdit 函数进行页面跳转</p><p>完成<code>page_edit.vue</code> 页面的基本构造</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-form :model&#x3D;&quot;pageForm&quot; label-width&#x3D;&quot;80px&quot; :rules&#x3D;&quot;pageFormRules&quot; ref&#x3D;&quot;pageForm&quot;&gt;      &lt;el-form-item label&#x3D;&quot;所属站点&quot; prop&#x3D;&quot;siteId&quot;&gt;        &lt;el-select v-model&#x3D;&quot;pageForm.siteId&quot; placeholder&#x3D;&quot;请选择站点&quot;&gt;          &lt;el-option            v-for&#x3D;&quot;item in siteList&quot;            :key&#x3D;&quot;item.siteId&quot;            :label&#x3D;&quot;item.siteName&quot;            :value&#x3D;&quot;item.siteId&quot;&gt;          &lt;&#x2F;el-option&gt;        &lt;&#x2F;el-select&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;选择模版&quot; prop&#x3D;&quot;templateId&quot;&gt;        &lt;el-select v-model&#x3D;&quot;pageForm.templateId&quot; placeholder&#x3D;&quot;请选择&quot;&gt;          &lt;el-option            v-for&#x3D;&quot;item in templateList&quot;            :key&#x3D;&quot;item.templateId&quot;            :label&#x3D;&quot;item.templateName&quot;            :value&#x3D;&quot;item.templateId&quot;&gt;          &lt;&#x2F;el-option&gt;        &lt;&#x2F;el-select&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;页面名称&quot; prop&#x3D;&quot;pageName&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pageName&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;别名&quot; prop&#x3D;&quot;pageAliase&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pageAliase&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;访问路径&quot; prop&#x3D;&quot;pageWebPath&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pageWebPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;物理路径&quot; prop&#x3D;&quot;pagePhysicalPath&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pagePhysicalPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;类型&quot;&gt;        &lt;el-radio-group v-model&#x3D;&quot;pageForm.pageType&quot;&gt;          &lt;el-radio class&#x3D;&quot;radio&quot; label&#x3D;&quot;0&quot; &gt;静态&lt;&#x2F;el-radio&gt;          &lt;el-radio class&#x3D;&quot;radio&quot; label&#x3D;&quot;1&quot; &gt;动态&lt;&#x2F;el-radio&gt;        &lt;&#x2F;el-radio-group&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;创建时间&quot;&gt;        &lt;el-date-picker type&#x3D;&quot;datetime&quot; placeholder&#x3D;&quot;创建时间&quot; v-model&#x3D;&quot;pageForm.pageCreateTime&quot;&gt;        &lt;&#x2F;el-date-picker&gt;      &lt;&#x2F;el-form-item&gt;    &lt;&#x2F;el-form&gt;    &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;      &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addSubmit&quot;&gt;提交&lt;&#x2F;el-button&gt;      &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;goBack&quot;&gt;返回&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import * as cmsApi from &#39;..&#x2F;api&#x2F;cms&#39;  export default &#123;    created: function () &#123;    &#125;,    mounted() &#123;    &#125;,    data() &#123;      return &#123;        pageFormRules: &#123;          siteId: [            &#123;required: true, message: &#39;请选择站点&#39;, trigger: &#39;blur&#39;&#125;          ],          templateId: [            &#123;required: true, message: &#39;请选择模版&#39;, trigger: &#39;blur&#39;&#125;          ],          pageName: [            &#123;required: true, message: &#39;请输入页面名称&#39;, trigger: &#39;blur&#39;&#125;          ],          pageAliase: [            &#123;required: true, message: &#39;请输入页面别名&#39;, trigger: &#39;blur&#39;&#125;          ],          pageWebPath: [            &#123;required: true, message: &#39;请输入访问路径&#39;, trigger: &#39;blur&#39;&#125;          ],          pagePhysicalPath: [            &#123;required: true, message: &#39;请输入物理路径&#39;, trigger: &#39;blur&#39;&#125;          ]        &#125;,        &#x2F;&#x2F;站点列表        siteList: [],        &#x2F;&#x2F;模版列表        templateList: [],        &#x2F;&#x2F;新增界面数据        pageForm: &#123;          siteId: &#39;&#39;,          templateId: &#39;&#39;,          pageName: &#39;&#39;,          pageAliase: &#39;&#39;,          pageWebPath: &#39;&#39;,          pageParameter: &#39;&#39;,          pagePhysicalPath: &#39;&#39;,          pageType: &#39;&#39;,          pageCreateTime: new Date()        &#125;      &#125;    &#125;,    methods: &#123;      &#x2F;&#x2F;返回上一页      goBack() &#123;        this.$router.push(&#123;          path: &quot;&#x2F;cms&#x2F;page&#x2F;list&quot;,          query: &#123;            page: this.$route.query.page,            siteId: this.$route.query.siteId          &#125;        &#125;)      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><h4 id="1、页面初始化"><a href="#1、页面初始化" class="headerlink" title="1、页面初始化"></a>1、页面初始化</h4><p>在钩子函数 <code>created</code> 中进行一些数据的初始化请求，例如站点、模板的信息，用于下拉框的选择，以及在打开编辑页面之前，用户需要获取当前编辑的页面原有的数据，所以我们需要使用 <code>page_list</code> 页面通过的 <code>pageId</code> 来获取当前编辑的页面的数据。</p><div class="hljs"><pre><code class="hljs js">created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-comment">//初始化站点数据</span>    cmsApi.site_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"站点数据"</span>, res)            <span class="hljs-keyword">this</span>.siteList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取站点信息时发生了错误"</span>, res)        &#125;    &#125;)    <span class="hljs-comment">//初始化模板数据</span>    cmsApi.template_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"模板数据"</span>, res)            <span class="hljs-keyword">this</span>.templateList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取模板信息时发生了错误"</span>, res)        &#125;    &#125;)    <span class="hljs-comment">//初始化页面的数据</span>    cmsApi.page_query(<span class="hljs-keyword">this</span>.$route.params.pageId).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"初始化页面数据"</span>,res.cmsPage)            <span class="hljs-keyword">this</span>.pageForm = res.cmsPage        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"初始化页面数据失败"</span>,res)        &#125;    &#125;)&#125;,</code></pre></div><p>我们在页面路由定义了一个:pageId的参数，所以在初始化页面的数据部分从 <code>this.$route.params</code> 取出了<code>pageId</code></p><h4 id="2、提交更新表单"><a href="#2、提交更新表单" class="headerlink" title="2、提交更新表单"></a>2、提交更新表单</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//提交表单</span>addSubmit() &#123;    <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (valid) &#123;            <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交修改吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                cmsApi.page_edit(<span class="hljs-keyword">this</span>.$route.params.pageId,<span class="hljs-keyword">this</span>.pageForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.success) &#123;                        <span class="hljs-keyword">this</span>.$message(&#123;                            message: <span class="hljs-string">'修改提交成功'</span>,                            type: <span class="hljs-string">'success'</span>                        &#125;);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);                    &#125;                &#125;);            &#125;);        &#125;    &#125;)&#125;,</code></pre></div><h1 id="四、删除页面"><a href="#四、删除页面" class="headerlink" title="四、删除页面"></a>四、删除页面</h1><p>修改页面用户操作流程：</p><p>1、用户进入修改页面，在页面上显示了修改页面的信息</p><p>2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败”</p><h2 id="1-后端接口定义-1"><a href="#1-后端接口定义-1" class="headerlink" title="1. 后端接口定义"></a>1. 后端接口定义</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除接口</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 页面id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"删除页面"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">delete</span><span class="hljs-params">(String id)</span></span>;</code></pre></div><h2 id="2-服务端开发-1"><a href="#2-服务端开发-1" class="headerlink" title="2. 服务端开发"></a>2. 服务端开发</h2><h3 id="Dao层-3"><a href="#Dao层-3" class="headerlink" title="Dao层"></a>Dao层</h3><p><code>dao</code>层 使用 <code>MongoDB</code> 提供的dao接口来实现</p><h3 id="Service层-3"><a href="#Service层-3" class="headerlink" title="Service层"></a>Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据id删除</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">deleteCmsPage</span><span class="hljs-params">(String id)</span></span>&#123;    <span class="hljs-comment">//检索该页面id是否存在</span>    Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(id);    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;        <span class="hljs-comment">//删除并返回结果</span>        cmsPageRepository.deleteById(id);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);&#125;</code></pre></div><h3 id="Controller层-2"><a href="#Controller层-2" class="headerlink" title="Controller层"></a>Controller层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除页面</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 页面id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/delete/&#123;id&#125;"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">delete</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;    <span class="hljs-keyword">return</span> pageService.deleteCmsPage(id);&#125;</code></pre></div><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p><a href="https://qnoss.codeyee.com/20200704_3/image18" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image18.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-前端开发"><a href="#3-前端开发" class="headerlink" title="3.前端开发"></a>3.前端开发</h2><h3 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h3><p>1、在 <code>page_list</code> 页面内新增一个删除按钮</p><div class="hljs"><pre><code class="hljs vue">&lt;el-table-column label&#x3D;&quot;删除&quot; width&#x3D;&quot;75&quot; fixed&#x3D;&quot;right&quot;&gt;  &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;    &lt;el-button      size&#x3D;&quot;mini&quot;      type&#x3D;&quot;danger&quot;      @click&#x3D;&quot;deletePage(scope.row.pageId)&quot;&gt;删除    &lt;&#x2F;el-button&gt;  &lt;&#x2F;template&gt;&lt;&#x2F;el-table-column&gt;</code></pre></div><p>2、在 <code>cms.js</code> 定义删除的api</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除接口</span>export <span class="hljs-keyword">const</span> page_delete = (id) =&gt;&#123;  <span class="hljs-keyword">return</span> http.requestDelete(apiUrl + <span class="hljs-string">"/cms/page/delete/"</span> + id)&#125;</code></pre></div><p>3、创建 <code>deletePage</code> 函数，接收到 当前行的 <code>pageId</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//删除页面</span>deletePage(pageId) &#123;  <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">"此操作将永久的删除该页面"</span>, <span class="hljs-string">"提示"</span>, &#123;    confirmButtonText: <span class="hljs-string">'确定'</span>,    cancelButtonText: <span class="hljs-string">'取消'</span>,    type: <span class="hljs-string">'warning'</span>  &#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    cmsApi.page_delete(pageId).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (res.success) &#123;        <span class="hljs-keyword">this</span>.$message(&#123;          type: <span class="hljs-string">'success'</span>,          message: <span class="hljs-string">'删除成功!'</span>        &#125;)        <span class="hljs-keyword">this</span>.query()      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.$message(&#123;          type: <span class="hljs-string">'warning'</span>,          message: <span class="hljs-string">'删除失败'</span>        &#125;);      &#125;    &#125;)  &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">this</span>.$message(&#123;      type: <span class="hljs-string">'info'</span>,      message: <span class="hljs-string">'已取消删除'</span>    &#125;);  &#125;);&#125;,</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a href="https://qnoss.codeyee.com/20200704_3/image19" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image19.gif" srcset="/img/loading.gif" alt="img"></a></p><h1 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h1><h2 id="1-异常处理的问题分析"><a href="#1-异常处理的问题分析" class="headerlink" title="1. 异常处理的问题分析"></a>1. 异常处理的问题分析</h2><p>从添加页面的service方法中找问题：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 添加页面数据</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath());    <span class="hljs-keyword">if</span> (cmsPage1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//站点id由mongoDB自动生成，防止前端传值</span>        cmsPage.setPageId(<span class="hljs-keyword">null</span>);        CmsPage save = cmsPageRepository.save(cmsPage);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS, save);    &#125;    <span class="hljs-comment">//添加失败</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL, cmsPage);&#125;</code></pre></div><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h3><p>1、上边的代码只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信息。</p><p>2、<code>service</code> 方法在执行过程出现异常在哪捕获？在 <code>service</code> 中需要都加 <code>try</code>/<code>catch</code>，如果在<code>controller</code> 也需要添加 try/catch，代码冗余严重且不易维护。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、在 <code>Service</code> 方法中的编码顺序是先校验判断，有问题则抛出具体的异常信息，最后执行具体的业务操作，返回成功信息。</p><p>2、在统一异常处理类中去捕获异常，无需<code>controller</code>捕获异常，向用户返回统一规范的响应信息。</p><p>我们的代码应该是这样的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加页面数据</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-comment">//效验cmsPage是否为空</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//抛出异常，非法参数</span>    &#125;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath());    <span class="hljs-comment">//检验页面是否已存在</span>    <span class="hljs-keyword">if</span> (cmsPage1 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//抛出异常</span>    &#125;    <span class="hljs-comment">//站点id由mongoDB自动生成，防止前端传值</span>    cmsPage.setPageId(<span class="hljs-keyword">null</span>);    CmsPage save = cmsPageRepository.save(cmsPage);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS, save);    <span class="hljs-comment">//添加失败</span>&#125;</code></pre></div><p>在执行正常的逻辑之前，要把已知的异常进行验证，验证全部通过后才会去执行正常的逻辑代码。</p><h2 id="2-异常处理流程"><a href="#2-异常处理流程" class="headerlink" title="2. 异常处理流程"></a>2. 异常处理流程</h2><p>系统对异常的处理使用统一的异常处理流程：</p><p>1、自定义异常类型。</p><p>2、自定义错误代码及错误信息。</p><p>3、对于可预知的异常由程序员在代码中主动抛出，由 <code>SpringMVC</code> 统一捕获。</p><p>可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。</p><p>4、对于不可预知的异常（运行时异常）由<code>SpringMVC</code>统一捕获 <code>Exception</code> 类型的异常。</p><p>不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为 <code>RuntimeException</code>类型（运行时异常）。</p><p>5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随请求响应给客户端。</p><p>异常抛出及处理流程：</p><p><a href="https://qnoss.codeyee.com/20200704_3/image20" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image20.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、在 <code>controller</code>、<code>service</code>、<code>dao</code> 中程序员抛出自定义异常；<code>springMVC</code> 框架抛出框架异常类型</p><p>2、统一由异常捕获类捕获异常，并进行处理</p><p>3、捕获到自定义异常则直接取出错误代码及错误信息，响应给用户</p><p>4、捕获到非自定义异常类型首先从 <code>Map</code> 中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误信息并响应给用户，如果从 <code>Map</code> 中找不到异常类型所对应的错误代码则统一为 <code>99999</code> 错误代码并响应给用户。</p><p>5、将错误代码及错误信息以 <code>Json</code> 格式响应给用户。</p><h2 id="3-可预知异常处理"><a href="#3-可预知异常处理" class="headerlink" title="3. 可预知异常处理"></a>3. 可预知异常处理</h2><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>在common工程定义异常类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-keyword">private</span> ResultCode resultCode;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomException</span><span class="hljs-params">(ResultCode resultCode)</span></span>&#123;        <span class="hljs-comment">//异常信息为错误代码+异常信息</span>        <span class="hljs-keyword">super</span>(<span class="hljs-string">"错误代码: "</span> + resultCode.code() + <span class="hljs-string">" 错误信息: "</span> + resultCode.message());        <span class="hljs-keyword">this</span>.resultCode = resultCode;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultCode <span class="hljs-title">getResultCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resultCode;    &#125;&#125;</code></pre></div><p>上面的代码中我们自定义了一个名为 <code>CustomException</code> 的异常，并且继承了 <code>RuntimeException</code> 异常类，有的人可能会问，我们为什么不直接继承 <code>Exception</code> 类？因为如果继承了 <code>Exception</code> 类，我们在抛出异常时对代码会有一定的侵入性，例如我们需要在抛出该异常的方法前加入 <code>throws Exception</code> ，例如</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;&#125;</code></pre></div><p>或者使用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//抛出异常，非法参数</span>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125;</code></pre></div><p>而我们如果使用 <code>RuntimeException</code> ,至需要在抛出异常的地方写入下面代码就能抛出我们自定义的异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomException(resultCode);</code></pre></div><h3 id="抛出异常类"><a href="#抛出异常类" class="headerlink" title="抛出异常类"></a>抛出异常类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionCast</span> </span>&#123;    <span class="hljs-comment">//使用此静态方法抛出自定义异常</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cast</span><span class="hljs-params">(ResultCode resultCode)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomException(resultCode);    &#125;&#125;</code></pre></div><h3 id="异常捕获类"><a href="#异常捕获类" class="headerlink" title="异常捕获类"></a>异常捕获类</h3><p>使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionCatch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//捕获 CustomException 异常</span>    <span class="hljs-meta">@ExceptionHandler</span>(CustomException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">customException</span>(<span class="hljs-title">CustomException</span> <span class="hljs-title">e</span>)</span>&#123;        LOGGER.error(<span class="hljs-string">"catch exception：&#123;&#125;\r\nException："</span>,e.getMessage(),e);        ResultCode resultCode = e.getResultCode();        ResponseResult responseResult = <span class="hljs-keyword">new</span> ResponseResult(resultCode);        <span class="hljs-keyword">return</span> responseResult;    &#125;&#125;</code></pre></div><h3 id="异常处理测试"><a href="#异常处理测试" class="headerlink" title="异常处理测试"></a>异常处理测试</h3><h4 id="1）定义错误代码"><a href="#1）定义错误代码" class="headerlink" title="1）定义错误代码"></a>1）定义错误代码</h4><p>每个业务操作的异常使用异常代码去标识。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.model.response;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CmsCode implements ResultCode &#123;    CMS_ADDPAGE_EXISTS(<span class="hljs-keyword">false</span>,<span class="hljs-number">24001</span>,<span class="hljs-string">"页面已存在！"</span>);    <span class="hljs-comment">//操作结果</span>    <span class="hljs-keyword">boolean</span> success;    <span class="hljs-comment">//操作代码</span>    <span class="hljs-keyword">int</span> code;    <span class="hljs-comment">//提示信息</span>    String message;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">CmsCode</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> success, <span class="hljs-keyword">int</span> code, String message)</span></span>&#123;        <span class="hljs-keyword">this</span>.success = success;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.message = message;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">code</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">message</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> message;    &#125;&#125;</code></pre></div><h4 id="2）异常处理测试"><a href="#2）异常处理测试" class="headerlink" title="2）异常处理测试"></a>2）异常处理测试</h4><p>1、抛出异常</p><p>回到我们 <code>PageService</code> 中的 <code>addCmsPage</code> 抛出异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//检验页面是否已存在</span><span class="hljs-keyword">if</span> (cmsPage1 != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">//抛出异常</span>    ExceptionCast.cast(CmsCode.CMS_ADDPAGE_EXISTS);&#125;</code></pre></div><p>2、在启动工程中扫描异常捕获类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)  <span class="hljs-comment">// 扫描framework下的异常捕获类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>3、前端展示异常信息</p><p>在前端新增页面的表单提交中增加判断</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.message)&#123;<span class="hljs-keyword">this</span>.$message.error(res.message)&#125;</code></pre></div><p>全部代码如下</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//提交表单</span>addSubmit() &#123;  <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (valid) &#123;      <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        cmsApi.page_add(<span class="hljs-keyword">this</span>.pageForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(res);          <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-keyword">this</span>.$message(&#123;              message: <span class="hljs-string">'提交成功'</span>,              type: <span class="hljs-string">'success'</span>            &#125;);            <span class="hljs-keyword">this</span>.$refs[<span class="hljs-string">'pageForm'</span>].resetFields();          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.message)&#123;            <span class="hljs-keyword">this</span>.$message.error(res.message)          &#125;          <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);          &#125;        &#125;);      &#125;);    &#125;  &#125;)&#125;,</code></pre></div><p>测试</p><p><a href="https://qnoss.codeyee.com/20200704_3/image21" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-不可预知的异常处理"><a href="#4-不可预知的异常处理" class="headerlink" title="4. 不可预知的异常处理"></a>4. 不可预知的异常处理</h2><h4 id="1）定义异常捕获方法"><a href="#1）定义异常捕获方法" class="headerlink" title="1）定义异常捕获方法"></a>1）定义异常捕获方法</h4><h5 id="抛出异常测试"><a href="#抛出异常测试" class="headerlink" title="抛出异常测试"></a>抛出异常测试</h5><p>使用postman测试添加页面，不输入cmsPost信息，提交，报错信息如下：</p><div class="hljs"><pre><code class="hljs json">org.springframework.http.converter.HttpMessageNotReadableException此异常是springMVC在进行参数转换时报的错误。&#123;    <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1528712906727</span>,    <span class="hljs-attr">"status"</span>: <span class="hljs-number">400</span>,    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"Bad Request"</span>,    <span class="hljs-attr">"exception"</span>: <span class="hljs-string">"org.springframework.http.converter.HttpMessageNotReadableException"</span>,    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Required request body is missing: public</span><span class="hljs-string">    com.xuecheng.framework.domain.cms.response.CmsPageResult</span><span class="hljs-string">    com.xuecheng.manage_cms.web.controller.CmsPageController.add(com.xuecheng.framework.domain.cms.C</span><span class="hljs-string">    msPage)"</span>,    <span class="hljs-attr">"path"</span>: <span class="hljs-string">"/cms/page/add"</span>&#125;</code></pre></div><p>上边的响应信息在客户端是无法解析的。</p><p>在异常捕获类 <code>ExceptionCatch</code> 中添加对Exception异常的捕获，下面大致的代码结构：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ResponseBody</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">exception</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">exception</span>)</span>&#123;    <span class="hljs-comment">//记录日志</span>    LOGGER.error(<span class="hljs-string">"catch exception:&#123;&#125;"</span>,exception.getMessage());    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h5 id="异常捕获方法"><a href="#异常捕获方法" class="headerlink" title="异常捕获方法"></a>异常捕获方法</h5><p>针对上边的问题其解决方案是：</p><ol><li>我们在map中配置HttpMessageNotReadableException和错误代码。</li><li>在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型对应的错误代码，如果存在错误代码则返回此错误，否则统一返回99999错误。</li></ol><p>具体的开发实现如下：</p><p>1、在通用错误代码类CommCode中配置非法参数异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CommonCode implements ResultCode&#123;    INVALID_PARAM(<span class="hljs-keyword">false</span>,<span class="hljs-number">10003</span>,<span class="hljs-string">"非法参数！"</span>),    <span class="hljs-comment">/**其他代码省略**/</span>&#125;</code></pre></div><p>2、在异常捕获类中配置 HttpMessageNotReadableException 为非法参数异常。</p><p>具体的说明我都写在注释当中了，就不多做解释，直接看代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.google.common.collect.ImmutableMap;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 统一异常捕获类</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-09  11:12</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-comment">//控制器增强</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionCatch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//定义map，配置异常类型所对应的错误代码（ImmutableMap 只读，线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; EXCEPTIONS;    <span class="hljs-comment">//定义map的builder对象，去构建immutablemap</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; builder = ImmutableMap.builder();    <span class="hljs-comment">//捕获CustomException类的异常</span>    <span class="hljs-meta">@ExceptionHandler</span>(CustomException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">customException</span>(<span class="hljs-title">CustomException</span> <span class="hljs-title">customException</span>)</span>&#123;        <span class="hljs-comment">//记录日志</span>        LOGGER.error(<span class="hljs-string">"catch exception:&#123;&#125;"</span>,customException.getMessage());        ResultCode resultCode = customException.getResultCode();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(resultCode);    &#125;    <span class="hljs-comment">//捕获Exception类的异常</span>    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">exception</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">exception</span>)</span>&#123;        <span class="hljs-comment">//记录日志</span>        LOGGER.error(<span class="hljs-string">"catch exception:&#123;&#125;"</span>,exception.getMessage());        <span class="hljs-keyword">if</span> (EXCEPTIONS == <span class="hljs-keyword">null</span>)&#123;            EXCEPTIONS = builder.build();<span class="hljs-comment">//EXCEPTIONS构建成功</span>        &#125;        <span class="hljs-comment">//从EXCEPTIONS中找出异常类型所对应的错误代码，如果找到了将错误代码响应给用户</span>        <span class="hljs-comment">// 如果找不到给用户响应99999异常</span>        ResultCode resultCode = EXCEPTIONS.get(exception.getClass());        <span class="hljs-keyword">if</span> (resultCode != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(resultCode);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果非预定义的错误，则返回服务器错误</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SERVER_ERROR);        &#125;    &#125;    <span class="hljs-keyword">static</span> &#123;        builder.put(HttpMessageNotReadableException<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">CommonCode</span>.<span class="hljs-title">INVALID_PARAM</span>)</span>;    &#125;&#125;</code></pre></div><p>我们来测试一下，是否能成功捕抓到该异常</p><p><a href="https://qnoss.codeyee.com/20200704_3/image22" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们改成 GET 请求进行测试，由于我们没有预定这种异常的错误代码，所以统一返回99999错误代码</p><p><a href="https://qnoss.codeyee.com/20200704_3/image23" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image23.png" srcset="/img/loading.gif" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Data MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day02：CMS前端开发</title>
    <link href="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/"/>
    <url>/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day02</code> 的内容</p><ul><li><code>vue</code> 基础语法</li><li>对 <code>webpack</code>与 <code>webpack-dev-server</code> 的基本使用，理解 <code>webpack</code> 的打包过程。</li><li><code>CMS</code> 前端工程的基础构建</li><li>解决前端跨域请求的问题，并理解前端请求数据的流程。</li><li>配合使用 <code>Element-UI</code> 的 <code>table</code> 组件进行分页查询</li></ul><h1 id="一、vue基础"><a href="#一、vue基础" class="headerlink" title="一、vue基础"></a>一、vue基础</h1><p>vue基础部分内容的笔记略过，如过你仍需要该阶段的学习，阅读官方的讲义或者移步：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a> 进行阅读和练习。</p><h1 id="二、webpack入门"><a href="#二、webpack入门" class="headerlink" title="二、webpack入门"></a>二、webpack入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>使用vue.js开发大型应用需要使用 <code>webpack</code> 打包工具，本节研究webpack的使用方法。</p><p>Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image7.png" srcset="/img/loading.gif" alt></p><h2 id="2-使用webpack有什么好处呢？"><a href="#2-使用webpack有什么好处呢？" class="headerlink" title="2. 使用webpack有什么好处呢？"></a>2. 使用webpack有什么好处呢？</h2><p>从图中我们可以看出，Webpack 可以将js、css、png等多种静态资源 进行打包</p><ul><li>模块化开发<br>程序员在开发时可以分模块创建不同的js、 css等小文件方便开发，最后使用webpack将这些小文件打包成一个文<br>件，减少了http的请求次数。<br>webpack可以实现按需打包，为了避免出现打包文件过大可以打包成多个文件。</li><li>编译typescript、ES6等高级js语法<br>随着前端技术的强大，开发中可以使用javascript的很多高级版本，比如：typescript、ES6等，方便开发，<br>webpack可以将打包文件转换成浏览器可识别的js语法。</li><li>CSS预编译<br>webpack允许在开发中使用Sass 和 Less等原生CSS的扩展技术，通过sass-loader、less-loader将Sass 和 Less的<br>语法编译成浏览器可识别的css语法。</li></ul><h2 id="3-webpack的缺点"><a href="#3-webpack的缺点" class="headerlink" title="3. webpack的缺点"></a>3. webpack的缺点</h2><p>1、配置有些繁琐<br>2、文档不丰富</p><h2 id="4-安装-npm"><a href="#4-安装-npm" class="headerlink" title="4.安装 npm"></a>4.安装 npm</h2><p><code>node.js</code> 已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本，node可以直接去官网下载安装</p><p>设置包路径</p><div class="hljs"><pre><code class="hljs shell">npm config set prefix "C:\Program Files\nodejs\npm_modules"npm config set cache "c:\Program Files\nodejs\npm_cache"</code></pre></div><h2 id="5-安装-cnpm"><a href="#5-安装-cnpm" class="headerlink" title="5. 安装 cnpm"></a>5. 安装 cnpm</h2><p>执行以下命令</p><div class="hljs"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></div><p>安装完成后执行命令 <code>cnpm -v</code></p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image8.png" srcset="/img/loading.gif" alt></p><h2 id="6-安装-webpack"><a href="#6-安装-webpack" class="headerlink" title="6. 安装 webpack"></a>6. 安装 webpack</h2><p><strong>node.js 安装包分为两种模式</strong></p><ul><li>本地安装：仅将webpack安装在当前项目的node_modules目录中，仅对当前项目有效。</li><li>全局安装：将webpack安装在本机，对所有项目有效，全局安装会锁定一个webpack版本，该版本可能不适用某个项目。全局安装需要添加 -g 参数</li></ul><p><strong>本地安装</strong></p><div class="hljs"><pre><code class="hljs shell">npm install --save-dev webpack 或 cnpm install --save-dev webpacknpm install --save-dev webpack-cli (4.0以后的版本需要安装webpack-cli)</code></pre></div><p><strong>全局安装</strong></p><p>全局安装加-g，如下：全局安装就将webpack的js包下载到npm的包路径下。</p><div class="hljs"><pre><code class="hljs shell">npm install webpack -g 或 cnpm install webpack -g</code></pre></div><p><strong>安装 webpack 指定的版本：</strong><br>进入webpacktest测试目录，运行：<code>cnpm install --save-dev webpack@3.6.0</code><br>全局安装：<code>npm install webpack@3.6.0 -g</code> 或 <code>cnpm install webpack@3.6.0 -g</code></p><h2 id="7-入门程序"><a href="#7-入门程序" class="headerlink" title="7. 入门程序"></a>7. 入门程序</h2><p>通过本入门程序体会webpack打包的过程及模块化开发的思想。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>通过入门程序实现对js文件的打包，体会webpack是如何对应用进行模块化管理。<br>对上边1+1=2的例子使用webpack进行模块化管理</p><h3 id="定义-model01-js"><a href="#定义-model01-js" class="headerlink" title="定义 model01.js"></a>定义 model01.js</h3><p>在<code>webpacktest01</code>目录下创建<code>model01.js</code></p><p>将本程序使用的加法运算的js方法抽取到一个js文件，此文件就是一个模块 ，代码如下</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//定义add函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x+y;&#125;<span class="hljs-comment">//导出add函数</span><span class="hljs-built_in">module</span>.exports.add = add;</code></pre></div><h3 id="定义main-js"><a href="#定义main-js" class="headerlink" title="定义main.js"></a>定义main.js</h3><p>在<code>webpacktest01</code>目录下创建<code>main.js</code>，<code>main.js</code>是本程序的js主文件，包括如下内容：</p><p>1、在此文件中会引用model01.js模块<br>2、引用vue.min.js（它也一个模块）<br>3、将html页面中构建vue实例的代码放在main.js中。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;add&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./model01.js"</span>)<span class="hljs-keyword">var</span> Vue = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./vue.min"</span>)<span class="hljs-comment">// 实例化Vue对象</span><span class="hljs-comment">//vm :叫做MVVM中的 View Model</span><span class="hljs-keyword">var</span> VM = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,<span class="hljs-comment">//表示当前vue对象接管app的div区域</span>    data:&#123;        name:<span class="hljs-string">'黑马程序员'</span>,<span class="hljs-comment">// 相当于是MVVM中的Model这个角色</span>        num1:<span class="hljs-number">0</span>,        num2:<span class="hljs-number">0</span>,        result:<span class="hljs-number">0</span>,        url:<span class="hljs-string">'http://www.itcast.cn'</span>    &#125;,    methods:&#123;        change:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">this</span>.result = add(<span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.num1),<span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.num2));        &#125;    &#125;&#125;);</code></pre></div><h3 id="打包测试"><a href="#打包测试" class="headerlink" title="打包测试"></a>打包测试</h3><p>上边将 <code>mode01.js</code> 模块及 <code>main.js</code> 主文件编写完成，下边使用 <code>webpack</code> 对这些js文件进行打包</p><p>1、进入程序目录，执行 <code>webpack main.js -o build.js</code> ，这段指令表示将 <code>main.js</code> 打包输出为 <code>build.js</code> 文件执行完成，观察程序目录是否出现 <code>build.js</code>。</p><p>2、在创建一个html ，这里我命名为 <code>vue_02.html</code> 并 中引用 <code>build.js</code></p><div class="hljs"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">"en"</span> xmlns:v-on=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;&lt;head&gt;    &lt;meta http-equiv=<span class="hljs-string">"Content-Type"</span> content=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;    &lt;title&gt;vue.js入门程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=<span class="hljs-string">"app"</span>&gt;    &#123;&#123;name&#125;&#125;    &lt;input type=<span class="hljs-string">"text"</span> v-model=<span class="hljs-string">"num1"</span>&gt;+    &lt;input type=<span class="hljs-string">"text"</span> v-model=<span class="hljs-string">"num2"</span>&gt;=    &lt;input type=<span class="hljs-string">"text"</span> v-model=<span class="hljs-string">"result"</span>&gt;    &lt;button v-on:click="change"&gt;计算&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="build.js"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre></div><h3 id="运行html"><a href="#运行html" class="headerlink" title="运行html"></a>运行html</h3><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image9.png" srcset="/img/loading.gif" alt></p><h1 id="三、webpack-dev-server"><a href="#三、webpack-dev-server" class="headerlink" title="三、webpack-dev-server"></a>三、webpack-dev-server</h1><h2 id="1-测试环境搭建"><a href="#1-测试环境搭建" class="headerlink" title="1. 测试环境搭建"></a>1. 测试环境搭建</h2><p><code>webpack-dev-server</code> 开发服务器，它的功能可以实现热加载 并且自动刷新浏览器。</p><p>创建一个新的程序目录，这里我们创建 <code>webpacktest02</code> 目录，将 <code>webpack</code> 入门程序( <code>webpacktest01</code> )的代码拷贝进来，并在目录下创建 <code>src</code> 目录、<code>dist</code> 目录，并将main.js和model01.js拷贝到src目录。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image10.png" srcset="/img/loading.gif" alt></p><h2 id="2-安装配置"><a href="#2-安装配置" class="headerlink" title="2. 安装配置"></a>2. 安装配置</h2><h3 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h3><p>使用 <code>webpack-dev-server</code> 需要安装webpack、 webpack-dev-server 和 html-webpack-plugin三个包。</p><div class="hljs"><pre><code class="hljs shell">cnpm install webpackwebpack-dev-server html-webpack-plugin</code></pre></div><p>安装完成，会发现程序目录出现一个package.json文件，此文件中记录了程序的依赖。</p><h3 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h3><p>在package.json中配置script</p><div class="hljs"><pre><code class="hljs json">"scripts": &#123;  "dev": "webpack-dev-server --inline --hot --open --port 5008"&#125;</code></pre></div><p>–inline：自动刷新<br>–hot：热加载<br>–port：指定端口<br>–open：自动在默认浏览器打开<br>–host：可以指定服务器的 ip，不指定则为127.0.0.1，如果对外发布则填写公网ip地址</p><p>此时package.json的文件内容如下：</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"devDependencies"</span>: &#123;    <span class="hljs-attr">"html-webpack-plugin"</span>: <span class="hljs-string">"^3.2.0"</span>,    <span class="hljs-attr">"webpack-dev-server"</span>: <span class="hljs-string">"^3.10.3"</span>  &#125;,  <span class="hljs-attr">"scripts"</span>: &#123;    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"webpack-dev-server --inline --hot --open --port 5008"</span>  &#125;&#125;</code></pre></div><blockquote><p>devDependencies：开发人员在开发过程中所需要的依赖。<br>scripts：可执行的命令</p></blockquote><h2 id="3-webpack-config-js"><a href="#3-webpack-config-js" class="headerlink" title="3. webpack.config.js"></a>3. webpack.config.js</h2><p>在 <code>webpacktest02</code> 目录下创建 <code>webpack.config.js</code>， <code>webpack.config.js</code> 是 <code>webpack</code> 的配置文件。</p><p>在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置 <code>html-webpack-plugin</code> 插件。</p><p><code>html-webpack-plugin</code> 的作用是根据 <code>html</code> 模板在内存生成 <code>html</code> 文件，它的工作原理是根据模板文件在内存中生成一个 <code>index.html</code> 文件。</p><h3 id="配置模板文件"><a href="#配置模板文件" class="headerlink" title="配置模板文件"></a>配置模板文件</h3><p>将原来的 <code>vue_02.html</code> 作为模板文件，为了和内存中的 <code>index.html</code> 文件名区别，注意将 <code>vue_02.html</code> 中的<code>script</code> 标签去掉，内容如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:v-on</span>=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue.js入门程序<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    &#123;&#123;name&#125;&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"num1"</span>&gt;</span>+    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"num2"</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"result"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"change"</span>&gt;</span>计算<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="配置-html-webpack-plugin"><a href="#配置-html-webpack-plugin" class="headerlink" title="配置 html-webpack-plugin"></a>配置 html-webpack-plugin</h3><p>在 <code>webpack.config.js</code> 中配置 <code>html-webpack-plugin</code> 插件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">var</span> htmlwp = require(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span>=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">//指定打包的入口文件</span>    output:&#123;        path : __dirname + <span class="hljs-string">'/dist'</span>, <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>        filename:<span class="hljs-string">'build.js'</span> <span class="hljs-comment">//输出文件</span>    &#125;,    plugins:[        <span class="hljs-keyword">new</span> htmlwp(&#123;            <span class="hljs-comment">//生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;</span>            title: <span class="hljs-string">'首页'</span>,            <span class="hljs-comment">//webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部才能实现自动刷新功能</span>            filename: <span class="hljs-string">'index.html'</span>,            <span class="hljs-comment">//根据vue_02.html这个模板来生成(这个文件请程序员自己生成)</span>            template: <span class="hljs-string">'vue_02.html'</span>        &#125;)    ]&#125;</code></pre></div><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动文件：<br>1、进入 <code>webpacktest02</code>目录，执行<code>npm run dev</code><br>2、使用webstorm，右键<code>package.json</code>文件，选择 “Show npm Scripts”</p><p>打开窗口：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image11.png" srcset="/img/loading.gif" alt></p><p>双击 <code>dev</code>。<br>注意：dev 就是在 <code>package.json</code> 中配置的 <code>webpack dev server</code> 命令。<br>发现启动成功自动打开浏览器。<br>修改src中的任意文件内容，自动加载并刷新浏览器。</p><h3 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h3><p>使用了 <code>webpack</code> 之后就不能采用传统js的调试方法在 <code>chrome</code> 中打断点。</p><p><code>webpack</code> 将多个源文件打包成一个文件，并且文件的内容产生了很大的变化，<code>webpack</code> 提供 <code>devtool</code> 进行调试，<code>devtool</code> 是基于 <code>sourcemap</code> 的方式，在调试时会生成一个 <code>map</code> 文件，其内容记录生成文件和源文件的内容映射，即生成文件中的哪个位置对应源文件中的哪个位置，有了 <code>sourcemap</code> 就可以在调试时看到源代码。</p><p><strong>配置如下</strong></p><p>1、在webpack.config.js中配置：</p><div class="hljs"><pre><code class="hljs js">devtool: <span class="hljs-string">'eval‐source‐map'</span>,</code></pre></div><p>devtool: ‘eval‐source‐map’,</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> htmlwp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html‐webpack‐plugin'</span>);    <span class="hljs-built_in">module</span>.exports=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">//指定打包的入口文件</span>    output:&#123;    path : __dirname+<span class="hljs-string">'/dist'</span>, <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>    filename:<span class="hljs-string">'build.js'</span> <span class="hljs-comment">//输出文件</span>&#125;,devtool: <span class="hljs-string">'eval‐source‐map'</span>,......</code></pre></div><p>2、在js中跟踪代码的位置上添加debugger</p><p>一个例子：<br>在add方法中添加debugger</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 定义add函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>    <span class="hljs-keyword">return</span> x + y&#125;</code></pre></div><p>启动应用，刷新页面跟踪代码：<br>点击“计算” 即进入debugger代码位置，此时可以使用chrome进行调试了。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image12.png" srcset="/img/loading.gif" alt></p><h3 id="无法正常启动调试？"><a href="#无法正常启动调试？" class="headerlink" title="无法正常启动调试？"></a>无法正常启动调试？</h3><p>谷歌浏览器中先按下 <code>F12</code> 打开调试模式后在点击 <code>计算</code> 按钮进行触发代码中的 <code>debugger</code></p><h1 id="四、CMS前端工程创建"><a href="#四、CMS前端工程创建" class="headerlink" title="四、CMS前端工程创建"></a>四、CMS前端工程创建</h1><h2 id="1-导入系统管理前端工程"><a href="#1-导入系统管理前端工程" class="headerlink" title="1.导入系统管理前端工程"></a>1.导入系统管理前端工程</h2><p>CMS系统使用Vue-cli脚手架创建， <code>Vue-cli</code>是 <code>Vue</code> 官方提供的快速构建单页应用的脚手架，<code>github</code>地址：<br><a href="https://github.com/vuejs/vue-cli%EF%BC%88%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E5%90%8C%E5%AD%A6%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E5%AE%98%E6%96%B9%E6%8C%87%E5%AF%BC%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%EF%BC%89%EF%BC%8C%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%AF%B9" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli（有兴趣的同学可以参考官方指导使用vue-cli创建前端工程），本项目对</a> <code>Vue-cli</code>创建的工程进行二次封装，下边介绍CMS工程的情况。</p><h2 id="2-工程结构"><a href="#2-工程结构" class="headerlink" title="2. 工程结构"></a>2. 工程结构</h2><p>如果我要基于Vue-Cli创建的工程进行开发还需要在它基础上作一些封装，导入课程资料中提供Vue-Cli封装工程。<br><code>资料/xc-ui-pc-sysmanage.7z</code> 拷贝到UI工程目录中，并解压，用<code>WebStorm</code>打开 <code>xc-ui-pc-sysmanage</code> 目录。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image13.png" srcset="/img/loading.gif" alt></p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json记录了工程所有依赖，及脚本命令：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image14.png" srcset="/img/loading.gif" alt></p><p>开发使用：<code>npm run dev</code><br>打包使用：<code>npm run build</code></p><h3 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h3><p><code>webpack.base.conf.js</code> 就是 webpack 的 <code>webpack.config.js</code> 配置文件，在此文件中配置了入口文件及各种<code>Loader</code>。webpack 是通过<code>vue-load</code>解析 <code>.vue</code> 文件，通过 <code>css-load</code> 打包 <code>css</code> 文件等。</p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p><code>main.js</code> 是工程的入口文件，在此文件中加载了很多第三方组件，如：Element-UI、Base64、VueRouter 等。<br><code>index.html</code> 是模板文件。</p><h3 id="src目录"><a href="#src目录" class="headerlink" title="src目录"></a>src目录</h3><p>src目录下存放页面及js代码。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image15.png" srcset="/img/loading.gif" alt></p><ul><li>assets：存放一些静态文件，如图片。</li><li>base：存放基础组件</li><li>base/api：基础api接口</li><li>base/component：基础组件，被各各模块都使用的组件</li><li>base/router：总的路由配置，加载各模块的路由配置文件。</li><li>common：工具类</li><li>component：组件目录，本项目不用。</li><li>mock：存放前端单元测试方法。</li><li>module：存放各业务模块的页面和api方法。</li></ul><p>下级目录以模块名命名，下边以cms举例：</p><ul><li>cms/api：cms模块的api接口</li><li>cms/component：cms模块的组件</li><li>cms/page： cms模块的页面</li><li>cms/router：cms模块的路由配置</li><li>statics：存放第三方组件的静态资源</li><li>vuex：存放vuex文件，本项目不使用</li><li>static：与src的平级目录，此目录存放静态资源它与assets的区别在于，static目录中的文件不被webpack打包处理，会原样拷贝到dist目录下</li></ul><h2 id="3-单页面应用介绍"><a href="#3-单页面应用介绍" class="headerlink" title="3. 单页面应用介绍"></a>3. 单页面应用介绍</h2><h3 id="单页面应用的优缺点："><a href="#单页面应用的优缺点：" class="headerlink" title="单页面应用的优缺点："></a>单页面应用的优缺点：</h3><p><strong>优点</strong>：<br>1、用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。<br>2、适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。</p><p><strong>缺点</strong>：<br>1、首页加载慢<br>单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则<br>用户体验不好。</p><p>2、SEO不友好<br>SEO（Search Engine Optimization）为搜索引擎优化。它是一种利用搜索引擎的搜索规则来提高网站在搜索引擎<br>排名的方法。目前各家搜索引擎对JS支持不好，所以使用单页面应用将大大减少搜索引擎对网站的收录。</p><p>总结：本项目的门户、课程介绍不采用单页面应用架构去开发，对于需要用户登录的管理系统采用单页面开发。</p><h1 id="五、CMS前端页面查询开发"><a href="#五、CMS前端页面查询开发" class="headerlink" title="五、CMS前端页面查询开发"></a>五、CMS前端页面查询开发</h1><h2 id="1-页面原型"><a href="#1-页面原型" class="headerlink" title="1. 页面原型"></a>1. 页面原型</h2><h3 id="1、创建页面"><a href="#1、创建页面" class="headerlink" title="1、创建页面"></a>1、创建页面</h3><h4 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h4><p>在model目录创建 cms模块的目录结构</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image16.png" srcset="/img/loading.gif" alt></p><p>在page目录新建page_list.vue，扩展名为.vue。<br>.vue文件的结构如下：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;&lt;!‐‐编写页面静态部分，即view部分‐‐&gt;测试页面显示...&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;*编写页面静态部分，即model及vm部分。*&#x2F;&lt;&#x2F;script&gt;&lt;style&gt;&#x2F;*编写页面样式，不是必须*&#x2F;&lt;&#x2F;style&gt;</code></pre></div><p>在页面的<code>template</code>中填写 “测试页面显示…”。<br>注意：<code>template</code>内容必须有一个根元素，否则vue会报错，这里我们在<code>template</code>标签内定义一个<code>div</code>。</p><h4 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h4><p>在 <code>cms</code> 目录下创建 <code>page_list.vue</code> 页面。<br>现在先配置路由，实现 url 访问到页面再进行内容完善与调试。</p><p>1、在cms的router下配置路由</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/home.vue'</span>;<span class="hljs-keyword">import</span> page_list <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/cms/page/page_list.vue'</span>;    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [&#123;        path: <span class="hljs-string">'/cms'</span>,        component: Home,        name: <span class="hljs-string">'CMS内容管理'</span>,        hidden: <span class="hljs-literal">false</span>,        children:[            &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">'/cms/page/list'</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">'页面列表'</span>,<span class="hljs-attr">component</span>: page_list,<span class="hljs-attr">hidden</span>:<span class="hljs-literal">false</span>&#125;        ]    &#125;]</code></pre></div><p>2、在base目录下的router导入cms模块的路由</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// // 导入路由规则</span><span class="hljs-keyword">import</span> HomeRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/router'</span><span class="hljs-keyword">import</span> CmsRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/cms/router'</span><span class="hljs-comment">// 合并路由规则</span>concat(HomeRouter)concat(CmsRouter)</code></pre></div><p>3、测试</p><p>启动工程，刷新页面，页面可以外正常浏览，并且看到“测试页面显示…”字样</p><h3 id="2、Table组件测试"><a href="#2、Table组件测试" class="headerlink" title="2、Table组件测试"></a>2、Table组件测试</h3><p>本功能实现的页面列表，用户可以进行分页查询、输入查询条件查询，通过查看 <code>Element-UI</code> 库，我们需要<code>Table</code> 表格、<code>Form</code>表单 及<code>Pagination</code> 分页组件。</p><p>进入<a href="https://element.eleme.cn/#/zh-CN/component/table" target="_blank" rel="noopener">Element-UI</a>官方，找到 <code>Table</code> 组件，拷贝源代码到 <code>vue</code> 页面中，如下：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-table      :data&#x3D;&quot;tableData&quot;      border      style&#x3D;&quot;width: 100%&quot;&gt;      &lt;el-table-column        prop&#x3D;&quot;date&quot;        label&#x3D;&quot;日期&quot;        width&#x3D;&quot;180&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column        prop&#x3D;&quot;name&quot;        label&#x3D;&quot;姓名&quot;        width&#x3D;&quot;180&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column        prop&#x3D;&quot;address&quot;        label&#x3D;&quot;地址&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column        prop&#x3D;&quot;test&quot;        label&#x3D;&quot;测试列&quot;&gt;      &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        tableData: [&#123;          date: &#39;2016-05-02&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1518 弄&#39;,          test: &#39;测试&#39;        &#125;, &#123;          date: &#39;2016-05-04&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1517 弄&#39;        &#125;, &#123;          date: &#39;2016-05-01&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1519 弄&#39;        &#125;, &#123;          date: &#39;2016-05-03&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1516 弄&#39;        &#125;]      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt;</code></pre></div><p>测试：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image17.png" srcset="/img/loading.gif" alt></p><p>通过查看代码发现，<code>el-table</code> 组件绑定了<code>tableData</code>模型数据，<code>tableData</code>模型数据在<code>script</code>标签中定义。</p><h3 id="3、页面内容完善"><a href="#3、页面内容完善" class="headerlink" title="3、页面内容完善"></a>3、页面内容完善</h3><p>根据需求完善页面内容，完善列表字段，添加分页组件。</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;query&quot; size&#x3D;&quot;small&quot;&gt;查询&lt;&#x2F;el-button&gt;    &lt;el-table    :data&#x3D;&quot;list&quot;    border    style&#x3D;&quot;width: 100%&quot;&gt;    &lt;el-table-column prop&#x3D;&quot;pageName&quot; label&#x3D;&quot;页面名称&quot; width&#x3D;&quot;120&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageAliase&quot; label&#x3D;&quot;别名&quot; width&#x3D;&quot;120&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageType&quot; label&#x3D;&quot;页面类型&quot; width&#x3D;&quot;150&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageWebPath&quot; label&#x3D;&quot;访问路径&quot; width&#x3D;&quot;250&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pagePhysicalPath&quot; label&#x3D;&quot;物理路径&quot; width&#x3D;&quot;250&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageCreateTime&quot; label&#x3D;&quot;创建时间&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;    &lt;el-pagination    layout&#x3D;&quot;prev, pager, next&quot;    :page-size&#x3D;&quot;this.params.size&quot;    v-on:current-change&#x3D;&quot;changePage&quot;    :total&#x3D;&quot;total&quot; :current-page&#x3D;&quot;this.params.page&quot; style&#x3D;&quot;float:right;&quot;&gt;    &lt;&#x2F;el-pagination&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        list:[],        total:50,        params:&#123;          page:1,&#x2F;&#x2F;页码          size:2&#x2F;&#x2F;每页显示个数        &#125;      &#125;    &#125;,    methods:&#123;      changePage:function () &#123;        this.query()      &#125;,    &#x2F;&#x2F;查询      query:function () &#123;        alert(&quot;查询&quot;)      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><p>测试</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image18.png" srcset="/img/loading.gif" alt></p><h2 id="2-API调用"><a href="#2-API调用" class="headerlink" title="2. API调用"></a>2. API调用</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>在cms模块的 <code>api</code> 目录定义<code>cms.js</code>，<br>在 <code>cms.js</code> 中定义如下js方法，此方法实现 <code>http</code> 请求服务端页面查询接口。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//public是对axios的工具类封装，定义了http请求方法</span><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./../../../base/api/public'</span><span class="hljs-comment">//页面查询</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_list = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;    <span class="hljs-comment">//定义方法，请求服务端查询接口</span>    <span class="hljs-keyword">return</span> http.requestQuickGet(<span class="hljs-string">'http://localhost:31001/cms/page/list/'</span>+page+<span class="hljs-string">'/'</span>+size)&#125;</code></pre></div><p><code>axios</code>实现了<code>http</code>方法的封装，<code>vue.js</code> 官方不再继续维护 <code>vue-resource</code>,推荐使用 <code>axios</code>。</p><h3 id="2、调用"><a href="#2、调用" class="headerlink" title="2、调用"></a>2、调用</h3><p>前端 <code>page_list.vue</code> 页面导入cms.js，调用js方法请求服务端页面查询接口。</p><p>请求的参数根据后端的 <code>Swagger</code> 文档进行配置 <a href="http://localhost:31001/swagger-ui.html" target="_blank" rel="noopener">http://localhost:31001/swagger-ui.html</a></p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image19.png" srcset="/img/loading.gif" alt></p><p>配置</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;  <span class="hljs-comment">//导入api</span>  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cmsApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/cms'</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;      <span class="hljs-keyword">return</span> &#123;        list:[],        total:<span class="hljs-number">50</span>,        params:&#123;          page:<span class="hljs-number">1</span>,<span class="hljs-comment">//页码</span>          size:<span class="hljs-number">2</span><span class="hljs-comment">//每页显示个数</span>        &#125;      &#125;    &#125;,    methods:&#123;      changePage:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.query()      &#125;,    <span class="hljs-comment">//查询</span>      query:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">//调用服务端接口</span>        cmsApi.page_list(<span class="hljs-keyword">this</span>.params.page, <span class="hljs-keyword">this</span>.params.size).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;          <span class="hljs-comment">//将res结果数据赋值给数据模型对象</span>          <span class="hljs-keyword">this</span>.list = res.queryResult.list          <span class="hljs-keyword">this</span>.total = res.queryResult.total        &#125;)      &#125;    &#125;  &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="3-跨域问题解决"><a href="#3-跨域问题解决" class="headerlink" title="3. 跨域问题解决"></a>3. 跨域问题解决</h2><p>测试 上边的代理 ，结果 报错如下 ：</p><div class="hljs"><pre><code class="hljs html">No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin'http://localhost:11000' is therefore not allowed access.</code></pre></div><p>原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。</p><p>解决：采用 <code>proxyTable</code> 解决。</p><h3 id="proxyTable-是什么？"><a href="#proxyTable-是什么？" class="headerlink" title="proxyTable 是什么？"></a>proxyTable 是什么？</h3><p>vue-cli提供的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了 <code>http-proxymiddleware</code>（<a href="https://github.com/chimurai/http-proxy-middleware%EF%BC%89%EF%BC%8C%E5%AE%83%E6%98%AFhttp%E4%BB%A3%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E5%AE%83%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">https://github.com/chimurai/http-proxy-middleware），它是http代理中间件，它依赖</a> <code>node.js</code>，<br>基本原理是用服务端代理解决浏览器跨域：</p><h3 id="cms跨域解决原理："><a href="#cms跨域解决原理：" class="headerlink" title="cms跨域解决原理："></a>cms跨域解决原理：</h3><p>1、访问页面<a href="http://localhost:11000/" target="_blank" rel="noopener">http://localhost:11000/</a></p><p>2、页面请求<a href="http://localhost:11000/cms" target="_blank" rel="noopener">http://localhost:11000/cms</a></p><blockquote><p>由于url由<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:31001/cms…改为“<a href="http://localhost:11000/cms.&quot;，所以不存在跨域" target="_blank" rel="noopener">http://localhost:11000/cms.&quot;，所以不存在跨域</a></p></blockquote><p>3、通过proxyTable由node服务器代理请求 <a href="http://localhost:31001/cms" target="_blank" rel="noopener">http://localhost:31001/cms</a>.</p><blockquote><p>服务端不存在跨域问题</p></blockquote><p>具体的配置如下：</p><p>1、修改<code>api</code>方法中<code>url</code>的定义</p><p>请求前加/api前缀</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//public是对axios的工具类封装，定义了http请求方法</span><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./../../../base/api/public'</span>  <span class="hljs-comment">//ES6 导入</span><span class="hljs-keyword">let</span> sysConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/../config/sysConfig'</span>)<span class="hljs-keyword">let</span> apiUrl = sysConfig.xcApiUrlPre<span class="hljs-comment">//页面查询</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_list = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;  <span class="hljs-comment">//定义方法，请求服务端查询接口</span>  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl + <span class="hljs-string">'/cms/page/list/'</span>+page+<span class="hljs-string">'/'</span>+size)&#125;</code></pre></div><p>2、在 <code>config/index.js</code> 下配置 <code>proxyTable</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'/api/cms'</span>: &#123;    target: <span class="hljs-string">'http://localhost:31001'</span>,    pathRewrite: &#123;    <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span><span class="hljs-comment">//实际请求去掉/api</span>&#125;</code></pre></div><h2 id="4-分页查询测试"><a href="#4-分页查询测试" class="headerlink" title="4. 分页查询测试"></a>4. 分页查询测试</h2><p>1、定义分页视图</p><div class="hljs"><pre><code class="hljs vue"> &lt;el-pagination      @size-change&#x3D;&quot;handleSizeChange&quot;      @current-change&#x3D;&quot;handleCurrentChange&quot;      :page-sizes&#x3D;&quot;[5,10, 20, 30, 100]&quot;      :current-page&#x3D;&quot;this.params.page&quot;      :page-size&#x3D;&quot;this.params.size&quot;      :total&#x3D;&quot;this.total&quot;      layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;      v-on:current-change&#x3D;&quot;changePage&quot;      style&#x3D;&quot;float:right;&quot;&gt;&lt;&#x2F;el-pagination&gt;</code></pre></div><p>2、定义数据模型对象</p><div class="hljs"><pre><code class="hljs js">data() &#123;     <span class="hljs-keyword">return</span> &#123;       list:[],       total:<span class="hljs-number">0</span>,  <span class="hljs-comment">//数据总量</span>       params:&#123;         page:<span class="hljs-number">1</span>,<span class="hljs-comment">//默认页码</span>         size:<span class="hljs-number">10</span><span class="hljs-comment">//默认每页显示个数</span>       &#125;     &#125;&#125;,</code></pre></div><p>3、定义分页方法，接收页码参数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//触发分页参数变动</span>handleSizeChange(val) &#123;  <span class="hljs-keyword">this</span>.params.size = val  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`每页 <span class="hljs-subst">$&#123;val&#125;</span> 条`</span>);&#125;,handleCurrentChange(val) &#123;  <span class="hljs-keyword">this</span>.params.page = val  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`当前页: <span class="hljs-subst">$&#123;val&#125;</span>`</span>);&#125;,<span class="hljs-comment">//分页查询，接收page页码</span>changePage()&#123;  <span class="hljs-keyword">this</span>.query()&#125;,<span class="hljs-comment">//查询</span>query:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//调用服务端接口</span>  cmsApi.page_list(<span class="hljs-keyword">this</span>.params.page, <span class="hljs-keyword">this</span>.params.size).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;    <span class="hljs-comment">//将res结果数据赋值给数据模型对象</span>    <span class="hljs-keyword">this</span>.list = res.queryResult.list    <span class="hljs-keyword">this</span>.total = res.queryResult.total  &#125;)&#125;</code></pre></div><p>修改完毕，分页测试效果如下</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image20.png" srcset="/img/loading.gif" alt></p><h2 id="5-进入页面立即查询"><a href="#5-进入页面立即查询" class="headerlink" title="5.进入页面立即查询"></a>5.进入页面立即查询</h2><p>目前实现的功能是进入页面点击查询按钮向服务端表求查询，实际的需求是进入页面立即查询。</p><p><strong>那么如何实现？</strong></p><p>这要用到 <code>vue</code> 的钩子函数，每个 <code>Vue</code> 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 <code>DOM</code> 并在数据变化时更新 <code>DOM</code> 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会 。</p><p>通常使用最多的是 <code>created</code> 和 <code>mounted</code> 两个钩子：</p><p><code>created</code>：vue实例已创建但是DOM元素还没有渲染生成。</p><p><code>mounted</code>：DOM元素渲染生成完成后调用 。</p><p>本例子在两个方法的任意一个都满足需求：</p><p>添加如下代码：</p><div class="hljs"><pre><code class="hljs js">mounted() &#123;    <span class="hljs-comment">//默认查询页面</span>    <span class="hljs-keyword">this</span>.query()&#125;</code></pre></div><p>重新刷新页面。</p><h1 id="六、前端请求响应流程小结"><a href="#六、前端请求响应流程小结" class="headerlink" title="六、前端请求响应流程小结"></a>六、前端请求响应流程小结</h1><p>参考 “讲义–&gt;前后端请求响应流程.png”，如下：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image21.png" srcset="/img/loading.gif" alt></p><p>根据图中所示，我们总结流程如下：</p><p>1、在浏览器输入前端url</p><p>2、前端框架 <code>vue.js</code> 根据 <code>url</code> 解析路由，根据路由找到 <code>page_list.vue</code> 页面</p><p>3、首先执行 <code>page_list.vue</code> 中的钩子方法</p><p>4、在钩子方法中调用 <code>query</code> 方法。</p><p>5、在 <code>query</code> 方法中调用 <code>cms.js</code> 中的 <code>page_list</code> 方法</p><p>6、<code>cms.js</code> 中的 <code>page_list</code> 方法通过 <code>axios</code> 请求服务端接口</p><p>7、采用 <code>proxyTable</code> 解决跨域问题，<code>node.js</code> 将请求转发到服务端(<a href="http://localhost:31001/cms/page/list" target="_blank" rel="noopener">http://localhost:31001/cms/page/list</a>)</p><p>8、服务端处理，将查询结果响应给前端</p><p>9、成功响应调用 <code>then</code> 方法，在 <code>then</code> 方法中处理响应结果，将查询结果赋值给数据模型中的total和list变量。</p><p>10、<code>vue.js</code> 通过双向数据绑定将list数据渲染输出 。</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day01：搭建环境、CMS服务端开发</title>
    <link href="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/"/>
    <url>/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/</url>
    
    <content type="html"><![CDATA[<h1 id="😎-知识点概览"><a href="#😎-知识点概览" class="headerlink" title="😎 知识点概览"></a>😎 知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day01</code> 的内容</p><ul><li>搭建门户页面</li><li>搭建服务端基础工程</li><li>页面查询服务的构建</li><li>使用<code>MangoDB</code> 进行 <code>CRUD</code> 操作</li><li><code>Swagger</code> 的基本使用</li><li><code>Postman</code> 的基本使用</li></ul><h1 id="一、项目架构"><a href="#一、项目架构" class="headerlink" title="一、项目架构"></a>一、项目架构</h1><h2 id="1-业务架构"><a href="#1-业务架构" class="headerlink" title="1. 业务架构"></a>1. 业务架构</h2><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image1.png" srcset="/img/loading.gif" alt></p><h2 id="2-技术架构"><a href="#2-技术架构" class="headerlink" title="2. 技术架构"></a>2. 技术架构</h2><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image2.png" srcset="/img/loading.gif" alt></p><h1 id="二、CMS-门户工程搭建"><a href="#二、CMS-门户工程搭建" class="headerlink" title="二、CMS 门户工程搭建"></a>二、CMS 门户工程搭建</h1><h2 id="1-安装-WebStorm"><a href="#1-安装-WebStorm" class="headerlink" title="1. 安装 WebStorm"></a>1. 安装 WebStorm</h2><p>参考 <code>WebStorm安装手册.md</code> 安装WebStorm，导入 <code>资料\门户\xc-ui-pc-static-portal.rar</code> 压缩包下的内容。</p><h2 id="2-Nginx虚拟主机"><a href="#2-Nginx虚拟主机" class="headerlink" title="2. Nginx虚拟主机"></a>2. Nginx虚拟主机</h2><p>在nginx中配置虚拟主机：</p><div class="hljs"><pre><code class="hljs nginx">server&#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> www.xuecheng.com;    <span class="hljs-attribute">ssi</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">ssi_silent_errors</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-attribute">alias</span> F:/teach/xcEdu/xcEduUI/xc‐ui‐pc‐static‐portal/;    <span class="hljs-attribute">index</span> index.html;    &#125;&#125;</code></pre></div><p>F:/teach/xcEdu/xcEduUI/xc-ui-pc-static-portal/ 本目录即为门户的主目录，自行修改为自己的路径</p><h1 id="三、CMS-服务端工程搭建"><a href="#三、CMS-服务端工程搭建" class="headerlink" title="三、CMS 服务端工程搭建"></a>三、CMS 服务端工程搭建</h1><h2 id="1-基础工程搭建"><a href="#1-基础工程搭建" class="headerlink" title="1. 基础工程搭建"></a>1. 基础工程搭建</h2><p>创建一个项目文件夹 <code>xcEduService01</code>导入 <code>资料\基础工程\基础工程.zip</code> 中的基础工程，并依次将所有基础工程添加至<code>pom</code>项目中</p><h2 id="2-导入MongoDB数据"><a href="#2-导入MongoDB数据" class="headerlink" title="2. 导入MongoDB数据"></a>2. 导入MongoDB数据</h2><p>搭建好mongodb数据库后，导入 <code>资料\mongodb\xc_cms</code> 内的json数据</p><h2 id="3-定义接口"><a href="#3-定义接口" class="headerlink" title="3. 定义接口"></a>3. 定义接口</h2><h3 id="定义请求以及相应类型"><a href="#定义请求以及相应类型" class="headerlink" title="定义请求以及相应类型"></a>定义请求以及相应类型</h3><p>在 <code>domain.cms.request</code> 下创建 <code>QueryPageRequest</code> 并继承 <code>RequestData</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.cms.request;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.request.RequestData;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPageRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestData</span> </span>&#123;    <span class="hljs-comment">//站点id</span>    <span class="hljs-keyword">private</span> String siteId;    <span class="hljs-comment">//页面id</span>    <span class="hljs-keyword">private</span> String pageId;    <span class="hljs-comment">//页面名称</span>    <span class="hljs-keyword">private</span> String pageName;    <span class="hljs-comment">//别名</span>    <span class="hljs-keyword">private</span> String pageAliase;    <span class="hljs-comment">//模板id</span>    <span class="hljs-keyword">private</span> String templateId;&#125;</code></pre></div><h3 id="定义响应接口"><a href="#定义响应接口" class="headerlink" title="定义响应接口"></a>定义响应接口</h3><p>在 <code>com.xuecheng.api.cms</code> 下定义 <code>CmsPageControllerApi</code> 查询列表的响应格式统一为 <code>QueryResponseResult</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.cms;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest)</span></span>;&#125;</code></pre></div><h1 id="四、页面查询服务开发"><a href="#四、页面查询服务开发" class="headerlink" title="四、页面查询服务开发"></a>四、页面查询服务开发</h1><h2 id="1-创建CMS服务工程"><a href="#1-创建CMS服务工程" class="headerlink" title="1. 创建CMS服务工程"></a>1. 创建CMS服务工程</h2><p>导入 <code>pom.xml</code> 配置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-manage-cms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-utils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>创建一个 <code>xc-service-manage-cms</code> 的maven工程，依赖父工程 <code>xc-framework-parent</code> ，</p><p>创建在 <code>com.xuecheng.manage_cms</code> 包并在包下创建config、dao、service、controller 等包，目录结构如下</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image3.png" srcset="/img/loading.gif" alt></p><p>创建入口文件 <code>ManageCmsApplication</code>，并扫描相应的包</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.domain.EntityScan;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EntityScan</span>(<span class="hljs-string">"com.xuecheng.framework.domain.cms"</span>) <span class="hljs-comment">//扫描公共的实体类</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.api"</span>&#125;) <span class="hljs-comment">//扫描接口</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.manage_cms"</span>&#125;)  <span class="hljs-comment">// 扫描本项目下的所有类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>resources 下创建 <code>application.yml</code></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">31001</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc-service-manage-cms</span>  <span class="hljs-attr">data:</span>    <span class="hljs-attr">mongodb:</span>      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://root:123123@localhost:27017</span>      <span class="hljs-attr">database:</span> <span class="hljs-string">xc_cms</span></code></pre></div><p>resources 下导入日志文件，直接复制 <code>资料\CMS配置文件</code> 下的 <code>logback-spring.xml</code></p><h2 id="2-定义dao"><a href="#2-定义dao" class="headerlink" title="2. 定义dao"></a>2. 定义dao</h2><p>在dao下定义一个接口 <code>CmsPageRepository</code> 继承 <code>MongoRepository</code> 类</p><blockquote><p>MongoRepository&lt;CmsPage,String&gt; 中的 CmsPage 对应我们mongodb中集合的实体类</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.dao;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsPage</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h2 id="3-单元测试"><a href="#3-单元测试" class="headerlink" title="3. 单元测试"></a>3. 单元测试</h2><h3 id="查询测试"><a href="#查询测试" class="headerlink" title="查询测试"></a>查询测试</h3><p>定义<code>CmsPageRepository</code> 的测试类 <code>CmsPageRepositoryTest</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;<span class="hljs-keyword">import</span> org.springframework.data.domain.PageRequest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">CmsPageRepositoryTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;        List&lt;CmsPage&gt; all = cmsPageRepository.findAll();        System.out.println(all);    &#125;    <span class="hljs-comment">//分页查询</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindPage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//分页参数</span>        <span class="hljs-keyword">int</span> page = <span class="hljs-number">0</span>; <span class="hljs-comment">//从0开始</span>        <span class="hljs-keyword">int</span> size = <span class="hljs-number">10</span>;        Pageable pageable = PageRequest.of(page,size);        Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(pageable);        System.out.println(all);    &#125;&#125;</code></pre></div><p>运行测试，成功查询到分页数据。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//添加</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//定义实体类</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    <span class="hljs-comment">//设置属性</span>    cmsPage.setSiteId(<span class="hljs-string">"s01"</span>);    cmsPage.setTemplateId(<span class="hljs-string">"t01"</span>);    cmsPage.setPageName(<span class="hljs-string">"测试页面"</span>);    cmsPage.setPageCreateTime(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">//参数集合</span>    List&lt;CmsPageParam&gt; cmsPageParams = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    CmsPageParam cmsPageParam = <span class="hljs-keyword">new</span> CmsPageParam();    cmsPageParam.setPageParamName(<span class="hljs-string">"param1"</span>);    cmsPageParam.setPageParamValue(<span class="hljs-string">"value1"</span>);    <span class="hljs-comment">//将参数添加至集合内</span>    cmsPageParams.add(cmsPageParam);    <span class="hljs-comment">//实体添加参数集</span>    cmsPage.setPageParams(cmsPageParams);    cmsPageRepository.save(cmsPage);&#125;</code></pre></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span></span>&#123;    cmsPageRepository.deleteById(<span class="hljs-string">"5e705470cc53e4266c135ee7"</span>);    System.out.println(<span class="hljs-string">"删除成功!"</span>);&#125;</code></pre></div><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//修改</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;    Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(<span class="hljs-string">"5e705470cc53e4266c135ee7"</span>);    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;  <span class="hljs-comment">//判断是否为空，jdk1.8新特性optional</span>        CmsPage cmsPage = optional.get();        cmsPage.setPageName(<span class="hljs-string">"测试页面02"</span>);        CmsPage save = cmsPageRepository.save(cmsPage);        System.out.println(<span class="hljs-string">"修改成功 "</span> + save);    &#125;&#125;</code></pre></div><h2 id="4-配置-Service"><a href="#4-配置-Service" class="headerlink" title="4.配置 Service"></a>4.配置 Service</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.service;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.dao.CmsPageRepository;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;<span class="hljs-keyword">import</span> org.springframework.data.domain.PageRequest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page,<span class="hljs-keyword">int</span> size,QueryPageRequest queryPageRequest)</span> </span>&#123;        <span class="hljs-comment">//过滤条件</span>        <span class="hljs-keyword">if</span>(page &lt;= <span class="hljs-number">0</span>)&#123;            page = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;            size = <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">//创建分页查询参数</span>        PageRequest pageable = PageRequest.of(page, size);        <span class="hljs-comment">//分页查询数据</span>        Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(pageable);        <span class="hljs-comment">//整理查询到的数据</span>        QueryResult queryResult = <span class="hljs-keyword">new</span> QueryResult();        queryResult.setList(all.getContent());        queryResult.setTotal(all.getTotalElements());        <span class="hljs-comment">//返回结果</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);    &#125;&#125;</code></pre></div><h2 id="5-配置-Controller"><a href="#5-配置-Controller" class="headerlink" title="5. 配置 Controller"></a>5. 配置 Controller</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.web.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.cms.CmsPageControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.service.PageService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/cms/page"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PageService pageService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list/&#123;page&#125;/&#123;size&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page, @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest) </span>&#123;        <span class="hljs-keyword">return</span> pageService.findList(page,size,queryPageRequest);    &#125;&#125;</code></pre></div><h2 id="6-接口开发规范"><a href="#6-接口开发规范" class="headerlink" title="6.接口开发规范"></a>6.接口开发规范</h2><h3 id="Api请求及响应规范"><a href="#Api请求及响应规范" class="headerlink" title="Api请求及响应规范"></a>Api请求及响应规范</h3><p>为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。</p><ul><li><code>get</code> 请求时，采用key/value格式请求，SpringMVC可采用基本类型的变量接收，也可以采用对象接收。</li><li><code>Post</code> 请求时，可以提交form表单数据（application/x-www-form-urlencoded）和 <code>Json</code> 数据（Content-Type=application/json），文件等多部件类型（multipart/form-data）三种数据格式，SpringMVC接收Json数据使用@RequestBody注解解析请求的json数据。</li><li>响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。</li><li>响应结果统一格式为 <code>json</code>。</li></ul><h3 id="Api定义约束"><a href="#Api定义约束" class="headerlink" title="Api定义约束"></a>Api定义约束</h3><p>Api 定义使用SpringMVC来完成，由于此接口后期将作为微服务远程调用使用，在定义接口时有如下限制：</p><ul><li><code>@PathVariable</code> 统一指定参数名称，如：<code>@PathVariable(&quot;id&quot;)</code></li><li><code>@RequestParam</code> 统一指定参数名称，如：<code>@RequestParam(&quot;id&quot;)</code></li></ul><h1 id="五、Swagger-生成接口文档"><a href="#五、Swagger-生成接口文档" class="headerlink" title="五、Swagger 生成接口文档"></a>五、Swagger 生成接口文档</h1><h2 id="1-Swagger介绍"><a href="#1-Swagger介绍" class="headerlink" title="1. Swagger介绍"></a>1. Swagger介绍</h2><p>OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程，目前版本是V3.0，并且已经发布并开源在github上。<a href="https://github.com/OAI/OpenAPI-Specification" target="_blank" rel="noopener">https://github.com/OAI/OpenAPI-Specification</a></p><p>Swagger是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发。 (<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a>)</p><p>Spring Boot 可以集成Swagger，生成Swagger接口，Spring Boot是Java领域的神器，它是Spring项目下快速构建项目的框架。</p><h2 id="2-开启-Swagger"><a href="#2-开启-Swagger" class="headerlink" title="2. 开启 Swagger"></a>2. 开启 Swagger</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;<span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;<span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<span class="hljs-comment">//</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Configuration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.xuecheng"</span>))                .paths(PathSelectors.any())                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"学成网api文档"</span>)                .description(<span class="hljs-string">"学成网api文档"</span>)<span class="hljs-comment">//                .termsOfServiceUrl("/")</span>                .version(<span class="hljs-string">"1.0"</span>)                .build();    &#125;&#125;</code></pre></div><p>开启 <code>swagger</code> 后，它会自动扫描 <code>com.xuecheng</code> 包下所有标记了 <code>@RestController</code> 这个注解的类，根据这个类的方法来生成接口文档。</p><p>运行项目，访问 <a href="http://localhost:31001/swagger-ui.html" target="_blank" rel="noopener">http://localhost:31001/swagger-ui.html</a> 就可以看到我们刚才定义的这个 controller</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image4.png" srcset="/img/loading.gif" alt="image-20200317171117409.png"></p><h2 id="3-Swagger常用注解"><a href="#3-Swagger常用注解" class="headerlink" title="3. Swagger常用注解"></a>3. Swagger常用注解</h2><p>在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下：</p><ul><li>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口</li><li>@ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiModelProperty：用对象接收参数时，描述对象的一个字段</li><li>@ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述</li><li>@ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息</li><li>@ApiImplicitParam：一个请求参数</li><li>@ApiImplicitParams：多个请求参数</li><li>@ApiImplicitParam属性：</li></ul><table><thead><tr><th>属性</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>paramType</td><td>查询参数类型</td><td></td></tr><tr><td>path</td><td>以地址的形式提交数据</td><td></td></tr><tr><td>query</td><td>直接跟参数完成自动映射赋值</td><td></td></tr><tr><td>body</td><td>以流的形式提交 仅支持POST</td><td></td></tr><tr><td>header</td><td>参数在request headers 里边提交</td><td></td></tr><tr><td>form</td><td>以form表单的形式提交 仅支持POST</td><td></td></tr><tr><td>dataType</td><td>参数的数据类型 只作为标志说明，并没有实际验证</td><td></td></tr><tr><td>Long</td><td></td><td></td></tr><tr><td>String</td><td></td><td></td></tr><tr><td>name</td><td>接收参数名</td><td></td></tr><tr><td>value</td><td>接收参数的意义描述</td><td></td></tr><tr><td>required</td><td>参数是否必填</td><td></td></tr><tr><td>true</td><td>必填</td><td></td></tr><tr><td>false</td><td>非必填</td><td></td></tr><tr><td>defaultValue</td><td>默认值</td><td></td></tr></tbody></table><h2 id="4-Swagger接口定义"><a href="#4-Swagger接口定义" class="headerlink" title="4. Swagger接口定义"></a>4. Swagger接口定义</h2><p>使用 swagger 的常用注解来描述接口信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Api</span>(value=<span class="hljs-string">"cms页面管理接口"</span>,description = <span class="hljs-string">"cms页面管理接口，提供页面的增、删、改、查"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"分页查询页面列表"</span>)    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"page"</span>,value = <span class="hljs-string">"页码"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"path"</span>,dataType=<span class="hljs-string">"int"</span>),        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"size"</span>,value = <span class="hljs-string">"每页记录数"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"path"</span>,dataType=<span class="hljs-string">"int"</span>)    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest)</span></span>;&#125;</code></pre></div><p>在QueryPageRequest类中使用注解 ApiModelProperty 对属性注释</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPageRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestData</span> </span>&#123;    <span class="hljs-comment">//站点id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"站点id"</span>)    <span class="hljs-keyword">private</span> String siteId;    <span class="hljs-comment">//页面ID</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面ID"</span>)    <span class="hljs-keyword">private</span> String pageId;    <span class="hljs-comment">//页面名称</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面名称"</span>)    <span class="hljs-keyword">private</span> String pageName;    <span class="hljs-comment">//页面别名</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面别名"</span>)    <span class="hljs-keyword">private</span> String pageAliase;    <span class="hljs-comment">//模版id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"模版id"</span>)    <span class="hljs-keyword">private</span> String templateId;&#125;</code></pre></div><p>重启项目，访问 <a href="http://localhost:31001/swagger-ui.html" target="_blank" rel="noopener">http://localhost:31001/swagger-ui.html</a> ，可以看到我们添加的描述信息</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image5.png" srcset="/img/loading.gif" alt></p><h1 id="五、Postman-基本使用"><a href="#五、Postman-基本使用" class="headerlink" title="五、Postman 基本使用"></a>五、Postman 基本使用</h1><p><code>Postman</code> 是一款功能强大的http接口测试工具，使用 <code>postman</code> 可以完成 <code>http</code> 各种请求的功能测试。</p><p>官方地址：<a href="https://www.getpostman.com/" target="_blank" rel="noopener">https://www.getpostman.com/</a></p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image6.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>Swagger</tag>
      
      <tag>Postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB入门</title>
    <link href="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB入门"><a href="#MongoDB入门" class="headerlink" title="MongoDB入门"></a>MongoDB入门</h1><h2 id="1-mongodb介绍"><a href="#1-mongodb介绍" class="headerlink" title="1.mongodb介绍"></a>1.mongodb介绍</h2><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/1.png" srcset="/img/loading.gif" alt></p><h2 id="2-下载mongodb"><a href="#2-下载mongodb" class="headerlink" title="2.下载mongodb"></a>2.下载mongodb</h2><p>typora-copy-images-to:mongodb_imgmongodb安装1mongodb介绍2下载mongodbMongoDB提供了可用于32位和64位系统的预编译二进制包，你可以从MongoDB官网下载安装。官方地址：<a href="https://www.mongodb.com/本教程下载3.4版本http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi" target="_blank" rel="noopener">https://www.mongodb.com/本教程下载3.4版本http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi</a></p><h2 id="3-安装mongodb"><a href="#3-安装mongodb" class="headerlink" title="3.安装mongodb"></a>3.安装mongodb</h2><p>在win7系统安装mongodb需要vc++运行库，如果没有则会提示“无法启动此程序，因为计算机中丢失VCRUNTIME140.dll”。去网上下载或使用360安装：</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/2.png" srcset="/img/loading.gif" alt></p><p>运行mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/3.png" srcset="/img/loading.gif" alt></p><p>选择自定义路径</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/4.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/5.png" srcset="/img/loading.gif" alt></p><h2 id="4-启动mongodb"><a href="#4-启动mongodb" class="headerlink" title="4.启动mongodb"></a>4.启动mongodb</h2><p>创建几个文件夹具体如下：数据库路径（data目录）、日志路径（logs目录）和日志文件（mongo.log文件）</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/6.png" srcset="/img/loading.gif" alt></p><p>创建配置文件mongo.conf，文件内容如下:</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#数据库路径</span><span class="hljs-attr">dbpath</span>=<span class="hljs-string">d:\MongoDB\Server\3.4\data</span><span class="hljs-comment">#日志输出文件路径</span><span class="hljs-attr">logpath</span>=<span class="hljs-string">d:\MongoDB\Server\3.4\logs\mongo.log</span><span class="hljs-comment">#错误日志采用追加模式</span><span class="hljs-attr">logappend</span>=<span class="hljs-string">true</span><span class="hljs-comment">#启用日志文件，默认启用</span><span class="hljs-attr">journal</span>=<span class="hljs-string">true</span><span class="hljs-comment">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><span class="hljs-attr">quiet</span>=<span class="hljs-string">true</span><span class="hljs-comment">#端口号默认为27017</span><span class="hljs-attr">port</span>=<span class="hljs-string">27017</span></code></pre></div><p>注意如果出现服务启动失败，或者遇到特点错误100情况 第一种情况是dbpath后有多余空格，第二种情况是其他参数后面带有空格（亲测被坑</p><p>安装MongoDB服务通过执行bin/mongod.exe，使用–install选项来安装服务，使用–config选项来指定之前创建的配置文件。cmd进入d:\MongoDB\Server\3.4\bin</p><div class="hljs"><pre><code class="hljs shell">mongod.exe‐‐config"d:\MongoDB\Server\3.4\mongo.conf"‐‐install</code></pre></div><p>启动MongoDB服务</p><div class="hljs"><pre><code class="hljs shell">net start MongoDB</code></pre></div><p>关闭MongoDB服务</p><div class="hljs"><pre><code class="hljs shell">net stop MongoDB</code></pre></div><p>移除MongoDB服务</p><div class="hljs"><pre><code class="hljs shell">"d:\MongoDB\Server\3.4\bin\mongod.exe"‐‐remove</code></pre></div><p>启动mongodb服务，命令执行后，浏览器中输入<a href="http://127.0.0.1:27017" target="_blank" rel="noopener">http://127.0.0.1:27017</a></p><p>看到如下界面即说明启动成功</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/7.png" srcset="/img/loading.gif" alt></p><h2 id="5-安装studio3t"><a href="#5-安装studio3t" class="headerlink" title="5.安装studio3t"></a>5.安装studio3t</h2><p>studio3t是mongodb优秀的客户端工具(类似sqlyog操作mysql的工具）。官方地址在<a href="https://studio3t.com/" target="_blank" rel="noopener">https://studio3t.com/</a></p><p>下载最新版即可</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/8.png" srcset="/img/loading.gif" alt></p><p>下载默认安装后，会提示需要账号秘密，可直接点击完成，跳过 默认为试用版</p><p>创建一个新连接：</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/9.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/10.png" srcset="/img/loading.gif" alt></p><p>填写连接信息：（可不需要mangodb账号秘密直接连接）</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/11.png" srcset="/img/loading.gif" alt></p><p>连接成功：</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/12.png" srcset="/img/loading.gif" alt></p><h2 id="6-mongodb入门"><a href="#6-mongodb入门" class="headerlink" title="6.mongodb入门"></a>6.mongodb入门</h2><h3 id="6-1基础概念"><a href="#6-1基础概念" class="headerlink" title="6.1基础概念"></a>6.1基础概念</h3><p>在mongodb中是通过数据库、集合、文档的方式来管理数据，下边是mongodb与关系数据库的一些概念对比：</p><table><thead><tr><th align="center">SQL术语/概念</th><th align="center">MongoDB术语/概念</th><th align="left">解释/说明</th></tr></thead><tbody><tr><td align="center">database</td><td align="center">database</td><td align="left">数据库</td></tr><tr><td align="center">table</td><td align="center">collection</td><td align="left">数据库表/集合</td></tr><tr><td align="center">row</td><td align="center">document</td><td align="left">数据记录行/文档</td></tr><tr><td align="center">column</td><td align="center">field</td><td align="left">数据字段/域</td></tr><tr><td align="center">index</td><td align="center">index</td><td align="left">索引</td></tr><tr><td align="center">table joins</td><td align="center"></td><td align="left">表连接（MongoDB不支持）</td></tr><tr><td align="center">primary key</td><td align="center">primary key</td><td align="left">主键,MongoDB自动在每个集合中添加_id的主键</td></tr></tbody></table><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/13.png" srcset="/img/loading.gif" alt></p><p>1、一个mongodb实例可以创建多个数据库</p><p>2、一个数据库可以创建多个集合</p><p>3、一个集合可以包括多个文档。</p><h3 id="6-2连接mongodb"><a href="#6-2连接mongodb" class="headerlink" title="6.2连接mongodb"></a>6.2连接mongodb</h3><p>mongodb的使用方式是客户服务器模式，即使用一个客户端连接mongodb数据库（服务端）。</p><p>1、命令格式</p><div class="hljs"><pre><code class="hljs shell">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code></pre></div><p>mongodb://固定前缀</p><p>username：账号，可不填</p><p>password：密码，可不填</p><p>host：主机名或ip地址，只有host主机名为必填项。</p><p>port：端口，可不填，默认27017</p><p>/database：连接某一个数据库</p><p>?options：连接参数，key/value对</p><p>例子：</p><div class="hljs"><pre><code class="hljs shell">mongodb://localhost连接本地数据库27017端口mongodb://root:itcast@localhost使用用户名root密码为itcast连接本地数据库27017端口mongodb://localhost,localhost:27018,localhost:27019，连接三台主从服务器，端口为27017、27018、27019</code></pre></div><p>2、使用mongodb自带的javascriptshell（mongo.exe）连接</p><p>windows版本的mongodb安装成功，在安装目录下的bin目录有mongo.exe客户端程序</p><p>cmd状态执行mongo.exe:</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/14.png" srcset="/img/loading.gif" alt></p><p>此时就可以输入命令来操作mongodb数据库了，javascriptshell可以运行javascript程序。</p><p>3、使用studio3T连接</p><p>4、使用java程序连接</p><p>详细参数：<a href="http://mongodb.github.io/mongo-java-driver/3.4/driver/tutorials/connect-to-mongodb/" target="_blank" rel="noopener">http://mongodb.github.io/mongo-java-driver/3.4/driver/tutorials/connect-to-mongodb/</a></p><p>添加依赖：</p><div class="hljs"><pre><code class="hljs java">&lt;dependency&gt;&lt;groupId&gt;org.mongodb&lt;/groupId&gt;&lt;artifactId&gt;mongo‐java‐driver&lt;/artifactId&gt;&lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></div><p>测试程序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConnection</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//创建mongodb客户端</span>    MongoClientmongoClient=newMongoClient(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">27017</span>);    <span class="hljs-comment">//或者采用连接字符串</span>    <span class="hljs-comment">//MongoClientURIconnectionString=newMongoClientURI("mongodb://root:root@localhost:27017");</span>    <span class="hljs-comment">//MongoClientmongoClient=newMongoClient(connectionString);</span>    <span class="hljs-comment">//连接数据库</span>    MongoDatabasedatabase=mongoClient.getDatabase(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">//连接collectionMongo</span>    Collection&lt;Document&gt;collection=database.getCollection(<span class="hljs-string">"student"</span>);    <span class="hljs-comment">//查询第一个文档</span>    DocumentmyDoc=collection.find().first();    <span class="hljs-comment">//得到文件内容json串</span>    Stringjson=myDoc.toJson();System.out.println(json);&#125;</code></pre></div><h3 id="6-3数据库"><a href="#6-3数据库" class="headerlink" title="6.3数据库"></a>6.3数据库</h3><p>1、查询数据库</p><p>showv dbs 查询全部数据库</p><p>db 显示当前数据库</p><p>2、创建数据库命令格式：</p><div class="hljs"><pre><code class="hljs shell">useDATABASE_NAME</code></pre></div><p>例子：</p><p>usetest02</p><p>有test02数据库则切换到此数据库，没有则创建</p><p>注意：</p><p>新创建的数据库不显示，需要至少包括一个集合。</p><p>3、删除数据库（慎用！！！）</p><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.dropDatabase()</code></pre></div><p>例子：</p><p>删除test02数据库</p><p>先切换数据库：usetest02</p><p>再执行删除：db.dropDatabase()</p><h3 id="6-4集合"><a href="#6-4集合" class="headerlink" title="6.4集合"></a>6.4集合</h3><p>集合相当于关系数据库中的表，一个数据库可以创建多个集合，一个集合是将相同类型的文档管理起来。</p><p>1、创建集合</p><div class="hljs"><pre><code class="hljs shel">db.createCollection(name,options)name: 新创建的集合名称options: 创建参数</code></pre></div><p>2.删除集合</p><div class="hljs"><pre><code class="hljs shell">db.collection.drop()例子：db.student.drop() 删除student集合</code></pre></div><h3 id="6-5文档"><a href="#6-5文档" class="headerlink" title="6.5文档"></a>6.5文档</h3><h4 id="6-5-1插入文档"><a href="#6-5-1插入文档" class="headerlink" title="6.5.1插入文档"></a>6.5.1插入文档</h4><p>mongodb中文档的格式是json格式，下边就是一个文档，包括两个key：_id主键和name</p><div class="hljs"><pre><code class="hljs shell">&#123;"_id":ObjectId("5b2cc4bfa6a44812707739b5"),"name":"黑马程序员"&#125;</code></pre></div><p>插入命令：</p><div class="hljs"><pre><code class="hljs shell">db.COLLECTION_NAME.insert(document)</code></pre></div><p>每个文档默认以_id作为主键，主键默认类型为ObjectId（对象类型），mongodb会自动生成主键值。</p><p>例子：</p><div class="hljs"><pre><code class="hljs shell">db.student.insert(&#123;"name":"黑马程序员","age":10&#125;)</code></pre></div><p>注意：同一个集合中的文档的key可以不相同！但是建议设置为相同的</p><h4 id="6-5-2更新文档"><a href="#6-5-2更新文档" class="headerlink" title="6.5.2更新文档"></a>6.5.2更新文档</h4><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.collection.update(&lt;query&gt;,&lt;update&gt;,&lt;options&gt;)query:查询条件，相当于sql语句的whereupdate：更新文档内容options：选项</code></pre></div><p>1、替换文档</p><p>将符合条件”name”:”北京黑马程序”的第一个文档替换为{“name”:”北京黑马程序员”,”age”:10}</p><div class="hljs"><pre><code class="hljs shell">db.student.update(&#123;"name":"黑马程序员"&#125;,&#123;"name":"北京黑马程序员","age":10&#125;)</code></pre></div><p>2、$set修改器</p><p>使用$set修改器指定要更新的key，key不存在则创建，存在则更新。</p><p>将符合条件”name”:”北京黑马程序”的所有文档更新name和age的值。</p><div class="hljs"><pre><code class="hljs shell">db.student.update(&#123;"name":"黑马程序员"&#125;,&#123;$set:&#123;"name":"北京黑马程序员","age":10&#125;&#125;,&#123;multi:true&#125;)</code></pre></div><p>multi：false表示更新第一个匹配的文档，true表示更新所有匹配的文档</p><h4 id="6-5-3删除文档"><a href="#6-5-3删除文档" class="headerlink" title="6.5.3删除文档"></a>6.5.3删除文档</h4><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.student.remove(&lt;query&gt;)query：删除条件，相当于sql语句中的where</code></pre></div><p>1、删除所有文档</p><p>db.student.remove({})</p><p>2、删除符合条件的文档</p><p>db.student.remove({“name”:”黑马程序员”})</p><h4 id="6-5-4查询文档"><a href="#6-5-4查询文档" class="headerlink" title="6.5.4查询文档"></a>6.5.4查询文档</h4><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.collection.find(query,projection)query：查询条件，可不填projection：投影查询key，可不填</code></pre></div><p>1、查询全部</p><div class="hljs"><pre><code class="hljs shell">db.student.find()</code></pre></div><p>2、查询符合条件的记录</p><p>查询name等为”黑马程序员”的文档。</p><div class="hljs"><pre><code class="hljs shell">db.student.find(&#123;"name":"黑马程序员"&#125;)</code></pre></div><p>3、投影查询</p><p>只显示name和age两个key，_id主键不显示。</p><div class="hljs"><pre><code class="hljs shell">db.student.find(&#123;"name":"黑马程序员"&#125;,&#123;name:1,age:1,_id:0&#125;)</code></pre></div><h3 id="6-6用户"><a href="#6-6用户" class="headerlink" title="6.6用户"></a>6.6用户</h3><h4 id="6-6-1创建用户"><a href="#6-6-1创建用户" class="headerlink" title="6.6.1创建用户"></a>6.6.1创建用户</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs json">mongo&gt;db.createUser(    &#123;user:"&lt;name&gt;",     pwd:"&lt;cleartextpassword&gt;",customData:&#123;&lt;anyinformation&gt;&#125;,     roles:[         &#123;role:"&lt;role&gt;",db:"&lt;database&gt;"&#125;|"&lt;role&gt;",         ...     ]&#125;)</code></pre></div><p>例子：</p><p>创建root用户，角色为root</p><div class="hljs"><pre><code class="hljs json">use admindb.createUser(    &#123;        user:"root",        pwd:"root",        roles:[&#123;role:"root",db:"admin"&#125;]    &#125;)</code></pre></div><p>内置角色如下：</p><p>1.数据库用户角色：read、readWrite;</p><p>2.数据库管理角色：dbAdmin、dbOwner、userAdmin;</p><p>3.集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</p><p>4.备份恢复角色：backup、restore；</p><p>5.所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p><p>6.超级用户角色：root</p><h4 id="6-6-2查询用户"><a href="#6-6-2查询用户" class="headerlink" title="6.6.2查询用户"></a>6.6.2查询用户</h4><p>查询当前库下的所有用户：</p><div class="hljs"><pre><code class="hljs shell">show users</code></pre></div><h4 id="6-6-3删除用户"><a href="#6-6-3删除用户" class="headerlink" title="6.6.3删除用户"></a>6.6.3删除用户</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs shell">db.dropUser("用户名")</code></pre></div><p>例子：</p><p>删除root1用户</p><div class="hljs"><pre><code class="hljs shell">db.dropUser("root1")</code></pre></div><h4 id="6-6-4修改用户"><a href="#6-6-4修改用户" class="headerlink" title="6.6.4修改用户"></a>6.6.4修改用户</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs json">db.updateUser(    "&lt;username&gt;",    &#123;customData:&#123;&lt;anyinformation&gt;&#125;,     roles:[         &#123;role:"&lt;role&gt;",db:"&lt;database&gt;"&#125;|"&lt;role&gt;",         ...     ],         pwd:"&lt;cleartextpassword&gt;"         &#125;,         writeConcern:&#123;&lt;writeconcern&gt;&#125;)</code></pre></div><p>例子:</p><p>修改root用户的角色为readWriteAnyDatabase</p><div class="hljs"><pre><code class="hljs shell">use admindb.updateUser("root",&#123;roles:[&#123;role:"readWriteAnyDatabase",db:"admin"&#125;]&#125;)</code></pre></div><h4 id="6-6-5修改密码"><a href="#6-6-5修改密码" class="headerlink" title="6.6.5修改密码"></a>6.6.5修改密码</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs shell">db.changeUserPassword("username","newPasswd")</code></pre></div><p>例子：</p><p>修改root用户的密码为123</p><div class="hljs"><pre><code class="hljs shell">use admindb.changeUserPassword("root","123")</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义starter</title>
    <link href="/2020/08/04/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2020/08/04/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h1><p>starter：</p><p>​    1、这个场景需要使用到的依赖是什么？</p><p>​    2、如何编写自动配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//指定这个类是一个配置类</span><span class="hljs-meta">@ConditionalOnXXX</span>  <span class="hljs-comment">//在指定条件成立的情况下自动配置类生效</span><span class="hljs-meta">@AutoConfigureAfter</span>  <span class="hljs-comment">//指定自动配置类的顺序</span><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//给容器中添加组件</span><span class="hljs-meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置<span class="hljs-meta">@EnableConfigurationProperties</span> <span class="hljs-comment">//让xxxProperties生效加入到容器中</span>自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</code></pre></div><p>​    3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><h2 id="1）、启动器模块"><a href="#1）、启动器模块" class="headerlink" title="1）、启动器模块"></a>1）、启动器模块</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-comment">&lt;!--启动器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--引入自动配置模块--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h2 id="2）、自动配置模块"><a href="#2）、自动配置模块" class="headerlink" title="2）、自动配置模块"></a>2）、自动配置模块</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"atguigu.hello"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String prefix;    <span class="hljs-keyword">private</span> String suffix;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> prefix;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrefix</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-keyword">this</span>.prefix = prefix;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSuffix</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> suffix;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuffix</span><span class="hljs-params">(String suffix)</span> </span>&#123;        <span class="hljs-keyword">this</span>.suffix = suffix;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    HelloProperties helloProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloProperties <span class="hljs-title">getHelloProperties</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> helloProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHelloProperties</span><span class="hljs-params">(HelloProperties helloProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.helloProperties = helloProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHellAtguigu</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> helloProperties.getPrefix()+<span class="hljs-string">"-"</span> +name + helloProperties.getSuffix();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span> <span class="hljs-comment">//web应用才生效</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HelloProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">HelloServiceAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HelloProperties helloProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>&#123;        HelloService service = <span class="hljs-keyword">new</span> HelloService();        service.setHelloProperties(helloProperties);        <span class="hljs-keyword">return</span> service;    &#125;&#125;</code></pre></div><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot启动配置原理</title>
    <link href="/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="启动配置原理"><a href="#启动配置原理" class="headerlink" title="启动配置原理"></a>启动配置原理</h1><p>几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><p><strong>SpringApplicationRunListener</strong></p><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><p><strong>CommandLineRunner</strong></p><p>启动流程：</p><h2 id="1、创建SpringApplication对象"><a href="#1、创建SpringApplication对象" class="headerlink" title="1、创建SpringApplication对象"></a><strong>1、创建SpringApplication对象</strong></h2><div class="hljs"><pre><code class="hljs java">initialize(sources);<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Object[] sources)</span> </span>&#123;    <span class="hljs-comment">//保存主配置类</span>    <span class="hljs-keyword">if</span> (sources != <span class="hljs-keyword">null</span> &amp;&amp; sources.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.sources.addAll(Arrays.asList(sources));    &#125;    <span class="hljs-comment">//判断当前是否一个web应用</span>    <span class="hljs-keyword">this</span>.webEnvironment = deduceWebEnvironment();    <span class="hljs-comment">//从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span>    setInitializers((Collection) getSpringFactoriesInstances(        ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener</span>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//从多个配置类中找到有main方法的主配置类</span>    <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();&#125;</code></pre></div><p><img src="/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145727.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145855.png" srcset="/img/loading.gif" alt></p><h2 id="2、运行run方法"><a href="#2、运行run方法" class="headerlink" title="2、运行run方法"></a>2、运行run方法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();   stopWatch.start();   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;   FailureAnalyzers analyzers = <span class="hljs-keyword">null</span>;   configureHeadlessProperty();       <span class="hljs-comment">//获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories</span>   SpringApplicationRunListeners listeners = getRunListeners(args);    <span class="hljs-comment">//回调所有的获取SpringApplicationRunListener.starting()方法</span>   listeners.starting();   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-comment">//封装命令行参数</span>      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(            args);      <span class="hljs-comment">//准备环境</span>      ConfigurableEnvironment environment = prepareEnvironment(listeners,            applicationArguments);       <span class="hljs-comment">//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span>             Banner printedBanner = printBanner(environment);              <span class="hljs-comment">//创建ApplicationContext；决定创建web的ioc还是普通的ioc</span>      context = createApplicationContext();             analyzers = <span class="hljs-keyword">new</span> FailureAnalyzers(context);       <span class="hljs-comment">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span>       <span class="hljs-comment">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span>       <span class="hljs-comment">//回调所有的SpringApplicationRunListener的contextPrepared()；</span>       <span class="hljs-comment">//</span>      prepareContext(context, environment, listeners, applicationArguments,            printedBanner);       <span class="hljs-comment">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；</span>              <span class="hljs-comment">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span>       <span class="hljs-comment">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span>      refreshContext(context);       <span class="hljs-comment">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span>       <span class="hljs-comment">//ApplicationRunner先回调，CommandLineRunner再回调</span>      afterRefresh(context, applicationArguments);       <span class="hljs-comment">//所有的SpringApplicationRunListener回调finished方法</span>      listeners.finished(context, <span class="hljs-keyword">null</span>);      stopWatch.stop();      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass)               .logStarted(getApplicationLog(), stopWatch);      &#125;       <span class="hljs-comment">//整个SpringBoot应用启动完成以后返回启动的ioc容器；</span>      <span class="hljs-keyword">return</span> context;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      handleRunFailure(context, listeners, analyzers, ex);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);   &#125;&#125;</code></pre></div><h2 id="3、事件监听机制"><a href="#3、事件监听机制" class="headerlink" title="3、事件监听机制"></a>3、事件监听机制</h2><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextInitializer</span>&lt;<span class="hljs-title">ConfigurableApplicationContext</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;        System.out.println(<span class="hljs-string">"ApplicationContextInitializer...initialize..."</span>+applicationContext);    &#125;&#125;</code></pre></div><p><strong>SpringApplicationRunListener</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpringApplicationRunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SpringApplicationRunListener</span> </span>&#123;    <span class="hljs-comment">//必须有的构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloSpringApplicationRunListener</span><span class="hljs-params">(SpringApplication application, String[] args)</span></span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">starting</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...starting..."</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">environmentPrepared</span><span class="hljs-params">(ConfigurableEnvironment environment)</span> </span>&#123;        Object o = environment.getSystemProperties().get(<span class="hljs-string">"os.name"</span>);        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...environmentPrepared.."</span>+o);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...contextPrepared..."</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoaded</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...contextLoaded..."</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...finished..."</span>);    &#125;&#125;</code></pre></div><p>配置（META-INF/spring.factories）</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="hljs-string">\</span><span class="hljs-attr">com.atguigu.springboot.listener.HelloApplicationContextInitializer</span><span class="hljs-meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="hljs-string">\</span><span class="hljs-attr">com.atguigu.springboot.listener.HelloSpringApplicationRunListener</span></code></pre></div><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"ApplicationRunner...run...."</span>);    &#125;&#125;</code></pre></div><p><strong>CommandLineRunner</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"CommandLineRunner...run..."</span>+ Arrays.asList(args));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot与数据访问</title>
    <link href="/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"/>
    <url>/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot与数据访问"><a href="#SpringBoot与数据访问" class="headerlink" title="SpringBoot与数据访问"></a>SpringBoot与数据访问</h1><h2 id="1、JDBC"><a href="#1、JDBC" class="headerlink" title="1、JDBC"></a>1、JDBC</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://192.168.15.22:3306/jdbc</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span></code></pre></div><p>效果：</p><p>​    默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><p>​    数据源的相关配置都在DataSourceProperties里面；</p><p>自动配置原理：</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认可以支持；</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DataSource</span>、<span class="hljs-selector-tag">HikariDataSource</span>、<span class="hljs-selector-tag">BasicDataSource</span>、</code></pre></div><p>3、自定义数据源类型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Generic DataSource configuration.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(DataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">name</span> </span>= <span class="hljs-string">"spring.datasource.type"</span>)<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span> </span>&#123;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(DataSourceProperties properties)</span> </span>&#123;       <span class="hljs-comment">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span>      <span class="hljs-keyword">return</span> properties.initializeDataSourceBuilder().build();   &#125;&#125;</code></pre></div><p>4、<strong>DataSourceInitializer：ApplicationListener</strong>；</p><p>​    作用：</p><p>​        1）、runSchemaScripts();运行建表语句；</p><p>​        2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">schema-*.sql、data-*.sql</span><span class="hljs-attr">默认规则：schema.sql，schema-all.sql；</span><span class="hljs-meta">可以使用</span>   <span class="hljs-string"></span><span class="hljs-attr">schema</span>:<span class="hljs-string"></span>      <span class="hljs-meta">-</span> <span class="hljs-string">classpath:department.sql</span>      <span class="hljs-attr">指定位置</span></code></pre></div><p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p><h2 id="2、整合Druid数据源"><a href="#2、整合Druid数据源" class="headerlink" title="2、整合Druid数据源"></a>2、整合Druid数据源</h2><div class="hljs"><pre><code class="hljs java">导入druid数据源<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druid</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-comment">//配置Druid的监控</span>    <span class="hljs-comment">//1、配置一个管理后台的Servlet</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span></span>&#123;        ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/*"</span>);        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        initParams.put(<span class="hljs-string">"loginUsername"</span>,<span class="hljs-string">"admin"</span>);        initParams.put(<span class="hljs-string">"loginPassword"</span>,<span class="hljs-string">"123456"</span>);        initParams.put(<span class="hljs-string">"allow"</span>,<span class="hljs-string">""</span>);<span class="hljs-comment">//默认就是允许所有访问</span>        initParams.put(<span class="hljs-string">"deny"</span>,<span class="hljs-string">"192.168.15.21"</span>);        bean.setInitParameters(initParams);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-comment">//2、配置一个web监控的filter</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span></span>&#123;        FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();        bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        initParams.put(<span class="hljs-string">"exclusions"</span>,<span class="hljs-string">"*.js,*.css,/druid/*"</span>);        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));        <span class="hljs-keyword">return</span>  bean;    &#125;&#125;</code></pre></div><h2 id="3、整合MyBatis"><a href="#3、整合MyBatis" class="headerlink" title="3、整合MyBatis"></a>3、整合MyBatis</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><img src="/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180305194443.png" srcset="/img/loading.gif" alt></p><p>步骤：</p><p>​    1）、配置数据源相关属性（见上一节Druid）</p><p>​    2）、给数据库建表</p><p>​    3）、创建JavaBean</p><h3 id="4）、注解版"><a href="#4）、注解版" class="headerlink" title="4）、注解版"></a>4）、注解版</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//指定这是一个操作数据库的mapper</span><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DepartmentMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from department where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">getDeptById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Delete</span>(<span class="hljs-string">"delete from department where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteDeptById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Options</span>(useGeneratedKeys = <span class="hljs-keyword">true</span>,keyProperty = <span class="hljs-string">"id"</span>)    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into department(departmentName) values(#&#123;departmentName&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertDept</span><span class="hljs-params">(Department department)</span></span>;    <span class="hljs-meta">@Update</span>(<span class="hljs-string">"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateDept</span><span class="hljs-params">(Department department)</span></span>;&#125;</code></pre></div><p>问题：</p><p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurationCustomizer <span class="hljs-title">configurationCustomizer</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConfigurationCustomizer()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(Configuration configuration)</span> </span>&#123;                configuration.setMapUnderscoreToCamelCase(<span class="hljs-keyword">true</span>);            &#125;        &#125;;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java">使用MapperScan批量扫描所有的Mapper接口；<span class="hljs-meta">@MapperScan</span>(value = <span class="hljs-string">"com.atguigu.springboot.mapper"</span>)<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBoot06DataMybatisApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(SpringBoot06DataMybatisApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre></div><h3 id="5）、配置文件版"><a href="#5）、配置文件版" class="headerlink" title="5）、配置文件版"></a>5）、配置文件版</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span> <span class="hljs-string">指定全局配置文件的位置</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span>  <span class="hljs-string">指定sql映射文件的位置</span></code></pre></div><p>更多使用参照</p><p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><h2 id="4、整合SpringData-JPA"><a href="#4、整合SpringData-JPA" class="headerlink" title="4、整合SpringData JPA"></a>4、整合SpringData JPA</h2><h3 id="1）、SpringData简介"><a href="#1）、SpringData简介" class="headerlink" title="1）、SpringData简介"></a>1）、SpringData简介</h3><p><img src="/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306105412.png" srcset="/img/loading.gif" alt></p><h3 id="2）、整合SpringData-JPA"><a href="#2）、整合SpringData-JPA" class="headerlink" title="2）、整合SpringData JPA"></a>2）、整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）；</p><p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用JPA注解配置映射关系</span><span class="hljs-meta">@Entity</span> <span class="hljs-comment">//告诉JPA这是一个实体类（和数据表映射的类）</span><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tbl_user"</span>) <span class="hljs-comment">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span> <span class="hljs-comment">//这是一个主键</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="hljs-comment">//自增主键</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"last_name"</span>,length = <span class="hljs-number">50</span>) <span class="hljs-comment">//这是和数据表对应的一个列</span>    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-meta">@Column</span> <span class="hljs-comment">//省略默认列名就是属性名</span>    <span class="hljs-keyword">private</span> String email;</code></pre></div><p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//继承JpaRepository来完成对数据库的操作</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre></div><p>3）、基本的配置JpaProperties</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>   <span class="hljs-attr">jpa:</span>    <span class="hljs-attr">hibernate:</span><span class="hljs-comment">#     更新或者创建数据表结构</span>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><span class="hljs-comment">#    控制台显示SQL</span>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span></code></pre></div><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>MyBatis</tag>
      
      <tag>JDBC</tag>
      
      <tag>SpringData JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门</title>
    <link href="/2020/08/03/Docker%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/03/Docker%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="/2020/08/03/Docker%E5%85%A5%E9%97%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145450.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/03/Docker%E5%85%A5%E9%97%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145531.png" srcset="/img/loading.gif" alt></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p><img src="/2020/08/03/Docker%E5%85%A5%E9%97%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303165113.png" srcset="/img/loading.gif" alt></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="3、安装Docker"><a href="#3、安装Docker" class="headerlink" title="3、安装Docker"></a>3、安装Docker</h2><h4 id="1）、安装linux虚拟机"><a href="#1）、安装linux虚拟机" class="headerlink" title="1）、安装linux虚拟机"></a>1）、安装linux虚拟机</h4><p>​    1）、VMWare、VirtualBox（安装）；</p><p>​    2）、导入虚拟机文件centos7-atguigu.ova；</p><p>​    3）、双击启动linux虚拟机;使用  root/ 123456登陆</p><p>​    4）、使用客户端连接linux服务器进行命令操作；</p><p>​    5）、设置虚拟机网络；</p><p>​        桥接网络===选好网卡====接入网线；</p><p>​    6）、设置好网络以后使用命令重启虚拟机的网络</p><div class="hljs"><pre><code class="hljs shell">service network restart</code></pre></div><p>​    7）、查看linux的ip地址</p><div class="hljs"><pre><code class="hljs shell">ip addr</code></pre></div><p>​    8）、使用客户端连接linux；</p><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p><div class="hljs"><pre><code class="hljs shell">1、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker</code></pre></div><h2 id="4、Docker常用命令-amp-操作"><a href="#4、Docker常用命令-amp-操作" class="headerlink" title="4、Docker常用命令&amp;操作"></a>4、Docker常用命令&amp;操作</h2><h3 id="1）镜像操作"><a href="#1）镜像操作" class="headerlink" title="1）镜像操作"></a>1）镜像操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h3 id="2）容器操作"><a href="#2）容器操作" class="headerlink" title="2）容器操作"></a>2）容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><div class="hljs"><pre><code class="hljs shell">1、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps  查看运行中的容器5、 停止运行中的容器docker stop  容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档</code></pre></div><h3 id="3）安装MySQL示例"><a href="#3）安装MySQL示例" class="headerlink" title="3）安装MySQL示例"></a>3）安装MySQL示例</h3><div class="hljs"><pre><code class="hljs shell">docker pull mysql</code></pre></div><p>错误的启动</p><div class="hljs"><pre><code class="hljs shell">[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_goldstinec4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified   You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</code></pre></div><p>正确的启动</p><div class="hljs"><pre><code class="hljs shell">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESb874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</code></pre></div><p>做了端口映射</p><div class="hljs"><pre><code class="hljs shell">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMESad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</code></pre></div><p>几个其他的高级操作</p><div class="hljs"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker <span class="hljs-builtin-name">run</span> --name some-mysql -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag <span class="hljs-attribute">--character-set-server</span>=utf8mb4 <span class="hljs-attribute">--collation-server</span>=utf8mb4_unicode_ci指定mysql的一些配置参数</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置嵌入式Servlet容器</title>
    <link href="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h1><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180301142915.png" srcset="/img/loading.gif" alt></p><p>问题？</p><h3 id="一、如何定制和修改Servlet容器的相关配置"><a href="#一、如何定制和修改Servlet容器的相关配置" class="headerlink" title="一、如何定制和修改Servlet容器的相关配置"></a>一、如何定制和修改Servlet容器的相关配置</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">server.context-path</span>=<span class="hljs-string">/crud</span><span class="hljs-meta">server.tomcat.uri-encoding</span>=<span class="hljs-string">UTF-8</span><span class="hljs-attr">//通用的Servlet容器设置</span><span class="hljs-attr">server.xxx</span><span class="hljs-attr">//Tomcat的设置</span><span class="hljs-attr">server.tomcat.xxx</span></code></pre></div><p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//一定要将这个定制器加入到容器中</span><span class="hljs-function"><span class="hljs-keyword">public</span> EmbeddedServletContainerCustomizer <span class="hljs-title">embeddedServletContainerCustomizer</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedServletContainerCustomizer() &#123;        <span class="hljs-comment">//定制嵌入式的Servlet容器相关的规则</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;            container.setPort(<span class="hljs-number">8083</span>);        &#125;    &#125;;&#125;</code></pre></div><h3 id="二、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#二、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="二、注册Servlet三大组件【Servlet、Filter、Listener】"></a>二、注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p><p>注册三大组件用以下方式</p><p>ServletRegistrationBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//注册三大组件</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">myServlet</span><span class="hljs-params">()</span></span>&#123;    ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> MyServlet(),<span class="hljs-string">"/myServlet"</span>);    <span class="hljs-keyword">return</span> registrationBean;&#125;</code></pre></div><p>FilterRegistrationBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">myFilter</span><span class="hljs-params">()</span></span>&#123;    FilterRegistrationBean registrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean();    registrationBean.setFilter(<span class="hljs-keyword">new</span> MyFilter());    registrationBean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/hello"</span>,<span class="hljs-string">"/myServlet"</span>));    <span class="hljs-keyword">return</span> registrationBean;&#125;</code></pre></div><p>ServletListenerRegistrationBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServletListenerRegistrationBean <span class="hljs-title">myListener</span><span class="hljs-params">()</span></span>&#123;    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="hljs-keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> MyListener());    <span class="hljs-keyword">return</span> registrationBean;&#125;</code></pre></div><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)<span class="hljs-meta">@ConditionalOnBean</span>(value = DispatcherServlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span> </span>= DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)<span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">dispatcherServletRegistration</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;   ServletRegistrationBean registration = <span class="hljs-keyword">new</span> ServletRegistrationBean(         dispatcherServlet, <span class="hljs-keyword">this</span>.serverProperties.getServletMapping());    <span class="hljs-comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span>    <span class="hljs-comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span>       registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);   registration.setLoadOnStartup(         <span class="hljs-keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.multipartConfig != <span class="hljs-keyword">null</span>) &#123;      registration.setMultipartConfig(<span class="hljs-keyword">this</span>.multipartConfig);   &#125;   <span class="hljs-keyword">return</span> registration;&#125;</code></pre></div><p>2）、SpringBoot能不能支持其他的Servlet容器；</p><h3 id="三、替换为其他嵌入式Servlet容器"><a href="#三、替换为其他嵌入式Servlet容器" class="headerlink" title="三、替换为其他嵌入式Servlet容器"></a>三、替换为其他嵌入式Servlet容器</h3><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302114401.png" srcset="/img/loading.gif" alt></p><p>默认支持：</p><p>Tomcat（默认使用）</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Jetty</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入web模块 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--引入其他的Servlet容器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Undertow</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入web模块 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--引入其他的Servlet容器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="四、嵌入式Servlet容器自动配置原理；"><a href="#四、嵌入式Servlet容器自动配置原理；" class="headerlink" title="四、嵌入式Servlet容器自动配置原理；"></a>四、嵌入式Servlet容器自动配置原理；</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@Import</span>(BeanPostProcessorsRegistrar<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">//导入<span class="hljs-title">BeanPostProcessorsRegistrar</span>：<span class="hljs-title">Spring</span>注解版；给容器中导入一些组件</span><span class="hljs-class">//导入了<span class="hljs-title">EmbeddedServletContainerCustomizerBeanPostProcessor</span>：</span><span class="hljs-class">//后置处理器：<span class="hljs-title">bean</span>初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;        <span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Tomcat</span>.<span class="hljs-title">class</span> &#125;)//判断当前是否引入了<span class="hljs-title">Tomcat</span>依赖；</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">value</span> </span>= EmbeddedServletContainerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedTomcat</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="hljs-title">tomcatEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatEmbeddedServletContainerFactory();&#125;&#125;        <span class="hljs-comment">/**</span><span class="hljs-comment"> * Nested configuration if Jetty is being used.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Server</span>.<span class="hljs-title">class</span>, <span class="hljs-title">Loader</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebAppContext</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">value</span> </span>= EmbeddedServletContainerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedJetty</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> JettyEmbeddedServletContainerFactory <span class="hljs-title">jettyEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JettyEmbeddedServletContainerFactory();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Nested configuration if Undertow is being used.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Undertow</span>.<span class="hljs-title">class</span>, <span class="hljs-title">SslClientAuthMode</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">value</span> </span>= EmbeddedServletContainerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedUndertow</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="hljs-title">undertowEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UndertowEmbeddedServletContainerFactory();&#125;&#125;</code></pre></div><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EmbeddedServletContainerFactory</span> </span>&#123;   <span class="hljs-comment">//获取嵌入式的Servlet容器</span>   <span class="hljs-function">EmbeddedServletContainer <span class="hljs-title">getEmbeddedServletContainer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">         ServletContextInitializer... initializers)</span></span>;&#125;</code></pre></div><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144910.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302221835.png" srcset="/img/loading.gif" alt></p><p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EmbeddedServletContainer <span class="hljs-title">getEmbeddedServletContainer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ServletContextInitializer... initializers)</span> </span>&#123;    <span class="hljs-comment">//创建一个Tomcat</span>   Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();        <span class="hljs-comment">//配置Tomcat的基本环节</span>   File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.baseDirectory         : createTempDir(<span class="hljs-string">"tomcat"</span>));   tomcat.setBaseDir(baseDir.getAbsolutePath());   Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);   tomcat.getService().addConnector(connector);   customizeConnector(connector);   tomcat.setConnector(connector);   tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);   configureEngine(tomcat.getEngine());   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) &#123;      tomcat.getService().addConnector(additionalConnector);   &#125;   prepareContext(tomcat.getHost(), initializers);        <span class="hljs-comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span>   <span class="hljs-keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);&#125;</code></pre></div><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><div class="hljs"><pre><code class="hljs plain">ServerProperties、EmbeddedServletContainerCustomizer</code></pre></div><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//初始化之前</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span>   <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;       <span class="hljs-comment">//</span>      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);   &#125;   <span class="hljs-keyword">return</span> bean;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;    <span class="hljs-comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span>    <span class="hljs-keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;        customizer.customize(bean);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="hljs-title">getCustomizers</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.customizers == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// Look up does not include the parent context</span>        <span class="hljs-keyword">this</span>.customizers = <span class="hljs-keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(            <span class="hljs-keyword">this</span>.beanFactory            <span class="hljs-comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span>            <span class="hljs-comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span>            .getBeansOfType(EmbeddedServletContainerCustomizer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                            <span class="hljs-title">false</span>, <span class="hljs-title">false</span>)</span><span class="hljs-class">            .<span class="hljs-title">values</span>())</span>;        Collections.sort(<span class="hljs-keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);        <span class="hljs-keyword">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-keyword">this</span>.customizers);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customizers;&#125;ServerProperties也是定制器</code></pre></div><p>步骤：</p><p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p><p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p><h3 id="五、嵌入式Servlet容器启动原理；"><a href="#五、嵌入式Servlet容器启动原理；" class="headerlink" title="五、嵌入式Servlet容器启动原理；"></a>五、嵌入式Servlet容器启动原理；</h3><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;      <span class="hljs-comment">// Prepare this context for refreshing.</span>      prepareRefresh();      <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span>      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      <span class="hljs-comment">// Prepare the bean factory for use in this context.</span>      prepareBeanFactory(beanFactory);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>         postProcessBeanFactory(beanFactory);         <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>         invokeBeanFactoryPostProcessors(beanFactory);         <span class="hljs-comment">// Register bean processors that intercept bean creation.</span>         registerBeanPostProcessors(beanFactory);         <span class="hljs-comment">// Initialize message source for this context.</span>         initMessageSource();         <span class="hljs-comment">// Initialize event multicaster for this context.</span>         initApplicationEventMulticaster();         <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>         onRefresh();         <span class="hljs-comment">// Check for listener beans and register them.</span>         registerListeners();         <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>         finishBeanFactoryInitialization(beanFactory);         <span class="hljs-comment">// Last step: publish corresponding event.</span>         finishRefresh();      &#125;      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;         <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;            logger.warn(<span class="hljs-string">"Exception encountered during context initialization - "</span> +                  <span class="hljs-string">"cancelling refresh attempt: "</span> + ex);         &#125;         <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>         destroyBeans();         <span class="hljs-comment">// Reset 'active' flag.</span>         cancelRefresh(ex);         <span class="hljs-comment">// Propagate exception to caller.</span>         <span class="hljs-keyword">throw</span> ex;      &#125;      <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-comment">// Reset common introspection caches in Spring's core, since we</span>         <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>         resetCommonCaches();      &#125;   &#125;&#125;</code></pre></div><p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p><p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>​    从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p><p><strong>==IOC容器启动创建嵌入式的Servlet容器==</strong></p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set接口底层实现类</title>
    <link href="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <url>/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Set接口底层实现类"><a href="#Set接口底层实现类" class="headerlink" title="Set接口底层实现类"></a>Set接口底层实现类</h1><h1 id="一、Set接口继承关系"><a href="#一、Set接口继承关系" class="headerlink" title="一、Set接口继承关系"></a>一、Set接口继承关系</h1><p>存储的数据特点：无序的、不可重复的元素</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1595656190066.png" srcset="/img/loading.gif" alt></p><p>|—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p><ul><li>|—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</li><li>|—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。                   对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</li><li>|—-TreeSet：可以照添加对象的指定属性，进行排序。</li></ul><h1 id="二、HashSet"><a href="#二、HashSet" class="headerlink" title="二、HashSet"></a>二、HashSet</h1><h2 id="1-继承情况"><a href="#1-继承情况" class="headerlink" title="1.继承情况"></a>1.继承情况</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1595656458260.png" srcset="/img/loading.gif" alt></p><p>可以看到是直接实现了Set接口，和间接继承了Collection接口</p><h2 id="2-创建HashSet"><a href="#2-创建HashSet" class="headerlink" title="2.创建HashSet"></a>2.创建HashSet</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/abcsd.png" srcset="/img/loading.gif" alt></p><p>debug跟进源代码</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1.png" srcset="/img/loading.gif" alt></p><p>可以看到空参构造器里new了一个HashMap出来</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/2.png" srcset="/img/loading.gif" alt="59565709297"></p><p>而HashMap初始化了一个加载因子的常量，这里由于是map内容不多做细讲</p><p> 实际上HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变，此类允许使用null元素。 </p><p>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值<code>private static final Object PRESENT = new Object();</code>，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 在添加数据时就能观察到。</p><h2 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/3.png" srcset="/img/loading.gif" alt></p><p>跟进 首先是一个自动装箱</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/4.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/5.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java">而PRESENT就是刚才提及到的固定的value值 实现了双列变单列<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();</code></pre></div><p>接下来的put就是map的操作了</p><h2 id="4-不可重复性和无序性"><a href="#4-不可重复性和无序性" class="headerlink" title="4.不可重复性和无序性"></a>4.不可重复性和无序性</h2><p>HashSet的俩大特点</p><div class="hljs"><pre><code>1. 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。    2. 不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</code></pre></div><p>在进行测试过程中 我发现避免不了去到map的源码，由于太过复杂 尽量用大白话说明白，map会单独出一篇</p><p>在jdk7和之前 底层使用的是数组加链表，在jdk8后使用的是数组加链表加红黑树。</p><p>因为我们知道map的key是不允许的重复的，如果有重复的key值就会把map的key和value进行更新操作，这一来就说的通了，HashSet就是限制了map的功能，让map的value值固定为常量，只使用key去操作，所以说HashSet不允许有重复的值，其实也是这个新的值把原来的值给替换掉了</p><p><strong>而无序性，要重存放的方式说起。（注意，存进HashSet的对象一定要重写HashCode和equals方法）</strong></p><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断<br>        数组此位置上是否已经元素）：</p><p>  此时有俩种情况：  </p><p>​        1.如果此位置上没其他元素，则元素a添加成功。 —&gt;插入成功情况1<br>               2.如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值：</p><p>此时又有俩种情况：</p><p>​                1.如果hash值不相同，则元素a添加成功。—&gt;成功情况2<br>                2.如果hash值相同，进而需要调用元素a所在类的equals()方法：</p><p>此时还是有俩种情况：</p><p>​               1.equals()返回true,元素a添加失败<br>               2.equals()返回false,则元素a添加成功。—&gt;成功情况3</p><p>​    对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p><p>​    </p><p>（链表指向区别↓）</p><p>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a</p><p>此时同学们肯定会有疑问，如果HashCode相同难道会出现equals不同的情况嘛？（还真会待会贴出优秀代码）</p><p>由于在数组 和 链表 和 红黑树 的数据结构有点抽象 下面几副图可以形象看到HashSet添加时全过程</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/6.png" srcset="/img/loading.gif" alt></p><p>情况2：</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/7.png" srcset="/img/loading.gif" alt></p><p>情况3：</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/8.png" srcset="/img/loading.gif" alt></p><p>这里没有用到红黑树，是因为加入红黑树是让遍历等操作速度变快，具体的方式为，在数组某一个位置上的链表的层数到8层或总数量多于64个时，链表重新打散，改为使用树结构，当然树结构的头还是数组，变成一颗颗倒着的树。</p><h2 id="5-添加代码"><a href="#5-添加代码" class="headerlink" title="5.添加代码"></a>5.添加代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;        Integer num;        String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Integer num, String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.num = num;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> +                    <span class="hljs-string">"num="</span> + num +                    <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                    <span class="hljs-string">'&#125;'</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Person)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            Person person = (Person) o;            <span class="hljs-keyword">return</span> Objects.equals(num, person.num) &amp;&amp;                    Objects.equals(name, person.name);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> Objects.hash(num, name);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        HashSet set = <span class="hljs-keyword">new</span> HashSet();        Person p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"AA"</span>);        Person p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"BB"</span>);        set.add(p1);        set.add(p2);        System.out.println(set);        p1.name = <span class="hljs-string">"CC"</span>;        set.remove(p1);        System.out.println(set);        set.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"CC"</span>));        System.out.println(set);        set.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"AA"</span>));        System.out.println(set);    &#125;</code></pre></div><p>运行test1中代码结果为：</p><div class="hljs"><pre><code class="hljs java">[Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'AA'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;][Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;][Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;][Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'AA'</span>&#125;]</code></pre></div><p>是不是很诡异？其实归根结底还是那三种情况</p><h1 id="三、LinkedHashSet"><a href="#三、LinkedHashSet" class="headerlink" title="三、LinkedHashSet"></a>三、LinkedHashSet</h1><h2 id="1-继承情况-1"><a href="#1-继承情况-1" class="headerlink" title="1.继承情况"></a>1.继承情况</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/9.png" srcset="/img/loading.gif" alt></p><h2 id="2-优劣"><a href="#2-优劣" class="headerlink" title="2.优劣"></a>2.优劣</h2><p>LinkedHashSet 与 HashSet 区别在于 LinkedHashSet 遍历其内部数据时，可以按照添加的顺序遍历，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。 </p><p>特性就剩不可重复性了</p><p>对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><h1 id="四、TreeSet"><a href="#四、TreeSet" class="headerlink" title="四、TreeSet"></a>四、TreeSet</h1><h2 id="1-继承情况-2"><a href="#1-继承情况-2" class="headerlink" title="1.继承情况"></a>1.继承情况</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/10.png" srcset="/img/loading.gif" alt></p><p>TreeSet不太一样，它是可以将数据按照一定的排列顺序进行输出。有俩种方式（定制排序，自然排序）</p><h2 id="2-自然排序"><a href="#2-自然排序" class="headerlink" title="2.自然排序"></a>2.自然排序</h2><p>自然排序就是对象实现了Comparable接口</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/11.png" srcset="/img/loading.gif" alt></p><p>我们知道，Set是无序的，但是用TreeSet的数据就是有序的，那基本数据类型为什么存进去就会变有序呢？</p><p>其实这里有一个自动装箱的过程在Integer中就实现了这个接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;         在里面重写了compareTo     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Integer anotherInteger)</span> </span>&#123;        <span class="hljs-keyword">return</span> compare(<span class="hljs-keyword">this</span>.value, anotherInteger.value);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> (x &lt; y) ? -<span class="hljs-number">1</span> : ((x == y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);    &#125;    以后要想放在TreeSet实现排序的对象 先要自己重写compareTo方法，用自己的排列方式才能生效</code></pre></div><h2 id="3-定制排序"><a href="#3-定制排序" class="headerlink" title="3.定制排序"></a>3.定制排序</h2><p>往往在很多时候，自然排序根本不能用，因为不能去更改源代码，所以有另一种方法，帮助我们定制排序的顺序</p><p>这种方法就是给TreeSet构造器中给一个Comparator对象，在Comparator对象中重写compare方法，定制自己需要的排列规则</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;       Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;           <span class="hljs-comment">//照年龄从小到大排列</span>           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;               <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;                   User u1 = (User)o1;                   User u2 = (User)o2;                   <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());               &#125;<span class="hljs-keyword">else</span>&#123;                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不匹配"</span>);               &#125;           &#125;       &#125;;       TreeSet set = <span class="hljs-keyword">new</span> TreeSet(com);       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jim"</span>,<span class="hljs-number">2</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mike"</span>,<span class="hljs-number">65</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mary"</span>,<span class="hljs-number">33</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">33</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">56</span>));       Iterator iterator = set.iterator();       <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;           System.out.println(iterator.next());       &#125;   &#125;</code></pre></div><p>一般来说如果某个对象不需要经常使用排序，则使用定制排序就行，因为可以使用匿名内部类的方式，一次性的排序，而使用自然排序则是一直绑定着排序规则，不灵活。</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Set</tag>
      
      <tag>HashSet</tag>
      
      <tag>LinkedHashSet</tag>
      
      <tag>TreeSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List接口底层实现类</title>
    <link href="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <url>/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="List接口底层实现类"><a href="#List接口底层实现类" class="headerlink" title="List接口底层实现类"></a>List接口底层实现类</h1><h2 id="一、java集合类分类"><a href="#一、java集合类分类" class="headerlink" title="一、java集合类分类"></a>一、java集合类分类</h2><p>java集合框架分为俩种，单列集合框架Collection，和双列集合框架Map</p><h3 id="1-单列集合框架结构"><a href="#1-单列集合框架结构" class="headerlink" title="1.单列集合框架结构"></a>1.单列集合框架结构</h3><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>|—-List接口：存储序的、可重复的数据。  –&gt;“动态”数组<ul><li>|—-ArrayList、LinkedList、Vector<br>​</li></ul></li><li>|—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”<ul><li>|—-HashSet、LinkedHashSet、TreeSet</li></ul></li></ul><p>本文将对List接口进行解析</p><p>对应图示：</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592968971414.png" srcset="/img/loading.gif" alt="单列集合框架"></p><p><strong>实线为直接继承或实现，虚线为间接继承或实现</strong></p><h2 id="二、ArrayList"><a href="#二、ArrayList" class="headerlink" title="二、ArrayList"></a>二、ArrayList</h2><h3 id="1-jdk1-7的情况"><a href="#1-jdk1-7的情况" class="headerlink" title="1.jdk1.7的情况"></a>1.jdk1.7的情况</h3><p>​    ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</p><ul><li><p>list.add(123);//elementData[0] = new Integer(123);</p></li><li><p>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</p></li><li><p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p></li><li><p>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</p><p>​</p></li></ul><h3 id="2-jdk1-8的情况"><a href="#2-jdk1-8的情况" class="headerlink" title="2.jdk1.8的情况"></a>2.jdk1.8的情况</h3><p>​    由于现主流开发都是1.8版本的jdk，所有以下对ArrayList进行深入解读</p><h3 id="3-继承情况"><a href="#3-继承情况" class="headerlink" title="3.继承情况"></a>3.继承情况</h3><p>使用idea自带的可视化工具查看继承与实现情况，可以清楚的看到ArrayList间接的实现了Collection接口</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592969473(1).jpg" srcset="/img/loading.gif" alt="继承情况"></p><h3 id="4-创建ArrayList"><a href="#4-创建ArrayList" class="headerlink" title="4.创建ArrayList"></a>4.创建ArrayList</h3><p>​    接下来我们来看一下创建一个ArrayList容器会发生什么</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592969867(1).jpg" srcset="/img/loading.gif" alt="创建ArrayList"></p><p>当我用debug创建一个arrayList时 返回的是一个空的，长度为0的数组</p><p>我们跟进去构造函数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">//一个是Object[]对象,transient关键词是指该对象不需要被序列化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//一个空的Object[]对象</span></code></pre></div><p>与jdk7版本的区别是 jdk7创建后就创建一个长度为10的数组，但jdk8并没有，更加节省内存</p><h3 id="5-添加数据"><a href="#5-添加数据" class="headerlink" title="5.添加数据"></a>5.添加数据</h3><div class="hljs"><pre><code class="hljs java">arrayList.add(<span class="hljs-number">123</span>);</code></pre></div><p>我们用debug跟进源码</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592970609(1).jpg" srcset="/img/loading.gif" alt></p><p>因为存入123是基本数据类型，这里有一个自动装箱的过程（装换为Integer类型）</p><p>后面就是进入add方法</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592973839(1).jpg" srcset="/img/loading.gif" alt></p><p>size默认初始化为0，进入ensureCapacityInternal方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);            <span class="hljs-comment">//max方法取俩个参数最大的一个（这里DEFAULT_CAPACITY为10），将最大的值赋给minCapacity</span>        &#125;        ensureExplicitCapacity(minCapacity);    &#125;进入ensureExplicitCapacity(minCapacity)方法<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        modCount++;<span class="hljs-comment">//默认为0 </span>        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//判断最小容量减去原数组长度是否大于0</span>            grow(minCapacity);    &#125;   进入grow(minCapacity)方法 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<span class="hljs-comment">//记录老容量长度 此时elementData长度为0</span>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//定义新容量值，老容量长度右移一位后加再上老容量长度，而右移一位是取数值的一半，这里就决定了ArrayList以后进行扩容都是对原数组扩容1.5倍</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//0 - 10 小于0 所有进入 </span>            newCapacity = minCapacity;<span class="hljs-comment">//新容量长度就为10</span>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//判断此容量会不会超过最大长度（Integer.MAX_VALUE - 8）</span>            newCapacity = hugeCapacity(minCapacity);        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>        elementData = Arrays.copyOf(elementData, newCapacity);<span class="hljs-comment">//调用Arrays工具类，对数组进行扩容，原理为将旧数组数据复制到新数组</span>    &#125;</code></pre></div><h2 id="三、LinkedList"><a href="#三、LinkedList" class="headerlink" title="三、LinkedList"></a>三、LinkedList</h2><h3 id="1-继承情况"><a href="#1-继承情况" class="headerlink" title="1.继承情况"></a>1.继承情况</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592975059(1).jpg" srcset="/img/loading.gif" alt></p><p>可以看到不仅间接的实现了List接口，还间接的实现了队列Queue的接口</p><h3 id="2-创建LinkedList"><a href="#2-创建LinkedList" class="headerlink" title="2.创建LinkedList"></a>2.创建LinkedList</h3><div class="hljs"><pre><code class="hljs java">LinkedList linkedList = <span class="hljs-keyword">new</span> LinkedList();</code></pre></div><p>通过new的方式只是初始化LinkedList容器，底层双向链表结构还未创建。LinkedList Node类型的first和last属性，默认为null</p><h3 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h3><div class="hljs"><pre><code class="hljs java">linkedList.add(<span class="hljs-number">123</span>);</code></pre></div><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592975703(1).jpg" srcset="/img/loading.gif" alt></p><p>进入linkLast中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在linkedList里面有first和last属性</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last; <span class="hljs-comment">//将原料的last对象赋值给l</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//Node为一个静态内部类 在下面：作用是初始化Node对象（链表对象，prev为头指针，next为尾指针，element为数据）</span>    last = newNode;<span class="hljs-comment">//将有数据的newNode赋值给last</span>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<span class="hljs-comment">//判断是否是第一个节点，如果是</span>        first = newNode;<span class="hljs-comment">//将NewNode直接赋值给尾节点</span>    <span class="hljs-keyword">else</span>        l.next = newNode;<span class="hljs-comment">//不是的话。将节点添加到l.next 相当于将链表连接起来</span>    size++;    modCount++;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            <span class="hljs-keyword">this</span>.item = element;            <span class="hljs-keyword">this</span>.next = next;            <span class="hljs-keyword">this</span>.prev = prev;        &#125;    &#125;</code></pre></div><h2 id="四、Vector"><a href="#四、Vector" class="headerlink" title="四、Vector"></a>四、Vector</h2><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>在扩容方面，默认扩容为原来的数组长度的2倍。</p><h3 id="1-继承情况-1"><a href="#1-继承情况-1" class="headerlink" title="1.继承情况"></a>1.继承情况</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593002715(1).png" srcset="/img/loading.gif" alt></p><h3 id="2-创建Vector"><a href="#2-创建Vector" class="headerlink" title="2.创建Vector"></a>2.创建Vector</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593002840(1).jpg" srcset="/img/loading.gif" alt></p><p>让我们跟进去构造函数</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);    &#125;再往下跟，调用一个参数的构造函数<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0</span>);    &#125;    再往下跟，调用凉参数的构造函数<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">int</span> capacityIncrement)</span> </span>&#123;        <span class="hljs-keyword">super</span>();<span class="hljs-comment">//显示调用父构造函数</span>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//为0就报错，参数传进来为10</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                               initialCapacity);        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity]; <span class="hljs-comment">//创建并初始化了对象数组</span>        <span class="hljs-keyword">this</span>.capacityIncrement = capacityIncrement;    &#125;    上面俩个属性定义如下：<span class="hljs-keyword">protected</span> Object[] elementData;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> elementCount;</code></pre></div><p>此版本为jdk8，jdk7的Vector也是创建一个Vector容器就默认初始化长度为0，与jdk7的ArrayList一样，但是人家开发者对ArrayList进行了改进，使用懒加载，可能Vector要被放弃了吧！！</p><p>接下来讲为什么会放弃Vector</p><h3 id="3-添加数据-1"><a href="#3-添加数据-1" class="headerlink" title="3.添加数据"></a>3.添加数据</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593003620(1).jpg" srcset="/img/loading.gif" alt></p><p>接下来跟进源码</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593003749(1).jpg" srcset="/img/loading.gif" alt></p><p>elementCount默认为0。</p><p>可以看到有一个ensureCapacityHelper方法，此方法是校验长度是否足够，并去扩容的方法，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);<span class="hljs-comment">//扩容方法</span>&#125;</code></pre></div><p>但此处因为默认初始化长度为10，所以这里不会有扩容的需求。</p><p>稍等！Vector不是挺好的嘛，为什么要放弃他？？因为…</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></code></pre></div><p>因为他的方法上全加了synchronized，加上这个字段他就是一个线程安全的方法，而他的全部方法都是线程安全方法，又众所周知，线程安全效率大大减低，所以连开发jdk人员都懒得救他，毕竟，出现了更好的人，老情人全忘掉了~</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>上述介绍了List接口的全部实现类，如果数据不需要线程安全，则不要去考虑使用Vector，而因为ArrayList和LinkedList底层实现原理不同，他们使用的地方也有所不同，ArrayList底层使用的是数组实现，因此在需要频繁的插入和删除数据时效率会大大减低，而数组有一个好处，就是有下标，下标最直接好的好处就是查询速度非常的快，而LinkedList底层使用的是双向链表实现，所以在频繁的插入和删除数据时，有超高性能的表现，但是在查询的速度远远比不上ArrayList。</p><p>记重点：ArrayList数组实现，每次扩容1.5倍，使用懒加载，首次扩容长度为10</p><p>​        LinkedList双向链表实现</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
      <tag>ArrayList</tag>
      
      <tag>LinkedList</tag>
      
      <tag>Vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-SpringMVC自动配置</title>
    <link href="/2020/06/24/SpringBoot-SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/06/24/SpringBoot-SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC自动配置"><a href="#SpringMVC自动配置" class="headerlink" title="SpringMVC自动配置"></a>SpringMVC自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p><h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p><p>​</p></li><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mvc"</span>, name = <span class="hljs-string">"date-format"</span>)<span class="hljs-comment">//在文件中配置日期格式化的规则</span><span class="hljs-function"><span class="hljs-keyword">public</span> Formatter&lt;Date&gt; <span class="hljs-title">dateFormatter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DateFormatter(<span class="hljs-keyword">this</span>.mvcProperties.getDateFormat());<span class="hljs-comment">//日期格式化组件</span>&#125;</code></pre></div><p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p><p>​</p></li></ul></li><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p><div class="hljs"><pre><code class="hljs diff">初始化WebDataBinder；请求数据<span class="hljs-comment">=====JavaBean；</span></code></pre></div></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/hello"</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">"success"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/hello"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre></div><p><strong>==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==</strong>;</p><p>既保留了所有的自动配置，也能用我们扩展的配置；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite(); <span class="hljs-comment">//从容器中获取所有的WebMvcConfigurer</span>     <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;         <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;             <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);           <span class="hljs-comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span>           <span class="hljs-meta">@Override</span>            <span class="hljs-comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span>             <span class="hljs-comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span>              <span class="hljs-comment">//       delegate.addViewControllers(registry);</span>              <span class="hljs-comment">//   &#125;</span>             &#125;         &#125;&#125;</code></pre></div><p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​    4）、我们的配置类也会被调用；</p><p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(DelegatingWebMvcConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebMvc</span> </span>&#123;</code></pre></div><p>2）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</code></pre></div><p>3）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DispatcherServlet</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebMvcConfigurerAdapter</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">WebMvcConfigurationSupport</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">HIGHEST_PRECEDENCE</span> + 10)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ValidationAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;</code></pre></div><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h3 id="4、如何修改SpringBoot的默认配置"><a href="#4、如何修改SpringBoot的默认配置" class="headerlink" title="4、如何修改SpringBoot的默认配置"></a>4、如何修改SpringBoot的默认配置</h3><p>模式：</p><p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p><p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot日志</title>
    <link href="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/"/>
    <url>/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h2><p> 小张；开发一个大型系统；</p><p>​        1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p><p>​        2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p><p>​        3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p><p>​        4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p><p>​        5、JDBC—数据库驱动；</p><p>​            写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p><p>​            给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><p><strong>市面上的日志框架；</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p><p>​    <strong>==SpringBoot选用 SLF4j和logback；==</strong></p><h2 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h2><h3 id="1、如何在系统中使用SLF4j-https-www-slf4j-org"><a href="#1、如何在系统中使用SLF4j-https-www-slf4j-org" class="headerlink" title="1、如何在系统中使用SLF4j   https://www.slf4j.org"></a>1、如何在系统中使用SLF4j   <a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    logger.info(<span class="hljs-string">"Hello World"</span>);  &#125;&#125;</code></pre></div><p>图示；</p><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/concrete-bindings.png" srcset="/img/loading.gif" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2、遗留问题"><a href="#2、遗留问题" class="headerlink" title="2、遗留问题"></a>2、遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/legacy.png" srcset="/img/loading.gif" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>==1、将系统中其他日志框架先排除出去；==</p><p>==2、用中间包来替换原有的日志框架；==</p><p>==3、我们导入slf4j其他的实现==</p><h2 id="3、SpringBoot日志关系"><a href="#3、SpringBoot日志关系" class="headerlink" title="3、SpringBoot日志关系"></a>3、SpringBoot日志关系</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>SpringBoot使用它来做日志功能；</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>底层依赖关系</p><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131220946.png" srcset="/img/loading.gif" alt></p><p>总结：</p><p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​    3）、中间替换包？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFactory</span> </span>&#123;    <span class="hljs-keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="hljs-string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;    <span class="hljs-keyword">static</span> LogFactory logFactory = <span class="hljs-keyword">new</span> SLF4JLogFactory();</code></pre></div><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131221411.png" srcset="/img/loading.gif" alt></p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring框架用的是commons-logging；</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==</strong></p><h2 id="4、日志使用；"><a href="#4、日志使用；" class="headerlink" title="4、日志使用；"></a>4、日志使用；</h2><h3 id="1、默认配置"><a href="#1、默认配置" class="headerlink" title="1、默认配置"></a>1、默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//记录器</span>Logger logger = LoggerFactory.getLogger(getClass());<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//System.out.println();</span><span class="hljs-comment">//日志的级别；</span><span class="hljs-comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span><span class="hljs-comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span>logger.trace(<span class="hljs-string">"这是trace日志..."</span>);logger.debug(<span class="hljs-string">"这是debug日志..."</span>);<span class="hljs-comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span>logger.info(<span class="hljs-string">"这是info日志..."</span>);logger.warn(<span class="hljs-string">"这是warn日志..."</span>);logger.error(<span class="hljs-string">"这是error日志..."</span>);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs haml">  日志输出格式：<span class="hljs-tag">%<span class="hljs-selector-tag">d</span></span>表示日期时间，<span class="hljs-tag">%<span class="hljs-selector-tag">thread</span></span>表示线程名，<span class="hljs-tag">%</span>-5level：级别从左显示5个字符宽度<span class="hljs-tag">%<span class="hljs-selector-tag">logger</span>&#123;50&#125;</span> 表示logger名字最长50个字符，否则按照句点分割。 <span class="hljs-tag">%<span class="hljs-selector-tag">msg</span></span>：日志消息，<span class="hljs-tag">%<span class="hljs-selector-tag">n</span></span>是换行符  -<span class="ruby">-&gt;</span><span class="ruby">  %d&#123;yyyy-MM-dd <span class="hljs-symbol">HH:</span><span class="hljs-symbol">mm:</span>ss.SSS&#125; [%thread] <span class="hljs-string">%-5level %logger&#123;50&#125; -</span> %msg%n</span></code></pre></div><p>SpringBoot修改日志的默认配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.com.atguigu</span>=<span class="hljs-string">trace</span><span class="hljs-comment">#logging.path=</span><span class="hljs-comment"># 不指定路径在当前项目下生成springboot.log日志</span><span class="hljs-comment"># 可以指定完整的路径；</span><span class="hljs-comment">#logging.file=G:/springboot.log</span><span class="hljs-comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><span class="hljs-meta">logging.path</span>=<span class="hljs-string">/spring/log</span><span class="hljs-comment">#  在控制台输出的日志的格式</span><span class="hljs-meta">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><span class="hljs-comment"># 指定文件中日志输出的格式</span><span class="hljs-meta">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></code></pre></div><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>只在控制台输出</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>输出日志到my.log文件</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>输出到指定目录的 spring.log 文件中</td></tr></tbody></table><h3 id="2、指定配置"><a href="#2、指定配置" class="headerlink" title="2、指定配置"></a>2、指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"staging"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span>  可以指定某段配置只在某个环境下生效<span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span></code></pre></div><p>如：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stdout"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        日志输出格式：</span><span class="hljs-comment">%d表示日期时间，</span><span class="hljs-comment">%thread表示线程名，</span><span class="hljs-comment">%-5level：级别从左显示5个字符宽度</span><span class="hljs-comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><span class="hljs-comment">%msg：日志消息，</span><span class="hljs-comment">%n是换行符</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"!dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre></div><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p><p> <code>no applicable action for [springProfile]</code></p><h2 id="5、切换日志框架"><a href="#5、切换日志框架" class="headerlink" title="5、切换日志框架"></a>5、切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式；</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>切换为log4j2</p><div class="hljs"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><hr><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="/2020/06/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <url>/2020/06/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="1、自动配置原理："><a href="#1、自动配置原理：" class="headerlink" title="1、自动配置原理："></a>1、<strong>自动配置原理：</strong></h3><p><strong>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> 里面有 <span class="hljs-meta">@EnableAutoConfiguration</span></code></pre></div><p><strong>2）、@EnableAutoConfiguration 作用：</strong></p><ul><li><p>利用AutoConfigurationImportSelector给容器中导入一些组件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoConfiguration</span> 里面有 <span class="hljs-meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span></code></pre></div><p>​</p></li><li><p>可以查看selectImports()方法的内容；</p><div class="hljs"><pre><code class="hljs java">类中有selectImports方法关键代码：List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</code></pre></div></li><li><p>SpringFactoriesLoader.loadFactoryNames()</p><div class="hljs"><pre><code class="hljs java">进入getCandidateConfigurations方法<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());        Assert.notEmpty(configurations, <span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);        <span class="hljs-keyword">return</span> configurations;    &#125;    再进入loadFactoryNames方法<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;        String factoryClassName = factoryClass.getName();        <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());    &#125;   再进入loadSpringFactories方法可以看到有关键性代码Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="hljs-string">"META-INF/spring.factories"</span>);<span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;        URL url = (URL)urls.nextElement();        UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);        Properties properties = PropertiesLoaderUtils.loadProperties(resource);       （这处代码有删减，源码篇幅过长）    &#125;</code></pre></div><p>扫描所有jar包类路径下  META-INF/spring.factories<br>把扫描到的这些文件的内容包装成properties对象</p><p>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</p><p>​</p></li></ul><p><strong>==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==</strong></p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># Auto Configure</span><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\<span class="hljs-attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></code></pre></div><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p><strong>3）、每一个自动配置类进行自动配置功能；</strong></p><p><strong>4）、以</strong>HttpEncodingAutoConfiguration（Http编码自动配置）<strong>为例解释自动配置原理；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>   <span class="hljs-comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //启动指定类的<span class="hljs-title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="hljs-title">HttpEncodingProperties</span>绑定起来；并把<span class="hljs-title">HttpEncodingProperties</span>加入到<span class="hljs-title">ioc</span>容器中</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span> //<span class="hljs-title">Spring</span>底层@<span class="hljs-title">Conditional</span>注解（<span class="hljs-title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="hljs-title">web</span>应用，如果是，当前配置类生效</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">CharacterEncodingFilter</span>.<span class="hljs-title">class</span>)  //判断当前项目有没有这个类<span class="hljs-title">CharacterEncodingFilter</span>；<span class="hljs-title">SpringMVC</span>中进行乱码解决的过滤器；</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"spring.http.encoding"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)  <span class="hljs-comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span><span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpEncodingProperties properties;     <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpEncodingProperties properties)</span> </span>&#123;<span class="hljs-keyword">this</span>.properties = properties;&#125;      <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) //判断容器没有这个组件？</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">CharacterEncodingFilter</span> <span class="hljs-title">characterEncodingFilter</span>() </span>&#123;CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.REQUEST));filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.RESPONSE));<span class="hljs-keyword">return</span> filter;&#125;</code></pre></div><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p><strong>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.http.encoding"</span>)  <span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingProperties</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="hljs-string">"UTF-8"</span>);</code></pre></div><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><p><strong>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><div class="hljs"><pre><code class="hljs java">=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）-----------------   DispatcherServletAutoConfiguration matched:      - <span class="hljs-meta">@ConditionalOnClass</span> found required <span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">DispatcherServlet</span>'</span>; <span class="hljs-meta">@ConditionalOnMissingClass</span> <span class="hljs-function">did not find unwanted <span class="hljs-title">class</span> <span class="hljs-params">(OnClassCondition)</span></span><span class="hljs-function">      - @<span class="hljs-title">ConditionalOnWebApplication</span> <span class="hljs-params">(required)</span> found <span class="hljs-title">StandardServletEnvironment</span> <span class="hljs-params">(OnWebApplicationCondition)</span></span><span class="hljs-function">        </span><span class="hljs-function">    </span><span class="hljs-function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span><span class="hljs-function">-----------------</span><span class="hljs-function"></span><span class="hljs-function">   ActiveMQAutoConfiguration:</span><span class="hljs-function">      Did not match:</span><span class="hljs-function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="hljs-params">(OnClassCondition)</span></span><span class="hljs-function"></span><span class="hljs-function">   AopAutoConfiguration:</span><span class="hljs-function">      Did not match:</span><span class="hljs-function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="hljs-params">(OnClassCondition)</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类与实例初始化面试题</title>
    <link href="/2020/06/22/%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/06/22/%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jk.test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-06-15  21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = method();    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">"(1)"</span>);    &#125;    Father()&#123;        System.out.print(<span class="hljs-string">"(2)"</span>);    &#125;    &#123;        System.out.print(<span class="hljs-string">"(3)"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">"(4)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">"(5)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-keyword">package</span> com.jk.test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-06-15  21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = method();    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">"(6)"</span>);    &#125;    Son()&#123;        System.out.print(<span class="hljs-string">"(7)"</span>);    &#125;    &#123;        System.out.print(<span class="hljs-string">"(8)"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(9)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(10)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Son son1 = <span class="hljs-keyword">new</span> Son();        System.out.println();        Son son2 = <span class="hljs-keyword">new</span> Son();    &#125;&#125;</code></pre></div><p>main函数执行后，大家可以试试看输出的顺序是什么？</p><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><p>1、一个类的创建实例需要先加载并初始化该类<br>    - main方法所在的类需要先加载和初始化<br>2、一个子类要初始化需要先初始化父类<br>3、一个类初始化就是执行&lt;clinit&gt;()方法<br>    - &lt;clinit&gt;()方法由静态类变量显示赋值代码和静态代码块组成</p><hr><p>就是说在main方法启动的时候，就会去初始化类<br>因为在父类和子类中都有静态变量和静态代码块，静态变量和静态代码块顺序是根据代码书写的顺序执行的所以：<br>执行顺序为 （5）（1）（10）（6）</p><h2 id="实例的初始化过程"><a href="#实例的初始化过程" class="headerlink" title="实例的初始化过程"></a>实例的初始化过程</h2><p>实例初始化就是执行&lt;init&gt;()方法<br>    - &lt;init&gt;()方法可能重载有多个，有几个构造器就有几个&lt;init&gt;()方法<br>    - &lt;init&gt;()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成<br>    - 非静态实例变量显示复制代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行<br>    - 每次创建实例对象，调用对应构造器，执行的就是对应的&lt;init&gt;()方法<br>    - &lt;init&gt;()方法的首行是super()或super(实参列表)，即对应父类的&lt;init&gt;()方法</p><hr><p>就是说在调用构造函数进行实例的初始化时，不管有没有super关键字，都会调用父类的构造器先进行初始化，然后在初始化父类构造器后，再执行类中显示赋值代码和非静态代码块 比如Son子类的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();&#123;        System.out.print(<span class="hljs-string">"(8)"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(10)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p>最后才是Son子类的构造器</p><div class="hljs"><pre><code class="hljs java">Son()&#123;        System.out.print(<span class="hljs-string">"(7)"</span>);&#125;</code></pre></div><p>所有根据以上的顺序得出的全部顺序为<br>（5）（1）（10）（6）（4）（3）（2）（9）（8）（7）<br>（4）（3）（2）（9）（8）（7）</p><p>以为到这里结束了嘛，其实这里还有一个坑，就是多态性，方法的重写！</p><h2 id="方法的重写Override"><a href="#方法的重写Override" class="headerlink" title="方法的重写Override"></a>方法的重写Override</h2><p>1、哪些方法不可以被重写<br>    - final方法<br>    - 静态方法<br>    - private等子类中不可见方法<br>2、对象的多态性<br>    - 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码<br>    - 非静态方法默认的调用对象是this<br>    - this对象在构造器或者说<init>方法中就是正在创建的对象</init></p><hr><p>也就是说在初始化父类实例时，初始化变量时候调用test（）方法，因为是非静态方法，所有默认调用对象this，是当前对象，也就是Son对象 所以实际执行的是子类重写的方法</p><p>最终的结果顺序为<br><img src="https://img-blog.csdnimg.cn/2020061522493926.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>一叶知秋，穿插了类与实例的初始化过程。<br>此文章根据尚硅谷视频加上个人理解与实践。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类与实例初始化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
