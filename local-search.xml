<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="/2020/06/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <url>/2020/06/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="1、自动配置原理："><a href="#1、自动配置原理：" class="headerlink" title="1、自动配置原理："></a>1、<strong>自动配置原理：</strong></h3><p><strong>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> 里面有 <span class="hljs-meta">@EnableAutoConfiguration</span></code></pre></div><p><strong>2）、@EnableAutoConfiguration 作用：</strong></p><ul><li><p>利用AutoConfigurationImportSelector给容器中导入一些组件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoConfiguration</span> 里面有 <span class="hljs-meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span></code></pre></div><p>​</p></li><li><p>可以查看selectImports()方法的内容；</p><div class="hljs"><pre><code class="hljs java">类中有selectImports方法关键代码：List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</code></pre></div></li><li><p>SpringFactoriesLoader.loadFactoryNames()</p><div class="hljs"><pre><code class="hljs java">进入getCandidateConfigurations方法<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());        Assert.notEmpty(configurations, <span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);        <span class="hljs-keyword">return</span> configurations;    &#125;    再进入loadFactoryNames方法<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;        String factoryClassName = factoryClass.getName();        <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());    &#125;   再进入loadSpringFactories方法可以看到有关键性代码Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="hljs-string">"META-INF/spring.factories"</span>);<span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;        URL url = (URL)urls.nextElement();        UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);        Properties properties = PropertiesLoaderUtils.loadProperties(resource);       （这处代码有删减，源码篇幅过长）    &#125;</code></pre></div><p>扫描所有jar包类路径下  META-INF/spring.factories<br>把扫描到的这些文件的内容包装成properties对象</p><p>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</p><p>​</p></li></ul><p><strong>==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==</strong></p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># Auto Configure</span><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\<span class="hljs-attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></code></pre></div><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p><strong>3）、每一个自动配置类进行自动配置功能；</strong></p><p><strong>4）、以</strong>HttpEncodingAutoConfiguration（Http编码自动配置）<strong>为例解释自动配置原理；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>   <span class="hljs-comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //启动指定类的<span class="hljs-title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="hljs-title">HttpEncodingProperties</span>绑定起来；并把<span class="hljs-title">HttpEncodingProperties</span>加入到<span class="hljs-title">ioc</span>容器中</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span> //<span class="hljs-title">Spring</span>底层@<span class="hljs-title">Conditional</span>注解（<span class="hljs-title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="hljs-title">web</span>应用，如果是，当前配置类生效</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">CharacterEncodingFilter</span>.<span class="hljs-title">class</span>)  //判断当前项目有没有这个类<span class="hljs-title">CharacterEncodingFilter</span>；<span class="hljs-title">SpringMVC</span>中进行乱码解决的过滤器；</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"spring.http.encoding"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)  <span class="hljs-comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span><span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpEncodingProperties properties;     <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpEncodingProperties properties)</span> </span>&#123;<span class="hljs-keyword">this</span>.properties = properties;&#125;      <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) //判断容器没有这个组件？</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">CharacterEncodingFilter</span> <span class="hljs-title">characterEncodingFilter</span>() </span>&#123;CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.REQUEST));filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.RESPONSE));<span class="hljs-keyword">return</span> filter;&#125;</code></pre></div><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p><strong>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.http.encoding"</span>)  <span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingProperties</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="hljs-string">"UTF-8"</span>);</code></pre></div><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><p><strong>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><div class="hljs"><pre><code class="hljs java">=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）-----------------   DispatcherServletAutoConfiguration matched:      - <span class="hljs-meta">@ConditionalOnClass</span> found required <span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">DispatcherServlet</span>'</span>; <span class="hljs-meta">@ConditionalOnMissingClass</span> <span class="hljs-function">did not find unwanted <span class="hljs-title">class</span> <span class="hljs-params">(OnClassCondition)</span></span><span class="hljs-function">      - @<span class="hljs-title">ConditionalOnWebApplication</span> <span class="hljs-params">(required)</span> found <span class="hljs-title">StandardServletEnvironment</span> <span class="hljs-params">(OnWebApplicationCondition)</span></span><span class="hljs-function">        </span><span class="hljs-function">    </span><span class="hljs-function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span><span class="hljs-function">-----------------</span><span class="hljs-function"></span><span class="hljs-function">   ActiveMQAutoConfiguration:</span><span class="hljs-function">      Did not match:</span><span class="hljs-function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="hljs-params">(OnClassCondition)</span></span><span class="hljs-function"></span><span class="hljs-function">   AopAutoConfiguration:</span><span class="hljs-function">      Did not match:</span><span class="hljs-function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="hljs-params">(OnClassCondition)</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类与实例初始化面试题</title>
    <link href="/2020/06/22/%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/06/22/%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jk.test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-06-15  21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = method();    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">"(1)"</span>);    &#125;    Father()&#123;        System.out.print(<span class="hljs-string">"(2)"</span>);    &#125;    &#123;        System.out.print(<span class="hljs-string">"(3)"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">"(4)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">"(5)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-keyword">package</span> com.jk.test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-06-15  21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = method();    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">"(6)"</span>);    &#125;    Son()&#123;        System.out.print(<span class="hljs-string">"(7)"</span>);    &#125;    &#123;        System.out.print(<span class="hljs-string">"(8)"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(9)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(10)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Son son1 = <span class="hljs-keyword">new</span> Son();        System.out.println();        Son son2 = <span class="hljs-keyword">new</span> Son();    &#125;&#125;</code></pre></div><p>main函数执行后，大家可以试试看输出的顺序是什么？</p><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><p>1、一个类的创建实例需要先加载并初始化该类<br>    - main方法所在的类需要先加载和初始化<br>2、一个子类要初始化需要先初始化父类<br>3、一个类初始化就是执行&lt;clinit&gt;()方法<br>    - &lt;clinit&gt;()方法由静态类变量显示赋值代码和静态代码块组成</p><hr><p>就是说在main方法启动的时候，就会去初始化类<br>因为在父类和子类中都有静态变量和静态代码块，静态变量和静态代码块顺序是根据代码书写的顺序执行的所以：<br>执行顺序为 （5）（1）（10）（6）</p><h2 id="实例的初始化过程"><a href="#实例的初始化过程" class="headerlink" title="实例的初始化过程"></a>实例的初始化过程</h2><p>实例初始化就是执行&lt;init&gt;()方法<br>    - &lt;init&gt;()方法可能重载有多个，有几个构造器就有几个&lt;init&gt;()方法<br>    - &lt;init&gt;()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成<br>    - 非静态实例变量显示复制代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行<br>    - 每次创建实例对象，调用对应构造器，执行的就是对应的&lt;init&gt;()方法<br>    - &lt;init&gt;()方法的首行是super()或super(实参列表)，即对应父类的&lt;init&gt;()方法</p><hr><p>就是说在调用构造函数进行实例的初始化时，不管有没有super关键字，都会调用父类的构造器先进行初始化，然后在初始化父类构造器后，再执行类中显示赋值代码和非静态代码块 比如Son子类的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();&#123;        System.out.print(<span class="hljs-string">"(8)"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(10)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p>最后才是Son子类的构造器</p><div class="hljs"><pre><code class="hljs java">Son()&#123;        System.out.print(<span class="hljs-string">"(7)"</span>);&#125;</code></pre></div><p>所有根据以上的顺序得出的全部顺序为<br>（5）（1）（10）（6）（4）（3）（2）（9）（8）（7）<br>（4）（3）（2）（9）（8）（7）</p><p>以为到这里结束了嘛，其实这里还有一个坑，就是多态性，方法的重写！</p><h2 id="方法的重写Override"><a href="#方法的重写Override" class="headerlink" title="方法的重写Override"></a>方法的重写Override</h2><p>1、哪些方法不可以被重写<br>    - final方法<br>    - 静态方法<br>    - private等子类中不可见方法<br>2、对象的多态性<br>    - 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码<br>    - 非静态方法默认的调用对象是this<br>    - this对象在构造器或者说<init>方法中就是正在创建的对象</p><hr><p>也就是说在初始化父类实例时，初始化变量时候调用test（）方法，因为是非静态方法，所有默认调用对象this，是当前对象，也就是Son对象 所以实际执行的是子类重写的方法</p><p>最终的结果顺序为<br><img src="https://img-blog.csdnimg.cn/2020061522493926.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>一叶知秋，穿插了类与实例的初始化过程。<br>此文章根据尚硅谷视频加上个人理解与实践。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类与实例初始化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
