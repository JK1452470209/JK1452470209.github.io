<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Mr.JK">
  <meta name="keywords" content="">
  <title>学成在线day05：消息中间件RabbitMQ - Mr.JK</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>





<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>私人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-11 13:33">
      2020-08-11
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      109
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
	
   
	
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote>
<p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p>
</blockquote>
<p>本章节为【学成在线】项目的 <code>day05</code> 的内容</p>
<ul>
<li><code>RabbitMQ</code> 的基本应用场景</li>
<li>使用原生<code>RabbitMQ</code> 库构建生产者与消费者模型</li>
<li>整合 <code>Springboot</code> 实现 <code>RabbitMQ</code> 生产者与消费者模型</li>
</ul>
<h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><p><a href="https://qnoss.codeyee.com/20200704_5/image1" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image1.png" srcset="/img/loading.gif" alt="img"></a></p>
<p><strong>业务流程如下：</strong></p>
<p>1、管理员进入管理界面点击 “页面发布”，前端请求 <code>cms</code> 页面发布接口。</p>
<p>2、cms 页面发布接口执行页面静态化，并将静态化页面(<code>html</code>文件)存储至<code>GridFS</code>中。</p>
<p>3、静态化成功后，向消息队列发送页面发布的消息。页面发布的最终目标是将页面发布到<strong>服务器</strong>。通过消息队列将页面发布的消息发送给各个服务器。</p>
<p>4、消息队列负责将消息发送给各各服务器上部署的 <strong>Cms Client (Cms客户端)</strong>。在服务器上部署 <strong>Cms Client(Cms客户端)</strong>，客户端接收消息队列的通知。</p>
<p>5、每个接收到页面发布消息的 <code>Cms Client</code> 从 <code>GridFS</code> 获取 <code>Html</code> 页面文件，并将 <code>Html</code> 文件存储在本地服务器。<code>CmsClient</code> 根据页面发布消息的内容请求 <code>GridFS</code> 获取页面文件，存储在本地服务器 。</p>
<h1 id="二、初识RabbitMQ"><a href="#二、初识RabbitMQ" class="headerlink" title="二、初识RabbitMQ"></a>二、初识RabbitMQ</h1><p>要实现上边页面发布的功能，有一个重要的环节就是由消息队列将页面发布的消息通知给各各服务器。</p>
<p>本节的教学目标是对MQ的研究：</p>
<p>1、理解MQ的应用场景</p>
<p>2、理解MQ常用的工作模式</p>
<h2 id="1-简单的介绍"><a href="#1-简单的介绍" class="headerlink" title="1.简单的介绍"></a>1.简单的介绍</h2><h3 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h3><p>MQ全称为 Message Queue，即消息队列， <code>RabbitMQ</code>是由 <code>erlang</code> 语言开发，基于<strong>AMQP（Advanced Message Queue 高级消息队列协议）</strong>协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p>
<p>RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p>
<p>开发中消息队列通常有如下应用场景：</p>
<ul>
<li><p><strong>任务异步处理</strong></p>
<p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
</li>
<li><p><strong>应用程序解耦合</strong></p>
<p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p>
</li>
<li><p><strong>市场上还有哪些消息队列？</strong><br>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。</p>
</li>
<li><p><strong>为什么使用RabbitMQ呢？</strong></p>
<p>1、使得简单，功能强大。<br>2、基于 <code>AMQP</code> 协议。<br>3、社区活跃，文档完善。<br>4、高并发性能好，这主要得益于 <code>Erlang</code> 语言。<br>5、Spring Boot 默认已集成 <code>RabbitMQ</code></p>
</li>
</ul>
<h3 id="其它相关知识"><a href="#其它相关知识" class="headerlink" title="其它相关知识"></a>其它相关知识</h3><p>AMQP是什么 ？</p>
<p><code>AMQP</code> 是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决 <code>MQ</code> 市场上协议不统一的问题。<code>RabbitMQ</code> 就是遵循 <code>AMQP</code> 标准协议开发的MQ服务。</p>
<p>JMS是什么 ？</p>
<p><code>JMS</code>是 <code>java</code> 提供的一套消息服务API标准，其目的是为所有的 <code>java</code> 应用程序提供统一的消息通信的标准，类似 <code>java</code> 的 <code>jdbc</code>，只要遵循 <code>jms</code> 标准的应用程序之间都可以进行消息通信。它和 <code>AMQP</code> 有什么 不同，<code>jms</code> 是java语言专属的消息服务标准，它是在api层定义标准，并且只能用于 <code>java</code> 应用；而 <code>AMQP</code> 是在协议层定义的标准，是跨语言的 。</p>
<h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><h3 id="RabbitMQ-的工作原理"><a href="#RabbitMQ-的工作原理" class="headerlink" title="RabbitMQ 的工作原理"></a>RabbitMQ 的工作原理</h3><p>下图是 <code>RabbitMQ</code> 的基本结构</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image2" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image2.png" srcset="/img/loading.gif" alt="img"></a></p>
<p>组成部分说明如下：</p>
<ul>
<li><strong>Broker</strong>：消息队列服务进程，此进程包括两个部分：<code>Exchange</code> 和 <code>Queue</code>。</li>
<li><strong>Exchange</strong>：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过滤。</li>
<li><strong>Queue</strong>：消息队列，储存消息的队列，消息到达队列并转发给指定的消费方。</li>
<li><strong>Producer</strong>：消息生产者，即生产方客户端，生产方客户端将消息发送到 <code>MQ</code> 。</li>
<li><strong>Consumer</strong>：消息消费者，即消费方客户端，接收 <code>MQ</code> 转发的消息。</li>
</ul>
<p>消息 <strong>发布</strong> 与 <strong>接收</strong> 流程：</p>
<p>—–发送消息—–</p>
<p>1、生产者和 <code>Broker</code> 建立TCP连接。</p>
<p>2、生产者和 <code>Broker</code> 建立通道。</p>
<p>3、生产者通过通道消息发送给 <code>Broker</code> ，由 <code>Exchange</code> 将消息进行转发。</p>
<p>4、<code>Exchange</code>将消息转发到指定的 <code>Queue</code>（队列）</p>
<p>—-接收消息—–</p>
<p>1、消费者和 <code>Broker</code> 建立TCP连接</p>
<p>2、消费者和 <code>Broker</code> 建立通道</p>
<p>3、消费者监听指定的 <code>Queue</code>（队列）</p>
<p>4、当有消息到达 <code>Queue</code> 时 <code>Broker</code> 默认将消息推送给消费者。</p>
<p>5、消费者接收到消息。</p>
<h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><h4 id="1、下载并安装"><a href="#1、下载并安装" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h4><p>RabbitMQ由 <code>Erlang</code> 语言开发，<code>Erlang</code> 语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（OpenTelecom Platform）作为 <code>Erlang</code> 语言的一部分，包含了很多基于 <code>Erlang</code> 开发的中间件及工具库，安装 <code>RabbitMQ</code> 需要安装 Erlang/OTP，并保持版本匹配，如下图：</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image3" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image3.png" srcset="/img/loading.gif" alt="img"></a></p>
<p>本项目使用 <code>Erlang/OTP 20.3</code> 版本和 <code>RabbitMQ3.7.3</code> 版本。</p>
<p>官网 <code>RabbitMQ</code> 的下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p>
<h5 id="下载erlang"><a href="#下载erlang" class="headerlink" title="下载erlang"></a>下载erlang</h5><p>地址如下：<a href="http://erlang.org/download/otp_win64_20.3.exe" target="_blank" rel="noopener">http://erlang.org/download/otp_win64_20.3.exe</a></p>
<p>erlang安装完成需要配置erlang环境变量： ERLANG_HOME=D:\Program Files\erl9.3 在path中添<br>加%ERLANG_HOME%\bin;</p>
<h5 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h5><p>下载地址 <a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3</a></p>
<p>这里要注意 rabbitMQ的安装路径</p>
<h4 id="2、启动"><a href="#2、启动" class="headerlink" title="2、启动"></a>2、启动</h4><p>安装成功后会自动创建RabbitMQ服务并且启动。</p>
<ol>
<li><p>在系统path变量中添加 <code>rabbitMQ</code> 的环境变量：<code>D:\[rabbitMQ的安装路径]\sbin;</code></p>
</li>
<li><p>添加环境变量后，按下 <code>Win + X</code> 以管理员身份运行powershell 或者 cmd</p>
</li>
<li><p>运行 <code>rabbitmq-plugins.bat enable rabbitmq_management</code> 命令</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image4" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image4.png" srcset="/img/loading.gif" alt="安装过程"></a></p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image4" target="_blank" rel="noopener">安装过程</a></p>
<p>​</p>
</li>
<li><p>运行 <code>rabbitmq-service.bat stop</code> 和 <code>rabbitmq-service.bat start</code> 重启 rabbitMQ</p>
</li>
<li><p>启动成功，访问 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672</a> 登录Rabbit MQ，初始账号密码为 guest/guest</p>
</li>
</ol>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p>1、安装 <code>erlang</code> 和 <code>rabbitMQ</code> 以管理员身份运行。</p>
<p>2、当卸载重新安装时会出现 <code>RabbitMQ</code> 服务注册失败，此时需要进入注册表清理 <code>erlang</code><br>搜索RabbitMQ、ErlSrv，将对应的项全部删除。</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p><a href="https://qnoss.codeyee.com/20200704_5/image5" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image5.png" srcset="/img/loading.gif" alt="工作模式"></a></p>
<p>以下过程我们参考官方教程(<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a>)测试hello world:</p>
<h4 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a>1、搭建环境</h4><h5 id="java-client"><a href="#java-client" class="headerlink" title="java client"></a>java client</h5><p>生产者和消费者都属于客户端，rabbitMQ的java客户端如下：</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image6" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image6.png" srcset="/img/loading.gif" alt="img"></a></p>
<p>我们先用 <code>rabbitMQ</code> 官方提供的 <code>java client</code> 测试，目的是对 <code>RabbitMQ</code> 的交互过程有个清晰的认识。</p>
<p>参考 ：<a href="https://github.com/rabbitmq/rabbitmq-java-client/" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-java-client/</a></p>
<h5 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h5><p>创建生产者工程和消费者工程，分别加入<code>RabbitMQ java client</code>的依赖。</p>
<p>test-rabbitmq-producer：生产者工程</p>
<p>test-rabbitmq-consumer：消费者工程</p>
<p><strong>依赖配置如下：</strong></p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-comment">&lt;!--此版本与spring boot 1.5.9版本匹配--&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<p><a href="https://qnoss.codeyee.com/20200704_5/image7" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image7.png" srcset="/img/loading.gif" alt="img"></a></p>
<h4 id="2、生产者"><a href="#2、生产者" class="headerlink" title="2、生产者"></a>2、生产者</h4><p>在生产者工程下的单元测试内创建测试类如下</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer01</span> </span>&#123;
    <span class="hljs-comment">//队列名称</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">"helloworld2"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>
            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();

            factory.setHost(<span class="hljs-string">"localhost"</span>);
            factory.setPort(<span class="hljs-number">5672</span>);
            factory.setUsername(<span class="hljs-string">"guest"</span>);
            factory.setPassword(<span class="hljs-string">"guest"</span>);
            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
            factory.setVirtualHost(<span class="hljs-string">"/"</span>);

            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>
            connection = factory.newConnection();

            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>
            channel = connection.createChannel();

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span>
<span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">             *</span>
<span class="hljs-comment">             * param1:队列名称</span>
<span class="hljs-comment">             * param2:是否持久化</span>
<span class="hljs-comment">             * param3:队列是否独占此连接</span>
<span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span>
<span class="hljs-comment">             * param5:队列参数</span>
<span class="hljs-comment">             */</span>
            channel.queueDeclare(QUEUE,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);
            String message = <span class="hljs-string">"hello world 小明"</span> + System.currentTimeMillis();

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 消息发布方法</span>
<span class="hljs-comment">             消息发布方法</span>
<span class="hljs-comment">             * param1：Exchange的名称，如果没有指定，则使用Default Exchange</span>
<span class="hljs-comment">             * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列</span>
<span class="hljs-comment">             * param3:消息包含的属性</span>
<span class="hljs-comment">             * param4：消息体</span>
<span class="hljs-comment">             * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定</span>
<span class="hljs-comment">             * 默认的交换机，routingKey等于队列名称</span>
<span class="hljs-comment">             */</span>
            channel.basicPublish(<span class="hljs-string">""</span>,QUEUE,<span class="hljs-keyword">null</span>,message.getBytes());
            System.out.println(<span class="hljs-string">"Send Message is: ' "</span> + message + <span class="hljs-string">" '"</span>);

        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;
            ex.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//先关闭通道，再关闭连接</span>
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                channel.close();
            &#125;
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                connection.close();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>运行生产者后，<code>RabbitMQ</code> 后台会接收到一条等待消费的消息</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image8" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image8.png" srcset="/img/loading.gif" alt="img"></a></p>
<h4 id="3、消费者"><a href="#3、消费者" class="headerlink" title="3、消费者"></a>3、消费者</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer01</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE = <span class="hljs-string">"helloworld2"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
        factory.setHost(<span class="hljs-string">"localhost"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"guest"</span>);
        factory.setPassword(<span class="hljs-string">"guest"</span>);
        <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
        factory.setVirtualHost(<span class="hljs-string">"/"</span>);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        <span class="hljs-comment">//声明队列</span>
        <span class="hljs-comment">/** 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete,</span>
<span class="hljs-comment">         Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">         * 参数明细：</span>
<span class="hljs-comment">         * 1、queue 队列名称</span>
<span class="hljs-comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span>
<span class="hljs-comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭，队列则自动删除,可用于临时队列的创建</span>
<span class="hljs-comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive共同为true，就可以实现临时队列</span>
<span class="hljs-comment">         * 5、argmuacnts，可以设置一个队列扩展参数，比如：可设置存活的时间</span>
<span class="hljs-comment">         */</span>
        channel.queueDeclare(QUEUE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">//定义消费方法</span>
        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 消费者接收消息调用此方法</span>
<span class="hljs-comment">             * <span class="hljs-doctag">@param</span> consumerTag 消费者的标签，在channel.basicConsume()去指定</span>
<span class="hljs-comment">             * <span class="hljs-doctag">@param</span> envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志</span>
<span class="hljs-comment">            (收到消息失败后是否需要重新发送)</span>
<span class="hljs-comment">             * <span class="hljs-doctag">@param</span> properties 消息属性</span>
<span class="hljs-comment">             * <span class="hljs-doctag">@param</span> body 消息内容</span>
<span class="hljs-comment">             * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">            1、发送端操作流程</span>
<span class="hljs-comment">            1）创建连接</span>
<span class="hljs-comment">            2）创建通道</span>
<span class="hljs-comment">            3）声明队列</span>
<span class="hljs-comment">            4）发送消息</span>
<span class="hljs-comment">            2、接收端</span>
<span class="hljs-comment">            1）创建连接</span>
<span class="hljs-comment">            2）创建通道</span>
<span class="hljs-comment">            3）声明队列</span>
<span class="hljs-comment">            4）监听队列</span>
<span class="hljs-comment">            5）接收消息</span>
<span class="hljs-comment">             */</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">//交换机</span>
                String exchange = envelope.getExchange();
                <span class="hljs-comment">//路由key</span>
                String routingKey = envelope.getRoutingKey();
                <span class="hljs-comment">//消息id</span>
                <span class="hljs-keyword">long</span> deliveryTag = envelope.getDeliveryTag();
                <span class="hljs-comment">//消息内容</span>
                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                System.out.println(<span class="hljs-string">"receive message.."</span> + msg);
            &#125;
        &#125;;

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 监听队列String queue, boolean autoAck,Consumer callback</span>
<span class="hljs-comment">         * 参数明细</span>
<span class="hljs-comment">         * 1、queue 队列名称</span>
<span class="hljs-comment">         * 2、autoAck 是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复</span>
<span class="hljs-comment">         * 3、callback 消费消息的方法，消费者接收到消息后调用此方法</span>
<span class="hljs-comment">         */</span>
        channel.basicConsume(QUEUE, <span class="hljs-keyword">true</span>, defaultConsumer);
    &#125;
&#125;</code></pre></div>

<h4 id="4、消息接收测试"><a href="#4、消息接收测试" class="headerlink" title="4、消息接收测试"></a>4、消息接收测试</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image9" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image9.gif" srcset="/img/loading.gif" alt="img"></a></p>
<h2 id="3-工作模式"><a href="#3-工作模式" class="headerlink" title="3. 工作模式"></a>3. 工作模式</h2><p><code>RabbitMQ</code> 有以下几种工作模式 ：</p>
<p>1、Work queues，工作队列模式</p>
<p>2、Publish/Subscribe，发布订阅模式</p>
<p>3、Routing，路由模式</p>
<p>4、Topics，通配符模式</p>
<p>5、Header，header模式</p>
<p>6、RPC ，rpc模式</p>
<h3 id="Work-queues-模式"><a href="#Work-queues-模式" class="headerlink" title="Work queues 模式"></a>Work queues 模式</h3><p><code>work queues</code> 工作模式，与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息。</p>
<p>应用场景：对于 <strong>任务过重</strong> 或 <strong>任务较多</strong> 情况使用工作队列可以提高任务处理的速度 。</p>
<p><strong>测试：</strong></p>
<p>1、使用入门程序，启动多个消费者。</p>
<p>2、生产者发送多个消息。</p>
<p><strong>测试结果：</strong></p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image10" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image10.gif" srcset="/img/loading.gif" alt="img"></a></p>
<p>1、一条消息只会被一个消费者接收；</p>
<p>2、<code>rabbit</code> 采用 <strong>轮询</strong> 的方式将消息是平均发送给消费者的；</p>
<p>3、消费者在处理完某条消息后，才会收到下一条消息。</p>
<h3 id="Publish-Subscribe-模式"><a href="#Publish-Subscribe-模式" class="headerlink" title="Publish/Subscribe 模式"></a>Publish/Subscribe 模式</h3><h4 id="1、发布订阅模式"><a href="#1、发布订阅模式" class="headerlink" title="1、发布订阅模式"></a>1、发布订阅模式</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image11" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image11.png" srcset="/img/loading.gif" alt="发布订阅模式"></a></p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image11" target="_blank" rel="noopener"></a></p>
<p>1、每个消费者监听自己的队列。</p>
<p>2、生产者将消息发给 <code>broker</code>，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 。</p>
<h4 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h4><p>案例：</p>
<p>用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法 。</p>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p>声明 <code>Exchange_fanout_inform</code> 交换机。</p>
<p>声明两个队列并且绑定到此交换机，绑定时不需要指定 <code>routingkey</code></p>
<p>发送消息时不需要指定 <code>routingkey</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;

<span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;
<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer02_publish</span> </span>&#123;
    <span class="hljs-comment">//队列名称</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_FANOUT_INFORM = <span class="hljs-string">"exchange_fanout_inform"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>
            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
            factory.setHost(<span class="hljs-string">"localhost"</span>);
            factory.setPort(<span class="hljs-number">5672</span>);
            factory.setUsername(<span class="hljs-string">"guest"</span>);
            factory.setPassword(<span class="hljs-string">"guest"</span>);
            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
            factory.setVirtualHost(<span class="hljs-string">"/"</span>);

            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>
            connection = factory.newConnection();

            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>
            channel = connection.createChannel();
            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明交换机</span>
<span class="hljs-comment">             * 1、交换机名称</span>
<span class="hljs-comment">             * 2、交换机类型：fanout、topic、direct、headers</span>
<span class="hljs-comment">             */</span>
            channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT);

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span>
<span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">             *</span>
<span class="hljs-comment">             * param1:队列名称</span>
<span class="hljs-comment">             * param2:是否持久化</span>
<span class="hljs-comment">             * param3:队列是否独占此连接</span>
<span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span>
<span class="hljs-comment">             * param5:队列参数</span>
<span class="hljs-comment">             */</span>
            channel.queueDeclare(QUEUE_INFORM_EMAIL,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);
            channel.queueDeclare(QUEUE_INFORM_SMS,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 将交换机和队列进行绑定</span>
<span class="hljs-comment">             */</span>
            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>);
            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>);

            <span class="hljs-comment">//发布消息</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to user "</span> + i;
                <span class="hljs-comment">/**</span>
<span class="hljs-comment">                 * 消息发布方法</span>
<span class="hljs-comment">                 消息发布方法</span>
<span class="hljs-comment">                 * param1：Exchange的名称，如果没有指定，则使用Default Exchange</span>
<span class="hljs-comment">                 * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列</span>
<span class="hljs-comment">                 * param3:消息包含的属性</span>
<span class="hljs-comment">                 * param4：消息体</span>
<span class="hljs-comment">                 * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定</span>
<span class="hljs-comment">                 * 默认的交换机，routingKey等于队列名称</span>
<span class="hljs-comment">                 */</span>
                channel.basicPublish(EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;


        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;
            ex.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//关闭通道和连接</span>
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                channel.close();
            &#125;
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                connection.close();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<h5 id="邮件消费者"><a href="#邮件消费者" class="headerlink" title="邮件消费者"></a>邮件消费者</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;

<span class="hljs-keyword">import</span> com.rabbitmq.client.*;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer02_subscribe_email</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_FANOUT_INFORM = <span class="hljs-string">"exchange_fanout_inform"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
        factory.setHost(<span class="hljs-string">"localhost"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"guest"</span>);
        factory.setPassword(<span class="hljs-string">"guest"</span>);
        <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
        factory.setVirtualHost(<span class="hljs-string">"/"</span>);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        <span class="hljs-comment">//声明队列</span>
        <span class="hljs-comment">/** 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete,</span>
<span class="hljs-comment">         Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">         * 参数明细：</span>
<span class="hljs-comment">         * 1、queue 队列名称</span>
<span class="hljs-comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span>
<span class="hljs-comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭，队列则自动删除,可用于临时队列的创建</span>
<span class="hljs-comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive共同为true，就可以实现临时队列</span>
<span class="hljs-comment">         * 5、argmuacnts，可以设置一个队列扩展参数，比如：可设置存活的时间</span>
<span class="hljs-comment">         */</span>
        channel.queueDeclare(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 声明交换机</span>
<span class="hljs-comment">         */</span>
        channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM,BuiltinExchangeType.FANOUT);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 绑定交换机</span>
<span class="hljs-comment">         */</span>
        channel.queueBind(QUEUE_INFORM_EMAIL, EXCHANGE_FANOUT_INFORM,<span class="hljs-string">""</span>);

        <span class="hljs-comment">//定义消费方法</span>
        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">//交换机</span>
                String exchange = envelope.getExchange();
                <span class="hljs-comment">//路由key</span>
                String routingKey = envelope.getRoutingKey();
                <span class="hljs-comment">//消息id</span>
                <span class="hljs-keyword">long</span> deliveryTag = envelope.getDeliveryTag();
                <span class="hljs-comment">//消息内容</span>
                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                System.out.println(<span class="hljs-string">"receive message.."</span> + msg);
            &#125;
        &#125;;

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 监听队列String queue, boolean autoAck,Consumer callback</span>
<span class="hljs-comment">         * 参数明细</span>
<span class="hljs-comment">         * 1、queue 队列名称</span>
<span class="hljs-comment">         * 2、autoAck 是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复</span>
<span class="hljs-comment">         * 3、callback 消费消息的方法，消费者接收到消息后调用此方法</span>
<span class="hljs-comment">         */</span>
        channel.basicConsume(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, defaultConsumer);
    &#125;
&#125;</code></pre></div>

<h5 id="短信消费者"><a href="#短信消费者" class="headerlink" title="短信消费者"></a>短信消费者</h5><p>参考上边的邮件发送消费者代码，修改队列名称即可</p>
<h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image12" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image12.gif" srcset="/img/loading.gif" alt="img"></a></p>
<h4 id="4、思考"><a href="#4、思考" class="headerlink" title="4、思考"></a>4、思考</h4><ol>
<li><p><strong>publish/subscribe与work queues有什么区别。</strong></p>
<p><strong>区别：</strong><br>1）<code>work queues</code> 不用定义交换机，而 <code>publish/subscribe</code> 需要定义交换机。</p>
<p>2）<code>publish/subscribe</code> 的生产方是面向交换机发送消息，<code>work queues</code> 的生产方是面向队列</p>
<p>发送消息(底层使用默认交换机)。</p>
<p>3）<code>publish/subscribe</code> 需要设置队列和交换机的绑定，<code>work queues</code> 不需要设置，实质上<code>work queues</code> 会将队列绑定到默认的交换机 。</p>
<p><strong>相同点：</strong></p>
<p>所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p>
</li>
<li><p><strong>实质工作用什么 publish/subscribe 还是 work queues</strong></p>
<p>建议使用 <code>publish/subscribe</code>，发布订阅模式比工作队列模式更强大，并且发布订阅模式可以指定自己专用的交换机。</p>
</li>
</ol>
<h3 id="Routing-模式"><a href="#Routing-模式" class="headerlink" title="Routing 模式"></a>Routing 模式</h3><h4 id="1、路由模式"><a href="#1、路由模式" class="headerlink" title="1、路由模式"></a>1、路由模式</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image13" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image13.png" srcset="/img/loading.gif" alt=" "></a></p>
<p>1、每个消费者监听自己的队列，并且设置 <code>routingkey</code>。</p>
<p>2、生产者将消息发给交换机，由交换机根据 <code>routingkey</code> 来转发消息到指定的队列。</p>
<h4 id="2、代码-1"><a href="#2、代码-1" class="headerlink" title="2、代码"></a>2、代码</h4><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><p>路由模式的生产者代码基于 <strong>发布订阅模式</strong> 的代码，在这基础上增加以下几点</p>
<ul>
<li>增加 <code>routing key</code> 以及 修改交换机的模式</li>
<li>为每个队列绑定 <code>routing key</code></li>
<li>在下面的代码当中，我为 <code>CMS</code> 和 <code>EMAIL</code> 的队列分别绑定了一个单独的 <code>routing key</code>，再绑定了一个 共有的名为 <code>ALL</code> 的key，以便测试 <code>routing</code> 模式的特性</li>
</ul>
<p>具体代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;

<span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;
<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer03_routing</span> </span>&#123;
    <span class="hljs-comment">//队列名称</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_ROUTING_INFORM = <span class="hljs-string">"exchange_routing_inform"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_EMAIL = <span class="hljs-string">"inform_email"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_SMS = <span class="hljs-string">"inform_sms"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>
            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
            factory.setHost(<span class="hljs-string">"localhost"</span>);
            factory.setPort(<span class="hljs-number">5672</span>);
            factory.setUsername(<span class="hljs-string">"guest"</span>);
            factory.setPassword(<span class="hljs-string">"guest"</span>);
            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
            factory.setVirtualHost(<span class="hljs-string">"/"</span>);

            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>
            connection = factory.newConnection();

            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>
            channel = connection.createChannel();
            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明交换机</span>
<span class="hljs-comment">             * 1、交换机名称</span>
<span class="hljs-comment">             * 2、交换机类型：fanout、topic、direct、headers</span>
<span class="hljs-comment">             */</span>
            channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT);

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span>
<span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">             *</span>
<span class="hljs-comment">             * param1:队列名称</span>
<span class="hljs-comment">             * param2:是否持久化</span>
<span class="hljs-comment">             * param3:队列是否独占此连接</span>
<span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span>
<span class="hljs-comment">             * param5:队列参数</span>
<span class="hljs-comment">             */</span>
            channel.queueDeclare(QUEUE_INFORM_EMAIL,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);
            channel.queueDeclare(QUEUE_INFORM_SMS,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 将交换机和队列进行绑定</span>
<span class="hljs-comment">             */</span>
            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_SMS);
            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_EMAIL);

            <span class="hljs-comment">//两个队列都绑定一个ALL的KEY</span>
            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>);
            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>);

            <span class="hljs-comment">//发布消息到EMAIL</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to email "</span> + i;
                <span class="hljs-comment">/**</span>
<span class="hljs-comment">                 * 消息发布方法</span>
<span class="hljs-comment">                 消息发布方法</span>
<span class="hljs-comment">                 * param1：Exchange的名称，如果没有指定，则使用Default Exchange</span>
<span class="hljs-comment">                 * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列</span>
<span class="hljs-comment">                 * param3:消息包含的属性</span>
<span class="hljs-comment">                 * param4：消息体</span>
<span class="hljs-comment">                 * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定</span>
<span class="hljs-comment">                 * 默认的交换机，routingKey等于队列名称</span>
<span class="hljs-comment">                 */</span>
                channel.basicPublish(EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_EMAIL,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;
            <span class="hljs-comment">//发布消息SMS</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to sms "</span> + i;
                channel.basicPublish(EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_SMS,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;

            <span class="hljs-comment">//发布消息ALL</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to all user "</span> + i;
                channel.basicPublish(EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;


        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;
            ex.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//关闭通道和连接</span>
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                channel.close();
            &#125;
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                connection.close();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>单独运行生产者后，我们可以在 rabbitMQ 后台的 <code>EXCHANGES</code> 栏中看到，建立了4个队列对应 <code>routing key</code> 的通讯连接</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image14" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image14.png" srcset="/img/loading.gif" alt="img"></a></p>
<h5 id="短信消费者-1"><a href="#短信消费者-1" class="headerlink" title="短信消费者"></a>短信消费者</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;

<span class="hljs-keyword">import</span> com.rabbitmq.client.*;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer03_routing_sms</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_ROUTING_INFORM = <span class="hljs-string">"exchange_routing_inform"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_SMS = <span class="hljs-string">"inform_sms"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
        factory.setHost(<span class="hljs-string">"localhost"</span>);
        factory.setPort(<span class="hljs-number">5672</span>);
        factory.setUsername(<span class="hljs-string">"guest"</span>);
        factory.setPassword(<span class="hljs-string">"guest"</span>);
        <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
        factory.setVirtualHost(<span class="hljs-string">"/"</span>);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        <span class="hljs-comment">//声明队列</span>
        <span class="hljs-comment">/** 参数：String queue, boolean durable, boolean exclusive, boolean autoDelete,</span>
<span class="hljs-comment">         Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">         * 参数明细：</span>
<span class="hljs-comment">         * 1、queue 队列名称</span>
<span class="hljs-comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span>
<span class="hljs-comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭，队列则自动删除,可用于临时队列的创建</span>
<span class="hljs-comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive共同为true，就可以实现临时队列</span>
<span class="hljs-comment">         * 5、argmuacnts，可以设置一个队列扩展参数，比如：可设置存活的时间</span>
<span class="hljs-comment">         */</span>
        channel.queueDeclare(QUEUE_INFORM_SMS, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 声明交换机</span>
<span class="hljs-comment">         */</span>
        channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM,BuiltinExchangeType.DIRECT);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 绑定交换机</span>
<span class="hljs-comment">         */</span>
        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,ROUTINGKEY_INFORM_SMS);
        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>); <span class="hljs-comment">//绑定一个公有的key,用于接收公共的key</span>

        <span class="hljs-comment">//定义消费方法</span>
        DefaultConsumer defaultConsumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">//交换机</span>
                String exchange = envelope.getExchange();
                <span class="hljs-comment">//路由key</span>
                String routingKey = envelope.getRoutingKey();
                <span class="hljs-comment">//消息id</span>
                <span class="hljs-keyword">long</span> deliveryTag = envelope.getDeliveryTag();
                <span class="hljs-comment">//消息内容</span>
                String msg = <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">"utf-8"</span>);
                System.out.println(<span class="hljs-string">"receive message.."</span> + msg);
            &#125;
        &#125;;

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 监听队列String queue, boolean autoAck,Consumer callback</span>
<span class="hljs-comment">         * 参数明细</span>
<span class="hljs-comment">         * 1、queue 队列名称</span>
<span class="hljs-comment">         * 2、autoAck 是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复</span>
<span class="hljs-comment">         * 3、callback 消费消息的方法，消费者接收到消息后调用此方法</span>
<span class="hljs-comment">         */</span>
        channel.basicConsume(QUEUE_INFORM_SMS, <span class="hljs-keyword">true</span>, defaultConsumer);
    &#125;
&#125;</code></pre></div>

<p>这里要注意的一点是，在队列绑定交换机的代码中，除了绑定短信的key 我还单独绑定了一个 ALL 的key，用于接收全局的消息，代码块如下</p>
<div class="hljs"><pre><code class="hljs java">channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,<span class="hljs-string">"ALL"</span>); <span class="hljs-comment">//绑定一个公有的key,用于接收公共的key</span></code></pre></div>

<h5 id="邮件消费者-1"><a href="#邮件消费者-1" class="headerlink" title="邮件消费者"></a>邮件消费者</h5><p>具体代码参考短信消费者的代码</p>
<h4 id="3、测试-1"><a href="#3、测试-1" class="headerlink" title="3、测试"></a>3、测试</h4><p>预期结果：生产者分别发送5条消息到 <strong>SMS消费者</strong> 和 <strong>EMAIL 消费者</strong>，以及发送5条消息给<strong>全部消费者</strong>。</p>
<p><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image15.gif" srcset="/img/loading.gif" alt="img"></p>
<h4 id="4、思考-1"><a href="#4、思考-1" class="headerlink" title="4、思考"></a>4、思考</h4><p>1、Routing模式 和 Publish/subscibe有啥区别？</p>
<p>Routing模式要求队列在绑定交换机时要指定<code>routingkey</code>，消息会转发到符合 <code>routingkey</code> 的队列。</p>
<h3 id="Topics-模式"><a href="#Topics-模式" class="headerlink" title="Topics 模式"></a>Topics 模式</h3><h4 id="4-1、通配符模式（Topics）"><a href="#4-1、通配符模式（Topics）" class="headerlink" title="4-1、通配符模式（Topics）"></a>4-1、通配符模式（Topics）</h4><p><a href="https://qnoss.codeyee.com/20200704_5/image16" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image16.png" srcset="/img/loading.gif" alt="img"></a></p>
<p>通配符路由模式：</p>
<p>1、每个消费者监听自己的队列，并且设置带 <strong>通配符</strong> 的 <code>routingkey</code>。</p>
<p>2、生产者将消息发给 <code>broker</code>，由交换机根据 <code>routingkey</code> 来转发消息到指定的队列。</p>
<h4 id="4-2、代码"><a href="#4-2、代码" class="headerlink" title="4-2、代码"></a>4-2、代码</h4><p>根据用户的通知设置去通知用户，设置接收 <code>Email</code> 的用户只接收 <code>Email</code>，设置接收 <code>sms</code> 的用户只接收 <code>sms</code> ，设置两种通知类型都接收的则两种通知都有效</p>
<h5 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h5><p>声明交换机，指定topic类型：</p>
<p>核心代码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 声明交换机</span>
<span class="hljs-comment">* param1：交换机名称</span>
<span class="hljs-comment">* param2:交换机类型 四种交换机类型：direct、fanout、topic、headers</span>
<span class="hljs-comment">*/</span>
channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);
<span class="hljs-comment">//Email通知</span>
channel.basicPublish(EXCHANGE_TOPICS_INFORM, <span class="hljs-string">"inform.email"</span>, <span class="hljs-keyword">null</span>, message.getBytes());
<span class="hljs-comment">//sms通知</span>
channel.basicPublish(EXCHANGE_TOPICS_INFORM, <span class="hljs-string">"inform.sms"</span>, <span class="hljs-keyword">null</span>, message.getBytes());
<span class="hljs-comment">//两种都通知</span>
channel.basicPublish(EXCHANGE_TOPICS_INFORM, <span class="hljs-string">"inform.sms.email"</span>, <span class="hljs-keyword">null</span>, message.getBytes());</code></pre></div>

<p>全部代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> rabbitmq;

<span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;
<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer04_topcis</span> </span>&#123;
    <span class="hljs-comment">//队列名称</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_TOPICS_INFORM = <span class="hljs-string">"exchange_topics_inform"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_EMAIL = <span class="hljs-string">"inform.#.email.#"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROUTINGKEY_INFORM_SMS = <span class="hljs-string">"inform.#.sms.#"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;
        Connection connection = <span class="hljs-keyword">null</span>;
        Channel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//构建连接工厂，并设置一些基本的链接信息</span>
            ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
            factory.setHost(<span class="hljs-string">"localhost"</span>);
            factory.setPort(<span class="hljs-number">5672</span>);
            factory.setUsername(<span class="hljs-string">"guest"</span>);
            factory.setPassword(<span class="hljs-string">"guest"</span>);
            <span class="hljs-comment">//rabbitMQ默认的虚拟机名称为“/”，虚拟机相当于一个独立的mq服务</span>
            factory.setVirtualHost(<span class="hljs-string">"/"</span>);

            <span class="hljs-comment">//创建与RabbitMQ服务的TCP连接</span>
            connection = factory.newConnection();

            <span class="hljs-comment">//创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务</span>
            channel = connection.createChannel();

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明交换机</span>
<span class="hljs-comment">             * 1、交换机名称</span>
<span class="hljs-comment">             * 2、交换机类型：fanout、topic、direct、headers</span>
<span class="hljs-comment">             */</span>
            channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 声明队列，如果Rabbit中没有此队列，将自动创建</span>
<span class="hljs-comment">             * String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments</span>
<span class="hljs-comment">             *</span>
<span class="hljs-comment">             * param1:队列名称</span>
<span class="hljs-comment">             * param2:是否持久化</span>
<span class="hljs-comment">             * param3:队列是否独占此连接</span>
<span class="hljs-comment">             * param4:队列不再使用时是否自动删除此队列</span>
<span class="hljs-comment">             * param5:队列参数</span>
<span class="hljs-comment">             */</span>
            channel.queueDeclare(QUEUE_INFORM_EMAIL,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);
            channel.queueDeclare(QUEUE_INFORM_SMS,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);

            <span class="hljs-comment">/**</span>
<span class="hljs-comment">             * 将交换机和队列进行绑定</span>
<span class="hljs-comment">             */</span>
            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_TOPICS_INFORM,ROUTINGKEY_INFORM_SMS);
            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_TOPICS_INFORM,ROUTINGKEY_INFORM_EMAIL);

            <span class="hljs-comment">//发布消息到EMAIL</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to email "</span> + i;
                channel.basicPublish(EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.email"</span>,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;

            <span class="hljs-comment">//发布消息SMS</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to sms "</span> + i;
                channel.basicPublish(EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.sms"</span>,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;

            <span class="hljs-comment">//发布消息到cms和email</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span> ; i++) &#123;
                String message = <span class="hljs-string">"inform to sms and email "</span> + i;
                channel.basicPublish(EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.sms.email"</span>,<span class="hljs-keyword">null</span>,message.getBytes());
                System.out.println(<span class="hljs-string">"Send Message is: "</span> + message);
            &#125;


        &#125;<span class="hljs-keyword">catch</span> ( Exception ex)&#123;
            ex.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//关闭通道和连接</span>
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                channel.close();
            &#125;
            <span class="hljs-keyword">if</span>(channel != <span class="hljs-keyword">null</span>)&#123;
                connection.close();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p>队列绑定交换机指定通配符 <code>routing key</code></p>
<p>统配符规则：中间以“.”分隔。符号#可以匹配多个词，符号*可以匹配一个词语。</p>
<p>核心代码如下，具体代码参考 <code>routing</code> 模式的消费者</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//声明队列</span>
channel.queueDeclare(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
channel.queueDeclare(QUEUE_INFORM_SMS, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
<span class="hljs-comment">//声明交换机</span>
channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);
<span class="hljs-comment">//绑定email通知队列</span>
channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.#.email.#"</span>);
<span class="hljs-comment">//绑定sms通知队列</span>
channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_TOPICS_INFORM,<span class="hljs-string">"inform.#.sms.#"</span>);</code></pre></div>

<h4 id="4-3、测试"><a href="#4-3、测试" class="headerlink" title="4-3、测试"></a>4-3、测试</h4><p>在生产者端分别向 inform.email、inform.sms、inform.sms.email 这三个通配符发送了消息</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image17" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image17.png" srcset="/img/loading.gif" alt="rabbitMQ上的交换状态"></a></p>
<p>预期结果：ems和email消费者分别接收到 <code>sms</code> 和 <code>email</code> 信息和 <code>sms and email</code> 信息</p>
<p><strong>执行生产者</strong></p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image18" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image18.png" srcset="/img/loading.gif" alt="img"></a></p>
<p><strong>查看执行消费者端</strong></p>
<p>sms消费者</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image19" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image19.png" srcset="/img/loading.gif" alt="img"></a></p>
<p>email消费者</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image20" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image20.png" srcset="/img/loading.gif" alt="img"></a></p>
<h4 id="4-4、思考"><a href="#4-4、思考" class="headerlink" title="4-4、思考"></a>4-4、思考</h4><p>1、本案例的需求使用 <code>routing</code> 模式是否能实现？</p>
<p>使用 <code>routing</code> 模式也可以实现本案例，共设置三个 <code>routing key</code> ，分别是 email、sms、all 这三个，email 队列绑定 <code>email</code> 和 <code>all</code> ，sms 队列绑定 sms 和 all，这样就可以实现上述的案例，但是实现过程比 <code>topics</code> 复杂。</p>
<p>Topics 模式更强大，它可以实现 <code>Routing</code> 、<code>publish/subscirbe</code> 模式的功能。</p>
<h3 id="Header-模式"><a href="#Header-模式" class="headerlink" title="Header 模式"></a>Header 模式</h3><p><code>header</code> 模式与 <code>routing</code> 不同的地方在于，<code>header</code> 模式取消 <code>routing key</code>，使用 <code>header</code>中的 <code>key/value</code>（键值对）匹配<br>队列。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><p>根据用的通知设置去通知用户，设置接收 <code>Email</code> 的用户只接收<code>Email</code>，设置接收 <code>sms</code> 的用户只接收 <code>sms</code>，设置两种通知类型都接收的则两种通知都有效。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>生产者</p>
<p>队列与交换机绑定的代码与之前不同，核心代码如下：</p>
<div class="hljs"><pre><code class="hljs java">Map&lt;String, Object&gt; headers_email = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();
headers_email.put(<span class="hljs-string">"inform_type"</span>, <span class="hljs-string">"email"</span>);
Map&lt;String, Object&gt; headers_sms = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();
headers_sms.put(<span class="hljs-string">"inform_type"</span>, <span class="hljs-string">"sms"</span>);
channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,<span class="hljs-string">""</span>,headers_email);
channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_HEADERS_INFORM,<span class="hljs-string">""</span>,headers_sms);</code></pre></div>

<p>发布消息核心代码:</p>
<div class="hljs"><pre><code class="hljs java">String message = <span class="hljs-string">"email inform to user"</span>+i;
Map&lt;String,Object&gt; headers = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();
headers.put(<span class="hljs-string">"inform_type"</span>, <span class="hljs-string">"email"</span>);<span class="hljs-comment">//匹配email通知消费者绑定的header</span>
<span class="hljs-comment">//headers.put("inform_type", "sms");//匹配sms通知消费者绑定的header</span>
AMQP.BasicProperties.Builder properties = <span class="hljs-keyword">new</span> AMQP.BasicProperties.Builder();
properties.headers(headers);
<span class="hljs-comment">//Email通知</span>
channel.basicPublish(EXCHANGE_HEADERS_INFORM, <span class="hljs-string">""</span>, properties.build(), message.getBytes());</code></pre></div>

<h4 id="邮消费者"><a href="#邮消费者" class="headerlink" title="邮消费者"></a>邮消费者</h4><p>email 消费者核心代码</p>
<div class="hljs"><pre><code class="hljs java">channel.exchangeDeclare(EXCHANGE_HEADERS_INFORM, BuiltinExchangeType.HEADERS);
Map&lt;String, Object&gt; headers_email = <span class="hljs-keyword">new</span> Hashtable&lt;String, Object&gt;();
headers_email.put(<span class="hljs-string">"inform_email"</span>, <span class="hljs-string">"email"</span>);
<span class="hljs-comment">//交换机和队列绑定</span>
channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,<span class="hljs-string">""</span>,headers_email);
<span class="hljs-comment">//指定消费队列</span>
channel.basicConsume(QUEUE_INFORM_EMAIL, <span class="hljs-keyword">true</span>, consumer);</code></pre></div>

<p>测试</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image21" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image21.png" srcset="/img/loading.gif" alt="img"></a></p>
<h3 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h3><p><a href="https://qnoss.codeyee.com/20200704_5/image22" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image22.png" srcset="/img/loading.gif" alt="img"></a></p>
<p>RPC即客户端远程调用服务端的方法 ，使用 <code>MQ</code> 可以实现 <code>RPC</code> 的异步调用，基于 <code>Direct</code> 交换机实现，流程如下：</p>
<p>1、客户端即是生产者就是消费者，向 <code>RPC</code> 请求队列发送 <code>RPC</code> 调用消息，同时监听 <code>RPC</code> 响应队列。</p>
<p>2、服务端监听 <code>RPC</code> 请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果</p>
<p>3、服务端将 <code>RPC</code> 方法 的结果发送到 <code>RPC</code> 响应队列</p>
<p>4、客户端（<strong>RPC调用方</strong>）监听<code>RPC</code>响应队列，接收到 <code>RPC</code> 调用结果。</p>
<h2 id="4-Spring-Boot整合RibbitMQ"><a href="#4-Spring-Boot整合RibbitMQ" class="headerlink" title="4. Spring Boot整合RibbitMQ"></a>4. Spring Boot整合RibbitMQ</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>我们选择基于Spring-Rabbit去操作<code>RabbitMQ</code></p>
<p>源代码地址：<a href="https://github.com/spring-projects/spring-amqp" target="_blank" rel="noopener">https://github.com/spring-projects/spring-amqp</a></p>
<p>在我们之前创建得生产者模块中进行构建，添加如下依赖，注释掉之前原生的 <code>rabbitmq</code> 依赖</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!--原生rabbitMQ--&gt;</span>
    <span class="hljs-comment">&lt;!--&lt;dependency&gt;--&gt;</span>
    <span class="hljs-comment">&lt;!--&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;--&gt;</span>
    <span class="hljs-comment">&lt;!--&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;--&gt;</span>
    <span class="hljs-comment">&lt;!--&lt;version&gt;4.0.3&lt;/version&gt;&amp;lt;!&amp;ndash;此版本与spring boot 1.5.9版本匹配&amp;ndash;&amp;gt;--&gt;</span>
    <span class="hljs-comment">&lt;!--&lt;/dependency&gt;--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-comment">&lt;!--Springboot整合rabbitMQ启动器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1、配置application.yml</p>
<p>配置连接 <code>rabbitmq</code> 的参数</p>
<div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">44000</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">test-rabbitmq-producer</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>
    <span class="hljs-attr">virtualHost:</span> <span class="hljs-string">/</span></code></pre></div>

<p>创建 Springboot启动程序</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.rabbitmq;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRabbitmqApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(TestRabbitmqApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;
    &#125;
&#125;</code></pre></div>

<h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>构建 <code>RabbitmqConfig</code> ，用于配置交换机以及绑定队列</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.rabbitmq.config;

<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="hljs-string">"queue_inform_email"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_INFORM_SMS = <span class="hljs-string">"queue_inform_sms"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_TOPICS_INFORM = <span class="hljs-string">"exchange_topics_inform"</span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 交换机配置</span>
<span class="hljs-comment">     * ExchangeBuilder提供了fanout、direct、topic、header交换机类型的配置</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>(EXCHANGE_TOPICS_INFORM)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EXCHANGE_TOPICS_INFORM</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">//DURABLE(true) 持久化，消息队列重启后交换机仍然存在</span>
        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(<span class="hljs-keyword">true</span>).build();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 声明队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>(QUEUE_INFORM_SMS)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_INFORM_SMS</span><span class="hljs-params">()</span></span>&#123;
        Queue queue = <span class="hljs-keyword">new</span> Queue(QUEUE_INFORM_SMS);
        <span class="hljs-keyword">return</span> queue;
    &#125;

    <span class="hljs-meta">@Bean</span>(QUEUE_INFORM_EMAIL)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_INFORM_EMAIL</span><span class="hljs-params">()</span></span>&#123;
        Queue queue = <span class="hljs-keyword">new</span> Queue(QUEUE_INFORM_EMAIL);
        <span class="hljs-keyword">return</span> queue;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 绑定队列到交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 指定队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 指定交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_INFORM_SMS</span><span class="hljs-params">(@Qualifier(QUEUE_INFORM_SMS)</span> Queue queue,</span>
<span class="hljs-function">                                            @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange)</span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">"inform.#.sms.#"</span>).noargs();
    &#125;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_INFORM_EMAIL</span><span class="hljs-params">(@Qualifier(QUEUE_INFORM_EMAIL)</span> Queue queue,</span>
<span class="hljs-function">                                            @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange)</span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">"inform.#.email.#"</span>).noargs();
    &#125;
&#125;</code></pre></div>

<p>运行测试，成功生成5条消息到rabbitmq</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image23" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image23.png" srcset="/img/loading.gif" alt="img"></a></p>
<blockquote>
<p>运行生产端前删除原有的交换机</p>
</blockquote>
<h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>准备工作</p>
<ol>
<li>配置 <strong>4.1</strong> 给出的依赖包</li>
<li>复制 生产者端的 <code>RabbitmqConfig.java</code></li>
<li>创建消费端 <code>Springboot</code> 启动程序</li>
</ol>
<p>目录结构如下</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image24" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image24.png" srcset="/img/loading.gif" alt="消费端目录结构"></a></p>
<p>配置 <code>ReceiveHandler.java</code>，监听 rabbitMQ 的消息</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.test.rabbitmq.mq;

<span class="hljs-keyword">import</span> com.xuecheng.test.rabbitmq.config.RabbitmqConfig;
<span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;
<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.amqp.RabbitProperties;
<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveHandler</span> </span>&#123;

    <span class="hljs-comment">//监听email队列</span>
    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive_email</span><span class="hljs-params">(String msg, Message message, Channel channel)</span></span>&#123;
        System.out.println(<span class="hljs-string">"receive: "</span>+msg);
    &#125;

    <span class="hljs-comment">//监听sms队列</span>
    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitmqConfig.QUEUE_INFORM_SMS&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive_sms</span><span class="hljs-params">(String msg, Message message,Channel channel)</span></span>&#123;
        System.out.println(<span class="hljs-string">"receive: "</span>+msg);
    &#125;

&#125;</code></pre></div>

<p>启动消费者测试，可以看到刚才我们运行生产者所生产的消息，如下图</p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image25" target="_blank" rel="noopener"><img src="/2020/08/11/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday05/image25.png" srcset="/img/loading.gif" alt="消费者端接收到消息"></a></p>
<p><a href="https://qnoss.codeyee.com/20200704_5/image25" target="_blank" rel="noopener"></a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/">学成在线</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/RabbitMQ/">RabbitMQ</a>
                    
                      <a class="hover-with-bg" href="/tags/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/">SpringBoot整合RabbitMQ</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/08/12/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday06/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">学成在线day06：页面发布、课程管理</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/10/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday04/">
                        <span class="hidden-mobile">学成在线day04：页面静态化</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
  </div>
</div>
<!--

代码块js 用不到，fulid自带有，添加css样式即可实现
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 

<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>

-->




<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键字</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
	<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("06/20/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站勉强运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  </script>
</div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
	
  </div>
  

</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>



  
<script src="/js/custom.js"></script>




  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "学成在线day05：消息中间件RabbitMQ&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 65,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "<"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  
















<script type="text/javascript"
color="107,160,220" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
