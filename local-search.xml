<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学成在线day03</title>
    <link href="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/"/>
    <url>/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day03</code> 的内容</p><ul><li>使用 <code>Spring data</code> 提供的 <code>PageRequest</code> 模块进行分页查询的应用</li><li>使用 <code>Spring data</code> 提供 <code>MongoDB</code> 的dao接口进行前后端联调的 CRUD 操作</li><li>基于 <code>VUE.JS</code> 的前端模块化开发</li><li>使用统一的响应模型、状态码进行 <code>RESTful</code> 风格的API开发</li><li>熟悉使用 <code>Swagger</code> 进行接口文档的生成与测试</li><li>异常处理以及如何自定义异常，根据不同的异常自定义返回的消息格式。</li></ul><h1 id="一、自定义条件查询"><a href="#一、自定义条件查询" class="headerlink" title="一、自定义条件查询"></a>一、自定义条件查询</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>在页面输入查询条件，查询符合条件的页面信息。</p><p>查询条件如下：</p><p>站点Id：精确匹配</p><p>模板Id：精确匹配</p><p>页面别名：模糊匹配</p><h2 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2.服务端"></a>2.服务端</h2><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>使用 <code>CmsPageRepository</code> 中的 <code>findAll(Example&lt;S&gt; var1, Pageable var2)</code> 方法实现，无需定义。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>下边测试findAll方法实现自定义条件查询：</p><p>1、指定站点id、模板id作为查询条件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//自定义条件查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDiyFindAll</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//精确匹配条件值</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    cmsPage.setSiteId(<span class="hljs-string">"5a751fab6abb5044e0d19ea1"</span>);    cmsPage.setTemplateId(<span class="hljs-string">"5a925be7b00ffc4b3c1578b5"</span>);    <span class="hljs-comment">//条件匹配器,用于模糊匹配</span>    ExampleMatcher matching = ExampleMatcher.matching();    <span class="hljs-comment">//条件查询实例</span>    Example&lt;CmsPage&gt; example = Example.of(cmsPage, matching);    <span class="hljs-comment">//分页参数</span>    <span class="hljs-keyword">int</span> page = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> size = <span class="hljs-number">20</span>;    Pageable pageable = PageRequest.of(page,size);    <span class="hljs-comment">//调用dao</span>    Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(example, pageable);    List&lt;CmsPage&gt; content = all.getContent();    System.out.println(content);&#125;</code></pre></div><p>查询结果</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image1.png" srcset="/img/loading.gif" alt></p><p>在上面的代码基础上，增加 <code>ExampleMatcher</code> 实例的一些属性作为模糊查询的参数，增加的代码如下</p><div class="hljs"><pre><code class="hljs java">cmsPage.setPageAliase(<span class="hljs-string">"详细"</span>);<span class="hljs-comment">//条件匹配器,用于模糊匹配</span>ExampleMatcher matching = ExampleMatcher.matching()       .withMatcher(<span class="hljs-string">"pageAliase"</span>,ExampleMatcher.GenericPropertyMatchers.contains());</code></pre></div><p><code>.withMatcher</code> 的第一个参数表示要将哪个字段进行匹配，第二个则是要使用的匹配器；</p><p><code>ExampleMatcher.GenericPropertyMatchers</code> 有多个匹配器，这里我们用 <code>.contains()</code> 进行模糊匹配</p><p><a href="https://qnoss.codeyee.com/20200704_3/image2" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image2.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>CmsPageRepository cmsPageRepository;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page 页号</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> size 每页大小</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queryPageRequest 查询条件</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page,<span class="hljs-keyword">int</span> size,QueryPageRequest queryPageRequest)</span> </span>&#123;    <span class="hljs-comment">//判断条件对象是否为空</span>    <span class="hljs-keyword">if</span>(queryPageRequest == <span class="hljs-keyword">null</span>)&#123;        queryPageRequest = <span class="hljs-keyword">new</span> QueryPageRequest();    &#125;    <span class="hljs-comment">//匹配条件值</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    <span class="hljs-comment">//设置条件值</span>    <span class="hljs-comment">//站点ID</span>    <span class="hljs-keyword">if</span>(!StringUtil.isNullOrEmpty(queryPageRequest.getSiteId()))&#123;        cmsPage.setSiteId(queryPageRequest.getSiteId());    &#125;    <span class="hljs-comment">//模板ID</span>    <span class="hljs-keyword">if</span>(!StringUtil.isNullOrEmpty(queryPageRequest.getTemplateId()))&#123;        cmsPage.setTemplateId(queryPageRequest.getTemplateId());    &#125;    <span class="hljs-comment">//站点别名</span>    <span class="hljs-keyword">if</span>(!StringUtil.isNullOrEmpty(queryPageRequest.getPageAliase()))&#123;        cmsPage.setPageAliase(queryPageRequest.getPageAliase());    &#125;    <span class="hljs-comment">//条件匹配器，用于模糊查询</span>    ExampleMatcher exampleMatcher = ExampleMatcher.matching()            .withMatcher(<span class="hljs-string">"pageAliase"</span>, ExampleMatcher.GenericPropertyMatchers.contains());    <span class="hljs-comment">//条件查询实例</span>    Example&lt;CmsPage&gt; example = Example.of(cmsPage, exampleMatcher);    <span class="hljs-comment">//过滤条件</span>    <span class="hljs-keyword">if</span>(page &lt;= <span class="hljs-number">0</span>)&#123;        page = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;        size = <span class="hljs-number">10</span>;    &#125;    page = page - <span class="hljs-number">1</span>;    <span class="hljs-comment">//创建分页查询参数</span>    PageRequest pageable = PageRequest.of(page, size);    <span class="hljs-comment">//分页查询数据</span>    Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(example, pageable);    <span class="hljs-comment">//整理查询到的数据</span>    QueryResult queryResult = <span class="hljs-keyword">new</span> QueryResult();    queryResult.setList(all.getContent());    queryResult.setTotal(all.getTotalElements());    <span class="hljs-comment">//返回结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);&#125;</code></pre></div><p>Controller层无需修改</p><h3 id="使用SwaggerUI测试"><a href="#使用SwaggerUI测试" class="headerlink" title="使用SwaggerUI测试"></a>使用SwaggerUI测试</h3><p>参数</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image3.png" srcset="/img/loading.gif" alt="img"></p><p>查询结果</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image4.png" srcset="/img/loading.gif" alt="img"></p><p>从查询结果中我们可以看出，根据我们输入的条件，查询到了指定 <code>sizeId</code> 并且 <code>pageAliase</code> 包含预览的信息。</p><h2 id="3-前端"><a href="#3-前端" class="headerlink" title="3. 前端"></a>3. 前端</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>1、增加查询表单</p><blockquote><p>在el-table上方添加该表单</p></blockquote><div class="hljs"><pre><code class="hljs vue">&lt;!--查询表单--&gt;&lt;el-form :model&#x3D;&quot;params&quot;&gt;  &lt;el-select v-model&#x3D;&quot;params.siteId&quot; placeholder&#x3D;&quot;请选择站点&quot;&gt;    &lt;el-option    v-for&#x3D;&quot;item in siteList&quot;    :key&#x3D;&quot;item.siteId&quot;    :label&#x3D;&quot;item.siteName&quot;    :value&#x3D;&quot;item.siteId&quot;&gt;    &lt;&#x2F;el-option&gt;  &lt;&#x2F;el-select&gt;  页面别名: &lt;el-input v-model&#x3D;&quot;params.pageAliase&quot; style&#x3D;&quot;width: 100px&quot;&gt;&lt;&#x2F;el-input&gt;&lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;query&quot; size&#x3D;&quot;small&quot;&gt;查询&lt;&#x2F;el-button&gt;&lt;&#x2F;el-form&gt;</code></pre></div><p>2、新增数据模型对象</p><div class="hljs"><pre><code class="hljs js">data() &#123;  <span class="hljs-keyword">return</span> &#123;    siteList:[],<span class="hljs-comment">//站点列表</span>    list:[],    total:<span class="hljs-number">0</span>,    params:&#123;      siteId:<span class="hljs-string">''</span>,      pageAliase:<span class="hljs-string">''</span>,      page:<span class="hljs-number">1</span>,<span class="hljs-comment">//页码</span>      size:<span class="hljs-number">10</span><span class="hljs-comment">//每页显示个数</span>    &#125;  &#125;&#125;,</code></pre></div><p>3、在钩子方法中 获取 <code>siteList</code> 站点列表（这里暂时用静态数据代替）</p><div class="hljs"><pre><code class="hljs js">mounted() &#123;  <span class="hljs-comment">//默认查询页面</span>  <span class="hljs-keyword">this</span>.query()  <span class="hljs-comment">//初始化站点列表</span>  <span class="hljs-keyword">this</span>.siteList = [    &#123;      siteId:<span class="hljs-string">'5a751fab6abb5044e0d19ea1'</span>,      siteName:<span class="hljs-string">'门户主站'</span>    &#125;,    &#123;      siteId:<span class="hljs-string">'102'</span>,      siteName:<span class="hljs-string">'测试站'</span>    &#125;  ]&#125;,</code></pre></div><h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><p>1、向服务端传递查询条件，修改 cms.js，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//public是对axios的工具类封装，定义了http请求方法</span><span class="hljs-keyword">import</span> http from <span class="hljs-string">'./../../../base/api/public'</span>  <span class="hljs-comment">//ES6 导入</span><span class="hljs-keyword">import</span> querystring from <span class="hljs-string">"querystring"</span>let sysConfig = require(<span class="hljs-string">'@/../config/sysConfig'</span>)let apiUrl = sysConfig.xcApiUrlPre<span class="hljs-comment">//页面查询</span>export <span class="hljs-keyword">const</span> page_list = (page,size,params) =&gt; &#123;  <span class="hljs-comment">//将json对象转成key/value对</span>  let queryString = querystring.stringify(params);  <span class="hljs-comment">//定义方法，请求服务端查询接口</span>  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl + <span class="hljs-string">'/cms/page/list/'</span>+page+<span class="hljs-string">'/'</span>+ size +<span class="hljs-string">'?'</span> + queryString)&#125;</code></pre></div><p>2、页面调用api方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//查询</span>query:function () &#123;  <span class="hljs-comment">//调用服务端接口</span>  cmsApi.page_list(<span class="hljs-keyword">this</span>.params.page, <span class="hljs-keyword">this</span>.params.size, <span class="hljs-keyword">this</span>.params).then((res) =&gt;&#123;    console.log(res)    <span class="hljs-comment">//将res结果数据赋值给数据模型对象</span>    <span class="hljs-keyword">this</span>.list = res.queryResult.list    <span class="hljs-keyword">this</span>.total = res.queryResult.total  &#125;)&#125;</code></pre></div><p>3、测试</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image5.png" srcset="/img/loading.gif" alt="img"></p><h1 id="二、新增页面"><a href="#二、新增页面" class="headerlink" title="二、新增页面"></a>二、新增页面</h1><h2 id="1-准备工作，页面管理API"><a href="#1-准备工作，页面管理API" class="headerlink" title="1.准备工作，页面管理API"></a>1.准备工作，页面管理API</h2><p>在配置新增页面的功能之前，我们先配置一个接口，用于获取页面的信息</p><h3 id="Dao层-1"><a href="#Dao层-1" class="headerlink" title="Dao层"></a>Dao层</h3><p>CmsPageRepository</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 继承MongoDB自带的Repository</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  22:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsPage</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h3 id="定义查询模型"><a href="#定义查询模型" class="headerlink" title="定义查询模型"></a>定义查询模型</h3><p>QueryPageRequest</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.cms.request;<span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  21:13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPageRequest</span> </span>&#123;    <span class="hljs-comment">//接收页面查询的查询条件</span>    <span class="hljs-comment">//站点id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"站点id"</span>)    <span class="hljs-keyword">private</span> String siteId;    <span class="hljs-comment">//页面id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面id"</span>)    <span class="hljs-keyword">private</span> String pageId;    <span class="hljs-comment">//页面名称</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面名称"</span>)    <span class="hljs-keyword">private</span> String pageName;    <span class="hljs-comment">//别名</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"别名"</span>)    <span class="hljs-keyword">private</span> String pageAliase;    <span class="hljs-comment">//模板id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"模板id"</span>)    <span class="hljs-keyword">private</span> String templateId;    <span class="hljs-comment">//...</span>&#125;</code></pre></div><h3 id="定义响应模型"><a href="#定义响应模型" class="headerlink" title="定义响应模型"></a>定义响应模型</h3><p>CmsPageResult</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    CmsPage cmsPage;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmsPageResult</span><span class="hljs-params">(ResultCode resultCode,CmsPage cmsPage)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.cmsPage = cmsPage;    &#125;&#125;</code></pre></div><h3 id="Service层-1"><a href="#Service层-1" class="headerlink" title="Service层"></a>Service层</h3><p>PageService</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    &#125;</code></pre></div><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>定义页面相关操作的api</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  21:16</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"cms页面管理接口"</span>,description = <span class="hljs-string">"cms页面管理接口，提供页面的增，删，改，查"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-comment">//页面查询</span>    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"分页查询页面列表"</span>)    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"page"</span>,value = <span class="hljs-string">"页码"</span>,required = <span class="hljs-keyword">true</span>,paramType = <span class="hljs-string">"path"</span>,dataType = <span class="hljs-string">"int"</span>),            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"size"</span>,value = <span class="hljs-string">"每页记录数"</span>,required = <span class="hljs-keyword">true</span>,paramType = <span class="hljs-string">"path"</span>,dataType = <span class="hljs-string">"int"</span>)    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest)</span></span>; &#125;</code></pre></div><p>CmsPageController</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.cms.CmsPageControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.response.CmsPageResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.service.PageService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-06  22:04</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/cms/page"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PageService pageService;        <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list/&#123;page&#125;/&#123;size&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page, </span><span class="hljs-function">               @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest) </span>&#123;                   QueryResponseResult responseResult = pageService.findList(page, size, queryPageRequest);        <span class="hljs-keyword">return</span> responseResult;    &#125;</code></pre></div><p>测试</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image6.png" srcset="/img/loading.gif" alt="img"></p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image7.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-后端接口定义"><a href="#2-后端接口定义" class="headerlink" title="2.后端接口定义"></a>2.后端接口定义</h2><h3 id="1、定义响应模型"><a href="#1、定义响应模型" class="headerlink" title="1、定义响应模型"></a>1、定义响应模型</h3><blockquote><p>用于接口的响应规范，继承于项目中的ResponseResult</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageResult</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseResult</span> </span>&#123;    CmsPage cmsPage;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CmsPageResult</span><span class="hljs-params">(ResultCode resultCode,CmsPage cmsPage)</span> </span>&#123;        <span class="hljs-keyword">super</span>(resultCode);        <span class="hljs-keyword">this</span>.cmsPage = cmsPage;&#125;&#125;</code></pre></div><h3 id="2、定义添加Api"><a href="#2、定义添加Api" class="headerlink" title="2、定义添加Api"></a>2、定义添加Api</h3><p>在 <code>CmsPageControllerApi</code> 中新增 <code>addCmsPage</code> 接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加页面数据</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"添加页面数据"</span>)<span class="hljs-meta">@ApiImplicitParams</span>(&#123;        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"cmsPage"</span>,value = <span class="hljs-string">"请提交json形式的页面数据"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"CmsPage"</span>,dataType=<span class="hljs-string">"CmsPage"</span>),&#125;)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span></span>;</code></pre></div><h2 id="3-服务端开发"><a href="#3-服务端开发" class="headerlink" title="3. 服务端开发"></a>3. 服务端开发</h2><h3 id="1、页面唯一值索引"><a href="#1、页面唯一值索引" class="headerlink" title="1、页面唯一值索引"></a>1、页面唯一值索引</h3><blockquote><p>为了保证站点的唯一性，所以我们要根据 sizeId、pageName、pageWebPath 这三个字段来决定站点的数据是否唯一。</p></blockquote><p>右键 <code>cms_page</code> 集合，选择 <code>Add Index</code> 添加一个索引</p><p><a href="https://qnoss.codeyee.com/20200704_3/image8" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image8.png" srcset="/img/loading.gif" alt="img"></a></p><p>根据下图所示，点击 <code>Add Field</code> 按钮，选择 sizeId、pageName、pageWebPath 这三个字段，然后点击添加，选择第三步所示的 <code>Unique</code>，最后点击右边的 <code>Create Index</code> 创建索引。</p><p><a href="https://qnoss.codeyee.com/20200704_3/image9" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image9.png" srcset="/img/loading.gif" alt="img"></a></p><p>创建成功后</p><p><a href="https://qnoss.codeyee.com/20200704_3/image10" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image10.png" srcset="/img/loading.gif" alt="img"></a></p><h3 id="2、Dao层"><a href="#2、Dao层" class="headerlink" title="2、Dao层"></a>2、Dao层</h3><p>1、添加根据页面名称、站点Id、页面webpath查询页面方法，此方法用于校验页面是否存在</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据站点id、站点名称、站点路径来查询站点信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> siteId</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageName</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageWebPath</span><span class="hljs-comment"> */</span><span class="hljs-function">CmsPage <span class="hljs-title">findBySiteIdAndPageNameAndPageWebPath</span><span class="hljs-params">(String siteId, String pageName, String pageWebPath)</span></span>;</code></pre></div><p>2、使用 CmsPageRepository提供的save方法 。</p><h3 id="3、Service层"><a href="#3、Service层" class="headerlink" title="3、Service层"></a>3、Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加页面数据</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span></span>&#123;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage cmsPage1 = cmsPageRepository.findBySiteIdAndPageNameAndPageWebPath(cmsPage.getSiteId(), cmsPage.getPageName(), cmsPage.getPageWebPath());    <span class="hljs-keyword">if</span>(cmsPage1 == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//站点id由mongoDB自动生成，防止前端传值</span>        cmsPage.setPageId(<span class="hljs-keyword">null</span>);        CmsPage save = cmsPageRepository.save(cmsPage);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS,save);    &#125;    <span class="hljs-comment">//添加失败</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL,cmsPage);&#125;</code></pre></div><h3 id="4、Controller层"><a href="#4、Controller层" class="headerlink" title="4、Controller层"></a>4、Controller层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/add"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(@RequestBody CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-keyword">return</span> pageService.addCmsPage(cmsPage);&#125;</code></pre></div><h3 id="5、接口测试"><a href="#5、接口测试" class="headerlink" title="5、接口测试"></a>5、接口测试</h3><p>我们在 <code>swagger</code> 自动生成的文档接口中进行测试</p><p><a href="https://qnoss.codeyee.com/20200704_3/image11" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image11.png" srcset="/img/loading.gif" alt="img"></a></p><p>第一次添加，添加成功</p><p><a href="https://qnoss.codeyee.com/20200704_3/image12" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image12.png" srcset="/img/loading.gif" alt="img"></a></p><p>第二次添加重复的内容，由于唯一性的效验，返回添加失败</p><p><a href="https://qnoss.codeyee.com/20200704_3/image13" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image13.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-前端开发"><a href="#4-前端开发" class="headerlink" title="4. 前端开发"></a>4. 前端开发</h2><h3 id="构建新增页面"><a href="#构建新增页面" class="headerlink" title="构建新增页面"></a>构建新增页面</h3><h4 id="1、页面创建"><a href="#1、页面创建" class="headerlink" title="1、页面创建"></a>1、页面创建</h4><p>使用Element-UI的form组件编写添加表单内容，页面效果如下：</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image14.png" srcset="/img/loading.gif" alt="img"></p><p><strong>1）创建页面</strong></p><p>创建page_add.vue页面</p><p><strong>2）配置路由</strong></p><p>在cms模块的路由文件中配置“添加页面”的路由：</p><div class="hljs"><pre><code class="hljs vue">&#123;path:&#39;&#x2F;cms&#x2F;page&#x2F;add&#39;,name:&#39;新增页面&#39;,component: page_add,hidden:true&#125;</code></pre></div><p>注意：由于 “添加页面” 不需要显示为一个菜单，这里 <code>hidden</code> 设置为 <code>true</code> 隐藏菜单。</p><p>测试，在浏览器地址栏输入<a href="http://localhost:11000/#/cms/page/add" target="_blank" rel="noopener">http://localhost:11000/#/cms/page/add</a></p><p><strong>3）“添加页面” 的按钮</strong></p><p>实际情况是用户进入页面查询列表，点击“新增页面”按钮进入新增页面窗口。</p><p>在查询按钮的旁边添加：</p><div class="hljs"><pre><code class="hljs vue">&lt;router‐link class&#x3D;&quot;mui‐tab‐item&quot; :to&#x3D;&quot;&#123;path:&#39;&#x2F;cms&#x2F;page&#x2F;add&#x2F;&#39;&#125;&quot;&gt;&lt;el‐button type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot;&gt;新增页面&lt;&#x2F;el‐button&gt;&lt;&#x2F;router‐link&gt;</code></pre></div><blockquote><p>router-link是vue提供的路由功能，用于在页面生成路由链接，最终在html渲染后就是&lt;a标签。<br>to：目标路由地址</p></blockquote><p><strong>4）完善页面内容</strong></p><div class="hljs"><pre><code class="hljs vue">&lt;el-form :model&#x3D;&quot;pageForm&quot; label-width&#x3D;&quot;80px&quot;&gt;  &lt;el-form-item label&#x3D;&quot;所属站点&quot; prop&#x3D;&quot;siteId&quot;&gt;    &lt;el-select v-model&#x3D;&quot;pageForm.siteId&quot; placeholder&#x3D;&quot;请选择站点&quot;&gt;      &lt;el-option        v-for&#x3D;&quot;item in siteList&quot;        :key&#x3D;&quot;item.siteId&quot;        :label&#x3D;&quot;item.siteName&quot;        :value&#x3D;&quot;item.siteId&quot;&gt;      &lt;&#x2F;el-option&gt;    &lt;&#x2F;el-select&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;选择模版&quot; prop&#x3D;&quot;templateId&quot;&gt;    &lt;el-select v-model&#x3D;&quot;pageForm.templateId&quot; placeholder&#x3D;&quot;请选择&quot;&gt;      &lt;el-option        v-for&#x3D;&quot;item in templateList&quot;        :key&#x3D;&quot;item.templateId&quot;        :label&#x3D;&quot;item.templateName&quot;        :value&#x3D;&quot;item.templateId&quot;&gt;      &lt;&#x2F;el-option&gt;    &lt;&#x2F;el-select&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;页面名称&quot; prop&#x3D;&quot;pageName&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pageName&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;别名&quot; prop&#x3D;&quot;pageAliase&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pageAliase&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;访问路径&quot; prop&#x3D;&quot;pageWebPath&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pageWebPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;物理路径&quot; prop&#x3D;&quot;pagePhysicalPath&quot;&gt;    &lt;el-input v-model&#x3D;&quot;pageForm.pagePhysicalPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;类型&quot;&gt;    &lt;el-radio-group v-model&#x3D;&quot;pageForm.pageType&quot;&gt;      &lt;el-radio label&#x3D;&quot;0&quot;&gt;静态&lt;&#x2F;el-radio&gt;      &lt;el-radio label&#x3D;&quot;1&quot;&gt;动态&lt;&#x2F;el-radio&gt;    &lt;&#x2F;el-radio-group&gt;  &lt;&#x2F;el-form-item&gt;  &lt;el-form-item label&#x3D;&quot;创建时间&quot;&gt;    &lt;el-date-picker type&#x3D;&quot;datetime&quot; placeholder&#x3D;&quot;创建时间&quot; v-model&#x3D;&quot;pageForm.pageCreateTime&quot;&gt;    &lt;&#x2F;el-date-picker&gt;  &lt;&#x2F;el-form-item&gt;&lt;&#x2F;el-form&gt;&lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;  &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addSubmit&quot;&gt;提交&lt;&#x2F;el-button&gt;&lt;&#x2F;div&gt;</code></pre></div><p>Form Attributes说明：</p><ul><li>model 表单数据对象</li><li>rules 表单验证规则</li></ul><p>Form-Item Attributes说明：</p><ul><li>prop 表单域 model 字段，在使用 validate、resetFields 方法的情况下，该属性是必填的</li><li>label 标签文本</li></ul><p>详情属性及事件参考 <a href="http://element.eleme.io/#/zh-CN/component/form" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/form</a></p><p><strong>5）数据对象</strong></p><div class="hljs"><pre><code class="hljs js">  <span class="hljs-comment">//站点列表</span>    siteList: [],    <span class="hljs-comment">//模版列表</span>    templateList: [],    <span class="hljs-comment">//新增界面数据</span>    pageForm: &#123;      siteId: <span class="hljs-string">''</span>,      templateId: <span class="hljs-string">''</span>,      pageName: <span class="hljs-string">''</span>,      pageAliase: <span class="hljs-string">''</span>,      pageWebPath: <span class="hljs-string">''</span>,      pageParameter: <span class="hljs-string">''</span>,      pagePhysicalPath: <span class="hljs-string">''</span>,      pageType: <span class="hljs-string">'0'</span>,  <span class="hljs-comment">//默认选中0</span>      pageCreateTime: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()    &#125;  &#125;&#125;,methods: &#123;  addSubmit() &#123;    alert(<span class="hljs-string">"提交"</span>)  &#125;,&#125;</code></pre></div><p><strong>6）站点及模板数据</strong></p><p>定义请求api</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//获取所有站点信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> site_list = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestGet(apiUrl + <span class="hljs-string">"/cms/site/list"</span>)&#125;<span class="hljs-comment">//获取所有模板信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> template_list = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestGet(apiUrl + <span class="hljs-string">"/cms/template/list"</span>)&#125;</code></pre></div><blockquote><p>在created钩子中定义，原讲义内使用的是静态数据</p></blockquote><div class="hljs"><pre><code class="hljs js">created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//初始化站点数据</span>    cmsApi.site_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"站点数据"</span>,res)            <span class="hljs-comment">//赋值给站点信息列表</span>            <span class="hljs-keyword">this</span>.siteList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取站点信息时发生了错误"</span>, res)        &#125;    &#125;)    <span class="hljs-comment">//初始化模板数据</span>    cmsApi.template_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"模板数据"</span>,res)            <span class="hljs-comment">//赋值给模板列表</span>            <span class="hljs-keyword">this</span>.templateList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取模板信息时发生了错误"</span>, res)        &#125;    &#125;)&#125;,</code></pre></div><p><strong>7）测试预览</strong></p><p><a href="https://qnoss.codeyee.com/20200704_3/image15" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image15.png" srcset="/img/loading.gif" alt="img"></a></p><h4 id="2、添加返回"><a href="#2、添加返回" class="headerlink" title="2、添加返回"></a>2、添加返回</h4><blockquote><p>进入新增页面后只能通过菜单再次进入页面列表，可以在新增页面添加“返回”按钮，点击返回按钮返回到页面列表。</p></blockquote><ol><li>新增页面按钮带上参数</li></ol><div class="hljs"><pre><code class="hljs vue">&lt;router-link class&#x3D;&quot;mui-tab-item&quot;             :to&#x3D;&quot;&#123;path:&#39;&#x2F;cms&#x2F;page&#x2F;add&#x2F;&#39;, query:&#123; page:this.params.page,siteId:this.params.siteId &#125;&#125;&quot;&gt;  &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;small&quot;&gt;新增页面&lt;&#x2F;el-button&gt;&lt;&#x2F;router-link&gt;</code></pre></div><p>说明：query表示在路由url上带上参数</p><p>2）定义返回方法</p><p>在page_add.vue上定义返回按钮</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;go_back&quot; &gt;返回&lt;&#x2F;el‐button&gt;</code></pre></div><p>在page_add.vue上定义返回方法</p><div class="hljs"><pre><code class="hljs js">go_back()&#123;    <span class="hljs-keyword">this</span>.$router.push(&#123;        path: <span class="hljs-string">'/cms/page/list'</span>, <span class="hljs-attr">query</span>: &#123;        page: <span class="hljs-keyword">this</span>.$route.query.page,        siteId:<span class="hljs-keyword">this</span>.$route.query.siteId    &#125;    &#125;)&#125;</code></pre></div><p>说明：this.$route.query 表示取出路由上的参数列表，有两个取路由参数的方法：</p><blockquote><p>a、通过在路由上添加 key/value 串使用 <code>this.$route.query</code> 来取参数，例如：<code>/router1?id=123</code> , <code>/router1?id=456</code> 可以通过 <code>this.$route.query.id</code> 获取参数id的值。</p><p>b、通过将参数作为路由一部分进行传参数使用 <code>this.$route.params</code> 来获取，例如：定义的路由为 <code>/router1/:id</code> ，请求 <code>/router1/123</code> 时可以通过 <code>this.$route.params.id</code> 来获取，此种情况用 <code>this.$route.query.id</code> 是拿不到的。</p></blockquote><p>3）查询列表支持回显</p><p>进入查询列表，从url中获取页码和站点id并赋值给数据模型对象，从而实现页面回显。</p><p>url例子：<a href="http://localhost:12000/#/cms/page/list?page=2&amp;siteId=5a751fab6abb5044e0d19ea1" target="_blank" rel="noopener">http://localhost:12000/#/cms/page/list?page=2&amp;siteId=5a751fab6abb5044e0d19ea1</a></p><div class="hljs"><pre><code class="hljs js">created() &#123;    <span class="hljs-comment">//从路由上获取参数</span>    <span class="hljs-keyword">this</span>.params.page = <span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.$route.query.page||<span class="hljs-number">1</span>);    <span class="hljs-keyword">this</span>.params.siteId = <span class="hljs-keyword">this</span>.$route.query.siteId||<span class="hljs-string">''</span>;    .....&#125;</code></pre></div><blockquote><p>小技巧：使用 ||返回第一个有效值</p></blockquote><h4 id="1-3、表单验证"><a href="#1-3、表单验证" class="headerlink" title="1.3、表单验证"></a>1.3、表单验证</h4><p>1）配置校验规则</p><p>Element-UI的Form组件提供表单校验的方法：</p><p>在form属性上配置rules（表单验证规则）</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐form :model&#x3D;&quot;pageForm&quot; :rules&#x3D;&quot;pageFormRules&quot; label‐width&#x3D;&quot;80px&quot; &gt;</code></pre></div><p>在数据模型中配置校验规则：</p><div class="hljs"><pre><code class="hljs js">data() &#123;    <span class="hljs-keyword">return</span> &#123;        pageFormRules: &#123;            siteId:[                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择站点'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            templateId:[                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择模版'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pageName: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入页面名称'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pageAliase: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入页面别名'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pageWebPath: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入访问路径'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ],            pagePhysicalPath: [                &#123;<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入物理路径'</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>&#125;            ]        &#125;,    &#125;&#125;</code></pre></div><p>更多的校验规则参考 <a href="http://element.eleme.io/#/zh-CN/component/form" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/form</a> 中“表单验证”的例子</p><p>2）点击提交按钮触发校验</p><p>在form表单上添加 ref属性（ref=”pageForm”）在校验时引用此表单对象</p><div class="hljs"><pre><code class="hljs vue">&lt;el‐form :model&#x3D;&quot;pageForm&quot; :rules&#x3D;&quot;pageFormRules&quot; label‐width&#x3D;&quot;80px&quot; ref&#x3D;&quot;pageForm&quot;&gt;</code></pre></div><p>在提交表单时执行校验</p><div class="hljs"><pre><code class="hljs js">addSubmit() &#123;    <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (valid) &#123;            alert(<span class="hljs-string">'提交'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            alert(<span class="hljs-string">'校验失败'</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;)&#125;,</code></pre></div><p>测试</p><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image16.png" srcset="/img/loading.gif" alt="img"></p><h3 id="API调用-1"><a href="#API调用-1" class="headerlink" title="API调用"></a>API调用</h3><h4 id="1、在cms-js中定义page-add方法"><a href="#1、在cms-js中定义page-add方法" class="headerlink" title="1、在cms.js中定义page_add方法"></a>1、在cms.js中定义page_add方法</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_add = <span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestPost(apiUrl + <span class="hljs-string">"/cms/page/add"</span>,params)&#125;</code></pre></div><h4 id="2、添加事件"><a href="#2、添加事件" class="headerlink" title="2、添加事件"></a>2、添加事件</h4><p>完整的代码如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//提交表单</span>addSubmit()&#123;  <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (valid) &#123;      <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        cmsApi.page_add(<span class="hljs-keyword">this</span>.pageForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(res);          <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-keyword">this</span>.$message(&#123;              message: <span class="hljs-string">'提交成功'</span>,              type: <span class="hljs-string">'success'</span>          &#125;);          <span class="hljs-keyword">this</span>.$refs[<span class="hljs-string">'pageForm'</span>].resetFields();          &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);          &#125;        &#125;);      &#125;);    &#125;  &#125;)&#125;,</code></pre></div><p>本功能使用到两个UI组件：</p><ul><li>使用 <code>element-ui</code> 的 <code>message-box</code> 组件弹出确认提交窗口（<a href="http://element.eleme.io/#/zhCN/component/message-box%EF%BC%89" target="_blank" rel="noopener">http://element.eleme.io/#/zhCN/component/message-box）</a></li><li>使用 <code>message</code>组件提示操作结果 （<a href="http://element.eleme.io/#/zh-CN/component/message%EF%BC%89" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/message）</a></li></ul><h4 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h4><p><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image17.gif" srcset="/img/loading.gif" alt="img"></p><h1 id="三、修改页面"><a href="#三、修改页面" class="headerlink" title="三、修改页面"></a>三、修改页面</h1><p>修改页面用户操作流程：</p><p>1、用户进入修改页面，在页面上显示了修改页面的信息</p><p>2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败”</p><h2 id="1-后端接口定义"><a href="#1-后端接口定义" class="headerlink" title="1. 后端接口定义"></a>1. 后端接口定义</h2><p>修改页面需要定义的API如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//根据页面id查询页面信息</span>    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"根据页面id查询页面信息"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPage <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span></span>;    <span class="hljs-comment">//修改页面</span>    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"修改页面"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">edit</span><span class="hljs-params">(String id,CmsPage cmsPage)</span></span>;</code></pre></div><blockquote><p>我们从前面定义的 findList 用的是 <code>QueryResponseResult</code> 作为响应模型，但是这里我们定义的 <code>CmsPageResult</code> 作为响应模型，两者的区别是什么？</p><p>我个人的理解是，<code>findList</code> 是分页查询并且返回了多个对象的信息，而 <code>findById</code> 则是查询单个对象的信息，所以 <code>CmsPageResult</code> 作为操作或查询单个对象时的响应模型，而 <code>QueryResponseResult</code> 则作为操作多个对象时的响应模型。</p></blockquote><p>说明：提交数据使用post、put都可以，只是根据http方法的规范，put方法是对服务器指定资源进行修改，所以这里使用put方法对页面修改进行修改。</p><h2 id="2-服务端开发"><a href="#2-服务端开发" class="headerlink" title="2. 服务端开发"></a>2. 服务端开发</h2><h3 id="Dao层-2"><a href="#Dao层-2" class="headerlink" title="Dao层"></a>Dao层</h3><p>使用 Spring Data提供的findById方法完成根据主键查询 。<br>使用 Spring Data提供的save方法完成数据保存 。</p><h3 id="Service层-2"><a href="#Service层-2" class="headerlink" title="Service层"></a>Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//根据页面id查询页面</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPage <span class="hljs-title">findById</span><span class="hljs-params">(String id)</span> </span>&#123;        Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(id);        <span class="hljs-keyword">if</span> (optional.isPresent())&#123;            CmsPage cmsPage = optional.get();            <span class="hljs-keyword">return</span> cmsPage;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//修改页面</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">edit</span><span class="hljs-params">(String id, CmsPage cmsPage)</span> </span>&#123;        <span class="hljs-comment">//根据id从数据查询页面信息</span>        CmsPage updateCmsPage = <span class="hljs-keyword">this</span>.findById(id);        <span class="hljs-keyword">if</span> (updateCmsPage != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//设置要修改的数据</span>            updateCmsPage.setTemplateId(cmsPage.getTemplateId());            updateCmsPage.setSiteId(cmsPage.getSiteId());            updateCmsPage.setPageAliase(cmsPage.getPageAliase());            updateCmsPage.setPageName(cmsPage.getPageName());            updateCmsPage.setPageWebPath(cmsPage.getPageWebPath());            updateCmsPage.setPagePhysicalPath(cmsPage.getPagePhysicalPath());            <span class="hljs-comment">//提交修改</span>            cmsPageRepository.save(updateCmsPage);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS,updateCmsPage);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL,<span class="hljs-keyword">null</span>);    &#125;</code></pre></div><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/get/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPage <span class="hljs-title">findById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;        <span class="hljs-keyword">return</span> pageService.findById(id);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/edit/&#123;id&#125;"</span>)<span class="hljs-comment">//put表示更新</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">edit</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id,@RequestBody CmsPage cmsPage) </span>&#123;        <span class="hljs-keyword">return</span> pageService.edit(id,cmsPage);    &#125;</code></pre></div><h2 id="3-修改：前端开发"><a href="#3-修改：前端开发" class="headerlink" title="3. 修改：前端开发"></a>3. 修改：前端开发</h2><h3 id="页面处理流程"><a href="#页面处理流程" class="headerlink" title="页面处理流程"></a>页面处理流程</h3><blockquote><p>可以参考新增的逻辑</p></blockquote><ol><li>进入页面，通过钩子方法请求服务端获取页面信息，并赋值给数据模型对象。</li><li>页面信息通过数据绑定在表单中显示。</li><li>用户修改信息点击 “提交” 请求服务端修改页面信息接口。</li></ol><h3 id="前端HTTP-API构建"><a href="#前端HTTP-API构建" class="headerlink" title="前端HTTP API构建"></a>前端HTTP API构建</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//查询单个页面信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_query = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestPut(apiUrl + <span class="hljs-string">"/cms/page/get/"</span> + id)&#125;<span class="hljs-comment">//更新接口</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_update = <span class="hljs-function">(<span class="hljs-params">id,params</span>) =&gt;</span>&#123;  <span class="hljs-keyword">return</span> http.requestPut(apiUrl + <span class="hljs-string">"/cms/page/edit/"</span> + id,params)&#125;<span class="hljs-comment">//获取站点和模板列表</span></code></pre></div><h3 id="添加页面路由"><a href="#添加页面路由" class="headerlink" title="添加页面路由"></a>添加页面路由</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> page_update <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/cms/page/page_update.vue'</span>;<span class="hljs-comment">//子菜单</span>children: [    &#123;        path: <span class="hljs-string">'/cms/page/edit/:pageId'</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">"编辑页面信息"</span>,<span class="hljs-attr">component</span>: page_edit, <span class="hljs-attr">hidden</span>:<span class="hljs-literal">true</span>    &#125;,]</code></pre></div><p>path中的 <code>:pageId</code> 表示在路由url中定义了一个pageId变量</p><h3 id="构建前端页面"><a href="#构建前端页面" class="headerlink" title="构建前端页面"></a>构建前端页面</h3><p>在 <code>page_list</code> 页面新增编辑按钮</p><div class="hljs"><pre><code class="hljs vue">&lt;el-table-column label&#x3D;&quot;编辑&quot; width&#x3D;&quot;75&quot; fixed&#x3D;&quot;right&quot;&gt;    &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;&lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;info&quot; @click&#x3D;&quot;toEdit(scope.row.pageId)&quot;&gt;编辑&lt;&#x2F;el-button&gt;    &lt;&#x2F;template&gt;&lt;&#x2F;el-table-column&gt;</code></pre></div><p>增加跳转edit页面的函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//跳转至编辑页面</span>toEdit(pageId)&#123;  <span class="hljs-keyword">this</span>.$router.push(&#123;    path:<span class="hljs-string">"/cms/page/edit/"</span> + pageId,    query:&#123;      page:<span class="hljs-keyword">this</span>.params.page,      siteId:<span class="hljs-keyword">this</span>.params.siteId    &#125;  &#125;)&#125;,</code></pre></div><p>使用 <code>scope</code> 获取当前行数据中的 <code>pageId</code> 传入 toEdit 函数进行页面跳转</p><p>完成<code>page_edit.vue</code> 页面的基本构造</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-form :model&#x3D;&quot;pageForm&quot; label-width&#x3D;&quot;80px&quot; :rules&#x3D;&quot;pageFormRules&quot; ref&#x3D;&quot;pageForm&quot;&gt;      &lt;el-form-item label&#x3D;&quot;所属站点&quot; prop&#x3D;&quot;siteId&quot;&gt;        &lt;el-select v-model&#x3D;&quot;pageForm.siteId&quot; placeholder&#x3D;&quot;请选择站点&quot;&gt;          &lt;el-option            v-for&#x3D;&quot;item in siteList&quot;            :key&#x3D;&quot;item.siteId&quot;            :label&#x3D;&quot;item.siteName&quot;            :value&#x3D;&quot;item.siteId&quot;&gt;          &lt;&#x2F;el-option&gt;        &lt;&#x2F;el-select&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;选择模版&quot; prop&#x3D;&quot;templateId&quot;&gt;        &lt;el-select v-model&#x3D;&quot;pageForm.templateId&quot; placeholder&#x3D;&quot;请选择&quot;&gt;          &lt;el-option            v-for&#x3D;&quot;item in templateList&quot;            :key&#x3D;&quot;item.templateId&quot;            :label&#x3D;&quot;item.templateName&quot;            :value&#x3D;&quot;item.templateId&quot;&gt;          &lt;&#x2F;el-option&gt;        &lt;&#x2F;el-select&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;页面名称&quot; prop&#x3D;&quot;pageName&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pageName&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;别名&quot; prop&#x3D;&quot;pageAliase&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pageAliase&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;访问路径&quot; prop&#x3D;&quot;pageWebPath&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pageWebPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;物理路径&quot; prop&#x3D;&quot;pagePhysicalPath&quot;&gt;        &lt;el-input v-model&#x3D;&quot;pageForm.pagePhysicalPath&quot; auto-complete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;类型&quot;&gt;        &lt;el-radio-group v-model&#x3D;&quot;pageForm.pageType&quot;&gt;          &lt;el-radio class&#x3D;&quot;radio&quot; label&#x3D;&quot;0&quot; &gt;静态&lt;&#x2F;el-radio&gt;          &lt;el-radio class&#x3D;&quot;radio&quot; label&#x3D;&quot;1&quot; &gt;动态&lt;&#x2F;el-radio&gt;        &lt;&#x2F;el-radio-group&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-form-item label&#x3D;&quot;创建时间&quot;&gt;        &lt;el-date-picker type&#x3D;&quot;datetime&quot; placeholder&#x3D;&quot;创建时间&quot; v-model&#x3D;&quot;pageForm.pageCreateTime&quot;&gt;        &lt;&#x2F;el-date-picker&gt;      &lt;&#x2F;el-form-item&gt;    &lt;&#x2F;el-form&gt;    &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;      &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;addSubmit&quot;&gt;提交&lt;&#x2F;el-button&gt;      &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;goBack&quot;&gt;返回&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import * as cmsApi from &#39;..&#x2F;api&#x2F;cms&#39;  export default &#123;    created: function () &#123;    &#125;,    mounted() &#123;    &#125;,    data() &#123;      return &#123;        pageFormRules: &#123;          siteId: [            &#123;required: true, message: &#39;请选择站点&#39;, trigger: &#39;blur&#39;&#125;          ],          templateId: [            &#123;required: true, message: &#39;请选择模版&#39;, trigger: &#39;blur&#39;&#125;          ],          pageName: [            &#123;required: true, message: &#39;请输入页面名称&#39;, trigger: &#39;blur&#39;&#125;          ],          pageAliase: [            &#123;required: true, message: &#39;请输入页面别名&#39;, trigger: &#39;blur&#39;&#125;          ],          pageWebPath: [            &#123;required: true, message: &#39;请输入访问路径&#39;, trigger: &#39;blur&#39;&#125;          ],          pagePhysicalPath: [            &#123;required: true, message: &#39;请输入物理路径&#39;, trigger: &#39;blur&#39;&#125;          ]        &#125;,        &#x2F;&#x2F;站点列表        siteList: [],        &#x2F;&#x2F;模版列表        templateList: [],        &#x2F;&#x2F;新增界面数据        pageForm: &#123;          siteId: &#39;&#39;,          templateId: &#39;&#39;,          pageName: &#39;&#39;,          pageAliase: &#39;&#39;,          pageWebPath: &#39;&#39;,          pageParameter: &#39;&#39;,          pagePhysicalPath: &#39;&#39;,          pageType: &#39;&#39;,          pageCreateTime: new Date()        &#125;      &#125;    &#125;,    methods: &#123;      &#x2F;&#x2F;返回上一页      goBack() &#123;        this.$router.push(&#123;          path: &quot;&#x2F;cms&#x2F;page&#x2F;list&quot;,          query: &#123;            page: this.$route.query.page,            siteId: this.$route.query.siteId          &#125;        &#125;)      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><h4 id="1、页面初始化"><a href="#1、页面初始化" class="headerlink" title="1、页面初始化"></a>1、页面初始化</h4><p>在钩子函数 <code>created</code> 中进行一些数据的初始化请求，例如站点、模板的信息，用于下拉框的选择，以及在打开编辑页面之前，用户需要获取当前编辑的页面原有的数据，所以我们需要使用 <code>page_list</code> 页面通过的 <code>pageId</code> 来获取当前编辑的页面的数据。</p><div class="hljs"><pre><code class="hljs js">created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-comment">//初始化站点数据</span>    cmsApi.site_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"站点数据"</span>, res)            <span class="hljs-keyword">this</span>.siteList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取站点信息时发生了错误"</span>, res)        &#125;    &#125;)    <span class="hljs-comment">//初始化模板数据</span>    cmsApi.template_list().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"模板数据"</span>, res)            <span class="hljs-keyword">this</span>.templateList = res.queryResult.list        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获取模板信息时发生了错误"</span>, res)        &#125;    &#125;)    <span class="hljs-comment">//初始化页面的数据</span>    cmsApi.page_query(<span class="hljs-keyword">this</span>.$route.params.pageId).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;        <span class="hljs-keyword">if</span>(res.success)&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"初始化页面数据"</span>,res.cmsPage)            <span class="hljs-keyword">this</span>.pageForm = res.cmsPage        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"初始化页面数据失败"</span>,res)        &#125;    &#125;)&#125;,</code></pre></div><p>我们在页面路由定义了一个:pageId的参数，所以在初始化页面的数据部分从 <code>this.$route.params</code> 取出了<code>pageId</code></p><h4 id="2、提交更新表单"><a href="#2、提交更新表单" class="headerlink" title="2、提交更新表单"></a>2、提交更新表单</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//提交表单</span>addSubmit() &#123;    <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (valid) &#123;            <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交修改吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                cmsApi.page_edit(<span class="hljs-keyword">this</span>.$route.params.pageId,<span class="hljs-keyword">this</span>.pageForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (res.success) &#123;                        <span class="hljs-keyword">this</span>.$message(&#123;                            message: <span class="hljs-string">'修改提交成功'</span>,                            type: <span class="hljs-string">'success'</span>                        &#125;);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);                    &#125;                &#125;);            &#125;);        &#125;    &#125;)&#125;,</code></pre></div><h1 id="四、删除页面"><a href="#四、删除页面" class="headerlink" title="四、删除页面"></a>四、删除页面</h1><p>修改页面用户操作流程：</p><p>1、用户进入修改页面，在页面上显示了修改页面的信息</p><p>2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败”</p><h2 id="1-后端接口定义-1"><a href="#1-后端接口定义-1" class="headerlink" title="1. 后端接口定义"></a>1. 后端接口定义</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除接口</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 页面id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"删除页面"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">delete</span><span class="hljs-params">(String id)</span></span>;</code></pre></div><h2 id="2-服务端开发-1"><a href="#2-服务端开发-1" class="headerlink" title="2. 服务端开发"></a>2. 服务端开发</h2><h3 id="Dao层-3"><a href="#Dao层-3" class="headerlink" title="Dao层"></a>Dao层</h3><p><code>dao</code>层 使用 <code>MongoDB</code> 提供的dao接口来实现</p><h3 id="Service层-3"><a href="#Service层-3" class="headerlink" title="Service层"></a>Service层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据id删除</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">deleteCmsPage</span><span class="hljs-params">(String id)</span></span>&#123;    <span class="hljs-comment">//检索该页面id是否存在</span>    Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(id);    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;        <span class="hljs-comment">//删除并返回结果</span>        cmsPageRepository.deleteById(id);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.FAIL);&#125;</code></pre></div><h3 id="Controller层-2"><a href="#Controller层-2" class="headerlink" title="Controller层"></a>Controller层</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除页面</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id 页面id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/delete/&#123;id&#125;"</span>)<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">delete</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String id) </span>&#123;    <span class="hljs-keyword">return</span> pageService.deleteCmsPage(id);&#125;</code></pre></div><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p><a href="https://qnoss.codeyee.com/20200704_3/image18" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image18.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="3-前端开发"><a href="#3-前端开发" class="headerlink" title="3.前端开发"></a>3.前端开发</h2><h3 id="页面编写"><a href="#页面编写" class="headerlink" title="页面编写"></a>页面编写</h3><p>1、在 <code>page_list</code> 页面内新增一个删除按钮</p><div class="hljs"><pre><code class="hljs vue">&lt;el-table-column label&#x3D;&quot;删除&quot; width&#x3D;&quot;75&quot; fixed&#x3D;&quot;right&quot;&gt;  &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;    &lt;el-button      size&#x3D;&quot;mini&quot;      type&#x3D;&quot;danger&quot;      @click&#x3D;&quot;deletePage(scope.row.pageId)&quot;&gt;删除    &lt;&#x2F;el-button&gt;  &lt;&#x2F;template&gt;&lt;&#x2F;el-table-column&gt;</code></pre></div><p>2、在 <code>cms.js</code> 定义删除的api</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除接口</span>export <span class="hljs-keyword">const</span> page_delete = (id) =&gt;&#123;  <span class="hljs-keyword">return</span> http.requestDelete(apiUrl + <span class="hljs-string">"/cms/page/delete/"</span> + id)&#125;</code></pre></div><p>3、创建 <code>deletePage</code> 函数，接收到 当前行的 <code>pageId</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//删除页面</span>deletePage(pageId) &#123;  <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">"此操作将永久的删除该页面"</span>, <span class="hljs-string">"提示"</span>, &#123;    confirmButtonText: <span class="hljs-string">'确定'</span>,    cancelButtonText: <span class="hljs-string">'取消'</span>,    type: <span class="hljs-string">'warning'</span>  &#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    cmsApi.page_delete(pageId).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (res.success) &#123;        <span class="hljs-keyword">this</span>.$message(&#123;          type: <span class="hljs-string">'success'</span>,          message: <span class="hljs-string">'删除成功!'</span>        &#125;)        <span class="hljs-keyword">this</span>.query()      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.$message(&#123;          type: <span class="hljs-string">'warning'</span>,          message: <span class="hljs-string">'删除失败'</span>        &#125;);      &#125;    &#125;)  &#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">this</span>.$message(&#123;      type: <span class="hljs-string">'info'</span>,      message: <span class="hljs-string">'已取消删除'</span>    &#125;);  &#125;);&#125;,</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a href="https://qnoss.codeyee.com/20200704_3/image19" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image19.gif" srcset="/img/loading.gif" alt="img"></a></p><h1 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h1><h2 id="1-异常处理的问题分析"><a href="#1-异常处理的问题分析" class="headerlink" title="1. 异常处理的问题分析"></a>1. 异常处理的问题分析</h2><p>从添加页面的service方法中找问题：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 添加页面数据</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath());    <span class="hljs-keyword">if</span> (cmsPage1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//站点id由mongoDB自动生成，防止前端传值</span>        cmsPage.setPageId(<span class="hljs-keyword">null</span>);        CmsPage save = cmsPageRepository.save(cmsPage);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS, save);    &#125;    <span class="hljs-comment">//添加失败</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.FAIL, cmsPage);&#125;</code></pre></div><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h3><p>1、上边的代码只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信息。</p><p>2、<code>service</code> 方法在执行过程出现异常在哪捕获？在 <code>service</code> 中需要都加 <code>try</code>/<code>catch</code>，如果在<code>controller</code> 也需要添加 try/catch，代码冗余严重且不易维护。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、在 <code>Service</code> 方法中的编码顺序是先校验判断，有问题则抛出具体的异常信息，最后执行具体的业务操作，返回成功信息。</p><p>2、在统一异常处理类中去捕获异常，无需<code>controller</code>捕获异常，向用户返回统一规范的响应信息。</p><p>我们的代码应该是这样的</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加页面数据</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> </span>&#123;    <span class="hljs-comment">//效验cmsPage是否为空</span>    <span class="hljs-keyword">if</span>(cmsPage == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-comment">//抛出异常，非法参数</span>    &#125;    <span class="hljs-comment">//验证数据唯一性：sizeId、pageName、pageWebPath</span>    CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath());    <span class="hljs-comment">//检验页面是否已存在</span>    <span class="hljs-keyword">if</span> (cmsPage1 != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//抛出异常</span>    &#125;    <span class="hljs-comment">//站点id由mongoDB自动生成，防止前端传值</span>    cmsPage.setPageId(<span class="hljs-keyword">null</span>);    CmsPage save = cmsPageRepository.save(cmsPage);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CmsPageResult(CommonCode.SUCCESS, save);    <span class="hljs-comment">//添加失败</span>&#125;</code></pre></div><p>在执行正常的逻辑之前，要把已知的异常进行验证，验证全部通过后才会去执行正常的逻辑代码。</p><h2 id="2-异常处理流程"><a href="#2-异常处理流程" class="headerlink" title="2. 异常处理流程"></a>2. 异常处理流程</h2><p>系统对异常的处理使用统一的异常处理流程：</p><p>1、自定义异常类型。</p><p>2、自定义错误代码及错误信息。</p><p>3、对于可预知的异常由程序员在代码中主动抛出，由 <code>SpringMVC</code> 统一捕获。</p><p>可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。</p><p>4、对于不可预知的异常（运行时异常）由<code>SpringMVC</code>统一捕获 <code>Exception</code> 类型的异常。</p><p>不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为 <code>RuntimeException</code>类型（运行时异常）。</p><p>5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随请求响应给客户端。</p><p>异常抛出及处理流程：</p><p><a href="https://qnoss.codeyee.com/20200704_3/image20" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image20.png" srcset="/img/loading.gif" alt="img"></a></p><p>1、在 <code>controller</code>、<code>service</code>、<code>dao</code> 中程序员抛出自定义异常；<code>springMVC</code> 框架抛出框架异常类型</p><p>2、统一由异常捕获类捕获异常，并进行处理</p><p>3、捕获到自定义异常则直接取出错误代码及错误信息，响应给用户</p><p>4、捕获到非自定义异常类型首先从 <code>Map</code> 中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误信息并响应给用户，如果从 <code>Map</code> 中找不到异常类型所对应的错误代码则统一为 <code>99999</code> 错误代码并响应给用户。</p><p>5、将错误代码及错误信息以 <code>Json</code> 格式响应给用户。</p><h2 id="3-可预知异常处理"><a href="#3-可预知异常处理" class="headerlink" title="3. 可预知异常处理"></a>3. 可预知异常处理</h2><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>在common工程定义异常类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-keyword">private</span> ResultCode resultCode;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomException</span><span class="hljs-params">(ResultCode resultCode)</span></span>&#123;        <span class="hljs-comment">//异常信息为错误代码+异常信息</span>        <span class="hljs-keyword">super</span>(<span class="hljs-string">"错误代码: "</span> + resultCode.code() + <span class="hljs-string">" 错误信息: "</span> + resultCode.message());        <span class="hljs-keyword">this</span>.resultCode = resultCode;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ResultCode <span class="hljs-title">getResultCode</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resultCode;    &#125;&#125;</code></pre></div><p>上面的代码中我们自定义了一个名为 <code>CustomException</code> 的异常，并且继承了 <code>RuntimeException</code> 异常类，有的人可能会问，我们为什么不直接继承 <code>Exception</code> 类？因为如果继承了 <code>Exception</code> 类，我们在抛出异常时对代码会有一定的侵入性，例如我们需要在抛出该异常的方法前加入 <code>throws Exception</code> ，例如</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CmsPageResult <span class="hljs-title">addCmsPage</span><span class="hljs-params">(CmsPage cmsPage)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;&#125;</code></pre></div><p>或者使用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//抛出异常，非法参数</span>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125;</code></pre></div><p>而我们如果使用 <code>RuntimeException</code> ,至需要在抛出异常的地方写入下面代码就能抛出我们自定义的异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomException(resultCode);</code></pre></div><h3 id="抛出异常类"><a href="#抛出异常类" class="headerlink" title="抛出异常类"></a>抛出异常类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionCast</span> </span>&#123;    <span class="hljs-comment">//使用此静态方法抛出自定义异常</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cast</span><span class="hljs-params">(ResultCode resultCode)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomException(resultCode);    &#125;&#125;</code></pre></div><h3 id="异常捕获类"><a href="#异常捕获类" class="headerlink" title="异常捕获类"></a>异常捕获类</h3><p>使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionCatch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//捕获 CustomException 异常</span>    <span class="hljs-meta">@ExceptionHandler</span>(CustomException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">customException</span>(<span class="hljs-title">CustomException</span> <span class="hljs-title">e</span>)</span>&#123;        LOGGER.error(<span class="hljs-string">"catch exception：&#123;&#125;\r\nException："</span>,e.getMessage(),e);        ResultCode resultCode = e.getResultCode();        ResponseResult responseResult = <span class="hljs-keyword">new</span> ResponseResult(resultCode);        <span class="hljs-keyword">return</span> responseResult;    &#125;&#125;</code></pre></div><h3 id="异常处理测试"><a href="#异常处理测试" class="headerlink" title="异常处理测试"></a>异常处理测试</h3><h4 id="1）定义错误代码"><a href="#1）定义错误代码" class="headerlink" title="1）定义错误代码"></a>1）定义错误代码</h4><p>每个业务操作的异常使用异常代码去标识。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.model.response;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CmsCode implements ResultCode &#123;    CMS_ADDPAGE_EXISTS(<span class="hljs-keyword">false</span>,<span class="hljs-number">24001</span>,<span class="hljs-string">"页面已存在！"</span>);    <span class="hljs-comment">//操作结果</span>    <span class="hljs-keyword">boolean</span> success;    <span class="hljs-comment">//操作代码</span>    <span class="hljs-keyword">int</span> code;    <span class="hljs-comment">//提示信息</span>    String message;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">CmsCode</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> success, <span class="hljs-keyword">int</span> code, String message)</span></span>&#123;        <span class="hljs-keyword">this</span>.success = success;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.message = message;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> success;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">code</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">message</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> message;    &#125;&#125;</code></pre></div><h4 id="2）异常处理测试"><a href="#2）异常处理测试" class="headerlink" title="2）异常处理测试"></a>2）异常处理测试</h4><p>1、抛出异常</p><p>回到我们 <code>PageService</code> 中的 <code>addCmsPage</code> 抛出异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//检验页面是否已存在</span><span class="hljs-keyword">if</span> (cmsPage1 != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">//抛出异常</span>    ExceptionCast.cast(CmsCode.CMS_ADDPAGE_EXISTS);&#125;</code></pre></div><p>2、在启动工程中扫描异常捕获类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.framework"</span>&#125;)  <span class="hljs-comment">// 扫描framework下的异常捕获类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>3、前端展示异常信息</p><p>在前端新增页面的表单提交中增加判断</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.message)&#123;<span class="hljs-keyword">this</span>.$message.error(res.message)&#125;</code></pre></div><p>全部代码如下</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//提交表单</span>addSubmit() &#123;  <span class="hljs-keyword">this</span>.$refs.pageForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (valid) &#123;      <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'确认提交吗？'</span>, <span class="hljs-string">'提示'</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        cmsApi.page_add(<span class="hljs-keyword">this</span>.pageForm).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(res);          <span class="hljs-keyword">if</span> (res.success) &#123;            <span class="hljs-keyword">this</span>.$message(&#123;              message: <span class="hljs-string">'提交成功'</span>,              type: <span class="hljs-string">'success'</span>            &#125;);            <span class="hljs-keyword">this</span>.$refs[<span class="hljs-string">'pageForm'</span>].resetFields();          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.message)&#123;            <span class="hljs-keyword">this</span>.$message.error(res.message)          &#125;          <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'提交失败'</span>);          &#125;        &#125;);      &#125;);    &#125;  &#125;)&#125;,</code></pre></div><p>测试</p><p><a href="https://qnoss.codeyee.com/20200704_3/image21" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image21.png" srcset="/img/loading.gif" alt="img"></a></p><h2 id="4-不可预知的异常处理"><a href="#4-不可预知的异常处理" class="headerlink" title="4. 不可预知的异常处理"></a>4. 不可预知的异常处理</h2><h4 id="1）定义异常捕获方法"><a href="#1）定义异常捕获方法" class="headerlink" title="1）定义异常捕获方法"></a>1）定义异常捕获方法</h4><h5 id="抛出异常测试"><a href="#抛出异常测试" class="headerlink" title="抛出异常测试"></a>抛出异常测试</h5><p>使用postman测试添加页面，不输入cmsPost信息，提交，报错信息如下：</p><div class="hljs"><pre><code class="hljs json">org.springframework.http.converter.HttpMessageNotReadableException此异常是springMVC在进行参数转换时报的错误。&#123;    <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1528712906727</span>,    <span class="hljs-attr">"status"</span>: <span class="hljs-number">400</span>,    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"Bad Request"</span>,    <span class="hljs-attr">"exception"</span>: <span class="hljs-string">"org.springframework.http.converter.HttpMessageNotReadableException"</span>,    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Required request body is missing: public</span><span class="hljs-string">    com.xuecheng.framework.domain.cms.response.CmsPageResult</span><span class="hljs-string">    com.xuecheng.manage_cms.web.controller.CmsPageController.add(com.xuecheng.framework.domain.cms.C</span><span class="hljs-string">    msPage)"</span>,    <span class="hljs-attr">"path"</span>: <span class="hljs-string">"/cms/page/add"</span>&#125;</code></pre></div><p>上边的响应信息在客户端是无法解析的。</p><p>在异常捕获类 <code>ExceptionCatch</code> 中添加对Exception异常的捕获，下面大致的代码结构：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ResponseBody</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">exception</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">exception</span>)</span>&#123;    <span class="hljs-comment">//记录日志</span>    LOGGER.error(<span class="hljs-string">"catch exception:&#123;&#125;"</span>,exception.getMessage());    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h5 id="异常捕获方法"><a href="#异常捕获方法" class="headerlink" title="异常捕获方法"></a>异常捕获方法</h5><p>针对上边的问题其解决方案是：</p><ol><li>我们在map中配置HttpMessageNotReadableException和错误代码。</li><li>在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型对应的错误代码，如果存在错误代码则返回此错误，否则统一返回99999错误。</li></ol><p>具体的开发实现如下：</p><p>1、在通用错误代码类CommCode中配置非法参数异常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CommonCode implements ResultCode&#123;    INVALID_PARAM(<span class="hljs-keyword">false</span>,<span class="hljs-number">10003</span>,<span class="hljs-string">"非法参数！"</span>),    <span class="hljs-comment">/**其他代码省略**/</span>&#125;</code></pre></div><p>2、在异常捕获类中配置 HttpMessageNotReadableException 为非法参数异常。</p><p>具体的说明我都写在注释当中了，就不多做解释，直接看代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.exception;<span class="hljs-keyword">import</span> com.google.common.collect.ImmutableMap;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.ResultCode;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 统一异常捕获类</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-08-09  11:12</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-comment">//控制器增强</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionCatch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">//定义map，配置异常类型所对应的错误代码（ImmutableMap 只读，线程安全</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; EXCEPTIONS;    <span class="hljs-comment">//定义map的builder对象，去构建immutablemap</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; builder = ImmutableMap.builder();    <span class="hljs-comment">//捕获CustomException类的异常</span>    <span class="hljs-meta">@ExceptionHandler</span>(CustomException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">customException</span>(<span class="hljs-title">CustomException</span> <span class="hljs-title">customException</span>)</span>&#123;        <span class="hljs-comment">//记录日志</span>        LOGGER.error(<span class="hljs-string">"catch exception:&#123;&#125;"</span>,customException.getMessage());        ResultCode resultCode = customException.getResultCode();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(resultCode);    &#125;    <span class="hljs-comment">//捕获Exception类的异常</span>    <span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">ResponseResult</span> <span class="hljs-title">exception</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">exception</span>)</span>&#123;        <span class="hljs-comment">//记录日志</span>        LOGGER.error(<span class="hljs-string">"catch exception:&#123;&#125;"</span>,exception.getMessage());        <span class="hljs-keyword">if</span> (EXCEPTIONS == <span class="hljs-keyword">null</span>)&#123;            EXCEPTIONS = builder.build();<span class="hljs-comment">//EXCEPTIONS构建成功</span>        &#125;        <span class="hljs-comment">//从EXCEPTIONS中找出异常类型所对应的错误代码，如果找到了将错误代码响应给用户</span>        <span class="hljs-comment">// 如果找不到给用户响应99999异常</span>        ResultCode resultCode = EXCEPTIONS.get(exception.getClass());        <span class="hljs-keyword">if</span> (resultCode != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(resultCode);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果非预定义的错误，则返回服务器错误</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SERVER_ERROR);        &#125;    &#125;    <span class="hljs-keyword">static</span> &#123;        builder.put(HttpMessageNotReadableException<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">CommonCode</span>.<span class="hljs-title">INVALID_PARAM</span>)</span>;    &#125;&#125;</code></pre></div><p>我们来测试一下，是否能成功捕抓到该异常</p><p><a href="https://qnoss.codeyee.com/20200704_3/image22" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image22.png" srcset="/img/loading.gif" alt="img"></a></p><p>我们改成 GET 请求进行测试，由于我们没有预定这种异常的错误代码，所以统一返回99999错误代码</p><p><a href="https://qnoss.codeyee.com/20200704_3/image23" target="_blank" rel="noopener"><img src="/2020/08/09/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday03/image23.png" srcset="/img/loading.gif" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Data MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day02</title>
    <link href="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/"/>
    <url>/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/</url>
    
    <content type="html"><![CDATA[<h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day02</code> 的内容</p><ul><li><code>vue</code> 基础语法</li><li>对 <code>webpack</code>与 <code>webpack-dev-server</code> 的基本使用，理解 <code>webpack</code> 的打包过程。</li><li><code>CMS</code> 前端工程的基础构建</li><li>解决前端跨域请求的问题，并理解前端请求数据的流程。</li><li>配合使用 <code>Element-UI</code> 的 <code>table</code> 组件进行分页查询</li></ul><h1 id="一、vue基础"><a href="#一、vue基础" class="headerlink" title="一、vue基础"></a>一、vue基础</h1><p>vue基础部分内容的笔记略过，如过你仍需要该阶段的学习，阅读官方的讲义或者移步：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a> 进行阅读和练习。</p><h1 id="二、webpack入门"><a href="#二、webpack入门" class="headerlink" title="二、webpack入门"></a>二、webpack入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>使用vue.js开发大型应用需要使用 <code>webpack</code> 打包工具，本节研究webpack的使用方法。</p><p>Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image7.png" srcset="/img/loading.gif" alt></p><h2 id="2-使用webpack有什么好处呢？"><a href="#2-使用webpack有什么好处呢？" class="headerlink" title="2. 使用webpack有什么好处呢？"></a>2. 使用webpack有什么好处呢？</h2><p>从图中我们可以看出，Webpack 可以将js、css、png等多种静态资源 进行打包</p><ul><li>模块化开发<br>程序员在开发时可以分模块创建不同的js、 css等小文件方便开发，最后使用webpack将这些小文件打包成一个文<br>件，减少了http的请求次数。<br>webpack可以实现按需打包，为了避免出现打包文件过大可以打包成多个文件。</li><li>编译typescript、ES6等高级js语法<br>随着前端技术的强大，开发中可以使用javascript的很多高级版本，比如：typescript、ES6等，方便开发，<br>webpack可以将打包文件转换成浏览器可识别的js语法。</li><li>CSS预编译<br>webpack允许在开发中使用Sass 和 Less等原生CSS的扩展技术，通过sass-loader、less-loader将Sass 和 Less的<br>语法编译成浏览器可识别的css语法。</li></ul><h2 id="3-webpack的缺点"><a href="#3-webpack的缺点" class="headerlink" title="3. webpack的缺点"></a>3. webpack的缺点</h2><p>1、配置有些繁琐<br>2、文档不丰富</p><h2 id="4-安装-npm"><a href="#4-安装-npm" class="headerlink" title="4.安装 npm"></a>4.安装 npm</h2><p><code>node.js</code> 已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本，node可以直接去官网下载安装</p><p>设置包路径</p><div class="hljs"><pre><code class="hljs shell">npm config set prefix "C:\Program Files\nodejs\npm_modules"npm config set cache "c:\Program Files\nodejs\npm_cache"</code></pre></div><h2 id="5-安装-cnpm"><a href="#5-安装-cnpm" class="headerlink" title="5. 安装 cnpm"></a>5. 安装 cnpm</h2><p>执行以下命令</p><div class="hljs"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></div><p>安装完成后执行命令 <code>cnpm -v</code></p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image8.png" srcset="/img/loading.gif" alt></p><h2 id="6-安装-webpack"><a href="#6-安装-webpack" class="headerlink" title="6. 安装 webpack"></a>6. 安装 webpack</h2><p><strong>node.js 安装包分为两种模式</strong></p><ul><li>本地安装：仅将webpack安装在当前项目的node_modules目录中，仅对当前项目有效。</li><li>全局安装：将webpack安装在本机，对所有项目有效，全局安装会锁定一个webpack版本，该版本可能不适用某个项目。全局安装需要添加 -g 参数</li></ul><p><strong>本地安装</strong></p><div class="hljs"><pre><code class="hljs shell">npm install --save-dev webpack 或 cnpm install --save-dev webpacknpm install --save-dev webpack-cli (4.0以后的版本需要安装webpack-cli)</code></pre></div><p><strong>全局安装</strong></p><p>全局安装加-g，如下：全局安装就将webpack的js包下载到npm的包路径下。</p><div class="hljs"><pre><code class="hljs shell">npm install webpack -g 或 cnpm install webpack -g</code></pre></div><p><strong>安装 webpack 指定的版本：</strong><br>进入webpacktest测试目录，运行：<code>cnpm install --save-dev webpack@3.6.0</code><br>全局安装：<code>npm install webpack@3.6.0 -g</code> 或 <code>cnpm install webpack@3.6.0 -g</code></p><h2 id="7-入门程序"><a href="#7-入门程序" class="headerlink" title="7. 入门程序"></a>7. 入门程序</h2><p>通过本入门程序体会webpack打包的过程及模块化开发的思想。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>通过入门程序实现对js文件的打包，体会webpack是如何对应用进行模块化管理。<br>对上边1+1=2的例子使用webpack进行模块化管理</p><h3 id="定义-model01-js"><a href="#定义-model01-js" class="headerlink" title="定义 model01.js"></a>定义 model01.js</h3><p>在<code>webpacktest01</code>目录下创建<code>model01.js</code></p><p>将本程序使用的加法运算的js方法抽取到一个js文件，此文件就是一个模块 ，代码如下</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//定义add函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x+y;&#125;<span class="hljs-comment">//导出add函数</span><span class="hljs-built_in">module</span>.exports.add = add;</code></pre></div><h3 id="定义main-js"><a href="#定义main-js" class="headerlink" title="定义main.js"></a>定义main.js</h3><p>在<code>webpacktest01</code>目录下创建<code>main.js</code>，<code>main.js</code>是本程序的js主文件，包括如下内容：</p><p>1、在此文件中会引用model01.js模块<br>2、引用vue.min.js（它也一个模块）<br>3、将html页面中构建vue实例的代码放在main.js中。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;add&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./model01.js"</span>)<span class="hljs-keyword">var</span> Vue = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./vue.min"</span>)<span class="hljs-comment">// 实例化Vue对象</span><span class="hljs-comment">//vm :叫做MVVM中的 View Model</span><span class="hljs-keyword">var</span> VM = <span class="hljs-keyword">new</span> Vue(&#123;    el:<span class="hljs-string">"#app"</span>,<span class="hljs-comment">//表示当前vue对象接管app的div区域</span>    data:&#123;        name:<span class="hljs-string">'黑马程序员'</span>,<span class="hljs-comment">// 相当于是MVVM中的Model这个角色</span>        num1:<span class="hljs-number">0</span>,        num2:<span class="hljs-number">0</span>,        result:<span class="hljs-number">0</span>,        url:<span class="hljs-string">'http://www.itcast.cn'</span>    &#125;,    methods:&#123;        change:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">this</span>.result = add(<span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.num1),<span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-keyword">this</span>.num2));        &#125;    &#125;&#125;);</code></pre></div><h3 id="打包测试"><a href="#打包测试" class="headerlink" title="打包测试"></a>打包测试</h3><p>上边将 <code>mode01.js</code> 模块及 <code>main.js</code> 主文件编写完成，下边使用 <code>webpack</code> 对这些js文件进行打包</p><p>1、进入程序目录，执行 <code>webpack main.js -o build.js</code> ，这段指令表示将 <code>main.js</code> 打包输出为 <code>build.js</code> 文件执行完成，观察程序目录是否出现 <code>build.js</code>。</p><p>2、在创建一个html ，这里我命名为 <code>vue_02.html</code> 并 中引用 <code>build.js</code></p><div class="hljs"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;&lt;html lang=<span class="hljs-string">"en"</span> xmlns:v-on=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;&lt;head&gt;    &lt;meta http-equiv=<span class="hljs-string">"Content-Type"</span> content=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;    &lt;title&gt;vue.js入门程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=<span class="hljs-string">"app"</span>&gt;    &#123;&#123;name&#125;&#125;    &lt;input type=<span class="hljs-string">"text"</span> v-model=<span class="hljs-string">"num1"</span>&gt;+    &lt;input type=<span class="hljs-string">"text"</span> v-model=<span class="hljs-string">"num2"</span>&gt;=    &lt;input type=<span class="hljs-string">"text"</span> v-model=<span class="hljs-string">"result"</span>&gt;    &lt;button v-on:click="change"&gt;计算&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="build.js"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre></div><h3 id="运行html"><a href="#运行html" class="headerlink" title="运行html"></a>运行html</h3><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image9.png" srcset="/img/loading.gif" alt></p><h1 id="三、webpack-dev-server"><a href="#三、webpack-dev-server" class="headerlink" title="三、webpack-dev-server"></a>三、webpack-dev-server</h1><h2 id="1-测试环境搭建"><a href="#1-测试环境搭建" class="headerlink" title="1. 测试环境搭建"></a>1. 测试环境搭建</h2><p><code>webpack-dev-server</code> 开发服务器，它的功能可以实现热加载 并且自动刷新浏览器。</p><p>创建一个新的程序目录，这里我们创建 <code>webpacktest02</code> 目录，将 <code>webpack</code> 入门程序( <code>webpacktest01</code> )的代码拷贝进来，并在目录下创建 <code>src</code> 目录、<code>dist</code> 目录，并将main.js和model01.js拷贝到src目录。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image10.png" srcset="/img/loading.gif" alt></p><h2 id="2-安装配置"><a href="#2-安装配置" class="headerlink" title="2. 安装配置"></a>2. 安装配置</h2><h3 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h3><p>使用 <code>webpack-dev-server</code> 需要安装webpack、 webpack-dev-server 和 html-webpack-plugin三个包。</p><div class="hljs"><pre><code class="hljs shell">cnpm install webpackwebpack-dev-server html-webpack-plugin</code></pre></div><p>安装完成，会发现程序目录出现一个package.json文件，此文件中记录了程序的依赖。</p><h3 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h3><p>在package.json中配置script</p><div class="hljs"><pre><code class="hljs json">"scripts": &#123;  "dev": "webpack-dev-server --inline --hot --open --port 5008"&#125;</code></pre></div><p>–inline：自动刷新<br>–hot：热加载<br>–port：指定端口<br>–open：自动在默认浏览器打开<br>–host：可以指定服务器的 ip，不指定则为127.0.0.1，如果对外发布则填写公网ip地址</p><p>此时package.json的文件内容如下：</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"devDependencies"</span>: &#123;    <span class="hljs-attr">"html-webpack-plugin"</span>: <span class="hljs-string">"^3.2.0"</span>,    <span class="hljs-attr">"webpack-dev-server"</span>: <span class="hljs-string">"^3.10.3"</span>  &#125;,  <span class="hljs-attr">"scripts"</span>: &#123;    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"webpack-dev-server --inline --hot --open --port 5008"</span>  &#125;&#125;</code></pre></div><blockquote><p>devDependencies：开发人员在开发过程中所需要的依赖。<br>scripts：可执行的命令</p></blockquote><h2 id="3-webpack-config-js"><a href="#3-webpack-config-js" class="headerlink" title="3. webpack.config.js"></a>3. webpack.config.js</h2><p>在 <code>webpacktest02</code> 目录下创建 <code>webpack.config.js</code>， <code>webpack.config.js</code> 是 <code>webpack</code> 的配置文件。</p><p>在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置 <code>html-webpack-plugin</code> 插件。</p><p><code>html-webpack-plugin</code> 的作用是根据 <code>html</code> 模板在内存生成 <code>html</code> 文件，它的工作原理是根据模板文件在内存中生成一个 <code>index.html</code> 文件。</p><h3 id="配置模板文件"><a href="#配置模板文件" class="headerlink" title="配置模板文件"></a>配置模板文件</h3><p>将原来的 <code>vue_02.html</code> 作为模板文件，为了和内存中的 <code>index.html</code> 文件名区别，注意将 <code>vue_02.html</code> 中的<code>script</code> 标签去掉，内容如下：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:v-on</span>=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue.js入门程序<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    &#123;&#123;name&#125;&#125;    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"num1"</span>&gt;</span>+    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"num2"</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"result"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"change"</span>&gt;</span>计算<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="配置-html-webpack-plugin"><a href="#配置-html-webpack-plugin" class="headerlink" title="配置 html-webpack-plugin"></a>配置 html-webpack-plugin</h3><p>在 <code>webpack.config.js</code> 中配置 <code>html-webpack-plugin</code> 插件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">var</span> htmlwp = require(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span>=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">//指定打包的入口文件</span>    output:&#123;        path : __dirname + <span class="hljs-string">'/dist'</span>, <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>        filename:<span class="hljs-string">'build.js'</span> <span class="hljs-comment">//输出文件</span>    &#125;,    plugins:[        <span class="hljs-keyword">new</span> htmlwp(&#123;            <span class="hljs-comment">//生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;</span>            title: <span class="hljs-string">'首页'</span>,            <span class="hljs-comment">//webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部才能实现自动刷新功能</span>            filename: <span class="hljs-string">'index.html'</span>,            <span class="hljs-comment">//根据vue_02.html这个模板来生成(这个文件请程序员自己生成)</span>            template: <span class="hljs-string">'vue_02.html'</span>        &#125;)    ]&#125;</code></pre></div><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动文件：<br>1、进入 <code>webpacktest02</code>目录，执行<code>npm run dev</code><br>2、使用webstorm，右键<code>package.json</code>文件，选择 “Show npm Scripts”</p><p>打开窗口：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image11.png" srcset="/img/loading.gif" alt></p><p>双击 <code>dev</code>。<br>注意：dev 就是在 <code>package.json</code> 中配置的 <code>webpack dev server</code> 命令。<br>发现启动成功自动打开浏览器。<br>修改src中的任意文件内容，自动加载并刷新浏览器。</p><h3 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h3><p>使用了 <code>webpack</code> 之后就不能采用传统js的调试方法在 <code>chrome</code> 中打断点。</p><p><code>webpack</code> 将多个源文件打包成一个文件，并且文件的内容产生了很大的变化，<code>webpack</code> 提供 <code>devtool</code> 进行调试，<code>devtool</code> 是基于 <code>sourcemap</code> 的方式，在调试时会生成一个 <code>map</code> 文件，其内容记录生成文件和源文件的内容映射，即生成文件中的哪个位置对应源文件中的哪个位置，有了 <code>sourcemap</code> 就可以在调试时看到源代码。</p><p><strong>配置如下</strong></p><p>1、在webpack.config.js中配置：</p><div class="hljs"><pre><code class="hljs js">devtool: <span class="hljs-string">'eval‐source‐map'</span>,</code></pre></div><p>devtool: ‘eval‐source‐map’,</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> htmlwp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html‐webpack‐plugin'</span>);    <span class="hljs-built_in">module</span>.exports=&#123;    entry:<span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">//指定打包的入口文件</span>    output:&#123;    path : __dirname+<span class="hljs-string">'/dist'</span>, <span class="hljs-comment">// 注意：__dirname表示webpack.config.js所在目录的绝对路径</span>    filename:<span class="hljs-string">'build.js'</span> <span class="hljs-comment">//输出文件</span>&#125;,devtool: <span class="hljs-string">'eval‐source‐map'</span>,......</code></pre></div><p>2、在js中跟踪代码的位置上添加debugger</p><p>一个例子：<br>在add方法中添加debugger</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 定义add函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">debugger</span>    <span class="hljs-keyword">return</span> x + y&#125;</code></pre></div><p>启动应用，刷新页面跟踪代码：<br>点击“计算” 即进入debugger代码位置，此时可以使用chrome进行调试了。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image12.png" srcset="/img/loading.gif" alt></p><h3 id="无法正常启动调试？"><a href="#无法正常启动调试？" class="headerlink" title="无法正常启动调试？"></a>无法正常启动调试？</h3><p>谷歌浏览器中先按下 <code>F12</code> 打开调试模式后在点击 <code>计算</code> 按钮进行触发代码中的 <code>debugger</code></p><h1 id="四、CMS前端工程创建"><a href="#四、CMS前端工程创建" class="headerlink" title="四、CMS前端工程创建"></a>四、CMS前端工程创建</h1><h2 id="1-导入系统管理前端工程"><a href="#1-导入系统管理前端工程" class="headerlink" title="1.导入系统管理前端工程"></a>1.导入系统管理前端工程</h2><p>CMS系统使用Vue-cli脚手架创建， <code>Vue-cli</code>是 <code>Vue</code> 官方提供的快速构建单页应用的脚手架，<code>github</code>地址：<br><a href="https://github.com/vuejs/vue-cli%EF%BC%88%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E5%90%8C%E5%AD%A6%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E5%AE%98%E6%96%B9%E6%8C%87%E5%AF%BC%E4%BD%BF%E7%94%A8vue-cli%E5%88%9B%E5%BB%BA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%EF%BC%89%EF%BC%8C%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%AF%B9" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli（有兴趣的同学可以参考官方指导使用vue-cli创建前端工程），本项目对</a> <code>Vue-cli</code>创建的工程进行二次封装，下边介绍CMS工程的情况。</p><h2 id="2-工程结构"><a href="#2-工程结构" class="headerlink" title="2. 工程结构"></a>2. 工程结构</h2><p>如果我要基于Vue-Cli创建的工程进行开发还需要在它基础上作一些封装，导入课程资料中提供Vue-Cli封装工程。<br><code>资料/xc-ui-pc-sysmanage.7z</code> 拷贝到UI工程目录中，并解压，用<code>WebStorm</code>打开 <code>xc-ui-pc-sysmanage</code> 目录。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image13.png" srcset="/img/loading.gif" alt></p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json记录了工程所有依赖，及脚本命令：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image14.png" srcset="/img/loading.gif" alt></p><p>开发使用：<code>npm run dev</code><br>打包使用：<code>npm run build</code></p><h3 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a>webpack.base.conf.js</h3><p><code>webpack.base.conf.js</code> 就是 webpack 的 <code>webpack.config.js</code> 配置文件，在此文件中配置了入口文件及各种<code>Loader</code>。webpack 是通过<code>vue-load</code>解析 <code>.vue</code> 文件，通过 <code>css-load</code> 打包 <code>css</code> 文件等。</p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p><code>main.js</code> 是工程的入口文件，在此文件中加载了很多第三方组件，如：Element-UI、Base64、VueRouter 等。<br><code>index.html</code> 是模板文件。</p><h3 id="src目录"><a href="#src目录" class="headerlink" title="src目录"></a>src目录</h3><p>src目录下存放页面及js代码。</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image15.png" srcset="/img/loading.gif" alt></p><ul><li>assets：存放一些静态文件，如图片。</li><li>base：存放基础组件</li><li>base/api：基础api接口</li><li>base/component：基础组件，被各各模块都使用的组件</li><li>base/router：总的路由配置，加载各模块的路由配置文件。</li><li>common：工具类</li><li>component：组件目录，本项目不用。</li><li>mock：存放前端单元测试方法。</li><li>module：存放各业务模块的页面和api方法。</li></ul><p>下级目录以模块名命名，下边以cms举例：</p><ul><li>cms/api：cms模块的api接口</li><li>cms/component：cms模块的组件</li><li>cms/page： cms模块的页面</li><li>cms/router：cms模块的路由配置</li><li>statics：存放第三方组件的静态资源</li><li>vuex：存放vuex文件，本项目不使用</li><li>static：与src的平级目录，此目录存放静态资源它与assets的区别在于，static目录中的文件不被webpack打包处理，会原样拷贝到dist目录下</li></ul><h2 id="3-单页面应用介绍"><a href="#3-单页面应用介绍" class="headerlink" title="3. 单页面应用介绍"></a>3. 单页面应用介绍</h2><h3 id="单页面应用的优缺点："><a href="#单页面应用的优缺点：" class="headerlink" title="单页面应用的优缺点："></a>单页面应用的优缺点：</h3><p><strong>优点</strong>：<br>1、用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。<br>2、适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。</p><p><strong>缺点</strong>：<br>1、首页加载慢<br>单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则<br>用户体验不好。</p><p>2、SEO不友好<br>SEO（Search Engine Optimization）为搜索引擎优化。它是一种利用搜索引擎的搜索规则来提高网站在搜索引擎<br>排名的方法。目前各家搜索引擎对JS支持不好，所以使用单页面应用将大大减少搜索引擎对网站的收录。</p><p>总结：本项目的门户、课程介绍不采用单页面应用架构去开发，对于需要用户登录的管理系统采用单页面开发。</p><h1 id="五、CMS前端页面查询开发"><a href="#五、CMS前端页面查询开发" class="headerlink" title="五、CMS前端页面查询开发"></a>五、CMS前端页面查询开发</h1><h2 id="1-页面原型"><a href="#1-页面原型" class="headerlink" title="1. 页面原型"></a>1. 页面原型</h2><h3 id="1、创建页面"><a href="#1、创建页面" class="headerlink" title="1、创建页面"></a>1、创建页面</h3><h4 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h4><p>在model目录创建 cms模块的目录结构</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image16.png" srcset="/img/loading.gif" alt></p><p>在page目录新建page_list.vue，扩展名为.vue。<br>.vue文件的结构如下：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;&lt;!‐‐编写页面静态部分，即view部分‐‐&gt;测试页面显示...&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;*编写页面静态部分，即model及vm部分。*&#x2F;&lt;&#x2F;script&gt;&lt;style&gt;&#x2F;*编写页面样式，不是必须*&#x2F;&lt;&#x2F;style&gt;</code></pre></div><p>在页面的<code>template</code>中填写 “测试页面显示…”。<br>注意：<code>template</code>内容必须有一个根元素，否则vue会报错，这里我们在<code>template</code>标签内定义一个<code>div</code>。</p><h4 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h4><p>在 <code>cms</code> 目录下创建 <code>page_list.vue</code> 页面。<br>现在先配置路由，实现 url 访问到页面再进行内容完善与调试。</p><p>1、在cms的router下配置路由</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/page/home.vue'</span>;<span class="hljs-keyword">import</span> page_list <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/cms/page/page_list.vue'</span>;    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [&#123;        path: <span class="hljs-string">'/cms'</span>,        component: Home,        name: <span class="hljs-string">'CMS内容管理'</span>,        hidden: <span class="hljs-literal">false</span>,        children:[            &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">'/cms/page/list'</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">'页面列表'</span>,<span class="hljs-attr">component</span>: page_list,<span class="hljs-attr">hidden</span>:<span class="hljs-literal">false</span>&#125;        ]    &#125;]</code></pre></div><p>2、在base目录下的router导入cms模块的路由</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// // 导入路由规则</span><span class="hljs-keyword">import</span> HomeRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/home/router'</span><span class="hljs-keyword">import</span> CmsRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'@/module/cms/router'</span><span class="hljs-comment">// 合并路由规则</span>concat(HomeRouter)concat(CmsRouter)</code></pre></div><p>3、测试</p><p>启动工程，刷新页面，页面可以外正常浏览，并且看到“测试页面显示…”字样</p><h3 id="2、Table组件测试"><a href="#2、Table组件测试" class="headerlink" title="2、Table组件测试"></a>2、Table组件测试</h3><p>本功能实现的页面列表，用户可以进行分页查询、输入查询条件查询，通过查看 <code>Element-UI</code> 库，我们需要<code>Table</code> 表格、<code>Form</code>表单 及<code>Pagination</code> 分页组件。</p><p>进入<a href="https://element.eleme.cn/#/zh-CN/component/table" target="_blank" rel="noopener">Element-UI</a>官方，找到 <code>Table</code> 组件，拷贝源代码到 <code>vue</code> 页面中，如下：</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-table      :data&#x3D;&quot;tableData&quot;      border      style&#x3D;&quot;width: 100%&quot;&gt;      &lt;el-table-column        prop&#x3D;&quot;date&quot;        label&#x3D;&quot;日期&quot;        width&#x3D;&quot;180&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column        prop&#x3D;&quot;name&quot;        label&#x3D;&quot;姓名&quot;        width&#x3D;&quot;180&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column        prop&#x3D;&quot;address&quot;        label&#x3D;&quot;地址&quot;&gt;      &lt;&#x2F;el-table-column&gt;      &lt;el-table-column        prop&#x3D;&quot;test&quot;        label&#x3D;&quot;测试列&quot;&gt;      &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        tableData: [&#123;          date: &#39;2016-05-02&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1518 弄&#39;,          test: &#39;测试&#39;        &#125;, &#123;          date: &#39;2016-05-04&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1517 弄&#39;        &#125;, &#123;          date: &#39;2016-05-01&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1519 弄&#39;        &#125;, &#123;          date: &#39;2016-05-03&#39;,          name: &#39;王小虎&#39;,          address: &#39;上海市普陀区金沙江路 1516 弄&#39;        &#125;]      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt;</code></pre></div><p>测试：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image17.png" srcset="/img/loading.gif" alt></p><p>通过查看代码发现，<code>el-table</code> 组件绑定了<code>tableData</code>模型数据，<code>tableData</code>模型数据在<code>script</code>标签中定义。</p><h3 id="3、页面内容完善"><a href="#3、页面内容完善" class="headerlink" title="3、页面内容完善"></a>3、页面内容完善</h3><p>根据需求完善页面内容，完善列表字段，添加分页组件。</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;query&quot; size&#x3D;&quot;small&quot;&gt;查询&lt;&#x2F;el-button&gt;    &lt;el-table    :data&#x3D;&quot;list&quot;    border    style&#x3D;&quot;width: 100%&quot;&gt;    &lt;el-table-column prop&#x3D;&quot;pageName&quot; label&#x3D;&quot;页面名称&quot; width&#x3D;&quot;120&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageAliase&quot; label&#x3D;&quot;别名&quot; width&#x3D;&quot;120&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageType&quot; label&#x3D;&quot;页面类型&quot; width&#x3D;&quot;150&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageWebPath&quot; label&#x3D;&quot;访问路径&quot; width&#x3D;&quot;250&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pagePhysicalPath&quot; label&#x3D;&quot;物理路径&quot; width&#x3D;&quot;250&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;el-table-column prop&#x3D;&quot;pageCreateTime&quot; label&#x3D;&quot;创建时间&quot;&gt;    &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;    &lt;el-pagination    layout&#x3D;&quot;prev, pager, next&quot;    :page-size&#x3D;&quot;this.params.size&quot;    v-on:current-change&#x3D;&quot;changePage&quot;    :total&#x3D;&quot;total&quot; :current-page&#x3D;&quot;this.params.page&quot; style&#x3D;&quot;float:right;&quot;&gt;    &lt;&#x2F;el-pagination&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        list:[],        total:50,        params:&#123;          page:1,&#x2F;&#x2F;页码          size:2&#x2F;&#x2F;每页显示个数        &#125;      &#125;    &#125;,    methods:&#123;      changePage:function () &#123;        this.query()      &#125;,    &#x2F;&#x2F;查询      query:function () &#123;        alert(&quot;查询&quot;)      &#125;    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre></div><p>测试</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image18.png" srcset="/img/loading.gif" alt></p><h2 id="2-API调用"><a href="#2-API调用" class="headerlink" title="2. API调用"></a>2. API调用</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>在cms模块的 <code>api</code> 目录定义<code>cms.js</code>，<br>在 <code>cms.js</code> 中定义如下js方法，此方法实现 <code>http</code> 请求服务端页面查询接口。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//public是对axios的工具类封装，定义了http请求方法</span><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./../../../base/api/public'</span><span class="hljs-comment">//页面查询</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_list = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;    <span class="hljs-comment">//定义方法，请求服务端查询接口</span>    <span class="hljs-keyword">return</span> http.requestQuickGet(<span class="hljs-string">'http://localhost:31001/cms/page/list/'</span>+page+<span class="hljs-string">'/'</span>+size)&#125;</code></pre></div><p><code>axios</code>实现了<code>http</code>方法的封装，<code>vue.js</code> 官方不再继续维护 <code>vue-resource</code>,推荐使用 <code>axios</code>。</p><h3 id="2、调用"><a href="#2、调用" class="headerlink" title="2、调用"></a>2、调用</h3><p>前端 <code>page_list.vue</code> 页面导入cms.js，调用js方法请求服务端页面查询接口。</p><p>请求的参数根据后端的 <code>Swagger</code> 文档进行配置 <a href="http://localhost:31001/swagger-ui.html" target="_blank" rel="noopener">http://localhost:31001/swagger-ui.html</a></p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image19.png" srcset="/img/loading.gif" alt></p><p>配置</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;  <span class="hljs-comment">//导入api</span>  <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cmsApi <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/cms'</span>;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;      <span class="hljs-keyword">return</span> &#123;        list:[],        total:<span class="hljs-number">50</span>,        params:&#123;          page:<span class="hljs-number">1</span>,<span class="hljs-comment">//页码</span>          size:<span class="hljs-number">2</span><span class="hljs-comment">//每页显示个数</span>        &#125;      &#125;    &#125;,    methods:&#123;      changePage:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.query()      &#125;,    <span class="hljs-comment">//查询</span>      query:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">//调用服务端接口</span>        cmsApi.page_list(<span class="hljs-keyword">this</span>.params.page, <span class="hljs-keyword">this</span>.params.size).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;          <span class="hljs-comment">//将res结果数据赋值给数据模型对象</span>          <span class="hljs-keyword">this</span>.list = res.queryResult.list          <span class="hljs-keyword">this</span>.total = res.queryResult.total        &#125;)      &#125;    &#125;  &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="3-跨域问题解决"><a href="#3-跨域问题解决" class="headerlink" title="3. 跨域问题解决"></a>3. 跨域问题解决</h2><p>测试 上边的代理 ，结果 报错如下 ：</p><div class="hljs"><pre><code class="hljs html">No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin'http://localhost:11000' is therefore not allowed access.</code></pre></div><p>原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。</p><p>解决：采用 <code>proxyTable</code> 解决。</p><h3 id="proxyTable-是什么？"><a href="#proxyTable-是什么？" class="headerlink" title="proxyTable 是什么？"></a>proxyTable 是什么？</h3><p>vue-cli提供的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了 <code>http-proxymiddleware</code>（<a href="https://github.com/chimurai/http-proxy-middleware%EF%BC%89%EF%BC%8C%E5%AE%83%E6%98%AFhttp%E4%BB%A3%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E5%AE%83%E4%BE%9D%E8%B5%96" target="_blank" rel="noopener">https://github.com/chimurai/http-proxy-middleware），它是http代理中间件，它依赖</a> <code>node.js</code>，<br>基本原理是用服务端代理解决浏览器跨域：</p><h3 id="cms跨域解决原理："><a href="#cms跨域解决原理：" class="headerlink" title="cms跨域解决原理："></a>cms跨域解决原理：</h3><p>1、访问页面<a href="http://localhost:11000/" target="_blank" rel="noopener">http://localhost:11000/</a></p><p>2、页面请求<a href="http://localhost:11000/cms" target="_blank" rel="noopener">http://localhost:11000/cms</a></p><blockquote><p>由于url由<a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:31001/cms…改为“<a href="http://localhost:11000/cms.&quot;，所以不存在跨域" target="_blank" rel="noopener">http://localhost:11000/cms.&quot;，所以不存在跨域</a></p></blockquote><p>3、通过proxyTable由node服务器代理请求 <a href="http://localhost:31001/cms" target="_blank" rel="noopener">http://localhost:31001/cms</a>.</p><blockquote><p>服务端不存在跨域问题</p></blockquote><p>具体的配置如下：</p><p>1、修改<code>api</code>方法中<code>url</code>的定义</p><p>请求前加/api前缀</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//public是对axios的工具类封装，定义了http请求方法</span><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'./../../../base/api/public'</span>  <span class="hljs-comment">//ES6 导入</span><span class="hljs-keyword">let</span> sysConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@/../config/sysConfig'</span>)<span class="hljs-keyword">let</span> apiUrl = sysConfig.xcApiUrlPre<span class="hljs-comment">//页面查询</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> page_list = <span class="hljs-function">(<span class="hljs-params">page,size,params</span>) =&gt;</span> &#123;  <span class="hljs-comment">//定义方法，请求服务端查询接口</span>  <span class="hljs-keyword">return</span> http.requestQuickGet(apiUrl + <span class="hljs-string">'/cms/page/list/'</span>+page+<span class="hljs-string">'/'</span>+size)&#125;</code></pre></div><p>2、在 <code>config/index.js</code> 下配置 <code>proxyTable</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'/api/cms'</span>: &#123;    target: <span class="hljs-string">'http://localhost:31001'</span>,    pathRewrite: &#123;    <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span><span class="hljs-comment">//实际请求去掉/api</span>&#125;</code></pre></div><h2 id="4-分页查询测试"><a href="#4-分页查询测试" class="headerlink" title="4. 分页查询测试"></a>4. 分页查询测试</h2><p>1、定义分页视图</p><div class="hljs"><pre><code class="hljs vue"> &lt;el-pagination      @size-change&#x3D;&quot;handleSizeChange&quot;      @current-change&#x3D;&quot;handleCurrentChange&quot;      :page-sizes&#x3D;&quot;[5,10, 20, 30, 100]&quot;      :current-page&#x3D;&quot;this.params.page&quot;      :page-size&#x3D;&quot;this.params.size&quot;      :total&#x3D;&quot;this.total&quot;      layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;      v-on:current-change&#x3D;&quot;changePage&quot;      style&#x3D;&quot;float:right;&quot;&gt;&lt;&#x2F;el-pagination&gt;</code></pre></div><p>2、定义数据模型对象</p><div class="hljs"><pre><code class="hljs js">data() &#123;     <span class="hljs-keyword">return</span> &#123;       list:[],       total:<span class="hljs-number">0</span>,  <span class="hljs-comment">//数据总量</span>       params:&#123;         page:<span class="hljs-number">1</span>,<span class="hljs-comment">//默认页码</span>         size:<span class="hljs-number">10</span><span class="hljs-comment">//默认每页显示个数</span>       &#125;     &#125;&#125;,</code></pre></div><p>3、定义分页方法，接收页码参数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//触发分页参数变动</span>handleSizeChange(val) &#123;  <span class="hljs-keyword">this</span>.params.size = val  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`每页 <span class="hljs-subst">$&#123;val&#125;</span> 条`</span>);&#125;,handleCurrentChange(val) &#123;  <span class="hljs-keyword">this</span>.params.page = val  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`当前页: <span class="hljs-subst">$&#123;val&#125;</span>`</span>);&#125;,<span class="hljs-comment">//分页查询，接收page页码</span>changePage()&#123;  <span class="hljs-keyword">this</span>.query()&#125;,<span class="hljs-comment">//查询</span>query:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//调用服务端接口</span>  cmsApi.page_list(<span class="hljs-keyword">this</span>.params.page, <span class="hljs-keyword">this</span>.params.size).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;    <span class="hljs-comment">//将res结果数据赋值给数据模型对象</span>    <span class="hljs-keyword">this</span>.list = res.queryResult.list    <span class="hljs-keyword">this</span>.total = res.queryResult.total  &#125;)&#125;</code></pre></div><p>修改完毕，分页测试效果如下</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image20.png" srcset="/img/loading.gif" alt></p><h2 id="5-进入页面立即查询"><a href="#5-进入页面立即查询" class="headerlink" title="5.进入页面立即查询"></a>5.进入页面立即查询</h2><p>目前实现的功能是进入页面点击查询按钮向服务端表求查询，实际的需求是进入页面立即查询。</p><p><strong>那么如何实现？</strong></p><p>这要用到 <code>vue</code> 的钩子函数，每个 <code>Vue</code> 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 <code>DOM</code> 并在数据变化时更新 <code>DOM</code> 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会 。</p><p>通常使用最多的是 <code>created</code> 和 <code>mounted</code> 两个钩子：</p><p><code>created</code>：vue实例已创建但是DOM元素还没有渲染生成。</p><p><code>mounted</code>：DOM元素渲染生成完成后调用 。</p><p>本例子在两个方法的任意一个都满足需求：</p><p>添加如下代码：</p><div class="hljs"><pre><code class="hljs js">mounted() &#123;    <span class="hljs-comment">//默认查询页面</span>    <span class="hljs-keyword">this</span>.query()&#125;</code></pre></div><p>重新刷新页面。</p><h1 id="六、前端请求响应流程小结"><a href="#六、前端请求响应流程小结" class="headerlink" title="六、前端请求响应流程小结"></a>六、前端请求响应流程小结</h1><p>参考 “讲义–&gt;前后端请求响应流程.png”，如下：</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday02/image21.png" srcset="/img/loading.gif" alt></p><p>根据图中所示，我们总结流程如下：</p><p>1、在浏览器输入前端url</p><p>2、前端框架 <code>vue.js</code> 根据 <code>url</code> 解析路由，根据路由找到 <code>page_list.vue</code> 页面</p><p>3、首先执行 <code>page_list.vue</code> 中的钩子方法</p><p>4、在钩子方法中调用 <code>query</code> 方法。</p><p>5、在 <code>query</code> 方法中调用 <code>cms.js</code> 中的 <code>page_list</code> 方法</p><p>6、<code>cms.js</code> 中的 <code>page_list</code> 方法通过 <code>axios</code> 请求服务端接口</p><p>7、采用 <code>proxyTable</code> 解决跨域问题，<code>node.js</code> 将请求转发到服务端(<a href="http://localhost:31001/cms/page/list" target="_blank" rel="noopener">http://localhost:31001/cms/page/list</a>)</p><p>8、服务端处理，将查询结果响应给前端</p><p>9、成功响应调用 <code>then</code> 方法，在 <code>then</code> 方法中处理响应结果，将查询结果赋值给数据模型中的total和list变量。</p><p>10、<code>vue.js</code> 通过双向数据绑定将list数据渲染输出 。</p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学成在线day01</title>
    <link href="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/"/>
    <url>/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/</url>
    
    <content type="html"><![CDATA[<h1 id="😎-知识点概览"><a href="#😎-知识点概览" class="headerlink" title="😎 知识点概览"></a>😎 知识点概览</h1><blockquote><p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p></blockquote><p>本章节为【学成在线】项目的 <code>day01</code> 的内容</p><ul><li>搭建门户页面</li><li>搭建服务端基础工程</li><li>页面查询服务的构建</li><li>使用<code>MangoDB</code> 进行 <code>CRUD</code> 操作</li><li><code>Swagger</code> 的基本使用</li><li><code>Postman</code> 的基本使用</li></ul><h1 id="一、项目架构"><a href="#一、项目架构" class="headerlink" title="一、项目架构"></a>一、项目架构</h1><h2 id="1-业务架构"><a href="#1-业务架构" class="headerlink" title="1. 业务架构"></a>1. 业务架构</h2><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image1.png" srcset="/img/loading.gif" alt></p><h2 id="2-技术架构"><a href="#2-技术架构" class="headerlink" title="2. 技术架构"></a>2. 技术架构</h2><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image2.png" srcset="/img/loading.gif" alt></p><h1 id="二、CMS-门户工程搭建"><a href="#二、CMS-门户工程搭建" class="headerlink" title="二、CMS 门户工程搭建"></a>二、CMS 门户工程搭建</h1><h2 id="1-安装-WebStorm"><a href="#1-安装-WebStorm" class="headerlink" title="1. 安装 WebStorm"></a>1. 安装 WebStorm</h2><p>参考 <code>WebStorm安装手册.md</code> 安装WebStorm，导入 <code>资料\门户\xc-ui-pc-static-portal.rar</code> 压缩包下的内容。</p><h2 id="2-Nginx虚拟主机"><a href="#2-Nginx虚拟主机" class="headerlink" title="2. Nginx虚拟主机"></a>2. Nginx虚拟主机</h2><p>在nginx中配置虚拟主机：</p><div class="hljs"><pre><code class="hljs nginx">server&#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> www.xuecheng.com;    <span class="hljs-attribute">ssi</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">ssi_silent_errors</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-attribute">alias</span> F:/teach/xcEdu/xcEduUI/xc‐ui‐pc‐static‐portal/;    <span class="hljs-attribute">index</span> index.html;    &#125;&#125;</code></pre></div><p>F:/teach/xcEdu/xcEduUI/xc-ui-pc-static-portal/ 本目录即为门户的主目录，自行修改为自己的路径</p><h1 id="三、CMS-服务端工程搭建"><a href="#三、CMS-服务端工程搭建" class="headerlink" title="三、CMS 服务端工程搭建"></a>三、CMS 服务端工程搭建</h1><h2 id="1-基础工程搭建"><a href="#1-基础工程搭建" class="headerlink" title="1. 基础工程搭建"></a>1. 基础工程搭建</h2><p>创建一个项目文件夹 <code>xcEduService01</code>导入 <code>资料\基础工程\基础工程.zip</code> 中的基础工程，并依次将所有基础工程添加至<code>pom</code>项目中</p><h2 id="2-导入MongoDB数据"><a href="#2-导入MongoDB数据" class="headerlink" title="2. 导入MongoDB数据"></a>2. 导入MongoDB数据</h2><p>搭建好mongodb数据库后，导入 <code>资料\mongodb\xc_cms</code> 内的json数据</p><h2 id="3-定义接口"><a href="#3-定义接口" class="headerlink" title="3. 定义接口"></a>3. 定义接口</h2><h3 id="定义请求以及相应类型"><a href="#定义请求以及相应类型" class="headerlink" title="定义请求以及相应类型"></a>定义请求以及相应类型</h3><p>在 <code>domain.cms.request</code> 下创建 <code>QueryPageRequest</code> 并继承 <code>RequestData</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.framework.domain.cms.request;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.request.RequestData;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPageRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestData</span> </span>&#123;    <span class="hljs-comment">//站点id</span>    <span class="hljs-keyword">private</span> String siteId;    <span class="hljs-comment">//页面id</span>    <span class="hljs-keyword">private</span> String pageId;    <span class="hljs-comment">//页面名称</span>    <span class="hljs-keyword">private</span> String pageName;    <span class="hljs-comment">//别名</span>    <span class="hljs-keyword">private</span> String pageAliase;    <span class="hljs-comment">//模板id</span>    <span class="hljs-keyword">private</span> String templateId;&#125;</code></pre></div><h3 id="定义响应接口"><a href="#定义响应接口" class="headerlink" title="定义响应接口"></a>定义响应接口</h3><p>在 <code>com.xuecheng.api.cms</code> 下定义 <code>CmsPageControllerApi</code> 查询列表的响应格式统一为 <code>QueryResponseResult</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.cms;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest)</span></span>;&#125;</code></pre></div><h1 id="四、页面查询服务开发"><a href="#四、页面查询服务开发" class="headerlink" title="四、页面查询服务开发"></a>四、页面查询服务开发</h1><h2 id="1-创建CMS服务工程"><a href="#1-创建CMS服务工程" class="headerlink" title="1. 创建CMS服务工程"></a>1. 创建CMS服务工程</h2><p>导入 <code>pom.xml</code> 配置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xc-framework-parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-manage-cms<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-service-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-utils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xc-framework-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>创建一个 <code>xc-service-manage-cms</code> 的maven工程，依赖父工程 <code>xc-framework-parent</code> ，</p><p>创建在 <code>com.xuecheng.manage_cms</code> 包并在包下创建config、dao、service、controller 等包，目录结构如下</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image3.png" srcset="/img/loading.gif" alt></p><p>创建入口文件 <code>ManageCmsApplication</code>，并扫描相应的包</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.domain.EntityScan;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EntityScan</span>(<span class="hljs-string">"com.xuecheng.framework.domain.cms"</span>) <span class="hljs-comment">//扫描公共的实体类</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.api"</span>&#125;) <span class="hljs-comment">//扫描接口</span><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.xuecheng.manage_cms"</span>&#125;)  <span class="hljs-comment">// 扫描本项目下的所有类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManageCmsApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ManageCmsApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p>resources 下创建 <code>application.yml</code></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">31001</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">xc-service-manage-cms</span>  <span class="hljs-attr">data:</span>    <span class="hljs-attr">mongodb:</span>      <span class="hljs-attr">uri:</span> <span class="hljs-string">mongodb://root:123123@localhost:27017</span>      <span class="hljs-attr">database:</span> <span class="hljs-string">xc_cms</span></code></pre></div><p>resources 下导入日志文件，直接复制 <code>资料\CMS配置文件</code> 下的 <code>logback-spring.xml</code></p><h2 id="2-定义dao"><a href="#2-定义dao" class="headerlink" title="2. 定义dao"></a>2. 定义dao</h2><p>在dao下定义一个接口 <code>CmsPageRepository</code> 继承 <code>MongoRepository</code> 类</p><blockquote><p>MongoRepository&lt;CmsPage,String&gt; 中的 CmsPage 对应我们mongodb中集合的实体类</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.dao;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoRepository</span>&lt;<span class="hljs-title">CmsPage</span>,<span class="hljs-title">String</span>&gt; </span>&#123;&#125;</code></pre></div><h2 id="3-单元测试"><a href="#3-单元测试" class="headerlink" title="3. 单元测试"></a>3. 单元测试</h2><h3 id="查询测试"><a href="#查询测试" class="headerlink" title="查询测试"></a>查询测试</h3><p>定义<code>CmsPageRepository</code> 的测试类 <code>CmsPageRepositoryTest</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;<span class="hljs-keyword">import</span> org.springframework.data.domain.PageRequest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@SpringBootTest</span><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">CmsPageRepositoryTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindAll</span><span class="hljs-params">()</span></span>&#123;        List&lt;CmsPage&gt; all = cmsPageRepository.findAll();        System.out.println(all);    &#125;    <span class="hljs-comment">//分页查询</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindPage</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//分页参数</span>        <span class="hljs-keyword">int</span> page = <span class="hljs-number">0</span>; <span class="hljs-comment">//从0开始</span>        <span class="hljs-keyword">int</span> size = <span class="hljs-number">10</span>;        Pageable pageable = PageRequest.of(page,size);        Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(pageable);        System.out.println(all);    &#125;&#125;</code></pre></div><p>运行测试，成功查询到分页数据。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//添加</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//定义实体类</span>    CmsPage cmsPage = <span class="hljs-keyword">new</span> CmsPage();    <span class="hljs-comment">//设置属性</span>    cmsPage.setSiteId(<span class="hljs-string">"s01"</span>);    cmsPage.setTemplateId(<span class="hljs-string">"t01"</span>);    cmsPage.setPageName(<span class="hljs-string">"测试页面"</span>);    cmsPage.setPageCreateTime(<span class="hljs-keyword">new</span> Date());    <span class="hljs-comment">//参数集合</span>    List&lt;CmsPageParam&gt; cmsPageParams = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    CmsPageParam cmsPageParam = <span class="hljs-keyword">new</span> CmsPageParam();    cmsPageParam.setPageParamName(<span class="hljs-string">"param1"</span>);    cmsPageParam.setPageParamValue(<span class="hljs-string">"value1"</span>);    <span class="hljs-comment">//将参数添加至集合内</span>    cmsPageParams.add(cmsPageParam);    <span class="hljs-comment">//实体添加参数集</span>    cmsPage.setPageParams(cmsPageParams);    cmsPageRepository.save(cmsPage);&#125;</code></pre></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span></span>&#123;    cmsPageRepository.deleteById(<span class="hljs-string">"5e705470cc53e4266c135ee7"</span>);    System.out.println(<span class="hljs-string">"删除成功!"</span>);&#125;</code></pre></div><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//修改</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;    Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(<span class="hljs-string">"5e705470cc53e4266c135ee7"</span>);    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;  <span class="hljs-comment">//判断是否为空，jdk1.8新特性optional</span>        CmsPage cmsPage = optional.get();        cmsPage.setPageName(<span class="hljs-string">"测试页面02"</span>);        CmsPage save = cmsPageRepository.save(cmsPage);        System.out.println(<span class="hljs-string">"修改成功 "</span> + save);    &#125;&#125;</code></pre></div><h2 id="4-配置-Service"><a href="#4-配置-Service" class="headerlink" title="4.配置 Service"></a>4.配置 Service</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.service;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.dao.CmsPageRepository;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;<span class="hljs-keyword">import</span> org.springframework.data.domain.PageRequest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CmsPageRepository cmsPageRepository;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页查询</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page,<span class="hljs-keyword">int</span> size,QueryPageRequest queryPageRequest)</span> </span>&#123;        <span class="hljs-comment">//过滤条件</span>        <span class="hljs-keyword">if</span>(page &lt;= <span class="hljs-number">0</span>)&#123;            page = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)&#123;            size = <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">//创建分页查询参数</span>        PageRequest pageable = PageRequest.of(page, size);        <span class="hljs-comment">//分页查询数据</span>        Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(pageable);        <span class="hljs-comment">//整理查询到的数据</span>        QueryResult queryResult = <span class="hljs-keyword">new</span> QueryResult();        queryResult.setList(all.getContent());        queryResult.setTotal(all.getTotalElements());        <span class="hljs-comment">//返回结果</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);    &#125;&#125;</code></pre></div><h2 id="5-配置-Controller"><a href="#5-配置-Controller" class="headerlink" title="5. 配置 Controller"></a>5. 配置 Controller</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.manage_cms.web.controller;<span class="hljs-keyword">import</span> com.xuecheng.api.cms.CmsPageControllerApi;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.CmsPage;<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.cms.request.QueryPageRequest;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.CommonCode;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResponseResult;<span class="hljs-keyword">import</span> com.xuecheng.framework.model.response.QueryResult;<span class="hljs-keyword">import</span> com.xuecheng.manage_cms.service.PageService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/cms/page"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CmsPageController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    PageService pageService;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list/&#123;page&#125;/&#123;size&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"page"</span>)</span> <span class="hljs-keyword">int</span> page, @<span class="hljs-title">PathVariable</span><span class="hljs-params">(<span class="hljs-string">"size"</span>)</span> <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest) </span>&#123;        <span class="hljs-keyword">return</span> pageService.findList(page,size,queryPageRequest);    &#125;&#125;</code></pre></div><h2 id="6-接口开发规范"><a href="#6-接口开发规范" class="headerlink" title="6.接口开发规范"></a>6.接口开发规范</h2><h3 id="Api请求及响应规范"><a href="#Api请求及响应规范" class="headerlink" title="Api请求及响应规范"></a>Api请求及响应规范</h3><p>为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。</p><ul><li><code>get</code> 请求时，采用key/value格式请求，SpringMVC可采用基本类型的变量接收，也可以采用对象接收。</li><li><code>Post</code> 请求时，可以提交form表单数据（application/x-www-form-urlencoded）和 <code>Json</code> 数据（Content-Type=application/json），文件等多部件类型（multipart/form-data）三种数据格式，SpringMVC接收Json数据使用@RequestBody注解解析请求的json数据。</li><li>响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。</li><li>响应结果统一格式为 <code>json</code>。</li></ul><h3 id="Api定义约束"><a href="#Api定义约束" class="headerlink" title="Api定义约束"></a>Api定义约束</h3><p>Api 定义使用SpringMVC来完成，由于此接口后期将作为微服务远程调用使用，在定义接口时有如下限制：</p><ul><li><code>@PathVariable</code> 统一指定参数名称，如：<code>@PathVariable(&quot;id&quot;)</code></li><li><code>@RequestParam</code> 统一指定参数名称，如：<code>@RequestParam(&quot;id&quot;)</code></li></ul><h1 id="五、Swagger-生成接口文档"><a href="#五、Swagger-生成接口文档" class="headerlink" title="五、Swagger 生成接口文档"></a>五、Swagger 生成接口文档</h1><h2 id="1-Swagger介绍"><a href="#1-Swagger介绍" class="headerlink" title="1. Swagger介绍"></a>1. Swagger介绍</h2><p>OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程，目前版本是V3.0，并且已经发布并开源在github上。<a href="https://github.com/OAI/OpenAPI-Specification" target="_blank" rel="noopener">https://github.com/OAI/OpenAPI-Specification</a></p><p>Swagger是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发。 (<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a>)</p><p>Spring Boot 可以集成Swagger，生成Swagger接口，Spring Boot是Java领域的神器，它是Spring项目下快速构建项目的框架。</p><h2 id="2-开启-Swagger"><a href="#2-开启-Swagger" class="headerlink" title="2. 开启 Swagger"></a>2. 开启 Swagger</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.api.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;<span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;<span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<span class="hljs-comment">//</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Configuration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.xuecheng"</span>))                .paths(PathSelectors.any())                .build();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()                .title(<span class="hljs-string">"学成网api文档"</span>)                .description(<span class="hljs-string">"学成网api文档"</span>)<span class="hljs-comment">//                .termsOfServiceUrl("/")</span>                .version(<span class="hljs-string">"1.0"</span>)                .build();    &#125;&#125;</code></pre></div><p>开启 <code>swagger</code> 后，它会自动扫描 <code>com.xuecheng</code> 包下所有标记了 <code>@RestController</code> 这个注解的类，根据这个类的方法来生成接口文档。</p><p>运行项目，访问 <a href="http://localhost:31001/swagger-ui.html" target="_blank" rel="noopener">http://localhost:31001/swagger-ui.html</a> 就可以看到我们刚才定义的这个 controller</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image4.png" srcset="/img/loading.gif" alt="image-20200317171117409.png"></p><h2 id="3-Swagger常用注解"><a href="#3-Swagger常用注解" class="headerlink" title="3. Swagger常用注解"></a>3. Swagger常用注解</h2><p>在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下：</p><ul><li>@Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口</li><li>@ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiModelProperty：用对象接收参数时，描述对象的一个字段</li><li>@ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述</li><li>@ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息</li><li>@ApiImplicitParam：一个请求参数</li><li>@ApiImplicitParams：多个请求参数</li><li>@ApiImplicitParam属性：</li></ul><table><thead><tr><th>属性</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>paramType</td><td>查询参数类型</td><td></td></tr><tr><td>path</td><td>以地址的形式提交数据</td><td></td></tr><tr><td>query</td><td>直接跟参数完成自动映射赋值</td><td></td></tr><tr><td>body</td><td>以流的形式提交 仅支持POST</td><td></td></tr><tr><td>header</td><td>参数在request headers 里边提交</td><td></td></tr><tr><td>form</td><td>以form表单的形式提交 仅支持POST</td><td></td></tr><tr><td>dataType</td><td>参数的数据类型 只作为标志说明，并没有实际验证</td><td></td></tr><tr><td>Long</td><td></td><td></td></tr><tr><td>String</td><td></td><td></td></tr><tr><td>name</td><td>接收参数名</td><td></td></tr><tr><td>value</td><td>接收参数的意义描述</td><td></td></tr><tr><td>required</td><td>参数是否必填</td><td></td></tr><tr><td>true</td><td>必填</td><td></td></tr><tr><td>false</td><td>非必填</td><td></td></tr><tr><td>defaultValue</td><td>默认值</td><td></td></tr></tbody></table><h2 id="4-Swagger接口定义"><a href="#4-Swagger接口定义" class="headerlink" title="4. Swagger接口定义"></a>4. Swagger接口定义</h2><p>使用 swagger 的常用注解来描述接口信息</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询接口</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Api</span>(value=<span class="hljs-string">"cms页面管理接口"</span>,description = <span class="hljs-string">"cms页面管理接口，提供页面的增、删、改、查"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CmsPageControllerApi</span> </span>&#123;    <span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"分页查询页面列表"</span>)    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"page"</span>,value = <span class="hljs-string">"页码"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"path"</span>,dataType=<span class="hljs-string">"int"</span>),        <span class="hljs-meta">@ApiImplicitParam</span>(name=<span class="hljs-string">"size"</span>,value = <span class="hljs-string">"每页记录数"</span>,required=<span class="hljs-keyword">true</span>,paramType=<span class="hljs-string">"path"</span>,dataType=<span class="hljs-string">"int"</span>)    &#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> QueryResponseResult <span class="hljs-title">findList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> page, <span class="hljs-keyword">int</span> size, QueryPageRequest queryPageRequest)</span></span>;&#125;</code></pre></div><p>在QueryPageRequest类中使用注解 ApiModelProperty 对属性注释</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPageRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestData</span> </span>&#123;    <span class="hljs-comment">//站点id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"站点id"</span>)    <span class="hljs-keyword">private</span> String siteId;    <span class="hljs-comment">//页面ID</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面ID"</span>)    <span class="hljs-keyword">private</span> String pageId;    <span class="hljs-comment">//页面名称</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面名称"</span>)    <span class="hljs-keyword">private</span> String pageName;    <span class="hljs-comment">//页面别名</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"页面别名"</span>)    <span class="hljs-keyword">private</span> String pageAliase;    <span class="hljs-comment">//模版id</span>    <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"模版id"</span>)    <span class="hljs-keyword">private</span> String templateId;&#125;</code></pre></div><p>重启项目，访问 <a href="http://localhost:31001/swagger-ui.html" target="_blank" rel="noopener">http://localhost:31001/swagger-ui.html</a> ，可以看到我们添加的描述信息</p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image5.png" srcset="/img/loading.gif" alt></p><h1 id="五、Postman-基本使用"><a href="#五、Postman-基本使用" class="headerlink" title="五、Postman 基本使用"></a>五、Postman 基本使用</h1><p><code>Postman</code> 是一款功能强大的http接口测试工具，使用 <code>postman</code> 可以完成 <code>http</code> 各种请求的功能测试。</p><p>官方地址：<a href="https://www.getpostman.com/" target="_blank" rel="noopener">https://www.getpostman.com/</a></p><p><img src="/2020/08/08/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday01/image6.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>学成在线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>Swagger</tag>
      
      <tag>Postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB入门</title>
    <link href="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB入门"><a href="#MongoDB入门" class="headerlink" title="MongoDB入门"></a>MongoDB入门</h1><h2 id="1-mongodb介绍"><a href="#1-mongodb介绍" class="headerlink" title="1.mongodb介绍"></a>1.mongodb介绍</h2><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/1.png" srcset="/img/loading.gif" alt></p><h2 id="2-下载mongodb"><a href="#2-下载mongodb" class="headerlink" title="2.下载mongodb"></a>2.下载mongodb</h2><p>typora-copy-images-to:mongodb_imgmongodb安装1mongodb介绍2下载mongodbMongoDB提供了可用于32位和64位系统的预编译二进制包，你可以从MongoDB官网下载安装。官方地址：<a href="https://www.mongodb.com/本教程下载3.4版本http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi" target="_blank" rel="noopener">https://www.mongodb.com/本教程下载3.4版本http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi</a></p><h2 id="3-安装mongodb"><a href="#3-安装mongodb" class="headerlink" title="3.安装mongodb"></a>3.安装mongodb</h2><p>在win7系统安装mongodb需要vc++运行库，如果没有则会提示“无法启动此程序，因为计算机中丢失VCRUNTIME140.dll”。去网上下载或使用360安装：</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/2.png" srcset="/img/loading.gif" alt></p><p>运行mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/3.png" srcset="/img/loading.gif" alt></p><p>选择自定义路径</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/4.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/5.png" srcset="/img/loading.gif" alt></p><h2 id="4-启动mongodb"><a href="#4-启动mongodb" class="headerlink" title="4.启动mongodb"></a>4.启动mongodb</h2><p>创建几个文件夹具体如下：数据库路径（data目录）、日志路径（logs目录）和日志文件（mongo.log文件）</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/6.png" srcset="/img/loading.gif" alt></p><p>创建配置文件mongo.conf，文件内容如下:</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#数据库路径</span><span class="hljs-attr">dbpath</span>=<span class="hljs-string">d:\MongoDB\Server\3.4\data</span><span class="hljs-comment">#日志输出文件路径</span><span class="hljs-attr">logpath</span>=<span class="hljs-string">d:\MongoDB\Server\3.4\logs\mongo.log</span><span class="hljs-comment">#错误日志采用追加模式</span><span class="hljs-attr">logappend</span>=<span class="hljs-string">true</span><span class="hljs-comment">#启用日志文件，默认启用</span><span class="hljs-attr">journal</span>=<span class="hljs-string">true</span><span class="hljs-comment">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><span class="hljs-attr">quiet</span>=<span class="hljs-string">true</span><span class="hljs-comment">#端口号默认为27017</span><span class="hljs-attr">port</span>=<span class="hljs-string">27017</span></code></pre></div><p>注意如果出现服务启动失败，或者遇到特点错误100情况 第一种情况是dbpath后有多余空格，第二种情况是其他参数后面带有空格（亲测被坑</p><p>安装MongoDB服务通过执行bin/mongod.exe，使用–install选项来安装服务，使用–config选项来指定之前创建的配置文件。cmd进入d:\MongoDB\Server\3.4\bin</p><div class="hljs"><pre><code class="hljs shell">mongod.exe‐‐config"d:\MongoDB\Server\3.4\mongo.conf"‐‐install</code></pre></div><p>启动MongoDB服务</p><div class="hljs"><pre><code class="hljs shell">net start MongoDB</code></pre></div><p>关闭MongoDB服务</p><div class="hljs"><pre><code class="hljs shell">net stop MongoDB</code></pre></div><p>移除MongoDB服务</p><div class="hljs"><pre><code class="hljs shell">"d:\MongoDB\Server\3.4\bin\mongod.exe"‐‐remove</code></pre></div><p>启动mongodb服务，命令执行后，浏览器中输入<a href="http://127.0.0.1:27017" target="_blank" rel="noopener">http://127.0.0.1:27017</a></p><p>看到如下界面即说明启动成功</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/7.png" srcset="/img/loading.gif" alt></p><h2 id="5-安装studio3t"><a href="#5-安装studio3t" class="headerlink" title="5.安装studio3t"></a>5.安装studio3t</h2><p>studio3t是mongodb优秀的客户端工具(类似sqlyog操作mysql的工具）。官方地址在<a href="https://studio3t.com/" target="_blank" rel="noopener">https://studio3t.com/</a></p><p>下载最新版即可</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/8.png" srcset="/img/loading.gif" alt></p><p>下载默认安装后，会提示需要账号秘密，可直接点击完成，跳过 默认为试用版</p><p>创建一个新连接：</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/9.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/10.png" srcset="/img/loading.gif" alt></p><p>填写连接信息：（可不需要mangodb账号秘密直接连接）</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/11.png" srcset="/img/loading.gif" alt></p><p>连接成功：</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/12.png" srcset="/img/loading.gif" alt></p><h2 id="6-mongodb入门"><a href="#6-mongodb入门" class="headerlink" title="6.mongodb入门"></a>6.mongodb入门</h2><h3 id="6-1基础概念"><a href="#6-1基础概念" class="headerlink" title="6.1基础概念"></a>6.1基础概念</h3><p>在mongodb中是通过数据库、集合、文档的方式来管理数据，下边是mongodb与关系数据库的一些概念对比：</p><table><thead><tr><th align="center">SQL术语/概念</th><th align="center">MongoDB术语/概念</th><th align="left">解释/说明</th></tr></thead><tbody><tr><td align="center">database</td><td align="center">database</td><td align="left">数据库</td></tr><tr><td align="center">table</td><td align="center">collection</td><td align="left">数据库表/集合</td></tr><tr><td align="center">row</td><td align="center">document</td><td align="left">数据记录行/文档</td></tr><tr><td align="center">column</td><td align="center">field</td><td align="left">数据字段/域</td></tr><tr><td align="center">index</td><td align="center">index</td><td align="left">索引</td></tr><tr><td align="center">table joins</td><td align="center"></td><td align="left">表连接（MongoDB不支持）</td></tr><tr><td align="center">primary key</td><td align="center">primary key</td><td align="left">主键,MongoDB自动在每个集合中添加_id的主键</td></tr></tbody></table><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/13.png" srcset="/img/loading.gif" alt></p><p>1、一个mongodb实例可以创建多个数据库</p><p>2、一个数据库可以创建多个集合</p><p>3、一个集合可以包括多个文档。</p><h3 id="6-2连接mongodb"><a href="#6-2连接mongodb" class="headerlink" title="6.2连接mongodb"></a>6.2连接mongodb</h3><p>mongodb的使用方式是客户服务器模式，即使用一个客户端连接mongodb数据库（服务端）。</p><p>1、命令格式</p><div class="hljs"><pre><code class="hljs shell">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code></pre></div><p>mongodb://固定前缀</p><p>username：账号，可不填</p><p>password：密码，可不填</p><p>host：主机名或ip地址，只有host主机名为必填项。</p><p>port：端口，可不填，默认27017</p><p>/database：连接某一个数据库</p><p>?options：连接参数，key/value对</p><p>例子：</p><div class="hljs"><pre><code class="hljs shell">mongodb://localhost连接本地数据库27017端口mongodb://root:itcast@localhost使用用户名root密码为itcast连接本地数据库27017端口mongodb://localhost,localhost:27018,localhost:27019，连接三台主从服务器，端口为27017、27018、27019</code></pre></div><p>2、使用mongodb自带的javascriptshell（mongo.exe）连接</p><p>windows版本的mongodb安装成功，在安装目录下的bin目录有mongo.exe客户端程序</p><p>cmd状态执行mongo.exe:</p><p><img src="/2020/08/06/MongoDB%E5%85%A5%E9%97%A8/14.png" srcset="/img/loading.gif" alt></p><p>此时就可以输入命令来操作mongodb数据库了，javascriptshell可以运行javascript程序。</p><p>3、使用studio3T连接</p><p>4、使用java程序连接</p><p>详细参数：<a href="http://mongodb.github.io/mongo-java-driver/3.4/driver/tutorials/connect-to-mongodb/" target="_blank" rel="noopener">http://mongodb.github.io/mongo-java-driver/3.4/driver/tutorials/connect-to-mongodb/</a></p><p>添加依赖：</p><div class="hljs"><pre><code class="hljs java">&lt;dependency&gt;&lt;groupId&gt;org.mongodb&lt;/groupId&gt;&lt;artifactId&gt;mongo‐java‐driver&lt;/artifactId&gt;&lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></div><p>测试程序：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testConnection</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//创建mongodb客户端</span>    MongoClientmongoClient=newMongoClient(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">27017</span>);    <span class="hljs-comment">//或者采用连接字符串</span>    <span class="hljs-comment">//MongoClientURIconnectionString=newMongoClientURI("mongodb://root:root@localhost:27017");</span>    <span class="hljs-comment">//MongoClientmongoClient=newMongoClient(connectionString);</span>    <span class="hljs-comment">//连接数据库</span>    MongoDatabasedatabase=mongoClient.getDatabase(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">//连接collectionMongo</span>    Collection&lt;Document&gt;collection=database.getCollection(<span class="hljs-string">"student"</span>);    <span class="hljs-comment">//查询第一个文档</span>    DocumentmyDoc=collection.find().first();    <span class="hljs-comment">//得到文件内容json串</span>    Stringjson=myDoc.toJson();System.out.println(json);&#125;</code></pre></div><h3 id="6-3数据库"><a href="#6-3数据库" class="headerlink" title="6.3数据库"></a>6.3数据库</h3><p>1、查询数据库</p><p>showv dbs 查询全部数据库</p><p>db 显示当前数据库</p><p>2、创建数据库命令格式：</p><div class="hljs"><pre><code class="hljs shell">useDATABASE_NAME</code></pre></div><p>例子：</p><p>usetest02</p><p>有test02数据库则切换到此数据库，没有则创建</p><p>注意：</p><p>新创建的数据库不显示，需要至少包括一个集合。</p><p>3、删除数据库（慎用！！！）</p><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.dropDatabase()</code></pre></div><p>例子：</p><p>删除test02数据库</p><p>先切换数据库：usetest02</p><p>再执行删除：db.dropDatabase()</p><h3 id="6-4集合"><a href="#6-4集合" class="headerlink" title="6.4集合"></a>6.4集合</h3><p>集合相当于关系数据库中的表，一个数据库可以创建多个集合，一个集合是将相同类型的文档管理起来。</p><p>1、创建集合</p><div class="hljs"><pre><code class="hljs shel">db.createCollection(name,options)name: 新创建的集合名称options: 创建参数</code></pre></div><p>2.删除集合</p><div class="hljs"><pre><code class="hljs shell">db.collection.drop()例子：db.student.drop() 删除student集合</code></pre></div><h3 id="6-5文档"><a href="#6-5文档" class="headerlink" title="6.5文档"></a>6.5文档</h3><h4 id="6-5-1插入文档"><a href="#6-5-1插入文档" class="headerlink" title="6.5.1插入文档"></a>6.5.1插入文档</h4><p>mongodb中文档的格式是json格式，下边就是一个文档，包括两个key：_id主键和name</p><div class="hljs"><pre><code class="hljs shell">&#123;"_id":ObjectId("5b2cc4bfa6a44812707739b5"),"name":"黑马程序员"&#125;</code></pre></div><p>插入命令：</p><div class="hljs"><pre><code class="hljs shell">db.COLLECTION_NAME.insert(document)</code></pre></div><p>每个文档默认以_id作为主键，主键默认类型为ObjectId（对象类型），mongodb会自动生成主键值。</p><p>例子：</p><div class="hljs"><pre><code class="hljs shell">db.student.insert(&#123;"name":"黑马程序员","age":10&#125;)</code></pre></div><p>注意：同一个集合中的文档的key可以不相同！但是建议设置为相同的</p><h4 id="6-5-2更新文档"><a href="#6-5-2更新文档" class="headerlink" title="6.5.2更新文档"></a>6.5.2更新文档</h4><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.collection.update(&lt;query&gt;,&lt;update&gt;,&lt;options&gt;)query:查询条件，相当于sql语句的whereupdate：更新文档内容options：选项</code></pre></div><p>1、替换文档</p><p>将符合条件”name”:”北京黑马程序”的第一个文档替换为{“name”:”北京黑马程序员”,”age”:10}</p><div class="hljs"><pre><code class="hljs shell">db.student.update(&#123;"name":"黑马程序员"&#125;,&#123;"name":"北京黑马程序员","age":10&#125;)</code></pre></div><p>2、$set修改器</p><p>使用$set修改器指定要更新的key，key不存在则创建，存在则更新。</p><p>将符合条件”name”:”北京黑马程序”的所有文档更新name和age的值。</p><div class="hljs"><pre><code class="hljs shell">db.student.update(&#123;"name":"黑马程序员"&#125;,&#123;$set:&#123;"name":"北京黑马程序员","age":10&#125;&#125;,&#123;multi:true&#125;)</code></pre></div><p>multi：false表示更新第一个匹配的文档，true表示更新所有匹配的文档</p><h4 id="6-5-3删除文档"><a href="#6-5-3删除文档" class="headerlink" title="6.5.3删除文档"></a>6.5.3删除文档</h4><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.student.remove(&lt;query&gt;)query：删除条件，相当于sql语句中的where</code></pre></div><p>1、删除所有文档</p><p>db.student.remove({})</p><p>2、删除符合条件的文档</p><p>db.student.remove({“name”:”黑马程序员”})</p><h4 id="6-5-4查询文档"><a href="#6-5-4查询文档" class="headerlink" title="6.5.4查询文档"></a>6.5.4查询文档</h4><p>命令格式：</p><div class="hljs"><pre><code class="hljs shell">db.collection.find(query,projection)query：查询条件，可不填projection：投影查询key，可不填</code></pre></div><p>1、查询全部</p><div class="hljs"><pre><code class="hljs shell">db.student.find()</code></pre></div><p>2、查询符合条件的记录</p><p>查询name等为”黑马程序员”的文档。</p><div class="hljs"><pre><code class="hljs shell">db.student.find(&#123;"name":"黑马程序员"&#125;)</code></pre></div><p>3、投影查询</p><p>只显示name和age两个key，_id主键不显示。</p><div class="hljs"><pre><code class="hljs shell">db.student.find(&#123;"name":"黑马程序员"&#125;,&#123;name:1,age:1,_id:0&#125;)</code></pre></div><h3 id="6-6用户"><a href="#6-6用户" class="headerlink" title="6.6用户"></a>6.6用户</h3><h4 id="6-6-1创建用户"><a href="#6-6-1创建用户" class="headerlink" title="6.6.1创建用户"></a>6.6.1创建用户</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs json">mongo&gt;db.createUser(    &#123;user:"&lt;name&gt;",     pwd:"&lt;cleartextpassword&gt;",customData:&#123;&lt;anyinformation&gt;&#125;,     roles:[         &#123;role:"&lt;role&gt;",db:"&lt;database&gt;"&#125;|"&lt;role&gt;",         ...     ]&#125;)</code></pre></div><p>例子：</p><p>创建root用户，角色为root</p><div class="hljs"><pre><code class="hljs json">use admindb.createUser(    &#123;        user:"root",        pwd:"root",        roles:[&#123;role:"root",db:"admin"&#125;]    &#125;)</code></pre></div><p>内置角色如下：</p><p>1.数据库用户角色：read、readWrite;</p><p>2.数据库管理角色：dbAdmin、dbOwner、userAdmin;</p><p>3.集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</p><p>4.备份恢复角色：backup、restore；</p><p>5.所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</p><p>6.超级用户角色：root</p><h4 id="6-6-2查询用户"><a href="#6-6-2查询用户" class="headerlink" title="6.6.2查询用户"></a>6.6.2查询用户</h4><p>查询当前库下的所有用户：</p><div class="hljs"><pre><code class="hljs shell">show users</code></pre></div><h4 id="6-6-3删除用户"><a href="#6-6-3删除用户" class="headerlink" title="6.6.3删除用户"></a>6.6.3删除用户</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs shell">db.dropUser("用户名")</code></pre></div><p>例子：</p><p>删除root1用户</p><div class="hljs"><pre><code class="hljs shell">db.dropUser("root1")</code></pre></div><h4 id="6-6-4修改用户"><a href="#6-6-4修改用户" class="headerlink" title="6.6.4修改用户"></a>6.6.4修改用户</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs json">db.updateUser(    "&lt;username&gt;",    &#123;customData:&#123;&lt;anyinformation&gt;&#125;,     roles:[         &#123;role:"&lt;role&gt;",db:"&lt;database&gt;"&#125;|"&lt;role&gt;",         ...     ],         pwd:"&lt;cleartextpassword&gt;"         &#125;,         writeConcern:&#123;&lt;writeconcern&gt;&#125;)</code></pre></div><p>例子:</p><p>修改root用户的角色为readWriteAnyDatabase</p><div class="hljs"><pre><code class="hljs shell">use admindb.updateUser("root",&#123;roles:[&#123;role:"readWriteAnyDatabase",db:"admin"&#125;]&#125;)</code></pre></div><h4 id="6-6-5修改密码"><a href="#6-6-5修改密码" class="headerlink" title="6.6.5修改密码"></a>6.6.5修改密码</h4><p>语法格式：</p><div class="hljs"><pre><code class="hljs shell">db.changeUserPassword("username","newPasswd")</code></pre></div><p>例子：</p><p>修改root用户的密码为123</p><div class="hljs"><pre><code class="hljs shell">use admindb.changeUserPassword("root","123")</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义starter</title>
    <link href="/2020/08/04/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2020/08/04/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h1><p>starter：</p><p>​    1、这个场景需要使用到的依赖是什么？</p><p>​    2、如何编写自动配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//指定这个类是一个配置类</span><span class="hljs-meta">@ConditionalOnXXX</span>  <span class="hljs-comment">//在指定条件成立的情况下自动配置类生效</span><span class="hljs-meta">@AutoConfigureAfter</span>  <span class="hljs-comment">//指定自动配置类的顺序</span><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//给容器中添加组件</span><span class="hljs-meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置<span class="hljs-meta">@EnableConfigurationProperties</span> <span class="hljs-comment">//让xxxProperties生效加入到容器中</span>自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</code></pre></div><p>​    3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><h2 id="1）、启动器模块"><a href="#1）、启动器模块" class="headerlink" title="1）、启动器模块"></a>1）、启动器模块</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-comment">&lt;!--启动器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--引入自动配置模块--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h2 id="2）、自动配置模块"><a href="#2）、自动配置模块" class="headerlink" title="2）、自动配置模块"></a>2）、自动配置模块</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.starter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"atguigu.hello"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String prefix;    <span class="hljs-keyword">private</span> String suffix;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> prefix;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrefix</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-keyword">this</span>.prefix = prefix;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSuffix</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> suffix;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuffix</span><span class="hljs-params">(String suffix)</span> </span>&#123;        <span class="hljs-keyword">this</span>.suffix = suffix;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;    HelloProperties helloProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloProperties <span class="hljs-title">getHelloProperties</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> helloProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHelloProperties</span><span class="hljs-params">(HelloProperties helloProperties)</span> </span>&#123;        <span class="hljs-keyword">this</span>.helloProperties = helloProperties;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHellAtguigu</span><span class="hljs-params">(String name)</span></span>&#123;        <span class="hljs-keyword">return</span> helloProperties.getPrefix()+<span class="hljs-string">"-"</span> +name + helloProperties.getSuffix();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.starter;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span> <span class="hljs-comment">//web应用才生效</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HelloProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">HelloServiceAutoConfiguration</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HelloProperties helloProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>&#123;        HelloService service = <span class="hljs-keyword">new</span> HelloService();        service.setHelloProperties(helloProperties);        <span class="hljs-keyword">return</span> service;    &#125;&#125;</code></pre></div><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot启动配置原理</title>
    <link href="/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="启动配置原理"><a href="#启动配置原理" class="headerlink" title="启动配置原理"></a>启动配置原理</h1><p>几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><p><strong>SpringApplicationRunListener</strong></p><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><p><strong>CommandLineRunner</strong></p><p>启动流程：</p><h2 id="1、创建SpringApplication对象"><a href="#1、创建SpringApplication对象" class="headerlink" title="1、创建SpringApplication对象"></a><strong>1、创建SpringApplication对象</strong></h2><div class="hljs"><pre><code class="hljs java">initialize(sources);<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Object[] sources)</span> </span>&#123;    <span class="hljs-comment">//保存主配置类</span>    <span class="hljs-keyword">if</span> (sources != <span class="hljs-keyword">null</span> &amp;&amp; sources.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.sources.addAll(Arrays.asList(sources));    &#125;    <span class="hljs-comment">//判断当前是否一个web应用</span>    <span class="hljs-keyword">this</span>.webEnvironment = deduceWebEnvironment();    <span class="hljs-comment">//从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span>    setInitializers((Collection) getSpringFactoriesInstances(        ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener</span>    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//从多个配置类中找到有main方法的主配置类</span>    <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();&#125;</code></pre></div><p><img src="/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145727.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/04/SpringBoot%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145855.png" srcset="/img/loading.gif" alt></p><h2 id="2、运行run方法"><a href="#2、运行run方法" class="headerlink" title="2、运行run方法"></a>2、运行run方法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();   stopWatch.start();   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;   FailureAnalyzers analyzers = <span class="hljs-keyword">null</span>;   configureHeadlessProperty();       <span class="hljs-comment">//获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories</span>   SpringApplicationRunListeners listeners = getRunListeners(args);    <span class="hljs-comment">//回调所有的获取SpringApplicationRunListener.starting()方法</span>   listeners.starting();   <span class="hljs-keyword">try</span> &#123;       <span class="hljs-comment">//封装命令行参数</span>      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(            args);      <span class="hljs-comment">//准备环境</span>      ConfigurableEnvironment environment = prepareEnvironment(listeners,            applicationArguments);       <span class="hljs-comment">//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span>             Banner printedBanner = printBanner(environment);              <span class="hljs-comment">//创建ApplicationContext；决定创建web的ioc还是普通的ioc</span>      context = createApplicationContext();             analyzers = <span class="hljs-keyword">new</span> FailureAnalyzers(context);       <span class="hljs-comment">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span>       <span class="hljs-comment">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span>       <span class="hljs-comment">//回调所有的SpringApplicationRunListener的contextPrepared()；</span>       <span class="hljs-comment">//</span>      prepareContext(context, environment, listeners, applicationArguments,            printedBanner);       <span class="hljs-comment">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；</span>              <span class="hljs-comment">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span>       <span class="hljs-comment">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span>      refreshContext(context);       <span class="hljs-comment">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span>       <span class="hljs-comment">//ApplicationRunner先回调，CommandLineRunner再回调</span>      afterRefresh(context, applicationArguments);       <span class="hljs-comment">//所有的SpringApplicationRunListener回调finished方法</span>      listeners.finished(context, <span class="hljs-keyword">null</span>);      stopWatch.stop();      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass)               .logStarted(getApplicationLog(), stopWatch);      &#125;       <span class="hljs-comment">//整个SpringBoot应用启动完成以后返回启动的ioc容器；</span>      <span class="hljs-keyword">return</span> context;   &#125;   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      handleRunFailure(context, listeners, analyzers, ex);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);   &#125;&#125;</code></pre></div><h2 id="3、事件监听机制"><a href="#3、事件监听机制" class="headerlink" title="3、事件监听机制"></a>3、事件监听机制</h2><p>配置在META-INF/spring.factories</p><p><strong>ApplicationContextInitializer</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextInitializer</span>&lt;<span class="hljs-title">ConfigurableApplicationContext</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;        System.out.println(<span class="hljs-string">"ApplicationContextInitializer...initialize..."</span>+applicationContext);    &#125;&#125;</code></pre></div><p><strong>SpringApplicationRunListener</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloSpringApplicationRunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SpringApplicationRunListener</span> </span>&#123;    <span class="hljs-comment">//必须有的构造器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloSpringApplicationRunListener</span><span class="hljs-params">(SpringApplication application, String[] args)</span></span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">starting</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...starting..."</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">environmentPrepared</span><span class="hljs-params">(ConfigurableEnvironment environment)</span> </span>&#123;        Object o = environment.getSystemProperties().get(<span class="hljs-string">"os.name"</span>);        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...environmentPrepared.."</span>+o);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...contextPrepared..."</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoaded</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...contextLoaded..."</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;        System.out.println(<span class="hljs-string">"SpringApplicationRunListener...finished..."</span>);    &#125;&#125;</code></pre></div><p>配置（META-INF/spring.factories）</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="hljs-string">\</span><span class="hljs-attr">com.atguigu.springboot.listener.HelloApplicationContextInitializer</span><span class="hljs-meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="hljs-string">\</span><span class="hljs-attr">com.atguigu.springboot.listener.HelloSpringApplicationRunListener</span></code></pre></div><p>只需要放在ioc容器中</p><p><strong>ApplicationRunner</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"ApplicationRunner...run...."</span>);    &#125;&#125;</code></pre></div><p><strong>CommandLineRunner</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"CommandLineRunner...run..."</span>+ Arrays.asList(args));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot与数据访问</title>
    <link href="/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"/>
    <url>/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot与数据访问"><a href="#SpringBoot与数据访问" class="headerlink" title="SpringBoot与数据访问"></a>SpringBoot与数据访问</h1><h2 id="1、JDBC"><a href="#1、JDBC" class="headerlink" title="1、JDBC"></a>1、JDBC</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://192.168.15.22:3306/jdbc</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span></code></pre></div><p>效果：</p><p>​    默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><p>​    数据源的相关配置都在DataSourceProperties里面；</p><p>自动配置原理：</p><p>org.springframework.boot.autoconfigure.jdbc：</p><p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p><p>2、SpringBoot默认可以支持；</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DataSource</span>、<span class="hljs-selector-tag">HikariDataSource</span>、<span class="hljs-selector-tag">BasicDataSource</span>、</code></pre></div><p>3、自定义数据源类型</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Generic DataSource configuration.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(DataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">name</span> </span>= <span class="hljs-string">"spring.datasource.type"</span>)<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span> </span>&#123;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(DataSourceProperties properties)</span> </span>&#123;       <span class="hljs-comment">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span>      <span class="hljs-keyword">return</span> properties.initializeDataSourceBuilder().build();   &#125;&#125;</code></pre></div><p>4、<strong>DataSourceInitializer：ApplicationListener</strong>；</p><p>​    作用：</p><p>​        1）、runSchemaScripts();运行建表语句；</p><p>​        2）、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-attr">schema-*.sql、data-*.sql</span><span class="hljs-attr">默认规则：schema.sql，schema-all.sql；</span><span class="hljs-meta">可以使用</span>   <span class="hljs-string"></span><span class="hljs-attr">schema</span>:<span class="hljs-string"></span>      <span class="hljs-meta">-</span> <span class="hljs-string">classpath:department.sql</span>      <span class="hljs-attr">指定位置</span></code></pre></div><p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p><h2 id="2、整合Druid数据源"><a href="#2、整合Druid数据源" class="headerlink" title="2、整合Druid数据源"></a>2、整合Druid数据源</h2><div class="hljs"><pre><code class="hljs java">导入druid数据源<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druid</span><span class="hljs-params">()</span></span>&#123;       <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-comment">//配置Druid的监控</span>    <span class="hljs-comment">//1、配置一个管理后台的Servlet</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span></span>&#123;        ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/*"</span>);        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        initParams.put(<span class="hljs-string">"loginUsername"</span>,<span class="hljs-string">"admin"</span>);        initParams.put(<span class="hljs-string">"loginPassword"</span>,<span class="hljs-string">"123456"</span>);        initParams.put(<span class="hljs-string">"allow"</span>,<span class="hljs-string">""</span>);<span class="hljs-comment">//默认就是允许所有访问</span>        initParams.put(<span class="hljs-string">"deny"</span>,<span class="hljs-string">"192.168.15.21"</span>);        bean.setInitParameters(initParams);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-comment">//2、配置一个web监控的filter</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span></span>&#123;        FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();        bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());        Map&lt;String,String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        initParams.put(<span class="hljs-string">"exclusions"</span>,<span class="hljs-string">"*.js,*.css,/druid/*"</span>);        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));        <span class="hljs-keyword">return</span>  bean;    &#125;&#125;</code></pre></div><h2 id="3、整合MyBatis"><a href="#3、整合MyBatis" class="headerlink" title="3、整合MyBatis"></a>3、整合MyBatis</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><img src="/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180305194443.png" srcset="/img/loading.gif" alt></p><p>步骤：</p><p>​    1）、配置数据源相关属性（见上一节Druid）</p><p>​    2）、给数据库建表</p><p>​    3）、创建JavaBean</p><h3 id="4）、注解版"><a href="#4）、注解版" class="headerlink" title="4）、注解版"></a>4）、注解版</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//指定这是一个操作数据库的mapper</span><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DepartmentMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from department where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Department <span class="hljs-title">getDeptById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Delete</span>(<span class="hljs-string">"delete from department where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deleteDeptById</span><span class="hljs-params">(Integer id)</span></span>;    <span class="hljs-meta">@Options</span>(useGeneratedKeys = <span class="hljs-keyword">true</span>,keyProperty = <span class="hljs-string">"id"</span>)    <span class="hljs-meta">@Insert</span>(<span class="hljs-string">"insert into department(departmentName) values(#&#123;departmentName&#125;)"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insertDept</span><span class="hljs-params">(Department department)</span></span>;    <span class="hljs-meta">@Update</span>(<span class="hljs-string">"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateDept</span><span class="hljs-params">(Department department)</span></span>;&#125;</code></pre></div><p>问题：</p><p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurationCustomizer <span class="hljs-title">configurationCustomizer</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConfigurationCustomizer()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(Configuration configuration)</span> </span>&#123;                configuration.setMapUnderscoreToCamelCase(<span class="hljs-keyword">true</span>);            &#125;        &#125;;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java">使用MapperScan批量扫描所有的Mapper接口；<span class="hljs-meta">@MapperScan</span>(value = <span class="hljs-string">"com.atguigu.springboot.mapper"</span>)<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBoot06DataMybatisApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(SpringBoot06DataMybatisApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre></div><h3 id="5）、配置文件版"><a href="#5）、配置文件版" class="headerlink" title="5）、配置文件版"></a>5）、配置文件版</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span> <span class="hljs-string">指定全局配置文件的位置</span>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span>  <span class="hljs-string">指定sql映射文件的位置</span></code></pre></div><p>更多使用参照</p><p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><h2 id="4、整合SpringData-JPA"><a href="#4、整合SpringData-JPA" class="headerlink" title="4、整合SpringData JPA"></a>4、整合SpringData JPA</h2><h3 id="1）、SpringData简介"><a href="#1）、SpringData简介" class="headerlink" title="1）、SpringData简介"></a>1）、SpringData简介</h3><p><img src="/2020/08/04/SpringBoot%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306105412.png" srcset="/img/loading.gif" alt></p><h3 id="2）、整合SpringData-JPA"><a href="#2）、整合SpringData-JPA" class="headerlink" title="2）、整合SpringData JPA"></a>2）、整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）；</p><p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用JPA注解配置映射关系</span><span class="hljs-meta">@Entity</span> <span class="hljs-comment">//告诉JPA这是一个实体类（和数据表映射的类）</span><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tbl_user"</span>) <span class="hljs-comment">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span> <span class="hljs-comment">//这是一个主键</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="hljs-comment">//自增主键</span>    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"last_name"</span>,length = <span class="hljs-number">50</span>) <span class="hljs-comment">//这是和数据表对应的一个列</span>    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-meta">@Column</span> <span class="hljs-comment">//省略默认列名就是属性名</span>    <span class="hljs-keyword">private</span> String email;</code></pre></div><p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//继承JpaRepository来完成对数据库的操作</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;&#125;</code></pre></div><p>3）、基本的配置JpaProperties</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>   <span class="hljs-attr">jpa:</span>    <span class="hljs-attr">hibernate:</span><span class="hljs-comment">#     更新或者创建数据表结构</span>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><span class="hljs-comment">#    控制台显示SQL</span>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span></code></pre></div><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>MyBatis</tag>
      
      <tag>JDBC</tag>
      
      <tag>SpringData JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门</title>
    <link href="/2020/08/03/Docker%E5%85%A5%E9%97%A8/"/>
    <url>/2020/08/03/Docker%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像称为容器，容器启动是非常快速的。</p><p><img src="/2020/08/03/Docker%E5%85%A5%E9%97%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145450.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/03/Docker%E5%85%A5%E9%97%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145531.png" srcset="/img/loading.gif" alt></p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p><p>docker客户端(Client)：连接docker主机进行操作；</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p><p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p><p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p><p><img src="/2020/08/03/Docker%E5%85%A5%E9%97%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303165113.png" srcset="/img/loading.gif" alt></p><p>使用Docker的步骤：</p><p>1）、安装Docker</p><p>2）、去Docker仓库找到这个软件对应的镜像；</p><p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p><p>4）、对容器的启动停止就是对软件的启动停止；</p><h2 id="3、安装Docker"><a href="#3、安装Docker" class="headerlink" title="3、安装Docker"></a>3、安装Docker</h2><h4 id="1）、安装linux虚拟机"><a href="#1）、安装linux虚拟机" class="headerlink" title="1）、安装linux虚拟机"></a>1）、安装linux虚拟机</h4><p>​    1）、VMWare、VirtualBox（安装）；</p><p>​    2）、导入虚拟机文件centos7-atguigu.ova；</p><p>​    3）、双击启动linux虚拟机;使用  root/ 123456登陆</p><p>​    4）、使用客户端连接linux服务器进行命令操作；</p><p>​    5）、设置虚拟机网络；</p><p>​        桥接网络===选好网卡====接入网线；</p><p>​    6）、设置好网络以后使用命令重启虚拟机的网络</p><div class="hljs"><pre><code class="hljs shell">service network restart</code></pre></div><p>​    7）、查看linux的ip地址</p><div class="hljs"><pre><code class="hljs shell">ip addr</code></pre></div><p>​    8）、使用客户端连接linux；</p><h4 id="2）、在linux虚拟机上安装docker"><a href="#2）、在linux虚拟机上安装docker" class="headerlink" title="2）、在linux虚拟机上安装docker"></a>2）、在linux虚拟机上安装docker</h4><p>步骤：</p><div class="hljs"><pre><code class="hljs shell">1、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker</code></pre></div><h2 id="4、Docker常用命令-amp-操作"><a href="#4、Docker常用命令-amp-操作" class="headerlink" title="4、Docker常用命令&amp;操作"></a>4、Docker常用命令&amp;操作</h2><h3 id="1）镜像操作"><a href="#1）镜像操作" class="headerlink" title="1）镜像操作"></a>1）镜像操作</h3><table><thead><tr><th>操作</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>检索</td><td>docker  search 关键字  eg：docker  search redis</td><td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td></tr><tr><td>拉取</td><td>docker pull 镜像名:tag</td><td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td></tr><tr><td>列表</td><td>docker images</td><td>查看所有本地镜像</td></tr><tr><td>删除</td><td>docker rmi image-id</td><td>删除指定的本地镜像</td></tr></tbody></table><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h3 id="2）容器操作"><a href="#2）容器操作" class="headerlink" title="2）容器操作"></a>2）容器操作</h3><p>软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）；</p><p>步骤：</p><div class="hljs"><pre><code class="hljs shell">1、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps  查看运行中的容器5、 停止运行中的容器docker stop  容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档</code></pre></div><h3 id="3）安装MySQL示例"><a href="#3）安装MySQL示例" class="headerlink" title="3）安装MySQL示例"></a>3）安装MySQL示例</h3><div class="hljs"><pre><code class="hljs shell">docker pull mysql</code></pre></div><p>错误的启动</p><div class="hljs"><pre><code class="hljs shell">[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_goldstinec4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified   You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</code></pre></div><p>正确的启动</p><div class="hljs"><pre><code class="hljs shell">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESb874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</code></pre></div><p>做了端口映射</p><div class="hljs"><pre><code class="hljs shell">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMESad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</code></pre></div><p>几个其他的高级操作</p><div class="hljs"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker <span class="hljs-builtin-name">run</span> --name some-mysql -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag <span class="hljs-attribute">--character-set-server</span>=utf8mb4 <span class="hljs-attribute">--collation-server</span>=utf8mb4_unicode_ci指定mysql的一些配置参数</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>新手教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置嵌入式Servlet容器</title>
    <link href="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h1><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180301142915.png" srcset="/img/loading.gif" alt></p><p>问题？</p><h3 id="一、如何定制和修改Servlet容器的相关配置"><a href="#一、如何定制和修改Servlet容器的相关配置" class="headerlink" title="一、如何定制和修改Servlet容器的相关配置"></a>一、如何定制和修改Servlet容器的相关配置</h3><p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">server.context-path</span>=<span class="hljs-string">/crud</span><span class="hljs-meta">server.tomcat.uri-encoding</span>=<span class="hljs-string">UTF-8</span><span class="hljs-attr">//通用的Servlet容器设置</span><span class="hljs-attr">server.xxx</span><span class="hljs-attr">//Tomcat的设置</span><span class="hljs-attr">server.tomcat.xxx</span></code></pre></div><p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>  <span class="hljs-comment">//一定要将这个定制器加入到容器中</span><span class="hljs-function"><span class="hljs-keyword">public</span> EmbeddedServletContainerCustomizer <span class="hljs-title">embeddedServletContainerCustomizer</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EmbeddedServletContainerCustomizer() &#123;        <span class="hljs-comment">//定制嵌入式的Servlet容器相关的规则</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;            container.setPort(<span class="hljs-number">8083</span>);        &#125;    &#125;;&#125;</code></pre></div><h3 id="二、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#二、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="二、注册Servlet三大组件【Servlet、Filter、Listener】"></a>二、注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p><p>注册三大组件用以下方式</p><p>ServletRegistrationBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//注册三大组件</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">myServlet</span><span class="hljs-params">()</span></span>&#123;    ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> MyServlet(),<span class="hljs-string">"/myServlet"</span>);    <span class="hljs-keyword">return</span> registrationBean;&#125;</code></pre></div><p>FilterRegistrationBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">myFilter</span><span class="hljs-params">()</span></span>&#123;    FilterRegistrationBean registrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean();    registrationBean.setFilter(<span class="hljs-keyword">new</span> MyFilter());    registrationBean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/hello"</span>,<span class="hljs-string">"/myServlet"</span>));    <span class="hljs-keyword">return</span> registrationBean;&#125;</code></pre></div><p>ServletListenerRegistrationBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServletListenerRegistrationBean <span class="hljs-title">myListener</span><span class="hljs-params">()</span></span>&#123;    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="hljs-keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="hljs-keyword">new</span> MyListener());    <span class="hljs-keyword">return</span> registrationBean;&#125;</code></pre></div><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)<span class="hljs-meta">@ConditionalOnBean</span>(value = DispatcherServlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span> </span>= DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)<span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">dispatcherServletRegistration</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;   ServletRegistrationBean registration = <span class="hljs-keyword">new</span> ServletRegistrationBean(         dispatcherServlet, <span class="hljs-keyword">this</span>.serverProperties.getServletMapping());    <span class="hljs-comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span>    <span class="hljs-comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span>       registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);   registration.setLoadOnStartup(         <span class="hljs-keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.multipartConfig != <span class="hljs-keyword">null</span>) &#123;      registration.setMultipartConfig(<span class="hljs-keyword">this</span>.multipartConfig);   &#125;   <span class="hljs-keyword">return</span> registration;&#125;</code></pre></div><p>2）、SpringBoot能不能支持其他的Servlet容器；</p><h3 id="三、替换为其他嵌入式Servlet容器"><a href="#三、替换为其他嵌入式Servlet容器" class="headerlink" title="三、替换为其他嵌入式Servlet容器"></a>三、替换为其他嵌入式Servlet容器</h3><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302114401.png" srcset="/img/loading.gif" alt></p><p>默认支持：</p><p>Tomcat（默认使用）</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Jetty</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入web模块 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--引入其他的Servlet容器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>Undertow</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入web模块 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--引入其他的Servlet容器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="四、嵌入式Servlet容器自动配置原理；"><a href="#四、嵌入式Servlet容器自动配置原理；" class="headerlink" title="四、嵌入式Servlet容器自动配置原理；"></a>四、嵌入式Servlet容器自动配置原理；</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@Import</span>(BeanPostProcessorsRegistrar<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">//导入<span class="hljs-title">BeanPostProcessorsRegistrar</span>：<span class="hljs-title">Spring</span>注解版；给容器中导入一些组件</span><span class="hljs-class">//导入了<span class="hljs-title">EmbeddedServletContainerCustomizerBeanPostProcessor</span>：</span><span class="hljs-class">//后置处理器：<span class="hljs-title">bean</span>初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;        <span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Tomcat</span>.<span class="hljs-title">class</span> &#125;)//判断当前是否引入了<span class="hljs-title">Tomcat</span>依赖；</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">value</span> </span>= EmbeddedServletContainerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedTomcat</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="hljs-title">tomcatEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatEmbeddedServletContainerFactory();&#125;&#125;        <span class="hljs-comment">/**</span><span class="hljs-comment"> * Nested configuration if Jetty is being used.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Server</span>.<span class="hljs-title">class</span>, <span class="hljs-title">Loader</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebAppContext</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">value</span> </span>= EmbeddedServletContainerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedJetty</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> JettyEmbeddedServletContainerFactory <span class="hljs-title">jettyEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JettyEmbeddedServletContainerFactory();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Nested configuration if Undertow is being used.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Undertow</span>.<span class="hljs-title">class</span>, <span class="hljs-title">SslClientAuthMode</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">value</span> </span>= EmbeddedServletContainerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">search</span> </span>= SearchStrategy.CURRENT)<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedUndertow</span> </span>&#123;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="hljs-title">undertowEmbeddedServletContainerFactory</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UndertowEmbeddedServletContainerFactory();&#125;&#125;</code></pre></div><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EmbeddedServletContainerFactory</span> </span>&#123;   <span class="hljs-comment">//获取嵌入式的Servlet容器</span>   <span class="hljs-function">EmbeddedServletContainer <span class="hljs-title">getEmbeddedServletContainer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">         ServletContextInitializer... initializers)</span></span>;&#125;</code></pre></div><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144910.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/08/03/SpringBoot%E9%85%8D%E7%BD%AE%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302221835.png" srcset="/img/loading.gif" alt></p><p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EmbeddedServletContainer <span class="hljs-title">getEmbeddedServletContainer</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ServletContextInitializer... initializers)</span> </span>&#123;    <span class="hljs-comment">//创建一个Tomcat</span>   Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();        <span class="hljs-comment">//配置Tomcat的基本环节</span>   File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.baseDirectory         : createTempDir(<span class="hljs-string">"tomcat"</span>));   tomcat.setBaseDir(baseDir.getAbsolutePath());   Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);   tomcat.getService().addConnector(connector);   customizeConnector(connector);   tomcat.setConnector(connector);   tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);   configureEngine(tomcat.getEngine());   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) &#123;      tomcat.getService().addConnector(additionalConnector);   &#125;   prepareContext(tomcat.getHost(), initializers);        <span class="hljs-comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span>   <span class="hljs-keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);&#125;</code></pre></div><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><div class="hljs"><pre><code class="hljs plain">ServerProperties、EmbeddedServletContainerCustomizer</code></pre></div><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><p>怎么修改的原理？</p><p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//初始化之前</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span></span><span class="hljs-function">      <span class="hljs-keyword">throws</span> BeansException </span>&#123;    <span class="hljs-comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span>   <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;       <span class="hljs-comment">//</span>      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);   &#125;   <span class="hljs-keyword">return</span> bean;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;    <span class="hljs-comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span>    <span class="hljs-keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;        customizer.customize(bean);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="hljs-title">getCustomizers</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.customizers == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// Look up does not include the parent context</span>        <span class="hljs-keyword">this</span>.customizers = <span class="hljs-keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(            <span class="hljs-keyword">this</span>.beanFactory            <span class="hljs-comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span>            <span class="hljs-comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span>            .getBeansOfType(EmbeddedServletContainerCustomizer<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">                            <span class="hljs-title">false</span>, <span class="hljs-title">false</span>)</span><span class="hljs-class">            .<span class="hljs-title">values</span>())</span>;        Collections.sort(<span class="hljs-keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);        <span class="hljs-keyword">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-keyword">this</span>.customizers);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customizers;&#125;ServerProperties也是定制器</code></pre></div><p>步骤：</p><p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p><p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p><p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p><h3 id="五、嵌入式Servlet容器启动原理；"><a href="#五、嵌入式Servlet容器启动原理；" class="headerlink" title="五、嵌入式Servlet容器启动原理；"></a>五、嵌入式Servlet容器启动原理；</h3><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p><p>获取嵌入式的Servlet容器工厂：</p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;      <span class="hljs-comment">// Prepare this context for refreshing.</span>      prepareRefresh();      <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span>      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      <span class="hljs-comment">// Prepare the bean factory for use in this context.</span>      prepareBeanFactory(beanFactory);      <span class="hljs-keyword">try</span> &#123;         <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>         postProcessBeanFactory(beanFactory);         <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>         invokeBeanFactoryPostProcessors(beanFactory);         <span class="hljs-comment">// Register bean processors that intercept bean creation.</span>         registerBeanPostProcessors(beanFactory);         <span class="hljs-comment">// Initialize message source for this context.</span>         initMessageSource();         <span class="hljs-comment">// Initialize event multicaster for this context.</span>         initApplicationEventMulticaster();         <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>         onRefresh();         <span class="hljs-comment">// Check for listener beans and register them.</span>         registerListeners();         <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>         finishBeanFactoryInitialization(beanFactory);         <span class="hljs-comment">// Last step: publish corresponding event.</span>         finishRefresh();      &#125;      <span class="hljs-keyword">catch</span> (BeansException ex) &#123;         <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;            logger.warn(<span class="hljs-string">"Exception encountered during context initialization - "</span> +                  <span class="hljs-string">"cancelling refresh attempt: "</span> + ex);         &#125;         <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>         destroyBeans();         <span class="hljs-comment">// Reset 'active' flag.</span>         cancelRefresh(ex);         <span class="hljs-comment">// Propagate exception to caller.</span>         <span class="hljs-keyword">throw</span> ex;      &#125;      <span class="hljs-keyword">finally</span> &#123;         <span class="hljs-comment">// Reset common introspection caches in Spring's core, since we</span>         <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>         resetCommonCaches();      &#125;   &#125;&#125;</code></pre></div><p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p><p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>​    从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p><p><strong>==IOC容器启动创建嵌入式的Servlet容器==</strong></p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set接口底层实现类</title>
    <link href="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <url>/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Set接口底层实现类"><a href="#Set接口底层实现类" class="headerlink" title="Set接口底层实现类"></a>Set接口底层实现类</h1><h1 id="一、Set接口继承关系"><a href="#一、Set接口继承关系" class="headerlink" title="一、Set接口继承关系"></a>一、Set接口继承关系</h1><p>存储的数据特点：无序的、不可重复的元素</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1595656190066.png" srcset="/img/loading.gif" alt></p><p>|—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p><ul><li>|—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</li><li>|—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。                   对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</li><li>|—-TreeSet：可以照添加对象的指定属性，进行排序。</li></ul><h1 id="二、HashSet"><a href="#二、HashSet" class="headerlink" title="二、HashSet"></a>二、HashSet</h1><h2 id="1-继承情况"><a href="#1-继承情况" class="headerlink" title="1.继承情况"></a>1.继承情况</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1595656458260.png" srcset="/img/loading.gif" alt></p><p>可以看到是直接实现了Set接口，和间接继承了Collection接口</p><h2 id="2-创建HashSet"><a href="#2-创建HashSet" class="headerlink" title="2.创建HashSet"></a>2.创建HashSet</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/abcsd.png" srcset="/img/loading.gif" alt></p><p>debug跟进源代码</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1.png" srcset="/img/loading.gif" alt></p><p>可以看到空参构造器里new了一个HashMap出来</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/2.png" srcset="/img/loading.gif" alt="59565709297"></p><p>而HashMap初始化了一个加载因子的常量，这里由于是map内容不多做细讲</p><p> 实际上HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变，此类允许使用null元素。 </p><p>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值<code>private static final Object PRESENT = new Object();</code>，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。) 在添加数据时就能观察到。</p><h2 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/3.png" srcset="/img/loading.gif" alt></p><p>跟进 首先是一个自动装箱</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/4.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/5.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java">而PRESENT就是刚才提及到的固定的value值 实现了双列变单列<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();</code></pre></div><p>接下来的put就是map的操作了</p><h2 id="4-不可重复性和无序性"><a href="#4-不可重复性和无序性" class="headerlink" title="4.不可重复性和无序性"></a>4.不可重复性和无序性</h2><p>HashSet的俩大特点</p><div class="hljs"><pre><code>1. 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。    2. 不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</code></pre></div><p>在进行测试过程中 我发现避免不了去到map的源码，由于太过复杂 尽量用大白话说明白，map会单独出一篇</p><p>在jdk7和之前 底层使用的是数组加链表，在jdk8后使用的是数组加链表加红黑树。</p><p>因为我们知道map的key是不允许的重复的，如果有重复的key值就会把map的key和value进行更新操作，这一来就说的通了，HashSet就是限制了map的功能，让map的value值固定为常量，只使用key去操作，所以说HashSet不允许有重复的值，其实也是这个新的值把原来的值给替换掉了</p><p><strong>而无序性，要重存放的方式说起。（注意，存进HashSet的对象一定要重写HashCode和equals方法）</strong></p><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>        此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断<br>        数组此位置上是否已经元素）：</p><p>  此时有俩种情况：  </p><p>​        1.如果此位置上没其他元素，则元素a添加成功。 —&gt;插入成功情况1<br>               2.如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值：</p><p>此时又有俩种情况：</p><p>​                1.如果hash值不相同，则元素a添加成功。—&gt;成功情况2<br>                2.如果hash值相同，进而需要调用元素a所在类的equals()方法：</p><p>此时还是有俩种情况：</p><p>​               1.equals()返回true,元素a添加失败<br>               2.equals()返回false,则元素a添加成功。—&gt;成功情况3</p><p>​    对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p><p>​    </p><p>（链表指向区别↓）</p><p>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a</p><p>此时同学们肯定会有疑问，如果HashCode相同难道会出现equals不同的情况嘛？（还真会待会贴出优秀代码）</p><p>由于在数组 和 链表 和 红黑树 的数据结构有点抽象 下面几副图可以形象看到HashSet添加时全过程</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/6.png" srcset="/img/loading.gif" alt></p><p>情况2：</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/7.png" srcset="/img/loading.gif" alt></p><p>情况3：</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/8.png" srcset="/img/loading.gif" alt></p><p>这里没有用到红黑树，是因为加入红黑树是让遍历等操作速度变快，具体的方式为，在数组某一个位置上的链表的层数到8层或总数量多于64个时，链表重新打散，改为使用树结构，当然树结构的头还是数组，变成一颗颗倒着的树。</p><h2 id="5-添加代码"><a href="#5-添加代码" class="headerlink" title="5.添加代码"></a>5.添加代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;        Integer num;        String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Integer num, String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.num = num;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> +                    <span class="hljs-string">"num="</span> + num +                    <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                    <span class="hljs-string">'&#125;'</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Person)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            Person person = (Person) o;            <span class="hljs-keyword">return</span> Objects.equals(num, person.num) &amp;&amp;                    Objects.equals(name, person.name);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> Objects.hash(num, name);        &#125;    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        HashSet set = <span class="hljs-keyword">new</span> HashSet();        Person p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"AA"</span>);        Person p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"BB"</span>);        set.add(p1);        set.add(p2);        System.out.println(set);        p1.name = <span class="hljs-string">"CC"</span>;        set.remove(p1);        System.out.println(set);        set.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"CC"</span>));        System.out.println(set);        set.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">"AA"</span>));        System.out.println(set);    &#125;</code></pre></div><p>运行test1中代码结果为：</p><div class="hljs"><pre><code class="hljs java">[Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'AA'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;][Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;][Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;][Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'BB'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'CC'</span>&#125;, Person&#123;num=<span class="hljs-number">1002</span>, name=<span class="hljs-string">'AA'</span>&#125;]</code></pre></div><p>是不是很诡异？其实归根结底还是那三种情况</p><h1 id="三、LinkedHashSet"><a href="#三、LinkedHashSet" class="headerlink" title="三、LinkedHashSet"></a>三、LinkedHashSet</h1><h2 id="1-继承情况-1"><a href="#1-继承情况-1" class="headerlink" title="1.继承情况"></a>1.继承情况</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/9.png" srcset="/img/loading.gif" alt></p><h2 id="2-优劣"><a href="#2-优劣" class="headerlink" title="2.优劣"></a>2.优劣</h2><p>LinkedHashSet 与 HashSet 区别在于 LinkedHashSet 遍历其内部数据时，可以按照添加的顺序遍历，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。 </p><p>特性就剩不可重复性了</p><p>对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><h1 id="四、TreeSet"><a href="#四、TreeSet" class="headerlink" title="四、TreeSet"></a>四、TreeSet</h1><h2 id="1-继承情况-2"><a href="#1-继承情况-2" class="headerlink" title="1.继承情况"></a>1.继承情况</h2><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/10.png" srcset="/img/loading.gif" alt></p><p>TreeSet不太一样，它是可以将数据按照一定的排列顺序进行输出。有俩种方式（定制排序，自然排序）</p><h2 id="2-自然排序"><a href="#2-自然排序" class="headerlink" title="2.自然排序"></a>2.自然排序</h2><p>自然排序就是对象实现了Comparable接口</p><p><img src="/2020/07/25/Set%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/11.png" srcset="/img/loading.gif" alt></p><p>我们知道，Set是无序的，但是用TreeSet的数据就是有序的，那基本数据类型为什么存进去就会变有序呢？</p><p>其实这里有一个自动装箱的过程在Integer中就实现了这个接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;         在里面重写了compareTo     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Integer anotherInteger)</span> </span>&#123;        <span class="hljs-keyword">return</span> compare(<span class="hljs-keyword">this</span>.value, anotherInteger.value);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> (x &lt; y) ? -<span class="hljs-number">1</span> : ((x == y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);    &#125;    以后要想放在TreeSet实现排序的对象 先要自己重写compareTo方法，用自己的排列方式才能生效</code></pre></div><h2 id="3-定制排序"><a href="#3-定制排序" class="headerlink" title="3.定制排序"></a>3.定制排序</h2><p>往往在很多时候，自然排序根本不能用，因为不能去更改源代码，所以有另一种方法，帮助我们定制排序的顺序</p><p>这种方法就是给TreeSet构造器中给一个Comparator对象，在Comparator对象中重写compare方法，定制自己需要的排列规则</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;       Comparator com = <span class="hljs-keyword">new</span> Comparator() &#123;           <span class="hljs-comment">//照年龄从小到大排列</span>           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;               <span class="hljs-keyword">if</span>(o1 <span class="hljs-keyword">instanceof</span> User &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> User)&#123;                   User u1 = (User)o1;                   User u2 = (User)o2;                   <span class="hljs-keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());               &#125;<span class="hljs-keyword">else</span>&#123;                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不匹配"</span>);               &#125;           &#125;       &#125;;       TreeSet set = <span class="hljs-keyword">new</span> TreeSet(com);       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">12</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">32</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jim"</span>,<span class="hljs-number">2</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mike"</span>,<span class="hljs-number">65</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Mary"</span>,<span class="hljs-number">33</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">33</span>));       set.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">56</span>));       Iterator iterator = set.iterator();       <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;           System.out.println(iterator.next());       &#125;   &#125;</code></pre></div><p>一般来说如果某个对象不需要经常使用排序，则使用定制排序就行，因为可以使用匿名内部类的方式，一次性的排序，而使用自然排序则是一直绑定着排序规则，不灵活。</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Set</tag>
      
      <tag>HashSet</tag>
      
      <tag>LinkedHashSet</tag>
      
      <tag>TreeSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List接口底层实现类</title>
    <link href="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/"/>
    <url>/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="List接口底层实现类"><a href="#List接口底层实现类" class="headerlink" title="List接口底层实现类"></a>List接口底层实现类</h1><h2 id="一、java集合类分类"><a href="#一、java集合类分类" class="headerlink" title="一、java集合类分类"></a>一、java集合类分类</h2><p>java集合框架分为俩种，单列集合框架Collection，和双列集合框架Map</p><h3 id="1-单列集合框架结构"><a href="#1-单列集合框架结构" class="headerlink" title="1.单列集合框架结构"></a>1.单列集合框架结构</h3><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>|—-List接口：存储序的、可重复的数据。  –&gt;“动态”数组<ul><li>|—-ArrayList、LinkedList、Vector<br>​</li></ul></li><li>|—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”<ul><li>|—-HashSet、LinkedHashSet、TreeSet</li></ul></li></ul><p>本文将对List接口进行解析</p><p>对应图示：</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592968971414.png" srcset="/img/loading.gif" alt="单列集合框架"></p><p><strong>实线为直接继承或实现，虚线为间接继承或实现</strong></p><h2 id="二、ArrayList"><a href="#二、ArrayList" class="headerlink" title="二、ArrayList"></a>二、ArrayList</h2><h3 id="1-jdk1-7的情况"><a href="#1-jdk1-7的情况" class="headerlink" title="1.jdk1.7的情况"></a>1.jdk1.7的情况</h3><p>​    ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</p><ul><li><p>list.add(123);//elementData[0] = new Integer(123);</p></li><li><p>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</p></li><li><p>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p></li><li><p>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</p><p>​</p></li></ul><h3 id="2-jdk1-8的情况"><a href="#2-jdk1-8的情况" class="headerlink" title="2.jdk1.8的情况"></a>2.jdk1.8的情况</h3><p>​    由于现主流开发都是1.8版本的jdk，所有以下对ArrayList进行深入解读</p><h3 id="3-继承情况"><a href="#3-继承情况" class="headerlink" title="3.继承情况"></a>3.继承情况</h3><p>使用idea自带的可视化工具查看继承与实现情况，可以清楚的看到ArrayList间接的实现了Collection接口</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592969473(1).jpg" srcset="/img/loading.gif" alt="继承情况"></p><h3 id="4-创建ArrayList"><a href="#4-创建ArrayList" class="headerlink" title="4.创建ArrayList"></a>4.创建ArrayList</h3><p>​    接下来我们来看一下创建一个ArrayList容器会发生什么</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592969867(1).jpg" srcset="/img/loading.gif" alt="创建ArrayList"></p><p>当我用debug创建一个arrayList时 返回的是一个空的，长度为0的数组</p><p>我们跟进去构造函数</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">//一个是Object[]对象,transient关键词是指该对象不需要被序列化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//一个空的Object[]对象</span></code></pre></div><p>与jdk7版本的区别是 jdk7创建后就创建一个长度为10的数组，但jdk8并没有，更加节省内存</p><h3 id="5-添加数据"><a href="#5-添加数据" class="headerlink" title="5.添加数据"></a>5.添加数据</h3><div class="hljs"><pre><code class="hljs java">arrayList.add(<span class="hljs-number">123</span>);</code></pre></div><p>我们用debug跟进源码</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592970609(1).jpg" srcset="/img/loading.gif" alt></p><p>因为存入123是基本数据类型，这里有一个自动装箱的过程（装换为Integer类型）</p><p>后面就是进入add方法</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592973839(1).jpg" srcset="/img/loading.gif" alt></p><p>size默认初始化为0，进入ensureCapacityInternal方法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);            <span class="hljs-comment">//max方法取俩个参数最大的一个（这里DEFAULT_CAPACITY为10），将最大的值赋给minCapacity</span>        &#125;        ensureExplicitCapacity(minCapacity);    &#125;进入ensureExplicitCapacity(minCapacity)方法<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        modCount++;<span class="hljs-comment">//默认为0 </span>        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//判断最小容量减去原数组长度是否大于0</span>            grow(minCapacity);    &#125;   进入grow(minCapacity)方法 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-comment">// overflow-conscious code</span>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<span class="hljs-comment">//记录老容量长度 此时elementData长度为0</span>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//定义新容量值，老容量长度右移一位后加再上老容量长度，而右移一位是取数值的一半，这里就决定了ArrayList以后进行扩容都是对原数组扩容1.5倍</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//0 - 10 小于0 所有进入 </span>            newCapacity = minCapacity;<span class="hljs-comment">//新容量长度就为10</span>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//判断此容量会不会超过最大长度（Integer.MAX_VALUE - 8）</span>            newCapacity = hugeCapacity(minCapacity);        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>        elementData = Arrays.copyOf(elementData, newCapacity);<span class="hljs-comment">//调用Arrays工具类，对数组进行扩容，原理为将旧数组数据复制到新数组</span>    &#125;</code></pre></div><h2 id="三、LinkedList"><a href="#三、LinkedList" class="headerlink" title="三、LinkedList"></a>三、LinkedList</h2><h3 id="1-继承情况"><a href="#1-继承情况" class="headerlink" title="1.继承情况"></a>1.继承情况</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592975059(1).jpg" srcset="/img/loading.gif" alt></p><p>可以看到不仅间接的实现了List接口，还间接的实现了队列Queue的接口</p><h3 id="2-创建LinkedList"><a href="#2-创建LinkedList" class="headerlink" title="2.创建LinkedList"></a>2.创建LinkedList</h3><div class="hljs"><pre><code class="hljs java">LinkedList linkedList = <span class="hljs-keyword">new</span> LinkedList();</code></pre></div><p>通过new的方式只是初始化LinkedList容器，底层双向链表结构还未创建。LinkedList Node类型的first和last属性，默认为null</p><h3 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h3><div class="hljs"><pre><code class="hljs java">linkedList.add(<span class="hljs-number">123</span>);</code></pre></div><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1592975703(1).jpg" srcset="/img/loading.gif" alt></p><p>进入linkLast中</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在linkedList里面有first和last属性</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last; <span class="hljs-comment">//将原料的last对象赋值给l</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//Node为一个静态内部类 在下面：作用是初始化Node对象（链表对象，prev为头指针，next为尾指针，element为数据）</span>    last = newNode;<span class="hljs-comment">//将有数据的newNode赋值给last</span>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)<span class="hljs-comment">//判断是否是第一个节点，如果是</span>        first = newNode;<span class="hljs-comment">//将NewNode直接赋值给尾节点</span>    <span class="hljs-keyword">else</span>        l.next = newNode;<span class="hljs-comment">//不是的话。将节点添加到l.next 相当于将链表连接起来</span>    size++;    modCount++;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            <span class="hljs-keyword">this</span>.item = element;            <span class="hljs-keyword">this</span>.next = next;            <span class="hljs-keyword">this</span>.prev = prev;        &#125;    &#125;</code></pre></div><h2 id="四、Vector"><a href="#四、Vector" class="headerlink" title="四、Vector"></a>四、Vector</h2><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>在扩容方面，默认扩容为原来的数组长度的2倍。</p><h3 id="1-继承情况-1"><a href="#1-继承情况-1" class="headerlink" title="1.继承情况"></a>1.继承情况</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593002715(1).png" srcset="/img/loading.gif" alt></p><h3 id="2-创建Vector"><a href="#2-创建Vector" class="headerlink" title="2.创建Vector"></a>2.创建Vector</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593002840(1).jpg" srcset="/img/loading.gif" alt></p><p>让我们跟进去构造函数</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);    &#125;再往下跟，调用一个参数的构造函数<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0</span>);    &#125;    再往下跟，调用凉参数的构造函数<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">int</span> capacityIncrement)</span> </span>&#123;        <span class="hljs-keyword">super</span>();<span class="hljs-comment">//显示调用父构造函数</span>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//为0就报错，参数传进来为10</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                               initialCapacity);        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity]; <span class="hljs-comment">//创建并初始化了对象数组</span>        <span class="hljs-keyword">this</span>.capacityIncrement = capacityIncrement;    &#125;    上面俩个属性定义如下：<span class="hljs-keyword">protected</span> Object[] elementData;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> elementCount;</code></pre></div><p>此版本为jdk8，jdk7的Vector也是创建一个Vector容器就默认初始化长度为0，与jdk7的ArrayList一样，但是人家开发者对ArrayList进行了改进，使用懒加载，可能Vector要被放弃了吧！！</p><p>接下来讲为什么会放弃Vector</p><h3 id="3-添加数据-1"><a href="#3-添加数据-1" class="headerlink" title="3.添加数据"></a>3.添加数据</h3><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593003620(1).jpg" srcset="/img/loading.gif" alt></p><p>接下来跟进源码</p><p><img src="/2020/06/24/List%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%B1%BB/1593003749(1).jpg" srcset="/img/loading.gif" alt></p><p>elementCount默认为0。</p><p>可以看到有一个ensureCapacityHelper方法，此方法是校验长度是否足够，并去扩容的方法，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);<span class="hljs-comment">//扩容方法</span>&#125;</code></pre></div><p>但此处因为默认初始化长度为10，所以这里不会有扩容的需求。</p><p>稍等！Vector不是挺好的嘛，为什么要放弃他？？因为…</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></code></pre></div><p>因为他的方法上全加了synchronized，加上这个字段他就是一个线程安全的方法，而他的全部方法都是线程安全方法，又众所周知，线程安全效率大大减低，所以连开发jdk人员都懒得救他，毕竟，出现了更好的人，老情人全忘掉了~</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>上述介绍了List接口的全部实现类，如果数据不需要线程安全，则不要去考虑使用Vector，而因为ArrayList和LinkedList底层实现原理不同，他们使用的地方也有所不同，ArrayList底层使用的是数组实现，因此在需要频繁的插入和删除数据时效率会大大减低，而数组有一个好处，就是有下标，下标最直接好的好处就是查询速度非常的快，而LinkedList底层使用的是双向链表实现，所以在频繁的插入和删除数据时，有超高性能的表现，但是在查询的速度远远比不上ArrayList。</p><p>记重点：ArrayList数组实现，每次扩容1.5倍，使用懒加载，首次扩容长度为10</p><p>​        LinkedList双向链表实现</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
      <tag>ArrayList</tag>
      
      <tag>LinkedList</tag>
      
      <tag>Vector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-SpringMVC自动配置</title>
    <link href="/2020/06/24/SpringBoot-SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/06/24/SpringBoot-SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC自动配置"><a href="#SpringMVC自动配置" class="headerlink" title="SpringMVC自动配置"></a>SpringMVC自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p><h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p><p>​</p></li><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mvc"</span>, name = <span class="hljs-string">"date-format"</span>)<span class="hljs-comment">//在文件中配置日期格式化的规则</span><span class="hljs-function"><span class="hljs-keyword">public</span> Formatter&lt;Date&gt; <span class="hljs-title">dateFormatter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DateFormatter(<span class="hljs-keyword">this</span>.mvcProperties.getDateFormat());<span class="hljs-comment">//日期格式化组件</span>&#125;</code></pre></div><p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p><p>​</p></li></ul></li><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p><div class="hljs"><pre><code class="hljs diff">初始化WebDataBinder；请求数据<span class="hljs-comment">=====JavaBean；</span></code></pre></div></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/hello"</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">"success"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/hello"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre></div><p><strong>==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==</strong>;</p><p>既保留了所有的自动配置，也能用我们扩展的配置；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite(); <span class="hljs-comment">//从容器中获取所有的WebMvcConfigurer</span>     <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;         <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;             <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);           <span class="hljs-comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span>           <span class="hljs-meta">@Override</span>            <span class="hljs-comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span>             <span class="hljs-comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span>              <span class="hljs-comment">//       delegate.addViewControllers(registry);</span>              <span class="hljs-comment">//   &#125;</span>             &#125;         &#125;&#125;</code></pre></div><p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​    4）、我们的配置类也会被调用；</p><p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(DelegatingWebMvcConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebMvc</span> </span>&#123;</code></pre></div><p>2）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</code></pre></div><p>3）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DispatcherServlet</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebMvcConfigurerAdapter</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">WebMvcConfigurationSupport</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">HIGHEST_PRECEDENCE</span> + 10)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ValidationAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;</code></pre></div><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h3 id="4、如何修改SpringBoot的默认配置"><a href="#4、如何修改SpringBoot的默认配置" class="headerlink" title="4、如何修改SpringBoot的默认配置"></a>4、如何修改SpringBoot的默认配置</h3><p>模式：</p><p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p><p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot日志</title>
    <link href="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/"/>
    <url>/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h2><p> 小张；开发一个大型系统；</p><p>​        1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p><p>​        2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p><p>​        3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p><p>​        4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p><p>​        5、JDBC—数据库驱动；</p><p>​            写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p><p>​            给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><p><strong>市面上的日志框架；</strong></p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p><p>​    <strong>==SpringBoot选用 SLF4j和logback；==</strong></p><h2 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h2><h3 id="1、如何在系统中使用SLF4j-https-www-slf4j-org"><a href="#1、如何在系统中使用SLF4j-https-www-slf4j-org" class="headerlink" title="1、如何在系统中使用SLF4j   https://www.slf4j.org"></a>1、如何在系统中使用SLF4j   <a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    logger.info(<span class="hljs-string">"Hello World"</span>);  &#125;&#125;</code></pre></div><p>图示；</p><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/concrete-bindings.png" srcset="/img/loading.gif" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2、遗留问题"><a href="#2、遗留问题" class="headerlink" title="2、遗留问题"></a>2、遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/legacy.png" srcset="/img/loading.gif" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>==1、将系统中其他日志框架先排除出去；==</p><p>==2、用中间包来替换原有的日志框架；==</p><p>==3、我们导入slf4j其他的实现==</p><h2 id="3、SpringBoot日志关系"><a href="#3、SpringBoot日志关系" class="headerlink" title="3、SpringBoot日志关系"></a>3、SpringBoot日志关系</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>SpringBoot使用它来做日志功能；</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>底层依赖关系</p><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131220946.png" srcset="/img/loading.gif" alt></p><p>总结：</p><p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​    3）、中间替换包？</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFactory</span> </span>&#123;    <span class="hljs-keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="hljs-string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;    <span class="hljs-keyword">static</span> LogFactory logFactory = <span class="hljs-keyword">new</span> SLF4JLogFactory();</code></pre></div><p><img src="/2020/06/23/SpringBoot%E6%97%A5%E5%BF%97/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131221411.png" srcset="/img/loading.gif" alt></p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring框架用的是commons-logging；</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==</strong></p><h2 id="4、日志使用；"><a href="#4、日志使用；" class="headerlink" title="4、日志使用；"></a>4、日志使用；</h2><h3 id="1、默认配置"><a href="#1、默认配置" class="headerlink" title="1、默认配置"></a>1、默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//记录器</span>Logger logger = LoggerFactory.getLogger(getClass());<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//System.out.println();</span><span class="hljs-comment">//日志的级别；</span><span class="hljs-comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span><span class="hljs-comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span>logger.trace(<span class="hljs-string">"这是trace日志..."</span>);logger.debug(<span class="hljs-string">"这是debug日志..."</span>);<span class="hljs-comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span>logger.info(<span class="hljs-string">"这是info日志..."</span>);logger.warn(<span class="hljs-string">"这是warn日志..."</span>);logger.error(<span class="hljs-string">"这是error日志..."</span>);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs haml">  日志输出格式：<span class="hljs-tag">%<span class="hljs-selector-tag">d</span></span>表示日期时间，<span class="hljs-tag">%<span class="hljs-selector-tag">thread</span></span>表示线程名，<span class="hljs-tag">%</span>-5level：级别从左显示5个字符宽度<span class="hljs-tag">%<span class="hljs-selector-tag">logger</span>&#123;50&#125;</span> 表示logger名字最长50个字符，否则按照句点分割。 <span class="hljs-tag">%<span class="hljs-selector-tag">msg</span></span>：日志消息，<span class="hljs-tag">%<span class="hljs-selector-tag">n</span></span>是换行符  -<span class="ruby">-&gt;</span><span class="ruby">  %d&#123;yyyy-MM-dd <span class="hljs-symbol">HH:</span><span class="hljs-symbol">mm:</span>ss.SSS&#125; [%thread] <span class="hljs-string">%-5level %logger&#123;50&#125; -</span> %msg%n</span></code></pre></div><p>SpringBoot修改日志的默认配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">logging.level.com.atguigu</span>=<span class="hljs-string">trace</span><span class="hljs-comment">#logging.path=</span><span class="hljs-comment"># 不指定路径在当前项目下生成springboot.log日志</span><span class="hljs-comment"># 可以指定完整的路径；</span><span class="hljs-comment">#logging.file=G:/springboot.log</span><span class="hljs-comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><span class="hljs-meta">logging.path</span>=<span class="hljs-string">/spring/log</span><span class="hljs-comment">#  在控制台输出的日志的格式</span><span class="hljs-meta">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><span class="hljs-comment"># 指定文件中日志输出的格式</span><span class="hljs-meta">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></code></pre></div><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>只在控制台输出</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>输出日志到my.log文件</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>输出到指定目录的 spring.log 文件中</td></tr></tbody></table><h3 id="2、指定配置"><a href="#2、指定配置" class="headerlink" title="2、指定配置"></a>2、指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"staging"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span>  可以指定某段配置只在某个环境下生效<span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span></code></pre></div><p>如：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stdout"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        日志输出格式：</span><span class="hljs-comment">%d表示日期时间，</span><span class="hljs-comment">%thread表示线程名，</span><span class="hljs-comment">%-5level：级别从左显示5个字符宽度</span><span class="hljs-comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><span class="hljs-comment">%msg：日志消息，</span><span class="hljs-comment">%n是换行符</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"!dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre></div><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p><p> <code>no applicable action for [springProfile]</code></p><h2 id="5、切换日志框架"><a href="#5、切换日志框架" class="headerlink" title="5、切换日志框架"></a>5、切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式；</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>切换为log4j2</p><div class="hljs"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><hr><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="/2020/06/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <url>/2020/06/23/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="1、自动配置原理："><a href="#1、自动配置原理：" class="headerlink" title="1、自动配置原理："></a>1、<strong>自动配置原理：</strong></h3><p><strong>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> 里面有 <span class="hljs-meta">@EnableAutoConfiguration</span></code></pre></div><p><strong>2）、@EnableAutoConfiguration 作用：</strong></p><ul><li><p>利用AutoConfigurationImportSelector给容器中导入一些组件</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoConfiguration</span> 里面有 <span class="hljs-meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span></code></pre></div><p>​</p></li><li><p>可以查看selectImports()方法的内容；</p><div class="hljs"><pre><code class="hljs java">类中有selectImports方法关键代码：List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</code></pre></div></li><li><p>SpringFactoriesLoader.loadFactoryNames()</p><div class="hljs"><pre><code class="hljs java">进入getCandidateConfigurations方法<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());        Assert.notEmpty(configurations, <span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);        <span class="hljs-keyword">return</span> configurations;    &#125;    再进入loadFactoryNames方法<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;        String factoryClassName = factoryClass.getName();        <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());    &#125;   再进入loadSpringFactories方法可以看到有关键性代码Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="hljs-string">"META-INF/spring.factories"</span>);<span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;        URL url = (URL)urls.nextElement();        UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);        Properties properties = PropertiesLoaderUtils.loadProperties(resource);       （这处代码有删减，源码篇幅过长）    &#125;</code></pre></div><p>扫描所有jar包类路径下  META-INF/spring.factories<br>把扫描到的这些文件的内容包装成properties对象</p><p>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</p><p>​</p></li></ul><p><strong>==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==</strong></p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># Auto Configure</span><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\<span class="hljs-attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></code></pre></div><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p><strong>3）、每一个自动配置类进行自动配置功能；</strong></p><p><strong>4）、以</strong>HttpEncodingAutoConfiguration（Http编码自动配置）<strong>为例解释自动配置原理；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>   <span class="hljs-comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)  //启动指定类的<span class="hljs-title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="hljs-title">HttpEncodingProperties</span>绑定起来；并把<span class="hljs-title">HttpEncodingProperties</span>加入到<span class="hljs-title">ioc</span>容器中</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span> //<span class="hljs-title">Spring</span>底层@<span class="hljs-title">Conditional</span>注解（<span class="hljs-title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="hljs-title">web</span>应用，如果是，当前配置类生效</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnClass</span>(<span class="hljs-title">CharacterEncodingFilter</span>.<span class="hljs-title">class</span>)  //判断当前项目有没有这个类<span class="hljs-title">CharacterEncodingFilter</span>；<span class="hljs-title">SpringMVC</span>中进行乱码解决的过滤器；</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">ConditionalOnProperty</span>(<span class="hljs-title">prefix</span> </span>= <span class="hljs-string">"spring.http.encoding"</span>, value = <span class="hljs-string">"enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)  <span class="hljs-comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span><span class="hljs-comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpEncodingProperties properties;     <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpEncodingProperties properties)</span> </span>&#123;<span class="hljs-keyword">this</span>.properties = properties;&#125;      <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>) //判断容器没有这个组件？</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">CharacterEncodingFilter</span> <span class="hljs-title">characterEncodingFilter</span>() </span>&#123;CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.REQUEST));filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(Type.RESPONSE));<span class="hljs-keyword">return</span> filter;&#125;</code></pre></div><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p><strong>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.http.encoding"</span>)  <span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingProperties</span> </span>&#123;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="hljs-string">"UTF-8"</span>);</code></pre></div><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><p><strong>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><div class="hljs"><pre><code class="hljs java">=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）-----------------   DispatcherServletAutoConfiguration matched:      - <span class="hljs-meta">@ConditionalOnClass</span> found required <span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">DispatcherServlet</span>'</span>; <span class="hljs-meta">@ConditionalOnMissingClass</span> <span class="hljs-function">did not find unwanted <span class="hljs-title">class</span> <span class="hljs-params">(OnClassCondition)</span></span><span class="hljs-function">      - @<span class="hljs-title">ConditionalOnWebApplication</span> <span class="hljs-params">(required)</span> found <span class="hljs-title">StandardServletEnvironment</span> <span class="hljs-params">(OnWebApplicationCondition)</span></span><span class="hljs-function">        </span><span class="hljs-function">    </span><span class="hljs-function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span><span class="hljs-function">-----------------</span><span class="hljs-function"></span><span class="hljs-function">   ActiveMQAutoConfiguration:</span><span class="hljs-function">      Did not match:</span><span class="hljs-function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="hljs-params">(OnClassCondition)</span></span><span class="hljs-function"></span><span class="hljs-function">   AopAutoConfiguration:</span><span class="hljs-function">      Did not match:</span><span class="hljs-function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="hljs-params">(OnClassCondition)</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类与实例初始化面试题</title>
    <link href="/2020/06/22/%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/06/22/%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jk.test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-06-15  21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = method();    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">"(1)"</span>);    &#125;    Father()&#123;        System.out.print(<span class="hljs-string">"(2)"</span>);    &#125;    &#123;        System.out.print(<span class="hljs-string">"(3)"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">"(4)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">"(5)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-keyword">package</span> com.jk.test;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mr.JK</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020-06-15  21:41</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = method();    <span class="hljs-keyword">static</span> &#123;        System.out.print(<span class="hljs-string">"(6)"</span>);    &#125;    Son()&#123;        System.out.print(<span class="hljs-string">"(7)"</span>);    &#125;    &#123;        System.out.print(<span class="hljs-string">"(8)"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(9)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(10)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Son son1 = <span class="hljs-keyword">new</span> Son();        System.out.println();        Son son2 = <span class="hljs-keyword">new</span> Son();    &#125;&#125;</code></pre></div><p>main函数执行后，大家可以试试看输出的顺序是什么？</p><h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><p>1、一个类的创建实例需要先加载并初始化该类<br>    - main方法所在的类需要先加载和初始化<br>2、一个子类要初始化需要先初始化父类<br>3、一个类初始化就是执行&lt;clinit&gt;()方法<br>    - &lt;clinit&gt;()方法由静态类变量显示赋值代码和静态代码块组成</p><hr><p>就是说在main方法启动的时候，就会去初始化类<br>因为在父类和子类中都有静态变量和静态代码块，静态变量和静态代码块顺序是根据代码书写的顺序执行的所以：<br>执行顺序为 （5）（1）（10）（6）</p><h2 id="实例的初始化过程"><a href="#实例的初始化过程" class="headerlink" title="实例的初始化过程"></a>实例的初始化过程</h2><p>实例初始化就是执行&lt;init&gt;()方法<br>    - &lt;init&gt;()方法可能重载有多个，有几个构造器就有几个&lt;init&gt;()方法<br>    - &lt;init&gt;()方法由非静态实例变量显示赋值代码和非静态代码块、对应构造器代码组成<br>    - 非静态实例变量显示复制代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行<br>    - 每次创建实例对象，调用对应构造器，执行的就是对应的&lt;init&gt;()方法<br>    - &lt;init&gt;()方法的首行是super()或super(实参列表)，即对应父类的&lt;init&gt;()方法</p><hr><p>就是说在调用构造函数进行实例的初始化时，不管有没有super关键字，都会调用父类的构造器先进行初始化，然后在初始化父类构造器后，再执行类中显示赋值代码和非静态代码块 比如Son子类的：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = test();&#123;        System.out.print(<span class="hljs-string">"(8)"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        System.out.print(<span class="hljs-string">"(10)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p>最后才是Son子类的构造器</p><div class="hljs"><pre><code class="hljs java">Son()&#123;        System.out.print(<span class="hljs-string">"(7)"</span>);&#125;</code></pre></div><p>所有根据以上的顺序得出的全部顺序为<br>（5）（1）（10）（6）（4）（3）（2）（9）（8）（7）<br>（4）（3）（2）（9）（8）（7）</p><p>以为到这里结束了嘛，其实这里还有一个坑，就是多态性，方法的重写！</p><h2 id="方法的重写Override"><a href="#方法的重写Override" class="headerlink" title="方法的重写Override"></a>方法的重写Override</h2><p>1、哪些方法不可以被重写<br>    - final方法<br>    - 静态方法<br>    - private等子类中不可见方法<br>2、对象的多态性<br>    - 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码<br>    - 非静态方法默认的调用对象是this<br>    - this对象在构造器或者说<init>方法中就是正在创建的对象</init></p><hr><p>也就是说在初始化父类实例时，初始化变量时候调用test（）方法，因为是非静态方法，所有默认调用对象this，是当前对象，也就是Son对象 所以实际执行的是子类重写的方法</p><p>最终的结果顺序为<br><img src="https://img-blog.csdnimg.cn/2020061522493926.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>一叶知秋，穿插了类与实例的初始化过程。<br>此文章根据尚硅谷视频加上个人理解与实践。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类与实例初始化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
