<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Mr.JK">
  <meta name="keywords" content="">
  <title>乐优商城day15：RabbitMQ及数据同步 - Mr.JK</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>





<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>私人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-10-01 10:00">
      2020-10-01
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      92
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
	
   
	
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>了解常见的MQ产品</li>
<li>了解RabbitMQ的5种消息模型</li>
<li>会使用Spring AMQP</li>
<li>利用MQ实现搜索和静态页的数据同步</li>
</ul>
<h1 id="1-RabbitMQ"><a href="#1-RabbitMQ" class="headerlink" title="1.RabbitMQ"></a>1.RabbitMQ</h1><h2 id="1-1-搜索与商品服务的问题"><a href="#1-1-搜索与商品服务的问题" class="headerlink" title="1.1.搜索与商品服务的问题"></a>1.1.搜索与商品服务的问题</h2><p>目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？</p>
<ul>
<li>商品的原始数据保存在数据库中，增删改查都在数据库中完成。</li>
<li>搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。</li>
<li>商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。</li>
</ul>
<p>如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？</p>
<p>这里有两种解决方案：</p>
<ul>
<li>方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面</li>
<li>方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口</li>
</ul>
<p>以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的<code>独立</code>原则。</p>
<p>所以，我们会通过另外一种方式来解决这个问题：消息队列</p>
<h2 id="1-2-消息队列（MQ）"><a href="#1-2-消息队列（MQ）" class="headerlink" title="1.2.消息队列（MQ）"></a>1.2.消息队列（MQ）</h2><h3 id="1-2-1-什么是消息队列"><a href="#1-2-1-什么是消息队列" class="headerlink" title="1.2.1.什么是消息队列"></a>1.2.1.什么是消息队列</h3><p>消息队列，即MQ，Message Queue。</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527063872737.png" srcset="/img/loading.gif" alt="1527063872737"></p>
<p>消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
<p>结合前面所说的问题：</p>
<ul>
<li>商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。</li>
<li>搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。</li>
</ul>
<p>如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。</p>
<h3 id="1-2-2-AMQP和JMS"><a href="#1-2-2-AMQP和JMS" class="headerlink" title="1.2.2.AMQP和JMS"></a>1.2.2.AMQP和JMS</h3><p>MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527064480681.png" srcset="/img/loading.gif" alt="1527064480681"></p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527064487042.png" srcset="/img/loading.gif" alt="1527064487042"></p>
<p>两者间的区别和联系：</p>
<ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模型；而AMQP的消息模型更加丰富</li>
</ul>
<h3 id="1-2-3-常见MQ产品"><a href="#1-2-3-常见MQ产品" class="headerlink" title="1.2.3.常见MQ产品"></a>1.2.3.常见MQ产品</h3><p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527064606029.png" srcset="/img/loading.gif" alt="1527064606029"></p>
<ul>
<li>ActiveMQ：基于JMS</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</li>
<li>Kafka：分布式消息系统，高吞吐量</li>
</ul>
<h3 id="1-2-4-RabbitMQ"><a href="#1-2-4-RabbitMQ" class="headerlink" title="1.2.4.RabbitMQ"></a>1.2.4.RabbitMQ</h3><p>RabbitMQ是基于AMQP的一款消息管理系统</p>
<p>官网： <a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p>
<p>官方教程：<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532758972119.png" srcset="/img/loading.gif" alt="1532758972119"></p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527064762982.png" srcset="/img/loading.gif" alt="1527064762982"></p>
<h2 id="1-3-下载和安装"><a href="#1-3-下载和安装" class="headerlink" title="1.3.下载和安装"></a>1.3.下载和安装</h2><h3 id="1-3-1-下载"><a href="#1-3-1-下载" class="headerlink" title="1.3.1.下载"></a>1.3.1.下载</h3><p>官网下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532759070767.png" srcset="/img/loading.gif" alt="1532759070767"></p>
<p>目前最新版本是：3.7.5</p>
<p>我们的课程中使用的是：3.4.1版本</p>
<p>课前资料提供了安装包：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532761948333.png" srcset="/img/loading.gif" alt="1532761948333"></p>
<h3 id="1-3-2-安装"><a href="#1-3-2-安装" class="headerlink" title="1.3.2.安装"></a>1.3.2.安装</h3><p>详见课前资料中的：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532761916357.png" srcset="/img/loading.gif" alt="1532761916357"></p>
<h1 id="2-五种消息模型"><a href="#2-五种消息模型" class="headerlink" title="2.五种消息模型"></a>2.五种消息模型</h1><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。</p>
<p>但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527068544487.png" srcset="/img/loading.gif" alt="1527068544487"></p>
<p>我们通过一个demo工程来了解下RabbitMQ的工作方式：</p>
<p>导入工程：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532762038694.png" srcset="/img/loading.gif" alt="1532762038694"></p>
<p>导入后：</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532762308507.png" srcset="/img/loading.gif" alt="1532762308507"></p>
<p>依赖：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">	<span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itcast.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>itcast-rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionUtil</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 建立与RabbitMQ的连接</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//定义连接工厂</span>
        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();
        <span class="hljs-comment">//设置服务地址</span>
        factory.setHost(<span class="hljs-string">"192.168.56.101"</span>);
        <span class="hljs-comment">//端口</span>
        factory.setPort(<span class="hljs-number">5672</span>);
        <span class="hljs-comment">//设置账号信息，用户名、密码、vhost</span>
        factory.setVirtualHost(<span class="hljs-string">"/leyou"</span>);
        factory.setUsername(<span class="hljs-string">"leyou"</span>);
        factory.setPassword(<span class="hljs-string">"leyou"</span>);
        <span class="hljs-comment">// 通过工程获取连接</span>
        Connection connection = factory.newConnection();
        <span class="hljs-keyword">return</span> connection;
    &#125;
&#125;</code></pre></div>



<h2 id="2-1-基本消息模型"><a href="#2-1-基本消息模型" class="headerlink" title="2.1.基本消息模型"></a>2.1.基本消息模型</h2><p>官方介绍：</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532762961149.png" srcset="/img/loading.gif" alt="1532762961149"></p>
<p>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。</p>
<p>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532762975546.png" srcset="/img/loading.gif" alt="1532762975546"></p>
<p>P（producer/ publisher）：生产者，一个发送消息的用户应用程序。</p>
<p>C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序</p>
<p>队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。</p>
<p>总之：</p>
<p>生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。</p>
<p>我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。</p>
<p>我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。</p>
<h3 id="2-1-1-生产者发送消息"><a href="#2-1-1-生产者发送消息" class="headerlink" title="2.1.1.生产者发送消息"></a>2.1.1.生产者发送消息</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"simple_queue"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接以及mq通道</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 从连接中创建通道，这是完成大部分API的地方。</span>
        Channel channel = connection.createChannel();

        <span class="hljs-comment">// 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。</span>
        <span class="hljs-comment">// 声明一个队列是幂等的 - 只有当它不存在时才会被创建</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">// 消息内容</span>
        String message = <span class="hljs-string">"Hello World!"</span>;
        channel.basicPublish(<span class="hljs-string">""</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes());
        System.out.println(<span class="hljs-string">" [x] Sent '"</span> + message + <span class="hljs-string">"'"</span>);

        <span class="hljs-comment">//关闭通道和连接</span>
        channel.close();
        connection.close();
    &#125;
&#125;</code></pre></div>

<p>控制台：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532763328424.png" srcset="/img/loading.gif" alt="1532763328424"></p>
<h3 id="2-1-2-管理工具中查看消息"><a href="#2-1-2-管理工具中查看消息" class="headerlink" title="2.1.2.管理工具中查看消息"></a>2.1.2.管理工具中查看消息</h3><p>进入队列页面，可以看到新建了一个队列：simple_queue</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532763817830.png" srcset="/img/loading.gif" alt="1532763817830"></p>
<p>点击队列名称，进入详情页，可以查看消息：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532763489858.png" srcset="/img/loading.gif" alt="1532763489858"></p>
<p>在控制台查看消息并不会将消息消费，所以消息还在。</p>
<h3 id="2-1-3-消费者获取消息"><a href="#2-1-3-消费者获取消息" class="headerlink" title="2.1.3.消费者获取消息"></a>2.1.3.消费者获取消息</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"simple_queue"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 创建通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [x] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，第二个参数：是否自动进行消息确认。</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>

<p>控制台：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532763733443.png" srcset="/img/loading.gif" alt="1532763733443"></p>
<p>这个时候，队列中的消息就没了：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532763773208.png" srcset="/img/loading.gif" alt="1532763773208"></p>
<p>我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.</p>
<h3 id="2-1-4-消息确认机制（ACK）"><a href="#2-1-4-消息确认机制（ACK）" class="headerlink" title="2.1.4.消息确认机制（ACK）"></a>2.1.4.消息确认机制（ACK）</h3><p>通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。</p>
<p>那么问题来了：RabbitMQ怎么知道消息被接收了呢？</p>
<p>如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！</p>
<p>因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p>
<ul>
<li>自动ACK：消息一旦被接收，消费者自动发送ACK</li>
<li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li>
</ul>
<p>大家觉得哪种更好呢？</p>
<p>这需要看消息的重要性：</p>
<ul>
<li>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便</li>
<li>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</li>
</ul>
<p>我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"simple_queue"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 创建通道</span>
        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [x] received : "</span> + msg + <span class="hljs-string">"!"</span>);
                <span class="hljs-comment">// 手动进行ACK</span>
                channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，第二个参数false，手动进行ACK</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">false</span>, consumer);
    &#125;
&#125;</code></pre></div>

<p>注意到最后一行代码：</p>
<div class="hljs"><pre><code class="hljs java">channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">false</span>, consumer);</code></pre></div>

<p>如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764253019.png" srcset="/img/loading.gif" alt="1532764253019"></p>
<h4 id="2-1-4-1-自动ACK存在的问题"><a href="#2-1-4-1-自动ACK存在的问题" class="headerlink" title="2.1.4.1.自动ACK存在的问题"></a>2.1.4.1.自动ACK存在的问题</h4><p>修改消费者，添加异常，如下：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764600849.png" srcset="/img/loading.gif" alt="1532764600849"></p>
<p>生产者不做任何修改，直接运行，消息发送成功：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764694290.png" srcset="/img/loading.gif" alt="1532764694290"></p>
<p>运行消费者，程序抛出异常。但是消息依然被消费：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764717995.png" srcset="/img/loading.gif" alt="1532764717995"></p>
<p>管理界面：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764734232.png" srcset="/img/loading.gif" alt="1532764734232"></p>
<h4 id="2-1-4-2-演示手动ACK"><a href="#2-1-4-2-演示手动ACK" class="headerlink" title="2.1.4.2.演示手动ACK"></a>2.1.4.2.演示手动ACK</h4><p>修改消费者，把自动改成手动（去掉之前制造的异常）</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764831241.png" srcset="/img/loading.gif" alt="1532764831241"></p>
<p>生产者不变，再次运行：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764895239.png" srcset="/img/loading.gif" alt="1532764895239"></p>
<p>运行消费者</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532764957092.png" srcset="/img/loading.gif" alt="1532764957092"></p>
<p>但是，查看管理界面，发现：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532765013834.png" srcset="/img/loading.gif" alt="1532765013834"></p>
<p>停掉消费者的程序，发现：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532765038088.png" srcset="/img/loading.gif" alt="1532765038088"></p>
<p>这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。</p>
<p>当我们关掉这个消费者，消息的状态再次称为Ready</p>
<p>修改代码手动ACK：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532765123282.png" srcset="/img/loading.gif" alt="1532765123282"></p>
<p>执行：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532765151039.png" srcset="/img/loading.gif" alt="1532765151039"></p>
<p>消息消费成功！</p>
<h2 id="2-2-work消息模型"><a href="#2-2-work消息模型" class="headerlink" title="2.2.work消息模型"></a>2.2.work消息模型</h2><p>工作队列或者竞争消费者模式</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532765197277.png" srcset="/img/loading.gif" alt="1532765197277"></p>
<p>在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。</p>
<p>工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。</p>
<p>这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<p>​    P：生产者：任务的发布者</p>
<p>​    C1：消费者，领取任务并且完成任务，假设完成速度较快</p>
<p>​    C2：消费者2：领取任务并完成任务，假设完成速度慢</p>
<p>面试题：避免消息堆积？</p>
<p>1） 采用workqueue，多个消费者监听同一队列。</p>
<p>2）接收到消息以后，而是通过线程池，异步消费。</p>
<h3 id="2-2-1-生产者"><a href="#2-2-1-生产者" class="headerlink" title="2.2.1.生产者"></a>2.2.1.生产者</h3><p>生产者与案例1中的几乎一样：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"test_work_queue"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        <span class="hljs-comment">// 循环发布任务</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
            <span class="hljs-comment">// 消息内容</span>
            String message = <span class="hljs-string">"task .. "</span> + i;
            channel.basicPublish(<span class="hljs-string">""</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes());
            System.out.println(<span class="hljs-string">" [x] Sent '"</span> + message + <span class="hljs-string">"'"</span>);

            Thread.sleep(i * <span class="hljs-number">2</span>);
        &#125;
        <span class="hljs-comment">// 关闭通道和连接</span>
        channel.close();
        connection.close();
    &#125;
&#125;</code></pre></div>

<p>不过这里我们是循环发送50条消息。</p>
<h3 id="2-2-2-消费者1"><a href="#2-2-2-消费者1" class="headerlink" title="2.2.2.消费者1"></a>2.2.2.消费者1</h3><p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527085386747.png" srcset="/img/loading.gif" alt="1527085386747"></p>
<h3 id="2-2-3-消费者2"><a href="#2-2-3-消费者2" class="headerlink" title="2.2.3.消费者2"></a>2.2.3.消费者2</h3><p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527085448377.png" srcset="/img/loading.gif" alt="1527085448377"></p>
<p>与消费者1基本类似，就是没有设置消费耗时时间。</p>
<p>这里是模拟有些消费者快，有些比较慢。</p>
<p>接下来，两个消费者一同启动，然后发送50条消息：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527085826462.png" srcset="/img/loading.gif" alt="1527085826462"></p>
<p>可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。</p>
<h3 id="2-2-4-能者多劳"><a href="#2-2-4-能者多劳" class="headerlink" title="2.2.4.能者多劳"></a>2.2.4.能者多劳</h3><p>刚才的实现有问题吗？</p>
<ul>
<li>消费者1比消费者2的效率要低，一次任务的耗时较长</li>
<li>然而两人最终消费的消息数量是一样的</li>
<li>消费者2大量时间处于空闲状态，消费者1一直忙碌</li>
</ul>
<p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p>
<p>怎么实现呢？</p>
<p>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532765689904.png" srcset="/img/loading.gif" alt="1532765689904"></p>
<p>再次测试：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527086159534.png" srcset="/img/loading.gif" alt="1527086159534"></p>
<h2 id="2-3-订阅模型分类"><a href="#2-3-订阅模型分类" class="headerlink" title="2.3.订阅模型分类"></a>2.3.订阅模型分类</h2><p>在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 </p>
<p>订阅模型示意图：</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527086284940.png" srcset="/img/loading.gif" alt="1527086284940"></p>
<p>解读：</p>
<p>1、1个生产者，多个消费者</p>
<p>2、每一个消费者都有自己的一个队列</p>
<p>3、生产者没有将消息直接发送到队列，而是发送到了交换机</p>
<p>4、每个队列都要绑定到交换机</p>
<p>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的</p>
<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>
<p>Exchange类型有以下几种：</p>
<p>​         Fanout：广播，将消息交给所有绑定到交换机的队列</p>
<p>​         Direct：定向，把消息交给符合指定routing key 的队列</p>
<p>​         Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p>
<p>我们这里先学习</p>
<p>​    Fanout：即广播模式</p>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="2-4-订阅模型-Fanout"><a href="#2-4-订阅模型-Fanout" class="headerlink" title="2.4.订阅模型-Fanout"></a>2.4.订阅模型-Fanout</h2><p>Fanout，也称为广播。</p>
<p>流程图：</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527086564505.png" srcset="/img/loading.gif" alt="1527086564505"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个消费者</li>
<li>2）  每个<strong>消费者有自己的queue</strong>（队列）</li>
<li>3）  每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li>4）  <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li>
<li>5）  交换机把消息发送给绑定过的所有队列</li>
<li>6）  队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li>
</ul>
<h3 id="2-4-1-生产者"><a href="#2-4-1-生产者" class="headerlink" title="2.4.1.生产者"></a>2.4.1.生产者</h3><p>两个变化：</p>
<ul>
<li>1）  声明Exchange，不再声明Queue</li>
<li>2）  发送消息到Exchange，不再发送到Queue</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        
        <span class="hljs-comment">// 声明exchange，指定类型为fanout</span>
        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">"fanout"</span>);
        
        <span class="hljs-comment">// 消息内容</span>
        String message = <span class="hljs-string">"Hello everyone"</span>;
        <span class="hljs-comment">// 发布消息到Exchange</span>
        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">""</span>, <span class="hljs-keyword">null</span>, message.getBytes());
        System.out.println(<span class="hljs-string">" [生产者] Sent '"</span> + message + <span class="hljs-string">"'"</span>);

        channel.close();
        connection.close();
    &#125;
&#125;</code></pre></div>

<h3 id="2-4-2-消费者1"><a href="#2-4-2-消费者1" class="headerlink" title="2.4.2.消费者1"></a>2.4.2.消费者1</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"fanout_exchange_queue_1"</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">// 绑定队列到交换机</span>
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">""</span>);

        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [消费者1] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，自动返回完成</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>

<p>要注意代码中：<strong>队列需要和交换机绑定</strong></p>
<h3 id="2-4-3-消费者2"><a href="#2-4-3-消费者2" class="headerlink" title="2.4.3.消费者2"></a>2.4.3.消费者2</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"fanout_exchange_queue_2"</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"fanout_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);

        <span class="hljs-comment">// 绑定队列到交换机</span>
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">""</span>);
        
        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [消费者2] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，手动返回完成</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>



<h3 id="2-4-4-测试"><a href="#2-4-4-测试" class="headerlink" title="2.4.4.测试"></a>2.4.4.测试</h3><p>我们运行两个消费者，然后发送1条消息：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532766264386.png" srcset="/img/loading.gif" alt="1532766264386"></p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532766291204.png" srcset="/img/loading.gif" alt="1532766291204"></p>
<h2 id="2-5-订阅模型-Direct"><a href="#2-5-订阅模型-Direct" class="headerlink" title="2.5.订阅模型-Direct"></a>2.5.订阅模型-Direct</h2><p>有选择性的接收消息</p>
<p>在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。</p>
<p>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p>
<p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p>
<p>消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532766437787.png" srcset="/img/loading.gif" alt="1532766437787"></p>
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<h3 id="2-5-1-生产者"><a href="#2-5-1-生产者" class="headerlink" title="2.5.1.生产者"></a>2.5.1.生产者</h3><p>此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明exchange，指定类型为direct</span>
        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">"direct"</span>);
        <span class="hljs-comment">// 消息内容</span>
        String message = <span class="hljs-string">"商品新增了， id = 1001"</span>;
        <span class="hljs-comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span>
        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">"insert"</span>, <span class="hljs-keyword">null</span>, message.getBytes());
        System.out.println(<span class="hljs-string">" [商品服务：] Sent '"</span> + message + <span class="hljs-string">"'"</span>);

        channel.close();
        connection.close();
    &#125;
&#125;</code></pre></div>

<h3 id="2-5-2-消费者1"><a href="#2-5-2-消费者1" class="headerlink" title="2.5.2.消费者1"></a>2.5.2.消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"direct_exchange_queue_1"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        
        <span class="hljs-comment">// 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息</span>
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"update"</span>);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"delete"</span>);

        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [消费者1] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，自动ACK</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>



<h3 id="2-5-3-消费者2"><a href="#2-5-3-消费者2" class="headerlink" title="2.5.3.消费者2"></a>2.5.3.消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"direct_exchange_queue_2"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"direct_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        
        <span class="hljs-comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span>
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"insert"</span>);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"update"</span>);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"delete"</span>);

        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [消费者2] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，自动ACK</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>



<h3 id="2-5-4-测试"><a href="#2-5-4-测试" class="headerlink" title="2.5.4.测试"></a>2.5.4.测试</h3><p>我们分别发送增、删、改的RoutingKey，发现结果：</p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527088296131.png" srcset="/img/loading.gif" alt="1527088296131"></p>
<h2 id="2-6-订阅模型-Topic"><a href="#2-6-订阅模型-Topic" class="headerlink" title="2.6.订阅模型-Topic"></a>2.6.订阅模型-Topic</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<p>​         <code>#</code>：匹配一个或多个词</p>
<p>​         <code>*</code>：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p>​         <code>audit.#</code>：能够匹配<code>audit.irs.corporate</code> 或者 <code>audit.irs</code></p>
<p>​         <code>audit.*</code>：只能匹配<code>audit.irs</code></p>
<p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532766712166.png" srcset="/img/loading.gif" alt="1532766712166"></p>
<p>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</species></color></speed></p>
<p>我们创建了三个绑定：Q1绑定了绑定键“* .orange.<em>”，Q2绑定了“</em>.*.rabbit”和“lazy.＃”。</p>
<p>Q1匹配所有的橙色动物。</p>
<p>Q2匹配关于兔子以及懒惰动物的消息。</p>
<p>练习，生产者发送如下消息，会进入那个队列：</p>
<p>quick.orange.rabbit à Q1 Q2</p>
<p>lazy.orange.elephant à Q1 Q2</p>
<p>quick.orange.fox à Q1</p>
<p>lazy.pink.rabbit à Q2</p>
<p>quick.brown.fox à 不匹配任意队列，被丢弃</p>
<p>quick.orange.male.rabbit à </p>
<p>orange à </p>
<h3 id="2-6-1-生产者"><a href="#2-6-1-生产者" class="headerlink" title="2.6.1.生产者"></a>2.6.1.生产者</h3><p>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.isnert</code>、<code>item.update</code>、<code>item.delete</code>：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Send</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"topic_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明exchange，指定类型为topic</span>
        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">"topic"</span>);
        <span class="hljs-comment">// 消息内容</span>
        String message = <span class="hljs-string">"新增商品 : id = 1001"</span>;
        <span class="hljs-comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span>
        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">"item.insert"</span>, <span class="hljs-keyword">null</span>, message.getBytes());
        System.out.println(<span class="hljs-string">" [商品服务：] Sent '"</span> + message + <span class="hljs-string">"'"</span>);

        channel.close();
        connection.close();
    &#125;
&#125;</code></pre></div>

<h3 id="2-6-2-消费者1"><a href="#2-6-2-消费者1" class="headerlink" title="2.6.2.消费者1"></a>2.6.2.消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"topic_exchange_queue_1"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"topic_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        
        <span class="hljs-comment">// 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete</span>
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"item.update"</span>);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"item.delete"</span>);

        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [消费者1] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，自动ACK</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>



<h3 id="2-6-3-消费者2"><a href="#2-6-3-消费者2" class="headerlink" title="2.6.3.消费者2"></a>2.6.3.消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 消费者2</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recv2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String QUEUE_NAME = <span class="hljs-string">"topic_exchange_queue_2"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String EXCHANGE_NAME = <span class="hljs-string">"topic_exchange_test"</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 获取到连接</span>
        Connection connection = ConnectionUtil.getConnection();
        <span class="hljs-comment">// 获取通道</span>
        Channel channel = connection.createChannel();
        <span class="hljs-comment">// 声明队列</span>
        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
        
        <span class="hljs-comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span>
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">"item.*"</span>);

        <span class="hljs-comment">// 定义队列的消费者</span>
        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;
            <span class="hljs-comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span>
<span class="hljs-function"><span class="hljs-params">                    <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
                <span class="hljs-comment">// body 即消息体</span>
                String msg = <span class="hljs-keyword">new</span> String(body);
                System.out.println(<span class="hljs-string">" [消费者2] received : "</span> + msg + <span class="hljs-string">"!"</span>);
            &#125;
        &#125;;
        <span class="hljs-comment">// 监听队列，自动ACK</span>
        channel.basicConsume(QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);
    &#125;
&#125;</code></pre></div>



<h2 id="2-7-持久化"><a href="#2-7-持久化" class="headerlink" title="2.7.持久化"></a>2.7.持久化</h2><p>如何避免消息丢失？</p>
<p>1）  消费者的ACK机制。可以防止消费者丢失消息。</p>
<p>2）  但是，如果在消费者消费之前，MQ就宕机了，消息就没了。</p>
<p>是可以将消息进行持久化呢？</p>
<p> 要将消息持久化，前提是：队列、Exchange都持久化</p>
<h3 id="2-7-1-交换机持久化"><a href="#2-7-1-交换机持久化" class="headerlink" title="2.7.1.交换机持久化"></a>2.7.1.交换机持久化</h3><p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532766951432.png" srcset="/img/loading.gif" alt="1532766951432"></p>
<h3 id="2-7-2-队列持久化"><a href="#2-7-2-队列持久化" class="headerlink" title="2.7.2.队列持久化"></a>2.7.2.队列持久化</h3><p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532766981230.png" srcset="/img/loading.gif" alt="1532766981230"></p>
<h3 id="2-7-3-消息持久化"><a href="#2-7-3-消息持久化" class="headerlink" title="2.7.3.消息持久化"></a>2.7.3.消息持久化</h3><p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532767057491.png" srcset="/img/loading.gif" alt="1532767057491"></p>
<h1 id="3-Spring-AMQP"><a href="#3-Spring-AMQP" class="headerlink" title="3.Spring AMQP"></a>3.Spring AMQP</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>Sprin有很多不同的项目，其中就有对AMQP的支持：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532767136007.png" srcset="/img/loading.gif" alt="1532767136007"></p>
<p>Spring AMQP的页面：<a href="http://spring.io/projects/spring-amqp" target="_blank" rel="noopener">http://spring.io/projects/spring-amqp</a></p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532767171063.png" srcset="/img/loading.gif" alt="1532767171063"></p>
<p>注意这里一段描述：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532767227821.png" srcset="/img/loading.gif" alt="1532767227821">                                             </p>
<p>​         Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。</p>
<h2 id="2-2-依赖和配置"><a href="#2-2-依赖和配置" class="headerlink" title="2.2.依赖和配置"></a>2.2.依赖和配置</h2><p>添加AMQP的启动器：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>在<code>application.yml</code>中添加RabbitMQ地址：</p>
<div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.101</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/leyou</span></code></pre></div>

<h2 id="2-3-监听者"><a href="#2-3-监听者" class="headerlink" title="2.3.监听者"></a>2.3.监听者</h2><p>在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener</span> </span>&#123;

    <span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(
            value = <span class="hljs-meta">@Queue</span>(value = <span class="hljs-string">"spring.test.queue"</span>, durable = <span class="hljs-string">"true"</span>),
            exchange = <span class="hljs-meta">@Exchange</span>(
                    value = <span class="hljs-string">"spring.test.exchange"</span>,
                    ignoreDeclarationExceptions = <span class="hljs-string">"true"</span>,
                    type = ExchangeTypes.TOPIC
            ),
            key = &#123;<span class="hljs-string">"#.#"</span>&#125;))
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">(String msg)</span></span>&#123;
        System.out.println(<span class="hljs-string">"接收到消息："</span> + msg);
    &#125;
&#125;</code></pre></div>

<ul>
<li><code>@Componet</code>：类上的注解，注册到Spring容器</li>
<li><code>@RabbitListener</code>：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：<ul>
<li><code>bindings</code>：指定绑定关系，可以有多个。值是<code>@QueueBinding</code>的数组。<code>@QueueBinding</code>包含下面属性：<ul>
<li><code>value</code>：这个消费者关联的队列。值是<code>@Queue</code>，代表一个队列</li>
<li><code>exchange</code>：队列所绑定的交换机，值是<code>@Exchange</code>类型</li>
<li><code>key</code>：队列和交换机绑定的<code>RoutingKey</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类似listen这样的方法在一个类中可以写多个，就代表多个消费者。</p>
<h2 id="2-4-AmqpTemplate"><a href="#2-4-AmqpTemplate" class="headerlink" title="2.4.AmqpTemplate"></a>2.4.AmqpTemplate</h2><p>Spring最擅长的事情就是封装，把他人的框架进行封装和整合。</p>
<p>Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1527090258083.png" srcset="/img/loading.gif" alt="1527090258083"></p>
<p>红框圈起来的是比较常用的3个方法，分别是：</p>
<ul>
<li>指定交换机、RoutingKey和消息体</li>
<li>指定消息</li>
<li>指定RoutingKey和消息，会向默认的交换机发送消息</li>
</ul>
<h2 id="2-5-测试代码"><a href="#2-5-测试代码" class="headerlink" title="2.5.测试代码"></a>2.5.测试代码</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= Application<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MqDemo</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSend</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        String msg = <span class="hljs-string">"hello, Spring boot amqp"</span>;
        <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(<span class="hljs-string">"spring.test.exchange"</span>,<span class="hljs-string">"a.b"</span>, msg);
        <span class="hljs-comment">// 等待10秒后再结束</span>
        Thread.sleep(<span class="hljs-number">10000</span>);
    &#125;
&#125;</code></pre></div>

<p>运行后查看日志：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532767726274.png" srcset="/img/loading.gif" alt="1532767726274"></p>
<h1 id="3-项目改造"><a href="#3-项目改造" class="headerlink" title="3.项目改造"></a>3.项目改造</h1><p>接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。</p>
<h2 id="3-1-思路分析"><a href="#3-1-思路分析" class="headerlink" title="3.1.思路分析"></a>3.1.思路分析</h2><blockquote>
<p>发送方：商品微服务</p>
</blockquote>
<ul>
<li><p>什么时候发？</p>
<p>当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。</p>
</li>
<li><p>发送什么内容？</p>
<p>对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们<strong>只发送商品id</strong>，其它服务可以根据id查询自己需要的信息。</p>
</li>
</ul>
<blockquote>
<p>接收方：搜索微服务、静态页微服务</p>
</blockquote>
<p>接收消息后如何处理？</p>
<ul>
<li>搜索微服务：<ul>
<li>增/改：添加新的数据到索引库</li>
<li>删：删除索引库数据</li>
</ul>
</li>
<li>静态页微服务：<ul>
<li>增：创建新的静态页</li>
<li>删：删除原来的静态页</li>
<li>改：创建新的静态页并删除原来的</li>
</ul>
</li>
</ul>
<h2 id="3-2-商品服务发送消息"><a href="#3-2-商品服务发送消息" class="headerlink" title="3.2.商品服务发送消息"></a>3.2.商品服务发送消息</h2><p>我们先在商品微服务<code>leyou-item-service</code>中实现发送消息。</p>
<h3 id="3-2-1-引入依赖"><a href="#3-2-1-引入依赖" class="headerlink" title="3.2.1.引入依赖"></a>3.2.1.引入依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="3-2-2-配置文件"><a href="#3-2-2-配置文件" class="headerlink" title="3.2.2.配置文件"></a>3.2.2.配置文件</h3><p>我们在application.yml中添加一些有关RabbitMQ的配置：</p>
<div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.101</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/leyou</span>
    <span class="hljs-attr">template:</span>
      <span class="hljs-attr">exchange:</span> <span class="hljs-string">leyou.item.exchange</span>
    <span class="hljs-attr">publisher-confirms:</span> <span class="hljs-literal">true</span></code></pre></div>

<ul>
<li>template：有关<code>AmqpTemplate</code>的配置<ul>
<li>retry：失败重试<ul>
<li>enabled：开启失败重试</li>
<li>initial-interval：第一次重试的间隔时长</li>
<li>max-interval：最长重试间隔，超过这个间隔将不再重试</li>
<li>multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍</li>
</ul>
</li>
<li>exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个</li>
</ul>
</li>
<li>publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试</li>
</ul>
<h3 id="3-2-3-改造GoodsService"><a href="#3-2-3-改造GoodsService" class="headerlink" title="3.2.3.改造GoodsService"></a>3.2.3.改造GoodsService</h3><p>在GoodsService中封装一个发送消息到mq的方法：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(Long id, String type)</span></span>&#123;
    <span class="hljs-comment">// 发送消息</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(<span class="hljs-string">"item."</span> + type, id);
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        logger.error(<span class="hljs-string">"&#123;&#125;商品消息发送异常，商品id：&#123;&#125;"</span>, type, id, e);
    &#125;
&#125;</code></pre></div>

<p>这里没有指定交换机，因此默认发送到了配置中的：<code>leyou.item.exchange</code></p>
<p><strong>注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑</strong></p>
<p>然后在新增的时候调用：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532768930797.png" srcset="/img/loading.gif" alt="1532768930797"></p>
<p>修改的时候调用：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532769005960.png" srcset="/img/loading.gif" alt="1532769005960"></p>
<h2 id="3-3-搜索服务接收消息"><a href="#3-3-搜索服务接收消息" class="headerlink" title="3.3.搜索服务接收消息"></a>3.3.搜索服务接收消息</h2><p>搜索服务接收到消息后要做的事情：</p>
<ul>
<li>增：添加新的数据到索引库</li>
<li>删：删除索引库数据</li>
<li>改：修改索引库数据</li>
</ul>
<p>因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。</p>
<h3 id="3-3-1-引入依赖"><a href="#3-3-1-引入依赖" class="headerlink" title="3.3.1.引入依赖"></a>3.3.1.引入依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="3-3-2-添加配置"><a href="#3-3-2-添加配置" class="headerlink" title="3.3.2.添加配置"></a>3.3.2.添加配置</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.101</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/leyou</span></code></pre></div>

<p>这里只是接收消息而不发送，所以不用配置template相关内容。</p>
<h3 id="3-3-3-编写监听器"><a href="#3-3-3-编写监听器" class="headerlink" title="3.3.3.编写监听器"></a>3.3.3.编写监听器</h3><p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532769181819.png" srcset="/img/loading.gif" alt="1532769181819"></p>
<p>代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsListener</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> SearchService searchService;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 处理insert和update的消息</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(
            value = <span class="hljs-meta">@Queue</span>(value = <span class="hljs-string">"leyou.create.index.queue"</span>, durable = <span class="hljs-string">"true"</span>),
            exchange = <span class="hljs-meta">@Exchange</span>(
                    value = <span class="hljs-string">"leyou.item.exchange"</span>,
                    ignoreDeclarationExceptions = <span class="hljs-string">"true"</span>,
                    type = ExchangeTypes.TOPIC),
            key = &#123;<span class="hljs-string">"item.insert"</span>, <span class="hljs-string">"item.update"</span>&#125;))
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenCreate</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">if</span> (id == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// 创建或更新索引</span>
        <span class="hljs-keyword">this</span>.searchService.createIndex(id);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 处理delete的消息</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(
            value = <span class="hljs-meta">@Queue</span>(value = <span class="hljs-string">"leyou.delete.index.queue"</span>, durable = <span class="hljs-string">"true"</span>),
            exchange = <span class="hljs-meta">@Exchange</span>(
                    value = <span class="hljs-string">"leyou.item.exchange"</span>,
                    ignoreDeclarationExceptions = <span class="hljs-string">"true"</span>,
                    type = ExchangeTypes.TOPIC),
            key = <span class="hljs-string">"item.delete"</span>))
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenDelete</span><span class="hljs-params">(Long id)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (id == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// 删除索引</span>
        <span class="hljs-keyword">this</span>.searchService.deleteIndex(id);
    &#125;
&#125;</code></pre></div>



<h3 id="3-3-4-编写创建和删除索引方法"><a href="#3-3-4-编写创建和删除索引方法" class="headerlink" title="3.3.4.编写创建和删除索引方法"></a>3.3.4.编写创建和删除索引方法</h3><p>这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createIndex</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;

    Spu spu = <span class="hljs-keyword">this</span>.goodsClient.querySpuById(id);
    <span class="hljs-comment">// 构建商品</span>
    Goods goods = <span class="hljs-keyword">this</span>.buildGoods(spu);

    <span class="hljs-comment">// 保存数据到索引库</span>
    <span class="hljs-keyword">this</span>.goodsRepository.save(goods);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteIndex</span><span class="hljs-params">(Long id)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.goodsRepository.deleteById(id);
&#125;</code></pre></div>

<p>创建索引的方法可以从之前导入数据的测试类中拷贝和改造。</p>
<h2 id="3-4-静态页服务接收消息"><a href="#3-4-静态页服务接收消息" class="headerlink" title="3.4.静态页服务接收消息"></a>3.4.静态页服务接收消息</h2><p>商品静态页服务接收到消息后的处理：</p>
<ul>
<li>增：创建新的静态页</li>
<li>删：删除原来的静态页</li>
<li>改：创建新的静态页并删除原来的</li>
</ul>
<p>不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。</p>
<h3 id="3-4-1-引入依赖"><a href="#3-4-1-引入依赖" class="headerlink" title="3.4.1.引入依赖"></a>3.4.1.引入依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="3-4-2-添加配置"><a href="#3-4-2-添加配置" class="headerlink" title="3.4.2.添加配置"></a>3.4.2.添加配置</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.101</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">leyou</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/leyou</span></code></pre></div>

<p>这里只是接收消息而不发送，所以不用配置template相关内容。</p>
<h3 id="3-4-3-编写监听器"><a href="#3-4-3-编写监听器" class="headerlink" title="3.4.3.编写监听器"></a>3.4.3.编写监听器</h3><p> <img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532769581964.png" srcset="/img/loading.gif" alt="1532769581964"></p>
<p>代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsListener</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> GoodsHtmlService goodsHtmlService;

    <span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(
            value = <span class="hljs-meta">@Queue</span>(value = <span class="hljs-string">"leyou.create.web.queue"</span>, durable = <span class="hljs-string">"true"</span>),
            exchange = <span class="hljs-meta">@Exchange</span>(
                    value = <span class="hljs-string">"leyou.item.exchange"</span>,
                    ignoreDeclarationExceptions = <span class="hljs-string">"true"</span>,
                    type = ExchangeTypes.TOPIC),
            key = &#123;<span class="hljs-string">"item.insert"</span>, <span class="hljs-string">"item.update"</span>&#125;))
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenCreate</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">if</span> (id == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// 创建页面</span>
        goodsHtmlService.createHtml(id);
    &#125;

    <span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(
            value = <span class="hljs-meta">@Queue</span>(value = <span class="hljs-string">"leyou.delete.web.queue"</span>, durable = <span class="hljs-string">"true"</span>),
            exchange = <span class="hljs-meta">@Exchange</span>(
                    value = <span class="hljs-string">"leyou.item.exchange"</span>,
                    ignoreDeclarationExceptions = <span class="hljs-string">"true"</span>,
                    type = ExchangeTypes.TOPIC),
            key = <span class="hljs-string">"item.delete"</span>))
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenDelete</span><span class="hljs-params">(Long id)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (id == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">// 创建页面</span>
        goodsHtmlService.deleteHtml(id);
    &#125;
&#125;</code></pre></div>

<h3 id="3-4-4-添加删除页面方法"><a href="#3-4-4-添加删除页面方法" class="headerlink" title="3.4.4.添加删除页面方法"></a>3.4.4.添加删除页面方法</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteHtml</span><span class="hljs-params">(Long id)</span> </span>&#123;
    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\project\\nginx-1.14.0\\html\\item\\"</span>, id + <span class="hljs-string">".html"</span>);
    file.deleteOnExit();
&#125;</code></pre></div>



<h2 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5.测试"></a>3.5.测试</h2><h3 id="3-5-1-查看RabbitMQ控制台"><a href="#3-5-1-查看RabbitMQ控制台" class="headerlink" title="3.5.1.查看RabbitMQ控制台"></a>3.5.1.查看RabbitMQ控制台</h3><p>重新启动项目，并且登录RabbitMQ管理界面：<a href="http://192.168.56.101:15672" target="_blank" rel="noopener">http://192.168.56.101:15672</a></p>
<p>可以看到，交换机已经创建出来了：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532772446520.png" srcset="/img/loading.gif" alt="1532772446520"></p>
<p>队列也已经创建完毕：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532772471931.png" srcset="/img/loading.gif" alt="1532772471931"></p>
<p>并且队列都已经绑定到交换机：</p>
<p><img src="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday15/1532772521932.png" srcset="/img/loading.gif" alt="1532772521932"></p>
<h3 id="3-5-2-修改数据试一试"><a href="#3-5-2-修改数据试一试" class="headerlink" title="3.5.2.修改数据试一试"></a>3.5.2.修改数据试一试</h3><p>在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E/">乐优商城</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/RabbitMQ/">RabbitMQ</a>
                    
                      <a class="hover-with-bg" href="/tags/Spring-AMQP/">Spring AMQP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/10/05/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday16/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">乐优商城day16：用户注册</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/10/01/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8Eday14/">
                        <span class="hidden-mobile">乐优商城day14：商品详情及静态化</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
  </div>
</div>
<!--

代码块js 用不到，fulid自带有，添加css样式即可实现
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 

<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>

-->




<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键字</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
	<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("06/20/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站已经勉强运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  </script>
</div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证20000725号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=20000725"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备20000725号</span>
      </a>
     
  </div>


    
	
  </div>
  

</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>



  
<script src="/js/custom.js"></script>




  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "乐优商城day15：RabbitMQ及数据同步&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 65,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "<"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  
















<script type="text/javascript"
color="107,160,220" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
