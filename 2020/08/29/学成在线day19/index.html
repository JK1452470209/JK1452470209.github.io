<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Mr.JK">
  <meta name="keywords" content="">
  <title>学成在线day19：分布式事务 - Mr.JK</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>





<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>私人博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-29 13:57">
      2020-08-29
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      94
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
	
   
	
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="😎知识点概览"><a href="#😎知识点概览" class="headerlink" title="😎知识点概览"></a>😎知识点概览</h1><blockquote>
<p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p>
</blockquote>
<p>本章节为【学成在线】项目的 <code>day19</code> 的内容</p>
<ul>
<li>分析了分布式事务的使用场景、以及 <code>2PC</code>、<code>TCC</code>、<code>MQ</code> 等解决方案</li>
<li>通过用户下单选课的案例来讲解了基于 <code>Spring Task</code> 以及 <code>RabbitMQ</code> 来实现 <code>MQ</code> 在分布式事务的整个流程。</li>
<li>对 <code>Mysql</code> 本地事务有了更深刻的了解，例如在同一个事务当中，<code>操作A</code> 与 <code>操作B</code> 需要同时都操作成功，数据才能真正的写入到数据库内，这样也就保证了数据的幂等性。</li>
</ul>
<blockquote>
<p>为了方便后续回顾该项目时能够清晰的知道本章节讲了哪些内容，并且能够从该章节的笔记中得到一些帮助，所以在完成本章节的学习后在此对本章节所涉及到的知识点进行总结概述。</p>
</blockquote>
<p>本章节为【学成在线】项目的 <code>day19</code> 的内容</p>
<ul>
<li>分析了分布式事务的使用场景、以及 <code>2PC</code>、<code>TCC</code>、<code>MQ</code> 等解决方案</li>
<li>通过用户下单选课的案例来讲解了基于 <code>Spring Task</code> 以及 <code>RabbitMQ</code> 来实现 <code>MQ</code> 在分布式事务的整个流程。</li>
<li>对 <code>Mysql</code> 本地事务有了更深刻的了解，例如在同一个事务当中，<code>操作A</code> 与 <code>操作B</code> 需要同时都操作成功，数据才能真正的写入到数据库内，这样也就保证了数据的幂等性。</li>
</ul>
<h1 id="一、订单与选课的需求分析"><a href="#一、订单与选课的需求分析" class="headerlink" title="一、订单与选课的需求分析"></a>一、订单与选课的需求分析</h1><h2 id="1-订单支付流程"><a href="#1-订单支付流程" class="headerlink" title="1. 订单支付流程"></a>1. 订单支付流程</h2><p>学成在线的课程分为免费和收费两种。对于收费课程，用户需提交订单并完成支付方可在线学习。</p>
<p>提交订单及支付流程如下：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image1.png" srcset="/img/loading.gif" alt="image-20200604112504575"></p>
<p><strong>系统处理流程：</strong></p>
<p>1、用户提交订单需要先登录系统</p>
<p>2、提交订单，订单信息保存到订单数据库</p>
<p>3、订单支付，调用微信支付接口完成支付</p>
<p>4、完成支付，微信支付系统通知学成在线支付结果</p>
<p>5、学成在线接收到支付结果通知，更新支付结果</p>
<p><strong>用户操作流程</strong>：</p>
<p>1、用户进入课程详情页面</p>
<p>2、点击“立即购买”，打开订单确认信息</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image2.png" srcset="/img/loading.gif" alt="image-20200604112633430"></p>
<p>3、点击“确认无误，提交订单”</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image3.png" srcset="/img/loading.gif" alt="image-20200604112640698"></p>
<p>订单提交成功，向订单数据库的 <code>xc_orders</code> 订单表保存一条记录，向 <code>xc_orders_detail</code>订单明细表保存一条或多条记录，向订单支付表插入一条记录。</p>
<p>4、订单提交成功自动进入订单支付页面</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image4.png" srcset="/img/loading.gif" alt="image-20200604112708567"></p>
<p>5、点击“微信支付”打开二维码</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image5.png" srcset="/img/loading.gif" alt="image-20200604112719253"></p>
<p>6、用手机扫码支付，支付完成，点击 “完成支付”</p>
<p>支付完成，收到微信支付系统的支付完成通知或请求微信查询支付已完成，更新学成在线订单支付表中的支付状态字段。</p>
<h2 id="2-自动选课需求"><a href="#2-自动选课需求" class="headerlink" title="2. 自动选课需求"></a>2. 自动选课需求</h2><p>支付成功即完成订单，订单完成之后系统需自动添加选课。</p>
<p>下图是微信支付、学成在线订单服务、学成在线学习服务交互图：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image6.png" srcset="/img/loading.gif" alt="image-20200604112937855"></p>
<p>1、用户支付完成，微信支付系统会主动通知学成在线支付结果，学成在线也可主动请求微信支付查询订单的支付结果。最终得到支付结果后将订单支付结果保存到订单数据库中。</p>
<p>2、订单支付完成系统自动向选课表添加学生选课记录。</p>
<p>3、选课记录添加完成学习即可在线开始学习。</p>
<h1 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>根据上边的自动选课的需求，分析如下：</p>
<p>用户支付完成后，会将支付状态及订单状态保存在订单数据库中，由订单服务去维护订单数据库。而学生选课信息在学习中心数据库，由学习服务去维护学习中心数据库的信息。下图是系统结图：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image7.png" srcset="/img/loading.gif" alt="image-20200604113050991"></p>
<p>如何实现两个分布式服务（订单服务、学习服务）共同完成一件事即订单支付成功自动添加学生选课的需求，这里的关键是如何保证两个分布式服务的事务的一致性。</p>
<p>尝试解决上边的需求，在订单服务中远程调用选课接口，伪代码如下：</p>
<div class="hljs"><pre><code class="hljs plain">订单支付结果通知方法｛
    更新支付表中支付状态为“成功”。
    远程调用选课接口添加选课记录。
｝</code></pre></div>

<p>上边的逻辑说明：</p>
<p>1、更新支付表状态为本地数据库操作。</p>
<p>2、远程调用选课接口为网络远程调用请求。</p>
<p>3、为保存事务上边两步操作由spring控制事务，当遇到 <code>Exception</code> 异常则 <code>回滚</code> 本地数据库操作。</p>
<p><strong>问题如下：</strong></p>
<p>1、如果更新支付表失败则抛出异常，不再执行远程调用，此设想没有问题。</p>
<p>2、如果更新支付表成功，网络远程调用超时，会拉长本地数据库事务时间，影响数据库性能。</p>
<p>3、如果更新支付表成功，远程调用添加选课成功（选课数据库commit成功），最后更新支付表时因为数据库意外宕机或其他原因导致无法访问数据库，导致commit时失败，此时出现操作不一致。</p>
<p>上边的几个问题涉及到分布式事务控制，下面我们带着这些问题，来继续了解一下什么是分布式事务。</p>
<h2 id="2-什么是分布式事务"><a href="#2-什么是分布式事务" class="headerlink" title="2. 什么是分布式事务"></a>2. 什么是分布式事务</h2><p>在了解分布式事务之前，我们来回顾一下什么是分布式系统。</p>
<p><strong>1、什么是分布式系统？</strong></p>
<p>部署在不同节点上的系统，通过网络交互来完成协同工作的系统。</p>
<p>比如：充值加积分的业务，用户在充值系统向自己的账户充钱，在积分系统中自己积分相应的增加。充值系统和积分系统是两个不同的系统，一次充值加积分的业务就需要这两个系统协同工作来完成。</p>
<p><strong>2、什么是事务？</strong></p>
<p>事务是指由一组操作组成的一个工作单元，这个工作单元具有以下几个特点</p>
<ul>
<li>原子性（atomicity）</li>
<li>一致性（consistency）</li>
<li>隔离性（isolation）</li>
<li>持久性（durability）</li>
</ul>
<p><strong>原子性：</strong></p>
<p>执行单元中的操作要么全部执行成功，要么全部失败。如果有一部分成功一部分失败那么成功的操作要全部回滚到执行前的状态。</p>
<p><strong>一致性：</strong></p>
<p>执行一次事务会使用数据从一个正确的状态转换到另一个正确的状态，执行前后<br>数据都是完整的。</p>
<p><strong>隔离性</strong>：</p>
<p>在该事务执行的过程中，任何数据的改变只存在于该事务之中，对外界没有影响，事务与事务之间是完全的隔离的。<strong>只有事务提交后数据才会真正的储存到数据库内</strong>，其它事务才可以查询到最新的数据。</p>
<p><strong>持久性：</strong></p>
<p>事务完成后对数据的改变会永久性的存储起来，即使发生断电宕机数据依然在。</p>
<h2 id="3-CAP理论"><a href="#3-CAP理论" class="headerlink" title="3. CAP理论"></a>3. CAP理论</h2><p>如何进行分布式事务控制？<code>CAP</code> 理论是分布式事务处理的理论基础，了解了 <code>CAP</code> 理论有助于我们研究分布式事务的处理方案。</p>
<p>CAP 理论是：分布式系统在设计时只能在 <strong>一致性 (Consistency)</strong>、<strong>可用性(Availability)</strong>、<strong>分区容忍性(PartitionTolerance)</strong> 中满足两种，无法兼顾三种。</p>
<p>我们通过下面的内容来进一步的了解 CAP 理论：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image8.png" srcset="/img/loading.gif" alt="image-20200604132506494"></p>
<ul>
<li><p>一致性(Consistency)：</p>
<p>服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。</p>
</li>
<li><p>可用性(Availability)：</p>
<p>服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结点，当服务A宕机整个系统将无法提供服务，增加服务B、C是为了保证系统的可用性。</p>
</li>
<li><p>分区容忍性(Partition Tolerance)：</p>
<p>分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。</p>
<p>分布式系统不可避免的出现了多个系统通过网络协同工作的场景，节点之间难免会出现 <strong>网络中断</strong>、<strong>网延延迟</strong> 等现象，这种现象一旦出现就导致数据被分散在不同的节点上，这就是网络分区。</p>
</li>
</ul>
<p><strong>分布式系统能否兼顾C、A、P？</strong></p>
<p>在保证 <strong>分区容忍性</strong> 的前提下 <strong>一致性</strong> 和 <strong>可用性</strong> 无法兼顾，如果要提高系统的可用性就要增加多个结点，如果要保证数据的一致性就要实现每个结点的数据一致，结点越多可用性越好，但是数据一致性越差。所以，在进行分布式系统设计时，同时满足 “一致性”、“可用性” 和 “分区容性” 三者是几乎不能的。</p>
<p><strong>CAP有哪些组合方式？</strong></p>
<ul>
<li><p>CA：放弃分区容忍性，加 <strong>强一致性</strong> 和可用性，关系数据库按照 <code>CA</code> 进行设计。</p>
</li>
<li><p>AP：放弃一致性，加强可用性和分区容忍性，追求 <strong>最终一致性</strong>，很多 <code>NoSQL</code> 数据库按照AP进行设计。</p>
<blockquote>
<p>这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允许暂时的数据不一致，只要最终在用户接受的时间内数据一致可。</p>
</blockquote>
</li>
<li><p>CP：放弃可用性，加强一致性和分区容忍性，一些 <strong>强一致性</strong> 要求的系统按 <code>CP</code> 进行设计，比如 <strong>跨行转账</strong>，<strong>一次转账</strong> 请求要等待双方银行系统都完成整个事务才算完成。</p>
<blockquote>
<p>由于网络问题的存在CP系统可能会出现待等待超时，如果没有处理超时问题则整理系统会出现阻塞</p>
</blockquote>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>在分布式系统设计中 <code>AP</code> 的应用较多，即 “保证分区容忍性” 和 “可用性 ”，牺牲数据的强一致性（写入操作后其他节点立即同步数据），而使用AP的方式来保证数据最终一致性。</p>
<p>比如：订单退款，今日退款成功，明日账户到账，只要在预定的用户可以接受的时间内退款事务走完即可。</p>
<h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><h3 id="两阶段提交协议（2PC）"><a href="#两阶段提交协议（2PC）" class="headerlink" title="两阶段提交协议（2PC）"></a>两阶段提交协议（2PC）</h3><p>为解决分布式系统的数据一致性问题，出现了两阶段提交协议（2 Phase Commitment Protocol），两阶段提交由 <code>协调者</code> 和 <code>参与者</code> 组成，共经过 “两个阶段” 和 “三个操作”，部分关系数据库如 <code>Oracle</code>、<code>MySQL</code> 支持两阶段提交协议，本节讲解关系数据库两阶段提交协议。</p>
<p>2PC协议流程图：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image9.png" srcset="/img/loading.gif" alt="image-20200604133432528"></p>
<p><strong>1）第一阶段：准备阶段（prepare）</strong></p>
<p>协调者通知参与者准备提交订单，参与者开始投票。</p>
<p>协调者完成准备工作向协调者回应Yes。</p>
<p><strong>2）第二阶段：提交(commit)/回滚(rollback)阶段</strong></p>
<p>协调者根据参与者的投票结果发起最终的提交指令。</p>
<p>如果有参与者没有准备好则发起回滚指令。</p>
<p><strong>一个下单减库存的例子：</strong></p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image10.png" srcset="/img/loading.gif" alt="image-20200604133512692"></p>
<p>1、应用程序连接两个数据源。</p>
<p>2、应用程序通过事务协调器向两个库发起 <code>prepare</code>，两个数据库收到消息分别执行本地事务（记录日志），但不提交，如果执行成功则回复 <code>yes</code>，否则回复 <code>no</code>。</p>
<p>3、事务协调器收到回复，只要有一方回复 <code>no</code> 则分别向参与者发起回滚事务，参与者开始回滚事务。</p>
<p>4、事务协调器收到回复，全部回复 <code>yes</code>，此时向参与者发起提交事务。如果参与者有一方提交事务失败则由事务协调器发起回滚事务。</p>
<p><strong>优点：</strong></p>
<p>实现强一致性，部分关系数据库支持（Oracle、MySQL等）。</p>
<p><strong>缺点：</strong></p>
<p>整个事务的执行需要由协调者在多个节点之间去协调，增加了事务的执行时间，性能低下。</p>
<p>解决方案有：<code>springboot</code> + <code>Atomikos</code> or <code>Bitronix</code></p>
<p>更详细的资料可以参考：<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a></p>
<h3 id="事务补偿（TCC）"><a href="#事务补偿（TCC）" class="headerlink" title="事务补偿（TCC）"></a>事务补偿（TCC）</h3><p>TCC 事务补偿是基于 <code>2PC</code> 实现的业务层事务控制方案，它是 <code>Try</code>、<code>Confirm</code> 和 <code>Cancel</code> 三个单词的首字母，含义如下：</p>
<p>1、Try 检查及预留业务资源，完成提交事务前的检查，并预留好资源。</p>
<p>2、Confirm 确定执行业务操作，对 try 阶段预留的资源正式执行。</p>
<p>3、Cancel 取消执行业务操作，对 try 阶段预留的资源释放。</p>
<p>下边用一个下单减库存的业务为例来说明：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image11.png" srcset="/img/loading.gif" alt="image-20200604133914143"></p>
<p>1、Try</p>
<ul>
<li>下单业务由 <code>订单服务</code> 和 <code>库存服务</code> 协同完成，在 try 阶段 订单服务 和 库存服务 完成检查和预留资源。</li>
<li>订单服务检查当前是否满足提交订单的条件（比如：当前存在未完成订单的不允许提交新订单）。</li>
<li>库存服务检查当前是否有充足的库存，并锁定资源。</li>
</ul>
<p>2、Confirm</p>
<ul>
<li>订单服务 和 库存服务 成功完成Try后开始正式执行资源操作。</li>
<li>订单服务向订单写一条订单信息。</li>
<li>库存服务减去库存。</li>
</ul>
<p>3、Cancel</p>
<ul>
<li>如果订单服务和库存服务有一方出现失败则全部取消操作。</li>
<li>订单服务需要删除新增的订单信息。</li>
<li>库存服务将减去的库存再还原。</li>
</ul>
<p>优点：最终保证数据的一致性，在业务层实现事务控制，灵活性好。</p>
<p>缺点：开发成本高，每个事务操作每个参与者都需要实现 <code>try/confirm/cancel</code> 三个接口。</p>
<p>注意：TCC 的 <code>try/confirm/cancel</code> 接口都要实现幂等性，在try、confirm、cancel失败后要不断重试 。</p>
<p>什么是幂等性？幂等性是指 <strong>同一个操作无论请求多少次</strong>，其结果都相同。</p>
<p>幂等操作实现方式有：</p>
<p>1、操作之前在业务方法进行判断如果执行过了就不再执行。</p>
<p>2、缓存所有请求和处理的结果，已经处理的请求则直接返回结果。</p>
<h3 id="消息队列实现最终一致性"><a href="#消息队列实现最终一致性" class="headerlink" title="消息队列实现最终一致性"></a>消息队列实现最终一致性</h3><p>本方案是将分布式事务拆分成多个本地事务来完成，并且由消息队列异步协调完成，如下图：<br>下边以下单减少库存为例来说明：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image12.png" srcset="/img/loading.gif" alt="image-20200604135609607"></p>
<p>1、订单服务和库存服务完成检查和预留资源。</p>
<p>2、订单服务在本地事务中完成 “添加订单表记录” 和添加 “减少库存任务消息”。</p>
<p>3、由定时任务根据消息表的记录发送给 <code>MQ</code> 通知库存服务执行减库存操作。</p>
<p>4、库存服务执行减少库存，并且记录执行消息状态（为避免重复执行消息，在执行减库存之前查询是否执行过此<br>消息。</p>
<blockquote>
<p>这里注意，每个消息通知都会带有一个消息id，用于通过本地事务校验该消息的状态</p>
</blockquote>
<p>5、库存服务向 <code>MQ</code> 发送完成减少库存的消息。</p>
<p>6、订单服务接收到完成库存减少的消息后，删除原来添加的 “减少库存任务消息”。</p>
<p><strong>实现最终事务一致要求：</strong></p>
<p>预留资源成功理论上要求正式执行成功，如果执行失败会进行重试，要求业务执行方法实现幂等。</p>
<p>也就是说，如果订单服务在指定时间内如果没有收到库存服务的 “库存减少成功” 的消息，那么订单服务会再次尝试发送这个 “减少库存” 的消息到 <code>MQ</code> 并且由 <code>MQ</code> 继续尝试去通知库存服务去减少库存，直到订单服务收到 “库存减少成功” 的消息。</p>
<p>优点 ：</p>
<p>由 <code>MQ</code> 按异步的方式协调完成事务，性能较高。</p>
<p>不用实现 <code>try/confirm/cancel</code> 接口，开发成本比 <code>TCC</code> 低。</p>
<p>缺点：</p>
<p>此方式基于关系数据库本地事务来实现，会出现频繁读写数据库记录，浪费数据库资源，另外对于高并发操作不是<br>最佳方案。</p>
<h2 id="5-自动添加选课方案"><a href="#5-自动添加选课方案" class="headerlink" title="5. 自动添加选课方案"></a>5. 自动添加选课方案</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>根据自动选课需求，为了更好的分析解决方案，这里搭建订单工程及数据库。</p>
<h4 id="1、创建订单工程"><a href="#1、创建订单工程" class="headerlink" title="1、创建订单工程"></a>1、创建订单工程</h4><p>导入资料下的 <code>xc-service-manage-order</code> 工程。</p>
<h4 id="2、创建订单数据库"><a href="#2、创建订单数据库" class="headerlink" title="2、创建订单数据库"></a>2、创建订单数据库</h4><p>创建订单数据库 xc_order（MySQL）导入 xc_order.sql</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image13.png" srcset="/img/loading.gif" alt="image-20200604144256737"></p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image14.png" srcset="/img/loading.gif" alt="image-20200604144250661"></p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image15.png" srcset="/img/loading.gif" alt="image-20200604144307880"></p>
<p><code>xc_orders</code>：订单主表</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image16.png" srcset="/img/loading.gif" alt="image-20200604144326034"></p>
<p><code>xc_orders_details</code>：订单明细表，记录订单的明细信息</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image17.png" srcset="/img/loading.gif" alt="image-20200604144339203"></p>
<p><code>xc_orders_pay</code>：订单支付表记录订单的支付状态</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image18.png" srcset="/img/loading.gif" alt="image-20200604144357001"></p>
<p>向 <code>xc_order</code> 数据库导入 <code>xc_order_task.sql</code></p>
<p>待处理任务表：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image19.png" srcset="/img/loading.gif" alt="image-20200604144421695"></p>
<p>在任务表中包括了交换机的名称、路由 <code>key</code> 等信息为了是将任务的处理做成一个通用的功能。</p>
<p>考虑分布式系统并发读取任务处理任务的情况发生项目使用乐观锁的方式解决并发问题。</p>
<p>已完成任务表 ：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image20.png" srcset="/img/loading.gif" alt="image-20200604144514253"></p>
<h4 id="3、创建选课数据库"><a href="#3、创建选课数据库" class="headerlink" title="3、创建选课数据库"></a>3、创建选课数据库</h4><p>创建 <code>xc_learning</code> 数据库，导入<code>xc_learning.sql</code>，<code>xc_learning_course</code> 为学生选课表。</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image21.png" srcset="/img/loading.gif" alt="image-20200604144604843"></p>
<p>导入 <code>xc_task_his.sql</code>，<code>xc_task_his</code> 为历史任务表 。</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image22.png" srcset="/img/loading.gif" alt="image-20200604144621397"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>本项目综合考虑选择基于消息的分布式事务解决方案，解决方案如下图：</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image23.png" srcset="/img/loading.gif" alt="image-20200604143344123"></p>
<p>1、支付成功后，订单服务向本地数据库更新订单状态，并向消息表写入“添加选课消息”，通过本地数据库保证订单状态和添加选课消息的事务。如果 <strong>更新订单状态</strong> 或者 <strong>消息写入</strong> 这两个操作其中一个失败了，那么这个事务都不会被执行，这样就保证了事务的一致性。</p>
<p>2、使用 <code>Spring Task</code> 定时任务扫描消息表，取出 “添加选课任务“ 的消息并发向<code>MQ</code>，由 <code>MQ</code> 通知学习服务添加选课。</p>
<p>3、学习服务接收到添加选课的消息，先查询本地数据库的历史消息表是否存在消息，存在则说明已经添加选课，则向 <code>MQ</code> 发送一个选课成功的消息，让订单服务知道该订单已经选课成功，否则向本地数据库添加选课，并向历史消息表添加选课消息，并发送选课成功的消息到 <code>MQ</code>。这里选课表和历史消息表在同一个数据库，通过本地事务保证一致性。</p>
<p>4、订单服务接收到完成选课的消息后，删除订单数据库中消息表的 “添加选课消息”，为保证后期对账将消息表的消息先添加到历史消息表再删除消息，表示此消息已经完成。</p>
<h1 id="三、Spring-Task定时任务"><a href="#三、Spring-Task定时任务" class="headerlink" title="三、Spring Task定时任务"></a>三、Spring Task定时任务</h1><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>根据分布式事务的研究结果，订单服务需要定时扫描任务表向 <code>MQ</code> 发送任务。本节研究定时任务处理的方案，并实现定时任务对任务表进行扫描，并向 <code>MQ</code> 发送消息。</p>
<p>实现定时任务的方案有以下几种：</p>
<p>1、使用jdk的 <code>Timer</code> 和 <code>TimerTask</code> 实现</p>
<p>可以实现简单的间隔执行任务，无法实现按日历去调度执行任务。</p>
<p>2、使用 Quartz 实现</p>
<p><code>Quartz</code> 是一个异步任务调度框架，功能丰富，可以实现按日历调度。</p>
<p>3、使用 Spring Task 实现</p>
<p><code>Spring 3.0</code> 后提供 <code>Spring Task</code> 实现任务调度，支持按日历调度，相比 <code>Quartz</code> 功能稍简单，但是在开发基本够用，支持注解编程方式。</p>
<p>本项目使用 <code>Spring Task</code> 实现任务调度。</p>
<h2 id="2-Spring-Task-串行任务"><a href="#2-Spring-Task-串行任务" class="headerlink" title="2. Spring Task 串行任务"></a>2. Spring Task 串行任务</h2><h3 id="1、编写任务类"><a href="#1、编写任务类" class="headerlink" title="1、编写任务类"></a>1、编写任务类</h3><p>在 Spring boot 启动类上添加注解：<code>@EnableScheduling</code></p>
<p>新建任务测试类 <code>TestTask</code>，编写测试方法如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChooseCourseTask</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-comment">// @Scheduled(fixedRate = 5000) //上次执行开始时间后5秒执行</span>
    <span class="hljs-comment">// @Scheduled(fixedDelay = 5000) //上次执行完毕后的5秒执行</span>
    <span class="hljs-comment">// @Scheduled(initialDelay=3000, fixedRate=5000) //第一次延迟3秒，以后每隔5秒执行一次</span>
    <span class="hljs-meta">@Scheduled</span>(cron=<span class="hljs-string">"0/3 * * * * *"</span>)<span class="hljs-comment">//每隔3秒执行一次</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task1</span><span class="hljs-params">()</span></span>&#123;
        LOGGER.info(<span class="hljs-string">"===============测试定时任务1开始==============="</span>);
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">5000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; 
        LOGGER.info(<span class="hljs-string">"===============测试定时任务1结束==============="</span>);
    &#125;
&#125;</code></pre></div>

<p>测试：</p>
<p>1、测试 <code>fixedRate</code> 和 <code>fixedDelay</code> 的区别</p>
<p>2、测试并观察串行执行的特点</p>
<h3 id="2、cron表达式"><a href="#2、cron表达式" class="headerlink" title="2、cron表达式"></a>2、cron表达式</h3><p>cron表达式包括6部分：</p>
<p>秒（0<del>59） 分钟（0</del>59） 小时（0<del>23） 月中的天（1</del>31） 月（1<del>12） 周中的天（填写MON，TUE，WED，THU，FRI，SAT,SUN，或数字1</del>7 1表示MON，依次类推）</p>
<p><strong>特殊字符介绍：</strong></p>
<ul>
<li>“/” 字符表示指定数值的增量</li>
<li>“*” 字符表示所有可能的值</li>
<li>“-” 字符表示区间范围</li>
<li>“,” 字符表示列举</li>
<li>“？” 字符仅被用于月中的天和周中的天两个子表达式，表示不指定值</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li>0/3 * * * * * 每隔 3 秒执行</li>
<li>0 0/5 * * * * 每隔 5 分钟执行</li>
<li>0 0 0 * * * 表示每天 0 点执行</li>
<li>0 0 12 ? * WEN 每周三 12 点执行</li>
<li>0 15 10 ? * MON-FRI 每月的周一到周五10点15分执行</li>
<li>0 15 10 ? * MON,FRI 每月的周一和周五10点 15分执行</li>
</ul>
<h3 id="3、串行任务测试"><a href="#3、串行任务测试" class="headerlink" title="3、串行任务测试"></a>3、串行任务测试</h3><p>参考 <code>task1</code> 方法的的定义方法，再定义 <code>task2</code> 方法，此时共用两个任务方法。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">3000</span>) <span class="hljs-comment">//上次执行开始时间后3秒执行</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task2</span><span class="hljs-params">()</span></span>&#123;
    LOGGER.info(<span class="hljs-string">"===============测试定时任务2开始==============="</span>);
    <span class="hljs-keyword">try</span> &#123;
        Thread.sleep(<span class="hljs-number">3000</span>);
    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125; 
    LOGGER.info(<span class="hljs-string">"===============测试定时任务2结束==============="</span>);
&#125;</code></pre></div>

<p>通过测试发现，两个任务方法由一个线程串行执行，<code>task1</code> 方法执行完成 <code>task2</code> 再执行。</p>
<h2 id="3-Spring-Task-并行任务"><a href="#3-Spring-Task-并行任务" class="headerlink" title="3. Spring Task 并行任务"></a>3. Spring Task 并行任务</h2><h3 id="1、需求分析"><a href="#1、需求分析" class="headerlink" title="1、需求分析"></a>1、需求分析</h3><p>在项目通常是需要多个不同的任务并行去执行。</p>
<p>本节实现 <code>Spring Task</code> 并行执行任务的方法。</p>
<h3 id="2、配置异步任务"><a href="#2、配置异步任务" class="headerlink" title="2、配置异步任务"></a>2、配置异步任务</h3><p>创建异步任务配置类，需要配置线程池实现多线程调度任务。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.config;
 
<span class="hljs-keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;
<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;
<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;
<span class="hljs-keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;
<span class="hljs-keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;
 
<span class="hljs-keyword">import</span> java.util.concurrent.Executor;
 
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableScheduling</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTaskConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SchedulingConfigurer</span>, <span class="hljs-title">AsyncConfigurer</span> </span>&#123;
    <span class="hljs-comment">//线程池线程数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> corePoolSize = <span class="hljs-number">5</span>;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskScheduler <span class="hljs-title">taskScheduler</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        ThreadPoolTaskScheduler scheduler = <span class="hljs-keyword">new</span> ThreadPoolTaskScheduler();
        scheduler.initialize();<span class="hljs-comment">//初始化线程池</span>
        scheduler.setPoolSize(corePoolSize);<span class="hljs-comment">//线程池容量</span>
        <span class="hljs-keyword">return</span> scheduler;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getAsyncExecutor</span><span class="hljs-params">()</span> </span>&#123;
        Executor executor = taskScheduler();
        <span class="hljs-keyword">return</span> executor;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar scheduledTaskRegistrar)</span> </span>&#123;
        scheduledTaskRegistrar.setTaskScheduler(taskScheduler());
    &#125;
&#125;</code></pre></div>

<p>将 <code>@EnableScheduling</code> 添加到此配置类上，<code>SpringBoot</code> 启动类上不用再添加 <code>@EnableScheduling</code></p>
<h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>通过测试发现两个任务由不同的线程在并行执行，互不影响。</p>
<h1 id="四、订单服务定时发送消息"><a href="#四、订单服务定时发送消息" class="headerlink" title="四、订单服务定时发送消息"></a>四、订单服务定时发送消息</h1><h2 id="1-需求分析-1"><a href="#1-需求分析-1" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>定时任务发送消息流程如下：</p>
<p>1、每隔1分钟扫描一次任务表。</p>
<p>1、定时任务扫描 <code>task</code> 表，一次取出多个任务，取出 <strong>超过1分钟</strong> 未处理的任务</p>
<p>2、考虑订单服务可能集群部署，为避免重复发送任务使用 <strong>乐观锁</strong> 的方式每次从任务列表取出要处理的任务</p>
<p>3、任务发送完毕更新任务发送时间</p>
<p><strong>关于任务表的添加：</strong></p>
<p>正常的流程是订单支付成功后，更新订单支付状态并向任务表写入 “添加选课任务”。</p>
<p>目前订单支付功能没有开发，所以我们暂时采用手动向任务表添加任务。</p>
<h2 id="2-RabbitMQ配置"><a href="#2-RabbitMQ配置" class="headerlink" title="2. RabbitMQ配置"></a>2. RabbitMQ配置</h2><p>向 <code>RabbitMQ</code> 声明两个队列：添加选课、完成选课，交换机使用路由模式，代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.config;
 
<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
 
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;
 
    <span class="hljs-comment">//添加选课任务交换机</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_LEARNING_ADDCHOOSECOURSE = <span class="hljs-string">"ex_learning_addchoosecourse"</span>;
 
 
    <span class="hljs-comment">//添加选课消息队列,用于发送添加选课消息</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_ADDCHOOSECOURSE = <span class="hljs-string">"xc_learning_addchoosecourse"</span>;
 
    <span class="hljs-comment">//完成添加选课消息队列,用于接收完成选课的消息</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_FINISHADDCHOOSECOURSE = <span class="hljs-string">"xc_learning_finishaddchoosecourse"</span>;
 
    <span class="hljs-comment">//添加选课路由key,用于发送添加选课的消息</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_ADDCHOOSECOURSE_KEY = <span class="hljs-string">"addchoosecourse"</span>;
 
    <span class="hljs-comment">//完成添加选课路由key</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XC_LEARNING_FINISHADDCHOOSECOURSE_KEY = <span class="hljs-string">"finishaddchoosecourse"</span>;
 
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 交换机配置,用于发送添加选课消息以及接收完成添加选课的消息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the exchange</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>(EX_LEARNING_ADDCHOOSECOURSE)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_DECLARE</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_LEARNING_ADDCHOOSECOURSE).durable(<span class="hljs-keyword">true</span>).build();
    &#125;
 
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 声明用于接收 "完成添加选课" 消息的队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Queue</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>(XC_LEARNING_FINISHADDCHOOSECOURSE)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_XC_LEARNING_FINISHADDCHOOSECOURSE</span><span class="hljs-params">()</span> </span>&#123;
        Queue queue = <span class="hljs-keyword">new</span> Queue(XC_LEARNING_FINISHADDCHOOSECOURSE);
        <span class="hljs-keyword">return</span> queue;
    &#125;
 
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 声明用于发送 "添加选课" 消息的队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Queue</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>(XC_LEARNING_ADDCHOOSECOURSE)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_XC_LEARNING_ADDCHOOSECOURSE</span><span class="hljs-params">()</span> </span>&#123;
        Queue queue = <span class="hljs-keyword">new</span> Queue(XC_LEARNING_ADDCHOOSECOURSE);
        <span class="hljs-keyword">return</span> queue;
    &#125;
 
 
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 将 "完成添加选课消息" 的队列绑定到交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 完成添加选课消息队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> BindingBuilder</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_FINISHADDCHOOSECOURSE</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">        @Qualifier(XC_LEARNING_FINISHADDCHOOSECOURSE)</span> Queue queue,</span>
<span class="hljs-function">        @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_LEARNING_ADDCHOOSECOURSE)</span> Exchange exchange) </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(XC_LEARNING_FINISHADDCHOOSECOURSE_KEY).noargs();
    &#125;
 
 
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 将 "添加选课" 消息的队列绑定到交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue 添加选课消息队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange 交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> BindingBuilder</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_ADDCHOOSECOURSE</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">        @Qualifier(XC_LEARNING_ADDCHOOSECOURSE)</span> Queue queue,</span>
<span class="hljs-function">        @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_LEARNING_ADDCHOOSECOURSE)</span> Exchange exchange) </span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(XC_LEARNING_ADDCHOOSECOURSE_KEY).noargs();
    &#125;
 
&#125;</code></pre></div>

<h2 id="3-查询前N条任务"><a href="#3-查询前N条任务" class="headerlink" title="3. 查询前N条任务"></a>3. 查询前N条任务</h2><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>在 <code>dao</code>下创建一个 XcTaskRepository 自定义方法如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.dao;
 
<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.task.XcTask;
<span class="hljs-keyword">import</span> org.springframework.data.domain.Page;
<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;
<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;
 
<span class="hljs-keyword">import</span> java.util.Date;
 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTask</span>, <span class="hljs-title">String</span>&gt; </span>&#123;
    <span class="hljs-comment">//取出指定时间之前的记录</span>
    <span class="hljs-function">Page&lt;XcTask&gt; <span class="hljs-title">findByUpdateTimeBefore</span><span class="hljs-params">(Pageable pageable, Date updateTime)</span></span>;
&#125;</code></pre></div>

<p><code>findByUpdateTimeBefore</code> 方法为 <code>JPA</code> 自带的一个组合方法，可以根据传入的分页参数以及时间查询，查询到该时间之前的数据。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    XcTaskRepository xcTaskRepository;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 查询任务列表的实现</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n 查询数量</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> updateTime 上次更新时间</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;XcTask&gt; <span class="hljs-title">findTaskList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, Date updateTime)</span> </span>&#123;
        Pageable pageable = <span class="hljs-keyword">new</span> PageRequest(<span class="hljs-number">0</span>, n);
        Page&lt;XcTask&gt; byUpdateTimeBefore = xcTaskRepository.findByUpdateTimeBefore(pageable, updateTime);
        List&lt;XcTask&gt; content = byUpdateTimeBefore.getContent();
        <span class="hljs-keyword">return</span> content;
    &#125;
&#125;</code></pre></div>

<p>在 Service 中我们调用刚才定义的 <code>findByUpdateTimeBefore</code> 来查询指定时间之前的数据</p>
<h3 id="编写定时任务"><a href="#编写定时任务" class="headerlink" title="编写定时任务"></a>编写定时任务</h3><p>编写任务类，每分钟执行任务，启动订单工程，观察定时发送消息日志，观察 <code>rabbitMQ</code> 队列中是否有消息，代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>
TaskService taskService;
 
<span class="hljs-comment">//每隔1分钟扫描消息表，向mq发送消息</span>
<span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0/60 * * * * *"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendChoosecourseTask</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-comment">//取出当前时间1分钟之前的时间</span>
    Calendar calendar =<span class="hljs-keyword">new</span> GregorianCalendar();
    calendar.setTime(<span class="hljs-keyword">new</span> Date());
    calendar.add(GregorianCalendar.MINUTE,-<span class="hljs-number">1</span>);
    Date time = calendar.getTime();
    List&lt;XcTask&gt; taskList = taskService.findTaskList(<span class="hljs-number">10</span>, time);
    System.out.println(taskList);
&#125;</code></pre></div>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>成功从 task 表中拿到了任务数据</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image24.png" srcset="/img/loading.gif" alt="image-20200605110002127"></p>
<h2 id="4-定时发送任务"><a href="#4-定时发送任务" class="headerlink" title="4. 定时发送任务"></a>4. 定时发送任务</h2><h3 id="Dao-1"><a href="#Dao-1" class="headerlink" title="Dao"></a>Dao</h3><p>在 <code>XcTaskRepository</code> 中添加更新任务方法 <code>updateTaskTime</code>，使用 JPA 提供的 <code>@Query</code> 注解来实现自定义SQL语句来实现更新操作</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTask</span>, <span class="hljs-title">String</span>&gt; </span>&#123;
    <span class="hljs-comment">//取出指定时间之前的记录</span>
    <span class="hljs-function">Page&lt;XcTask&gt; <span class="hljs-title">findByUpdateTimeBefore</span><span class="hljs-params">(Pageable pageable, Date updateTime)</span></span>;
 
    <span class="hljs-comment">//更细任务处理的时间</span>
    <span class="hljs-meta">@Modifying</span>  <span class="hljs-comment">//更新操作需要使用该注解</span>
    <span class="hljs-meta">@Query</span>(<span class="hljs-string">"update XcTask t set t.updateTime = :updateTimeParam where t.id = :idParam"</span>)  <span class="hljs-comment">//自定义更新语句</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateTaskTime</span><span class="hljs-params">(@Param(<span class="hljs-string">"idParam"</span>)</span> String id, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"updateTimeParam"</span>)</span>Date updateTime)</span>;
&#125;</code></pre></div>

<h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><p>添加发送消息方法， 使用 <code>RabbitTemplate</code> 提供的 <code>convertAndSend</code> 来实现发送消息到指定 <code>MQ</code> 交换机上，并且交换机根据提供的 <code>routekey</code> 转发到自定的消息队列，具体代码如下</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskService</span> </span>&#123;
 
    <span class="hljs-meta">@Autowired</span>
    RabbitTemplate rabbitTemplate;
 
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发送添加选课消息的实现</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> xcTask 消息内容</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ex 交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> routingKey 路由key</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishChooseMsg</span><span class="hljs-params">(XcTask xcTask, String ex, String routingKey)</span> </span>&#123;
        <span class="hljs-comment">//查询任务是否存在</span>
        Optional&lt;XcTask&gt; byId = xcTaskRepository.findById(xcTask.getId());
        <span class="hljs-keyword">if</span>(byId.isPresent())&#123;
            xcTask = byId.get();
            <span class="hljs-comment">//发送消息到MQ</span>
            rabbitTemplate.convertAndSend(ex, routingKey, xcTask);
            <span class="hljs-comment">//更细当前任务的时间</span>
            xcTaskRepository.updateTaskTime(xcTask.getId(), <span class="hljs-keyword">new</span> Date());
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="编写任务类"><a href="#编写任务类" class="headerlink" title="编写任务类"></a>编写任务类</h3><p>编写任务类，每分钟执行任务，启动订单工程，观察定时发送消息日志，观察 <code>rabbitMQ</code> 队列中是否有消息，代码如下</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.mq;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChooseCourseTask</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-meta">@Autowired</span>
    TaskService taskService;
    <span class="hljs-comment">//每隔1分钟扫描消息表，向mq发送消息</span>
    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0/3 * * * * *"</span>)  <span class="hljs-comment">//这里我们为了方便测试，时间改为了3秒一次</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendChoosecourseTask</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">//取出当前时间1分钟之前的时间</span>
        Calendar calendar =<span class="hljs-keyword">new</span> GregorianCalendar();
        calendar.setTime(<span class="hljs-keyword">new</span> Date());
        calendar.add(GregorianCalendar.MINUTE,-<span class="hljs-number">1</span>);
        Date time = calendar.getTime();
        List&lt;XcTask&gt; taskList = taskService.findTaskList(<span class="hljs-number">10</span>, time);
        <span class="hljs-keyword">for</span>(XcTask xcTask: taskList)&#123;
            String taskId = xcTask.getId();
            <span class="hljs-comment">//发送消息到MQ</span>
            taskService.publishChooseMsg(xcTask, xcTask.getMqExchange(), xcTask.getMqRoutingkey());
            LOGGER.info(<span class="hljs-string">"send choose course task id:&#123;&#125;"</span>,taskId);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>在测试之前注意检查以下 task 表的消息中的 交换机名称、路由key是否配置正确。</p>
</blockquote>
<p>我们在发布的方法中打个断点</p>
<p>这时已经将消息发送到了 <code>RabbitMQ</code> 中，我们到 <code>RabbitMQ</code> 的控制台中查看消息是否提交成功</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image26.png" srcset="/img/loading.gif" alt="image-20200605114804617"></p>
<p>消息成功发送到了 <code>MQ</code></p>
<h2 id="5-乐观锁取任务"><a href="#5-乐观锁取任务" class="headerlink" title="5. 乐观锁取任务"></a>5. 乐观锁取任务</h2><p>服务将来会集群部署，为了避免任务在 <code>1分钟</code> 内重复执行，这里使用 <strong>乐观锁</strong>，实现思路如下：</p>
<p>例如 <code>服务A</code> 和 <code>服务B</code> 都需要扫描 task 表里面的任务信息，他们各自手里都携带着一个 <code>version</code> 标识，默认值都为1，并且 task 表里面的 <code>任务X</code> 也会带有一个 <code>version</code> 字段，默认值也为1，如果A先达到数据库，A 在查询<code>任务X</code> 的时候会携带他手里的 version 标识进行匹配查询，如果能匹配到任务，证明A是第一个取出该任务的，取出该任务信息后，A会将该任务在数据库里面的version标识修改为2，在之后到达 task表进行查询的服务B也会以同样的方式匹配 version 为1的任务，这个时候 服务B 就不会再匹配到 <code>version</code> 值为 2 的 <code>任务X</code> 。</p>
<p>1、在 <code>Dao</code> 中增加校验当前版本及 <code>任务id</code> 的匹配方法</p>
<div class="hljs"><pre><code class="hljs jade">public interface XcTaskRepository extends JpaRepository&lt;XcTask, String&gt; &#123;
    &#x2F;&#x2F;使用乐观锁方式校验任务id和版本号是否匹配，匹配则版本号加1
    @Modifying
    @Query(&quot;update XcTask t set t.version &#x3D; :version+1 where t.id &#x3D; :id and t.version &#x3D;
           :version&quot;)
           public int updateTaskVersion(@Param(value &#x3D; &quot;id&quot;) String id,@Param(value &#x3D; &quot;version&quot;) int version);
           ...</code></pre></div>

<p>2、在 <code>service</code> 中增加方法，使用乐观锁方法校验任务</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTask</span><span class="hljs-params">(String taskId,<span class="hljs-keyword">int</span> version)</span></span>&#123;
    <span class="hljs-keyword">int</span> i = xcTaskRepository.updateTaskVersion(taskId, version);
    <span class="hljs-keyword">return</span> i;
&#125;</code></pre></div>

<p>3、执行任务类中修改</p>
<div class="hljs"><pre><code class="hljs java">...
    <span class="hljs-comment">//任务id</span>
    String taskId = xcTask.getId();
    <span class="hljs-comment">//版本号</span>
    Integer version = xcTask.getVersion();
    <span class="hljs-comment">//调用乐观锁方法校验任务是否可以执行</span>
    <span class="hljs-keyword">if</span>(taskService.getTask(taskId, version)&gt;<span class="hljs-number">0</span>)&#123;
        <span class="hljs-comment">//发送选课消息</span>
        taskService.publish(xcTask, xcTask.getMqExchange(),xcTask.getMqRoutingkey());
        LOGGER.info(<span class="hljs-string">"send choose course task id:&#123;&#125;"</span>,taskId);
	&#125;
...</code></pre></div>

<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>测试的预期结果：使用乐观锁保证同一分钟内同一个任务只能被获取一次</p>
<p>启动两个实例进行测试，测试流程如下</p>
<p><strong>1、配置两个端口不同的实例</strong></p>
<p>实例A</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image27.png" srcset="/img/loading.gif" alt="image-20200605140818128"></p>
<p>实例B</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image28.png" srcset="/img/loading.gif" alt="image-20200605140754305"></p>
<p>修改配置文件中的端口，有限从启动配置中获取</p>
<div class="hljs"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span>
<span class="hljs-symbol">  port:</span> $&#123;PORT:<span class="hljs-number">31500</span>&#125;</code></pre></div>

<p><strong>2、先启动实例A，在定时任务发送消息到MQ设置一个断点</strong></p>
<p>在遍历查询结果之前，设置断点后同时启动两个实例</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image29.png" srcset="/img/loading.gif" alt="image-20200605142540979"></p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image30.png" srcset="/img/loading.gif" alt="image-20200605142611363"></p>
<p>观察这两个实例都是否查询到了数据，并且达到断点的位置</p>
<p><strong>3、测试乐观锁</strong></p>
<p>实例A通过单步调试，运行到执行 getTask 之后，再将实例B也运行到 执行了 getTask之后。</p>
<p>在实例A执行完后，获取到了任务并且将当前任务的 version 值进行+1</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image31.png" srcset="/img/loading.gif" alt="image-20200605142819208"></p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image32.png" srcset="/img/loading.gif" alt="image-20200605142839878"></p>
<p>而实例B则没有匹配到该任务</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image33.png" srcset="/img/loading.gif" alt="image-20200605142912374"></p>
<h1 id="五、自动添加选课功能开发"><a href="#五、自动添加选课功能开发" class="headerlink" title="五、自动添加选课功能开发"></a>五、自动添加选课功能开发</h1><h2 id="1-学习服务添加选课"><a href="#1-学习服务添加选课" class="headerlink" title="1. 学习服务添加选课"></a>1. 学习服务添加选课</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>学习服务接收 <code>MQ</code> 发送添加选课消息，执行添加 选 课操作。</p>
<p>添加选课成功向学生选课表插入记录、向历史任务表插入记录、并向 <code>MQ</code> 发送“完成选课”消息。</p>
<h3 id="RabbitMQ配置"><a href="#RabbitMQ配置" class="headerlink" title="RabbitMQ配置"></a>RabbitMQ配置</h3><p>学习服务监听 <code>MQ</code> 的添加选课队列，并且声明完成选课队列，配置代码与 <code>订单服务</code> 中 <code>RabbitMQ</code> 配置相同。</p>
<h3 id="Dao-2"><a href="#Dao-2" class="headerlink" title="Dao"></a>Dao</h3><p>学生选课Dao</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcLearningCourseRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcLearningCourse</span>, <span class="hljs-title">String</span>&gt; </span>&#123;
    <span class="hljs-comment">//根据用户和课程查询选课记录，用于判断是否添加选课</span>
    <span class="hljs-function">XcLearningCourse <span class="hljs-title">findXcLearningCourseByUserIdAndCourseId</span><span class="hljs-params">(String userId, String courseId)</span></span>;
&#125;</code></pre></div>

<p>历史任务Dao：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskHisRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTaskHis</span>,<span class="hljs-title">String</span>&gt; </span>&#123;
    
&#125;</code></pre></div>

<h3 id="Service-2"><a href="#Service-2" class="headerlink" title="Service"></a>Service</h3><p>1、添加选课方法</p>
<p>向 <code>xc_learning_course</code> 添加记录，为保证不重复添加选课，先查询历史任务表，如果从历史任务表查询不到任务说明此任务还没有处理，此时则添加选课并添加历史任务。</p>
<p>在学习服务中编码如下代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//完成选课</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title">addChooseCourse</span><span class="hljs-params">(String userId, String courseId,String valid,Date startTime,Date endTime,XcTask xcTask)</span></span>&#123;
        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(courseId)) &#123;
            ExceptionCast.cast(LearningCode.CHOOSECOURSE_COURSEID_ISNULL);
        &#125;
        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(userId)) &#123;
            ExceptionCast.cast(LearningCode.CHOOSECOURSE_USERID_ISNULL);
        &#125;
        <span class="hljs-keyword">if</span>(xcTask == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(xcTask.getId()))&#123;
            ExceptionCast.cast(LearningCode.CHOOSECOURSE_TASKID_ISNULL);
        &#125;
    <span class="hljs-comment">//查询历史任务</span>
    Optional&lt;XcTaskHis&gt; optional = xcTaskHisRepository.findById(xcTask.getId());
    <span class="hljs-keyword">if</span>(optional.isPresent())&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);
    &#125; 
    XcLearningCourse xcLearningCourse = xcLearningCourseRepository.findXcLearningCourseByUserIdAndCourseId(userId, courseId);
    <span class="hljs-keyword">if</span> (xcLearningCourse == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//没有选课记录则添加</span>
        xcLearningCourse = <span class="hljs-keyword">new</span> XcLearningCourse();
        xcLearningCourse.setUserId(userId);
        xcLearningCourse.setCourseId(courseId);
        xcLearningCourse.setValid(valid);
        xcLearningCourse.setStartTime(startTime);
        xcLearningCourse.setEndTime(endTime);
        xcLearningCourse.setStatus(<span class="hljs-string">"501001"</span>);
        xcLearningCourseRepository.save(xcLearningCourse);
    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//有选课记录则更新日期</span>
        xcLearningCourse.setValid(valid);
        xcLearningCourse.setStartTime(startTime);
        xcLearningCourse.setEndTime(endTime);
        xcLearningCourse.setStatus(<span class="hljs-string">"501001"</span>);
        xcLearningCourseRepository.save(xcLearningCourse);
    &#125;
    <span class="hljs-comment">//向历史任务表播入记录</span>
    Optional&lt;XcTaskHis&gt; optional = xcTaskHisRepository.findById(xcTask.getId());
    <span class="hljs-keyword">if</span>(!optional.isPresent())&#123;
        <span class="hljs-comment">//添加历史任务</span>
        XcTaskHis xcTaskHis = <span class="hljs-keyword">new</span> XcTaskHis();
        BeanUtils.copyProperties(xcTask,xcTaskHis);
        xcTaskHisRepository.save(xcTaskHis);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseResult(CommonCode.SUCCESS);
&#125;</code></pre></div>

<h3 id="接收添加选课消息"><a href="#接收添加选课消息" class="headerlink" title="接收添加选课消息"></a>接收添加选课消息</h3><p>接收到添加选课的消息调用添加选课方法完成添加选课，并发送完成选课消息。</p>
<p>在 <code>com.xuecheng.learning.mq</code> 包下添加 <code>ChooseCourseTask</code> 类</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChooseCourseTask</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    <span class="hljs-meta">@Autowired</span>
    LearningService learningService;
    <span class="hljs-meta">@Autowired</span>
    RabbitTemplate rabbitTemplate;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 接收选课任务</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitMQConfig.XC_LEARNING_ADDCHOOSECOURSE&#125;)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveChoosecourseTask</span><span class="hljs-params">(XcTask xcTask,Message message,Channel channel)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">        IOException </span>&#123;
        LOGGER.info(<span class="hljs-string">"receive choose course task,taskId:&#123;&#125;"</span>,xcTask.getId());
        <span class="hljs-comment">//接收到 的消息id</span>
        String id = xcTask.getId();
        <span class="hljs-comment">//添加选课</span>
        <span class="hljs-keyword">try</span> &#123;
            String requestBody = xcTask.getRequestBody();
            Map map = JSON.parseObject(requestBody, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
            String userId = (String) map.get(<span class="hljs-string">"userId"</span>);
            String courseId = (String) map.get(<span class="hljs-string">"courseId"</span>);
            String valid = (String) map.get(<span class="hljs-string">"valid"</span>);
            Date startTime = <span class="hljs-keyword">null</span>;
            Date endTime = <span class="hljs-keyword">null</span>;
            SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"YYYY‐MM‐dd HH:mm:ss"</span>);
            <span class="hljs-keyword">if</span>(map.get(<span class="hljs-string">"startTime"</span>)!=<span class="hljs-keyword">null</span>)&#123;
                startTime =dateFormat.parse((String) map.get(<span class="hljs-string">"startTime"</span>));
            &#125; 
            <span class="hljs-keyword">if</span>(map.get(<span class="hljs-string">"endTime"</span>)!=<span class="hljs-keyword">null</span>)&#123;
                endTime =dateFormat.parse((String) map.get(<span class="hljs-string">"endTime"</span>));
            &#125; 
            <span class="hljs-comment">//添加选课</span>
            ResponseResult addcourse = learningService.addcourse(
                userId, courseId,valid,startTime, endTime,xcTask);
            <span class="hljs-comment">//选课成功发送响应消息</span>
            <span class="hljs-keyword">if</span>(addcourse.isSuccess())&#123;
                <span class="hljs-comment">//发送响应消息</span>
                rabbitTemplate.convertAndSend(
                    RabbitMQConfig.EX_LEARNING_ADDCHOOSECOURSE, 
                    RabbitMQConfig.XC_LEARNING_FINISHADDCHOOSECOURSE_KEY, 
                    xcTask );
                LOGGER.info(<span class="hljs-string">"send finish choose course taskId:&#123;&#125;"</span>,id);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
            LOGGER.error(<span class="hljs-string">"send finish choose course taskId:&#123;&#125;"</span>, id);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><p>测试接收选课消息，并且返回选课成功的消息到 <code>MQ</code></p>
<p>订单服务发送 “添加选课” 的消息到MQ</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image34.png" srcset="/img/loading.gif" alt="image-20200605165303909"></p>
<p>学习服务接从MQ中收到 “添加选课” 的消息，进行添加或者更新选课记录，再发送一个完成选课的消息到MQ</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image35.png" srcset="/img/loading.gif" alt="image-20200605165736109"></p>
<p>再到 <code>RabbitMQ</code> 的控制台查看消息是否发送成功</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image36.png" srcset="/img/loading.gif" alt="img"></p>
<h2 id="2-订单服务结束任务"><a href="#2-订单服务结束任务" class="headerlink" title="2. 订单服务结束任务"></a>2. 订单服务结束任务</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p>订单服务接收 <code>MQ</code> 完成选课的消息，将任务从当前任务表删除，将完成的任务添加到完成任务表。</p>
<h3 id="Dao-3"><a href="#Dao-3" class="headerlink" title="Dao"></a>Dao</h3><p>配置 XcTaskHisRepository</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xuecheng.order.dao;
 
<span class="hljs-keyword">import</span> com.xuecheng.framework.domain.task.XcTaskHis;
<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;
 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">XcTaskHisRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">XcTaskHis</span>, <span class="hljs-title">String</span>&gt; </span>&#123;
 
&#125;</code></pre></div>

<h3 id="Service-3"><a href="#Service-3" class="headerlink" title="Service"></a>Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//删除任务</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishTask</span><span class="hljs-params">(String taskId)</span></span>&#123;
    Optional&lt;XcTask&gt; taskOptional = xcTaskRepository.findById(taskId);
    <span class="hljs-keyword">if</span>(taskOptional.isPresent())&#123;
        XcTask xcTask = taskOptional.get();
        xcTask.setDeleteTime(<span class="hljs-keyword">new</span> Date());
        XcTaskHis xcTaskHis = <span class="hljs-keyword">new</span> XcTaskHis();
        BeanUtils.copyProperties(xcTask, xcTaskHis);
        <span class="hljs-comment">//保存任务到 task_hit 表内</span>
        xcTaskHisRepository.save(xcTaskHis);
        <span class="hljs-comment">//删除当前任务</span>
        xcTaskRepository.delete(xcTask);
    &#125;
&#125;</code></pre></div>

<h3 id="接收完成选课消息"><a href="#接收完成选课消息" class="headerlink" title="接收完成选课消息"></a>接收完成选课消息</h3><p>在 com.xuecheng.manage_order.mq 包下 <code>ChooseCourseTask</code> 类中添加 <code>receiveChoosecourseTask</code>，接收完成课任务消息并进行处理。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 接收选课响应结果</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RabbitListener</span>(queues = &#123;RabbitMQConfig.xc_learning_finishaddchoosecourse&#125;)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveFinishChoosecourseTask</span><span class="hljs-params">(XcTask task,Message message, Channel channel)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">    IOException </span>&#123;
    LOGGER.info(<span class="hljs-string">"receiveChoosecourseTask...&#123;&#125;"</span>,task.getId());
    <span class="hljs-comment">//接收到 的消息id</span>
    String id = task.getId();
    <span class="hljs-comment">//删除任务，添加历史任务</span>
    taskService.finishTask(id);
&#125;</code></pre></div>

<h2 id="3-集成测试"><a href="#3-集成测试" class="headerlink" title="3. 集成测试"></a>3. 集成测试</h2><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><h4 id="1、添加任务数据"><a href="#1、添加任务数据" class="headerlink" title="1、添加任务数据"></a>1、添加任务数据</h4><p>向 xc_task 表添加一行数据，模拟用户支付成功后向 xc_task 表写入添加选课的任务</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image37.png" srcset="/img/loading.gif" alt="image-20200605180154027"></p>
<p>SQL 语句如下</p>
<div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`xc_task`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'4028858162959ce5016295b604ba0000'</span>, <span class="hljs-string">'2018-04-05 20:09:17'</span>, <span class="hljs-string">'2020-06-05 17:15:51'</span>, <span class="hljs-string">'2020-06-05 17:40:04'</span>, <span class="hljs-string">'add_choosecourse'</span>, <span class="hljs-string">'ex_learning_addchoosecourse'</span>, <span class="hljs-string">'addchoosecourse'</span>, <span class="hljs-string">'&#123;\"courseId\":\"4028e58161bcf7f40161bcf8b77c0000,\",\"userId\":\"49\"&#125;'</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">'10201'</span>, <span class="hljs-literal">NULL</span>);</code></pre></div>

<h4 id="2、配置断点"><a href="#2、配置断点" class="headerlink" title="2、配置断点"></a>2、配置断点</h4><p>为了能够清楚的看到整个处理流程，我们在各个处理模块下设置断点。</p>
<p>在订单服务的 ChooseCourseTask 下配置断点，分别是发送 “添加选课” 消息到MQ的模块 和 接收 “选课完成” 消息的模块</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image38.png" srcset="/img/loading.gif" alt="image-20200605180510707"></p>
<p>在学习服务的接收选课任务方法下设置断点</p>
<h4 id="3、启动服务进行测试"><a href="#3、启动服务进行测试" class="headerlink" title="3、启动服务进行测试"></a>3、启动服务进行测试</h4><p>同时启动 <code>订单服务</code> 和 <code>学习服务</code></p>
<p>订单服务扫描 <code>xc_task</code> 表中的任务，并且发送 “添加选课” 的消息到 <code>MQ</code></p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image40.png" srcset="/img/loading.gif" alt="image-20200605182354315"></p>
<p>学习服务通过监听 MQ的消息，接收到了订单服务送过来的 “添加选课” 消息</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image41.png" srcset="/img/loading.gif" alt="image-20200605182533669"></p>
<p>完成选课添加后，发送响应的消息到MQ</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image42.png" srcset="/img/loading.gif" alt="image-20200605182603485"></p>
<p>订单服务接收到 “选课完成” 的消息，删除 <code>xc_task</code> 表中的任务，并且添加任务记录到 <code>xc_task_his</code> 表中</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image43.png" srcset="/img/loading.gif" alt="image-20200605182738167"></p>
<p>学习服务收到重复的完成消息，但由于 xc_task 中该任务的已经被删除，所以步任何的操作，如下图</p>
<p><img src="/2020/08/29/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday19/image44.png" srcset="/img/loading.gif" alt="image-20200605182948477"></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF/">学成在线</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/RabbitMQ/">RabbitMQ</a>
                    
                      <a class="hover-with-bg" href="/tags/Spring-Task/">Spring Task</a>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/28/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BFday18/">
                        <span class="hidden-mobile">学成在线day18：基于oauth2实现RBAC认证授权、微服务间认证实现</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
  </div>
</div>
<!--

代码块js 用不到，fulid自带有，添加css样式即可实现
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 

<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>

-->




<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键字</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
	<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("06/20/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站勉强运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  </script>
</div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证20000725号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=20000725"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备20000725号</span>
      </a>
     
  </div>


    
	
  </div>
  

</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>



  
<script src="/js/custom.js"></script>




  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "学成在线day19：分布式事务&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 65,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "<"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script>
      !function (e, t, a) {
        function r() {
          for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");
          requestAnimationFrame(r)
        }

        function n() {
          var t = "function" == typeof e.onclick && e.onclick;
          e.onclick = function (e) {
            t && t(), o(e)
          }
        }

        function o(e) {
          var a = t.createElement("div");
          a.className = "heart", s.push({
            el: a,
            x: e.clientX - 5,
            y: e.clientY - 5,
            scale: 1,
            alpha: 1,
            color: c()
          }), t.body.appendChild(a)
        }

        function i(e) {
          var a = t.createElement("style");
          a.type = "text/css";
          try {
            a.appendChild(t.createTextNode(e))
          } catch (t) {
            a.styleSheet.cssText = e
          }
          t.getElementsByTagName("head")[0].appendChild(a)
        }

        function c() {
          return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
        }

        var s = [];
        e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {
          setTimeout(e, 1e3 / 60)
        }, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()
      }(window, document);
    </script>
  
















<script type="text/javascript"
color="107,160,220" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
